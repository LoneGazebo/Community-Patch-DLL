/*	-------------------------------------------------------------------------------------------------------
	© 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "ICvDLLUserInterface.h"
#include "CvDiplomacyAI.h"
#include "CvGrandStrategyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvDealAI.h"
#include "CvGameCoreUtils.h"
#include "CvNotifications.h"
#include "CvDiplomacyRequests.h"

// must be included after all other headers
#include "LintFree.h"

#ifdef _MSC_VER
#	pragma warning ( disable : 4351 ) // default initialization of arrays
#endif

//=====================================
// CvDiplomacyAI
//=====================================

/// Constructor
CvDiplomacyAI::CvDiplomacyAI()
{
}

/// Destructor
CvDiplomacyAI::~CvDiplomacyAI(void)
{
	Uninit();
}

// ************************************
// Initialization & Serialization
// ************************************

/// Initialize
void CvDiplomacyAI::Init(CvPlayer* pPlayer)
{
	// Store off the pointer to the Player active for this game
	m_pPlayer = pPlayer;

	Reset();
}

/// Deallocate memory created in initialize
void CvDiplomacyAI::Uninit()
{
}

/// Reset everything to default state
void CvDiplomacyAI::Reset()
{
	// Personality Values
	m_iVictoryCompetitiveness = 0;
	m_iWonderCompetitiveness = 0;
	m_iMinorCivCompetitiveness = 0;
	m_iBoldness = 0;
	m_iDiploBalance = 0;
	m_iWarmongerHate = 0;
	m_iDenounceWillingness = 0;
	m_iDoFWillingness = 0;
	m_iLoyalty = 0;
	m_iNeediness = 0;
	m_iForgiveness = 0;
	m_iChattiness = 0;
	m_iMeanness = 0;

	for (int iI = 0; iI < NUM_MAJOR_CIV_APPROACHES; iI++)
	{
		m_aiPersonalityMajorCivApproachBiases[iI] = 0;
	}

	for (int iI = 0; iI < NUM_MINOR_CIV_APPROACHES; iI++)
	{
		m_aiPersonalityMinorCivApproachBiases[iI] = 0;
	}

	m_eDiploPersonalityType = NO_DIPLO_PERSONALITY_TYPE;

	// Key Players
	m_eMostValuableFriend = NO_PLAYER;
	m_eMostValuableAlly = NO_PLAYER;
	m_eBiggestCompetitor = NO_PLAYER;
	m_ePrimeLeagueCompetitor = NO_PLAYER;
	m_eDemandTargetPlayer = NO_PLAYER;
	m_eCSWarTarget = NO_PLAYER;
	m_eCSBullyTarget = NO_PLAYER;

	// Other Global Memory
	m_bEndedFriendshipThisTurn = false;
	m_bBackstabber = false;
	m_bCompetingForVictory = false;
	m_eVictoryFocus = NO_VICTORY_FOCUS_TYPE;
	m_eStateAllWars = STATE_ALL_WARS_NEUTRAL;

	// Diplomatic Interactions
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		for (int iJ = 0; iJ < MAX_DIPLO_LOG_STATEMENTS; iJ++)
		{
			m_aaDiploStatementsLog[iI][iJ].m_eDiploLogStatement = NO_DIPLO_STATEMENT_TYPE;
			m_aaDiploStatementsLog[iI][iJ].m_iTurn = -1;
		}
	}

	for (int iI = 0; iI < NUM_DIPLO_LOG_STATEMENT_TYPES; iI++)
	{
		m_aDiploLogStatementTurnCountScratchPad[iI] = NO_DIPLO_STATEMENT_TYPE;
	}

	for (int iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		m_aDeclarationsLog[iI].m_eDeclaration = NO_PUBLIC_DECLARATION_TYPE;
		m_aDeclarationsLog[iI].m_iTurn = -1;
	}

	// Minors
	for (int iI = 0; iI < MAX_MINOR_CIVS; iI++)
	{
		m_aeMinorCivApproach[iI] = NO_MINOR_CIV_APPROACH;
		m_abWantToRouteToMinor[iI] = true;
	}

	// Majors
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		// Diplomatic Interactions
		for (int iJ = 0; iJ < MAX_MINOR_CIVS; iJ++)
		{
			m_aabSentAttackMessageToMinorCivProtector[iI][iJ] = false;
		}

		// Opinion & Approach
		m_aeMajorCivOpinion[iI] = NO_MAJOR_CIV_OPINION;
		m_aiCachedOpinionWeight[iI] = 0;
		m_aeMajorCivApproach[iI] = NO_MAJOR_CIV_APPROACH;
		m_aeMajorCivStrategicApproach[iI] = NO_MAJOR_CIV_APPROACH;

		for (int iJ = 0; iJ < NUM_MAJOR_CIV_APPROACHES; iJ++)
		{
			m_aaiApproachValues[iI][iJ] = 0;
			m_aaiStrategicApproachValues[iI][iJ] = 0;
		}

		// Planning Exchanges
		m_abMajorCompetitor[iI] = false;
		m_abStrategicTradePartner[iI] = false;
		m_abWantsDoFWithPlayer[iI] = false;
		m_abWantsDefensivePactWithPlayer[iI] = false;
		m_abWantsToEndDoFWithPlayer[iI] = false;
		m_abWantsToEndDefensivePactWithPlayer[iI] = false;
		m_abWantsResearchAgreementWithPlayer[iI] = false;

		// Exchanges
		m_aiDoFAcceptedTurn[iI] = -1;
		m_aeDoFType[iI] = NO_DOF_TYPE;
		m_aiDenouncedPlayerTurn[iI] = -1;
		m_abCantMatchDeal[iI] = false;
		m_aiDemandEverMade[iI] = 0;
		m_aiDemandMadeTurn[iI] = -1;
		m_aiDemandTooSoonNumTurns[iI] = -1;
		m_aiTradeValue[iI] = 0;
		m_aiCommonFoeValue[iI] = 0;
		m_aiAssistValue[iI] = 0;

		// Coop Wars
		for (int iJ = 0; iJ < MAX_MAJOR_CIVS; iJ++)
		{
			m_aaeCoopWarState[iI][iJ] = NO_COOP_WAR_STATE;
			m_aaiCoopWarStateChangeTurn[iI][iJ] = -1;
		}
		m_aiCoopWarScore[iI] = 0;

		// War
		m_abWantsSneakAttack[iI] = false;
		m_aiNumWarsDeclaredOnUs[iI] = 0;

		// Peace
		m_aePeaceTreatyWillingToOffer[iI] = NO_PEACE_TREATY_TYPE;
		m_aePeaceTreatyWillingToAccept[iI] = NO_PEACE_TREATY_TYPE;

		// Backstabbing Penalties
		m_abUntrustworthyFriend[iI] = false;
		m_abEverBackstabbedBy[iI] = false;
		m_aiDoFBrokenTurn[iI] = -1;
		m_aiFriendDenouncedUsTurn[iI] = -1;
		m_aiFriendDeclaredWarOnUsTurn[iI] = -1;

		// Warmongering Penalties
		m_aiNumMinorsAttacked[iI] = 0;
		m_aiNumMinorsConquered[iI] = 0;
		m_aiNumMajorsAttacked[iI] = 0;
		m_aiNumMajorsConquered[iI] = 0;
		m_aiWarmongerAmountTimes100[iI] = 0;

		// Aggressive Postures
		m_aeExpansionAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_aePlotBuyingAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;

		// Dispute Levels
		m_abEndgameAggressiveTo[iI] = false;
		m_abRecklessExpander[iI] = false;
		m_abWonderSpammer[iI] = false;
		m_aeVictoryDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_aeVictoryBlockLevel[iI] = NO_BLOCK_LEVEL;
		m_aeWonderDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_aeMinorCivDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_aeTechBlockLevel[iI] = NO_BLOCK_LEVEL;
		m_aePolicyBlockLevel[iI] = NO_BLOCK_LEVEL;

		// Threat Levels
		m_aeMilitaryThreat[iI] = NO_THREAT_VALUE;
		m_aeWarmongerThreat[iI] = NO_THREAT_VALUE;

		// PROMISES
		// Military Promise
		m_aeMilitaryPromiseState[iI] = NO_PROMISE_STATE;
		m_aiMilitaryPromiseTurn[iI] = -1;

		// Expansion Promise
		m_aeExpansionPromiseState[iI] = NO_PROMISE_STATE;
		m_aeExpansionPromisePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_aiExpansionPromiseTurn[iI] = -1;
		m_aNoExpansionPromise[iI] = make_pair(-1, -1);
		m_aLastTurnEmpireDistance[iI] = make_pair(-1, -1);
		m_abEverMadeExpansionPromise[iI] = false;

		// Border Promise
		m_aeBorderPromiseState[iI] = NO_PROMISE_STATE;
		m_aeBorderPromisePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_aiBorderPromiseTurn[iI] = -1;
		m_abEverMadeBorderPromise[iI] = false;

		// Bully City-State Promise
		m_aeBullyCityStatePromiseState[iI] = NO_PROMISE_STATE;
		m_aiBullyCityStatePromiseTurn[iI] = -1;

		// Attack City-State Promise
		m_aeAttackCityStatePromiseState[iI] = NO_PROMISE_STATE;
		m_aiAttackCityStatePromiseTurn[iI] = -1;

		// Spy Promise
		m_aeSpyPromiseState[iI] = NO_PROMISE_STATE;
		m_aiSpyPromiseTurn[iI] = -1;

		// No Convert Promise
		m_aeNoConvertPromiseState[iI] = NO_PROMISE_STATE;
		m_aiNoConvertPromiseTurn[iI] = -1;
		m_abAskedNotToConvert[iI] = false;
		m_abEverConvertedCity[iI] = false;

		// No Digging Promise
		m_aeNoDiggingPromiseState[iI] = NO_PROMISE_STATE;
		m_aiNoDiggingPromiseTurn[iI] = -1;
		m_abAskedNotToDig[iI] = false;

		// Coop War Promise
		m_aiBrokenCoopWarPromiseTurn[iI] = -1;

		// END PROMISES
		// Event Flags
		m_abReturnedCapital[iI] = false;
		m_abReturnedHolyCity[iI] = false;
		m_abLiberatedCapital[iI] = false;
		m_abLiberatedHolyCity[iI] = false;
		m_abDoFEverAsked[iI] = false;
		m_abCapturedCapital[iI] = false;
		m_abCapturedHolyCity[iI] = false;

		// # of times/points counters
		m_aiNumCitiesLiberated[iI] = 0;
		m_aiNumCiviliansReturnedToMe[iI] = 0;
		m_aiNumTimesIntrigueSharedBy[iI] = 0;
		m_aiNumLandmarksBuiltForMe[iI] = 0;
		m_aiTheyPlottedAgainstUs[iI] = 0;
		m_aiNumTimesRazed[iI] = 0;
		m_aiNumTradeRoutesPlundered[iI] = 0;
		m_aiNumWondersBeatenTo[iI] = 0;
		m_aiNumTimesCultureBombed[iI] = 0;
		m_aiTheyLoweredOurInfluence[iI] = 0;
		m_aiNumProtectedMinorsBullied[iI] = 0;
		m_aiNumProtectedMinorsAttacked[iI] = 0;
		m_aiNumProtectedMinorsKilled[iI] = 0;
		m_aiNegativeReligiousConversionPoints[iI] = 0;
		m_aiNumTimesRobbedBy[iI] = 0;
		m_aiPerformedCoupAgainstUs[iI] = 0;
		m_aiLikedTheirProposalValue[iI] = 0;
		m_aiSupportedOurProposalValue[iI] = 0;
		m_aiSupportedOurHostingValue[iI] = 0;
		m_aiNegativeArchaeologyPoints[iI] = 0;
		m_aiArtifactsEverDugUp[iI] = 0;
		m_aiNumTimesNuked[iI] = 0;

		// Turn counters
		m_aiResurrectedOnTurn[iI] = -1;
		m_aiLiberatedCitiesTurn[iI] = -1;
		m_aiCiviliansReturnedToMeTurn[iI] = -1;
		m_aiIntrigueSharedTurn[iI] = -1;
		m_aiPlayerForgaveForSpyingTurn[iI] = -1;
		m_aiLandmarksBuiltForMeTurn[iI] = -1;
		m_aiPlottedAgainstUsTurn[iI] = -1;
		m_aiPlunderedTradeRouteTurn[iI] = -1;
		m_aiSidedWithProtectedMinorTurn[iI] = -1;
		m_aiBulliedProtectedMinorTurn[iI] = -1;
		m_aiAttackedProtectedMinorTurn[iI] = -1;
		m_aiKilledProtectedMinorTurn[iI] = -1;
		m_aiReligiousConversionTurn[iI] = -1;
		m_aiTimesRobbedTurn[iI] = -1;
		m_aiPerformedCoupTurn[iI] = -1;
		m_aiWeLikedTheirProposalTurn[iI] = -1;
		m_aiWeDislikedTheirProposalTurn[iI] = -1;
		m_aiTheySupportedOurProposalTurn[iI] = -1;
		m_aiTheyFoiledOurProposalTurn[iI] = -1;
		m_aiTheySupportedOurHostingTurn[iI] = -1;

		// Player-Specific Memory Values
		m_aeProtectedMinorBullied[iI] = NO_PLAYER;
		m_aeProtectedMinorAttacked[iI] = NO_PLAYER;
		m_aeProtectedMinorKilled[iI] = NO_PLAYER;

		// Guesses about other players' feelings towards us
		m_aeOpinionTowardsUsGuess[iI] = MAJOR_CIV_OPINION_NEUTRAL;
		m_aeApproachTowardsUsGuess[iI] = MAJOR_CIV_APPROACH_NEUTRAL;
		m_aeApproachTowardsUsGuessCounter[iI] = 0;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// C4DF Values
		m_abShareOpinionAccepted[iI] = false;
		m_abShareOpinionEverAsked[iI] = false;
		m_aiHelpRequestAcceptedTurn[iI] = -1;
		m_aiHelpRequestTooSoonNumTurns[iI] = -1;
		m_abTargetingVassal[iI] = false;
		m_aiPlayerVassalageFailedProtectValue[iI] = 0;
		m_aiPlayerVassalageProtectValue[iI] = 0;
		m_aiPlayerVassalagePeacefullyRevokedTurn[iI] = -1;
		m_aiPlayerVassalageForcefullyRevokedTurn[iI] = -1;
		m_aiNumTimesDemandedWhenVassal[iI] = 0;
		m_abHasPaidTributeTo[iI] = false;
		m_aiBrokenVassalAgreementTurn[iI] = -1;
		m_aiMoveTroopsRequestAcceptedTurn[iI] = -1;
		m_abOfferingGift[iI] = false;
		m_abOfferedGift[iI] = false;
		m_abMasterLiberatedMeFromVassalage[iI] = false;
		m_abVassalTaxRaised[iI] = false;
		m_abVassalTaxLowered[iI] = false;
		m_aiVassalGoldPerTurnTaxedSinceVassalStarted[iI] = 0;
		m_aiVassalGoldPerTurnCollectedSinceVassalStarted[iI] = 0;
#endif
#if defined(MOD_ACTIVE_DIPLOMACY)
		m_aTradePriority[iI] = 0.0f;
#endif
	}

	// All Civs
	for (int iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		// War
		m_abSaneDiplomaticTarget[iI] = true;
		m_abPotentialWarTarget[iI] = false;
		m_abArmyInPlaceForAttack[iI] = false;
		m_abAggressor[iI] = false;
		m_aiPlayerNumTurnsAtWar[iI] = 0;
		m_aiPlayerNumTurnsSinceCityCapture[iI] = 0;
		m_aiNumWarsFought[iI] = 0;
		m_aiNumCitiesCaptured[iI] = 0;
		m_aiWarValueLost[iI] = 0;
		m_aiWarDamageValue[iI] = 0;
		m_aeWarState[iI] = NO_WAR_STATE_TYPE;
		m_aeWarProjection[iI] = WAR_PROJECTION_UNKNOWN;
		m_aeWarGoal[iI] = NO_WAR_GOAL_TYPE;

		// Peace
		m_aiPlayerNumTurnsAtPeace[iI] = 0;
		m_aiWantPeaceCounter[iI] = 0;

		// Aggressive Postures
		m_aeMilitaryAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_aeLastTurnMilitaryAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;

		// Dispute Levels
		m_aeLandDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_aeLastTurnLandDisputeLevel[iI] = NO_DISPUTE_LEVEL;

		// Strength Assessments
		m_aeMilitaryStrengthComparedToUs[iI] = NO_STRENGTH_VALUE;
		m_aeEconomicStrengthComparedToUs[iI] = NO_STRENGTH_VALUE;
		m_aeTargetValue[iI] = NO_TARGET_VALUE;
		m_abEasyTarget[iI] = false;
	}

	m_bAvoidDeals = false;
	
	m_aGreetPlayers.clear();

	m_eDiploMode = DIPLO_ALL_PLAYERS;
	m_eTargetPlayer = NO_PLAYER;
}

/// Serialization read
void CvDiplomacyAI::Read(FDataStream& kStream)
{
	// Version number to maintain backwards compatibility
	uint uiVersion;
	kStream >> uiVersion;
	MOD_SERIALIZE_INIT_READ(kStream);

	// Personality Values
	kStream >> m_iVictoryCompetitiveness;
	kStream >> m_iWonderCompetitiveness;
	kStream >> m_iMinorCivCompetitiveness;
	kStream >> m_iBoldness;
	kStream >> m_iDiploBalance;
	kStream >> m_iWarmongerHate;
	kStream >> m_iDenounceWillingness;
	kStream >> m_iDoFWillingness;
	kStream >> m_iLoyalty;
	kStream >> m_iNeediness;
	kStream >> m_iForgiveness;
	kStream >> m_iChattiness;
	kStream >> m_iMeanness;
	kStream >> m_aiPersonalityMajorCivApproachBiases;
	kStream >> m_aiPersonalityMinorCivApproachBiases;
	kStream >> m_eDiploPersonalityType;

	// Key Players
	kStream >> m_eMostValuableFriend;
	kStream >> m_eMostValuableAlly;
	kStream >> m_eBiggestCompetitor;
	kStream >> m_ePrimeLeagueCompetitor;
	kStream >> m_eDemandTargetPlayer;
	kStream >> m_eCSWarTarget;
	kStream >> m_eCSBullyTarget;

	// Other Global Memory
	kStream >> m_bEndedFriendshipThisTurn;
	kStream >> m_bBackstabber;
	kStream >> m_bCompetingForVictory;
	kStream >> m_eVictoryFocus;
	kStream >> m_eStateAllWars;

	// Diplomatic Interactions
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		ArrayWrapper<DiploLogData> wrapm_aaDiploStatementsLog(MAX_DIPLO_LOG_STATEMENTS, m_aaDiploStatementsLog[iI]);
		kStream >> wrapm_aaDiploStatementsLog;
	}

	ArrayWrapper<DeclarationLogData> wrapm_aDeclarationsLog(MAX_DIPLO_LOG_STATEMENTS, m_aDeclarationsLog);
	kStream >> wrapm_aDeclarationsLog;

	kStream >> m_aDiploLogStatementTurnCountScratchPad;
	kStream >> m_aabSentAttackMessageToMinorCivProtector;

	// Opinion & Approach
	kStream >> m_aeMajorCivOpinion;
	kStream >> m_aiCachedOpinionWeight;
	kStream >> m_aeMajorCivApproach;
	kStream >> m_aeMajorCivStrategicApproach;
	kStream >> m_aaiApproachValues;
	kStream >> m_aaiStrategicApproachValues;

	// Minor Civs
	kStream >> m_aeMinorCivApproach;
	kStream >> m_abWantToRouteToMinor;

	// Planning Exchanges
	kStream >> m_abMajorCompetitor;
	kStream >> m_abStrategicTradePartner;
	kStream >> m_abWantsDoFWithPlayer;
	kStream >> m_abWantsDefensivePactWithPlayer;
	kStream >> m_abWantsToEndDoFWithPlayer;
	kStream >> m_abWantsToEndDefensivePactWithPlayer;
	kStream >> m_abWantsResearchAgreementWithPlayer;

	// Exchanges
	kStream >> m_aiDoFAcceptedTurn;
	kStream >> m_aeDoFType;
	kStream >> m_aiDenouncedPlayerTurn;
	kStream >> m_abCantMatchDeal;
	kStream >> m_aiDemandEverMade;
	kStream >> m_aiDemandMadeTurn;
	kStream >> m_aiDemandTooSoonNumTurns;
	kStream >> m_aiTradeValue;
	kStream >> m_aiCommonFoeValue;
	kStream >> m_aiAssistValue;

	// Coop Wars
	kStream >> m_aaeCoopWarState;
	kStream >> m_aaiCoopWarStateChangeTurn;
	kStream >> m_aiCoopWarScore;

	// War
	kStream >> m_abSaneDiplomaticTarget;
	kStream >> m_abPotentialWarTarget;
	kStream >> m_abWantsSneakAttack;
	kStream >> m_abArmyInPlaceForAttack;
	kStream >> m_abAggressor;
	kStream >> m_aiPlayerNumTurnsAtWar;
	kStream >> m_aiPlayerNumTurnsSinceCityCapture;
	kStream >> m_aiNumWarsFought;
	kStream >> m_aiNumWarsDeclaredOnUs;
	kStream >> m_aiNumCitiesCaptured;
	kStream >> m_aiWarValueLost;
	kStream >> m_aiWarDamageValue;
	kStream >> m_aeWarState;
	kStream >> m_aeWarProjection;
	kStream >> m_aeWarGoal;

	// Peace
	kStream >> m_aiPlayerNumTurnsAtPeace;
	kStream >> m_aePeaceTreatyWillingToOffer;
	kStream >> m_aePeaceTreatyWillingToAccept;
	kStream >> m_aiWantPeaceCounter;

	// Backstabbing Penalties
	kStream >> m_abUntrustworthyFriend;
	kStream >> m_abEverBackstabbedBy;
	kStream >> m_aiDoFBrokenTurn;
	kStream >> m_aiFriendDenouncedUsTurn;
	kStream >> m_aiFriendDeclaredWarOnUsTurn;

	// Warmongering Penalties
	kStream >> m_aiNumMinorsAttacked;
	kStream >> m_aiNumMinorsConquered;
	kStream >> m_aiNumMajorsAttacked;
	kStream >> m_aiNumMajorsConquered;
	kStream >> m_aiWarmongerAmountTimes100;

	// Aggressive Postures
	kStream >> m_aeMilitaryAggressivePosture;
	kStream >> m_aeLastTurnMilitaryAggressivePosture;
	kStream >> m_aeExpansionAggressivePosture;
	kStream >> m_aePlotBuyingAggressivePosture;

	// Dispute Levels
	kStream >> m_abEndgameAggressiveTo;
	kStream >> m_abRecklessExpander;
	kStream >> m_abWonderSpammer;
	kStream >> m_aeLandDisputeLevel;
	kStream >> m_aeLastTurnLandDisputeLevel;
	kStream >> m_aeVictoryDisputeLevel;
	kStream >> m_aeVictoryBlockLevel;
	kStream >> m_aeWonderDisputeLevel;
	kStream >> m_aeMinorCivDisputeLevel;
	kStream >> m_aeTechBlockLevel;
	kStream >> m_aePolicyBlockLevel;

	// Threat Levels
	kStream >> m_aeMilitaryThreat;
	kStream >> m_aeWarmongerThreat;

	// Strength Assessments
	kStream >> m_aeMilitaryStrengthComparedToUs;
	kStream >> m_aeEconomicStrengthComparedToUs;
	kStream >> m_aeTargetValue;
	kStream >> m_abEasyTarget;

	// PROMISES
	// Military Promise
	kStream >> m_aeMilitaryPromiseState;
	kStream >> m_aiMilitaryPromiseTurn;

	// Expansion Promise
	kStream >> m_aeExpansionPromiseState;
	kStream >> m_aeExpansionPromisePosture;
	kStream >> m_aiExpansionPromiseTurn;
	kStream >> m_aNoExpansionPromise;
	kStream >> m_aLastTurnEmpireDistance;
	kStream >> m_abEverMadeExpansionPromise;

	// Border Promise
	kStream >> m_aeBorderPromiseState;
	kStream >> m_aeBorderPromisePosture;
	kStream >> m_aiBorderPromiseTurn;
	kStream >> m_abEverMadeBorderPromise;

	// Bully City-State Promise
	kStream >> m_aeBullyCityStatePromiseState;
	kStream >> m_aiBullyCityStatePromiseTurn;

	// Attack City-State Promise
	kStream >> m_aeAttackCityStatePromiseState;
	kStream >> m_aiAttackCityStatePromiseTurn;

	// Spy Promise
	kStream >> m_aeSpyPromiseState;
	kStream >> m_aiSpyPromiseTurn;

	// No Convert Promise
	kStream >> m_aeNoConvertPromiseState;
	kStream >> m_aiNoConvertPromiseTurn;
	kStream >> m_abAskedNotToConvert;
	kStream >> m_abEverConvertedCity;

	// No Digging Promise
	kStream >> m_aeNoDiggingPromiseState;
	kStream >> m_aiNoDiggingPromiseTurn;
	kStream >> m_abAskedNotToDig;

	// Coop War Promise
	kStream >> m_aiBrokenCoopWarPromiseTurn;

	// END PROMISES
	// Event Flags
	kStream >> m_abReturnedCapital;
	kStream >> m_abReturnedHolyCity;
	kStream >> m_abLiberatedCapital;
	kStream >> m_abLiberatedHolyCity;
	kStream >> m_abDoFEverAsked;
	kStream >> m_abCapturedCapital;
	kStream >> m_abCapturedHolyCity;

	// # of times/points counters
	kStream >> m_aiNumCitiesLiberated;
	kStream >> m_aiNumCiviliansReturnedToMe;
	kStream >> m_aiNumTimesIntrigueSharedBy;
	kStream >> m_aiNumLandmarksBuiltForMe;
	kStream >> m_aiTheyPlottedAgainstUs;
	kStream >> m_aiNumTimesRazed;
	kStream >> m_aiNumTradeRoutesPlundered;	
	kStream >> m_aiNumWondersBeatenTo;
	kStream >> m_aiNumTimesCultureBombed;
	kStream >> m_aiTheyLoweredOurInfluence;
	kStream >> m_aiNumProtectedMinorsBullied;
	kStream >> m_aiNumProtectedMinorsAttacked;
	kStream >> m_aiNumProtectedMinorsKilled;
	kStream >> m_aiNegativeReligiousConversionPoints;
	kStream >> m_aiNumTimesRobbedBy;
	kStream >> m_aiPerformedCoupAgainstUs;
	kStream >> m_aiLikedTheirProposalValue;
	kStream >> m_aiSupportedOurProposalValue;
	kStream >> m_aiSupportedOurHostingValue;
	kStream >> m_aiNegativeArchaeologyPoints;
	kStream >> m_aiArtifactsEverDugUp;
	kStream >> m_aiNumTimesNuked;

	// Turn counters
	kStream >> m_aiResurrectedOnTurn;
	kStream >> m_aiLiberatedCitiesTurn;
	kStream >> m_aiCiviliansReturnedToMeTurn;
	kStream >> m_aiIntrigueSharedTurn;
	kStream >> m_aiPlayerForgaveForSpyingTurn;
	kStream >> m_aiLandmarksBuiltForMeTurn;
	kStream >> m_aiPlottedAgainstUsTurn;
	kStream >> m_aiPlunderedTradeRouteTurn;
	kStream >> m_aiSidedWithProtectedMinorTurn;
	kStream >> m_aiBulliedProtectedMinorTurn;
	kStream >> m_aiAttackedProtectedMinorTurn;
	kStream >> m_aiKilledProtectedMinorTurn;
	kStream >> m_aiReligiousConversionTurn;
	kStream >> m_aiTimesRobbedTurn;
	kStream >> m_aiPerformedCoupTurn;
	kStream >> m_aiWeLikedTheirProposalTurn;
	kStream >> m_aiWeDislikedTheirProposalTurn;
	kStream >> m_aiTheySupportedOurProposalTurn;
	kStream >> m_aiTheyFoiledOurProposalTurn;
	kStream >> m_aiTheySupportedOurHostingTurn;

	// Player-Specific Memory
	kStream >> m_aeProtectedMinorBullied;
	kStream >> m_aeProtectedMinorAttacked;
	kStream >> m_aeProtectedMinorKilled;

	// GUESSES
	// Guesses about other players' feelings towards us
	kStream >> m_aeOpinionTowardsUsGuess;
	kStream >> m_aeApproachTowardsUsGuess;
	kStream >> m_aeApproachTowardsUsGuessCounter;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// C4DF Values
	kStream >> m_abShareOpinionAccepted;
	kStream >> m_abShareOpinionEverAsked;
	kStream >> m_aiHelpRequestAcceptedTurn;
	kStream >> m_aiHelpRequestTooSoonNumTurns;
	kStream >> m_abTargetingVassal;
	kStream >> m_aiPlayerVassalageFailedProtectValue;
	kStream >> m_aiPlayerVassalageProtectValue;
	kStream >> m_aiPlayerVassalagePeacefullyRevokedTurn;
	kStream >> m_aiPlayerVassalageForcefullyRevokedTurn;
	kStream >> m_aiNumTimesDemandedWhenVassal;
	kStream >> m_abHasPaidTributeTo;
	kStream >> m_aiBrokenVassalAgreementTurn;
	kStream >> m_aiMoveTroopsRequestAcceptedTurn;
	kStream >> m_abOfferingGift;
	kStream >> m_abOfferedGift;
	kStream >> m_abMasterLiberatedMeFromVassalage;
	kStream >> m_abVassalTaxRaised;
	kStream >> m_abVassalTaxLowered;
	kStream >> m_aiVassalGoldPerTurnTaxedSinceVassalStarted;
	kStream >> m_aiVassalGoldPerTurnCollectedSinceVassalStarted;
#endif
}

/// Serialization write
void CvDiplomacyAI::Write(FDataStream& kStream)
{
	// Current version number
	uint uiVersion = 4;
	kStream << uiVersion;
	MOD_SERIALIZE_INIT_WRITE(kStream);

	// Personality Values
	kStream << m_iVictoryCompetitiveness;
	kStream << m_iWonderCompetitiveness;
	kStream << m_iMinorCivCompetitiveness;
	kStream << m_iBoldness;
	kStream << m_iDiploBalance;
	kStream << m_iWarmongerHate;
	kStream << m_iDenounceWillingness;
	kStream << m_iDoFWillingness;
	kStream << m_iLoyalty;
	kStream << m_iNeediness;
	kStream << m_iForgiveness;
	kStream << m_iChattiness;
	kStream << m_iMeanness;
	kStream << m_aiPersonalityMajorCivApproachBiases;
	kStream << m_aiPersonalityMinorCivApproachBiases;
	kStream << m_eDiploPersonalityType;

	// Key Players
	kStream << m_eMostValuableFriend;
	kStream << m_eMostValuableAlly;
	kStream << m_eBiggestCompetitor;
	kStream << m_ePrimeLeagueCompetitor;
	kStream << m_eDemandTargetPlayer;
	kStream << m_eCSWarTarget;
	kStream << m_eCSBullyTarget;

	// Other Global Memory
	kStream << m_bEndedFriendshipThisTurn;
	kStream << m_bBackstabber;
	kStream << m_bCompetingForVictory;
	kStream << m_eVictoryFocus;
	kStream << m_eStateAllWars;

	// Diplomatic Interactions
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		kStream << ArrayWrapper<DiploLogData>(MAX_DIPLO_LOG_STATEMENTS, m_aaDiploStatementsLog[iI]);
	}

	kStream << ArrayWrapper<DeclarationLogData>(MAX_DIPLO_LOG_STATEMENTS, m_aDeclarationsLog);

	kStream << m_aDiploLogStatementTurnCountScratchPad;
	kStream << m_aabSentAttackMessageToMinorCivProtector;

	// Opinion & Approach
	kStream << m_aeMajorCivOpinion;
	kStream << m_aiCachedOpinionWeight;
	kStream << m_aeMajorCivApproach;
	kStream << m_aeMajorCivStrategicApproach;
	kStream << m_aaiApproachValues;
	kStream << m_aaiStrategicApproachValues;

	// Minor Civs
	kStream << m_aeMinorCivApproach;
	kStream << m_abWantToRouteToMinor;

	// Planning Exchanges
	kStream << m_abMajorCompetitor;
	kStream << m_abStrategicTradePartner;
	kStream << m_abWantsDoFWithPlayer;
	kStream << m_abWantsDefensivePactWithPlayer;
	kStream << m_abWantsToEndDoFWithPlayer;
	kStream << m_abWantsToEndDefensivePactWithPlayer;
	kStream << m_abWantsResearchAgreementWithPlayer;

	// Exchanges
	kStream << m_aiDoFAcceptedTurn;
	kStream << m_aeDoFType;
	kStream << m_aiDenouncedPlayerTurn;
	kStream << m_abCantMatchDeal;
	kStream << m_aiDemandEverMade;
	kStream << m_aiDemandMadeTurn;
	kStream << m_aiDemandTooSoonNumTurns;
	kStream << m_aiTradeValue;
	kStream << m_aiCommonFoeValue;
	kStream << m_aiAssistValue;

	// Coop Wars
	kStream << m_aaeCoopWarState;
	kStream << m_aaiCoopWarStateChangeTurn;
	kStream << m_aiCoopWarScore;

	// War
	kStream << m_abSaneDiplomaticTarget;
	kStream << m_abPotentialWarTarget;
	kStream << m_abWantsSneakAttack;
	kStream << m_abArmyInPlaceForAttack;
	kStream << m_abAggressor;
	kStream << m_aiPlayerNumTurnsAtWar;
	kStream << m_aiPlayerNumTurnsSinceCityCapture;
	kStream << m_aiNumWarsFought;
	kStream << m_aiNumWarsDeclaredOnUs;
	kStream << m_aiNumCitiesCaptured;
	kStream << m_aiWarValueLost;
	kStream << m_aiWarDamageValue;
	kStream << m_aeWarState;
	kStream << m_aeWarProjection;
	kStream << m_aeWarGoal;

	// Peace
	kStream << m_aiPlayerNumTurnsAtPeace;
	kStream << m_aePeaceTreatyWillingToOffer;
	kStream << m_aePeaceTreatyWillingToAccept;
	kStream << m_aiWantPeaceCounter;

	// Backstabbing Penalties
	kStream << m_abUntrustworthyFriend;
	kStream << m_abEverBackstabbedBy;
	kStream << m_aiDoFBrokenTurn;
	kStream << m_aiFriendDenouncedUsTurn;
	kStream << m_aiFriendDeclaredWarOnUsTurn;

	// Warmongering Penalties
	kStream << m_aiNumMinorsAttacked;
	kStream << m_aiNumMinorsConquered;
	kStream << m_aiNumMajorsAttacked;
	kStream << m_aiNumMajorsConquered;
	kStream << m_aiWarmongerAmountTimes100;

	// Aggressive Postures
	kStream << m_aeMilitaryAggressivePosture;
	kStream << m_aeLastTurnMilitaryAggressivePosture;
	kStream << m_aeExpansionAggressivePosture;
	kStream << m_aePlotBuyingAggressivePosture;

	// Dispute Levels
	kStream << m_abEndgameAggressiveTo;
	kStream << m_abRecklessExpander;
	kStream << m_abWonderSpammer;
	kStream << m_aeLandDisputeLevel;
	kStream << m_aeLastTurnLandDisputeLevel;
	kStream << m_aeVictoryDisputeLevel;
	kStream << m_aeVictoryBlockLevel;
	kStream << m_aeWonderDisputeLevel;
	kStream << m_aeMinorCivDisputeLevel;
	kStream << m_aeTechBlockLevel;
	kStream << m_aePolicyBlockLevel;

	// Threat Levels
	kStream << m_aeMilitaryThreat;
	kStream << m_aeWarmongerThreat;

	// Strength Assessments
	kStream << m_aeMilitaryStrengthComparedToUs;
	kStream << m_aeEconomicStrengthComparedToUs;
	kStream << m_aeTargetValue;
	kStream << m_abEasyTarget;

	// PROMISES
	// Military Promise
	kStream << m_aeMilitaryPromiseState;
	kStream << m_aiMilitaryPromiseTurn;

	// Expansion Promise
	kStream << m_aeExpansionPromiseState;
	kStream << m_aeExpansionPromisePosture;
	kStream << m_aiExpansionPromiseTurn;
	kStream << m_aNoExpansionPromise;
	kStream << m_aLastTurnEmpireDistance;
	kStream << m_abEverMadeExpansionPromise;

	// Border Promise
	kStream << m_aeBorderPromiseState;
	kStream << m_aeBorderPromisePosture;
	kStream << m_aiBorderPromiseTurn;
	kStream << m_abEverMadeBorderPromise;

	// Bully City-State Promise
	kStream << m_aeBullyCityStatePromiseState;
	kStream << m_aiBullyCityStatePromiseTurn;

	// Attack City-State Promise
	kStream << m_aeAttackCityStatePromiseState;
	kStream << m_aiAttackCityStatePromiseTurn;

	// Spy Promise
	kStream << m_aeSpyPromiseState;
	kStream << m_aiSpyPromiseTurn;

	// No Convert Promise
	kStream << m_aeNoConvertPromiseState;
	kStream << m_aiNoConvertPromiseTurn;
	kStream << m_abAskedNotToConvert;
	kStream << m_abEverConvertedCity;

	// No Digging Promise
	kStream << m_aeNoDiggingPromiseState;
	kStream << m_aiNoDiggingPromiseTurn;
	kStream << m_abAskedNotToDig;

	// Coop War Promise
	kStream << m_aiBrokenCoopWarPromiseTurn;

	// END PROMISES
	// Event Flags
	kStream << m_abReturnedCapital;
	kStream << m_abReturnedHolyCity;
	kStream << m_abLiberatedCapital;
	kStream << m_abLiberatedHolyCity;
	kStream << m_abDoFEverAsked;
	kStream << m_abCapturedCapital;
	kStream << m_abCapturedHolyCity;

	// # of times/points counters
	kStream << m_aiNumCitiesLiberated;
	kStream << m_aiNumCiviliansReturnedToMe;
	kStream << m_aiNumTimesIntrigueSharedBy;
	kStream << m_aiNumLandmarksBuiltForMe;
	kStream << m_aiTheyPlottedAgainstUs;
	kStream << m_aiNumTimesRazed;
	kStream << m_aiNumTradeRoutesPlundered;	
	kStream << m_aiNumWondersBeatenTo;
	kStream << m_aiNumTimesCultureBombed;
	kStream << m_aiTheyLoweredOurInfluence;
	kStream << m_aiNumProtectedMinorsBullied;
	kStream << m_aiNumProtectedMinorsAttacked;
	kStream << m_aiNumProtectedMinorsKilled;
	kStream << m_aiNegativeReligiousConversionPoints;
	kStream << m_aiNumTimesRobbedBy;
	kStream << m_aiPerformedCoupAgainstUs;
	kStream << m_aiLikedTheirProposalValue;
	kStream << m_aiSupportedOurProposalValue;
	kStream << m_aiSupportedOurHostingValue;
	kStream << m_aiNegativeArchaeologyPoints;
	kStream << m_aiArtifactsEverDugUp;
	kStream << m_aiNumTimesNuked;

	// Turn counters
	kStream << m_aiResurrectedOnTurn;
	kStream << m_aiLiberatedCitiesTurn;
	kStream << m_aiCiviliansReturnedToMeTurn;
	kStream << m_aiIntrigueSharedTurn;
	kStream << m_aiPlayerForgaveForSpyingTurn;
	kStream << m_aiLandmarksBuiltForMeTurn;
	kStream << m_aiPlottedAgainstUsTurn;
	kStream << m_aiPlunderedTradeRouteTurn;
	kStream << m_aiSidedWithProtectedMinorTurn;
	kStream << m_aiBulliedProtectedMinorTurn;
	kStream << m_aiAttackedProtectedMinorTurn;
	kStream << m_aiKilledProtectedMinorTurn;
	kStream << m_aiReligiousConversionTurn;
	kStream << m_aiTimesRobbedTurn;
	kStream << m_aiPerformedCoupTurn;
	kStream << m_aiWeLikedTheirProposalTurn;
	kStream << m_aiWeDislikedTheirProposalTurn;
	kStream << m_aiTheySupportedOurProposalTurn;
	kStream << m_aiTheyFoiledOurProposalTurn;
	kStream << m_aiTheySupportedOurHostingTurn;

	// Player-Specific Memory
	kStream << m_aeProtectedMinorBullied;
	kStream << m_aeProtectedMinorAttacked;
	kStream << m_aeProtectedMinorKilled;

	// GUESSES
	// Guesses about other players' feelings towards us
	kStream << m_aeOpinionTowardsUsGuess;
	kStream << m_aeApproachTowardsUsGuess;
	kStream << m_aeApproachTowardsUsGuessCounter;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// C4DF Values
	kStream << m_abShareOpinionAccepted;
	kStream << m_abShareOpinionEverAsked;
	kStream << m_aiHelpRequestAcceptedTurn;
	kStream << m_aiHelpRequestTooSoonNumTurns;
	kStream << m_abTargetingVassal;
	kStream << m_aiPlayerVassalageFailedProtectValue;
	kStream << m_aiPlayerVassalageProtectValue;
	kStream << m_aiPlayerVassalagePeacefullyRevokedTurn;
	kStream << m_aiPlayerVassalageForcefullyRevokedTurn;
	kStream << m_aiNumTimesDemandedWhenVassal;
	kStream << m_abHasPaidTributeTo;
	kStream << m_aiBrokenVassalAgreementTurn;
	kStream << m_aiMoveTroopsRequestAcceptedTurn;
	kStream << m_abOfferingGift;
	kStream << m_abOfferedGift;
	kStream << m_abMasterLiberatedMeFromVassalage;
	kStream << m_abVassalTaxRaised;
	kStream << m_abVassalTaxLowered;
	kStream << m_aiVassalGoldPerTurnTaxedSinceVassalStarted;
	kStream << m_aiVassalGoldPerTurnCollectedSinceVassalStarted;
#endif
}

//	-----------------------------------------------------------------------------------------------
void CvDiplomacyAI::update()
{
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (!GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if (!m_aGreetPlayers.empty())
		{
			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
			// In out list?
			PlayerTypesArray::iterator itr = std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), eActivePlayer);
			if (itr != m_aGreetPlayers.end())
			{
				m_aGreetPlayers.erase(itr);

				const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_INTRO);
				if (szText)
				{
					CvDiplomacyRequests::SendRequest(GetID(), eActivePlayer, DIPLO_UI_STATE_DEFAULT_ROOT, szText, LEADERHEAD_ANIM_INTRO);
				}
			}
		}
	}
#endif
}

//	-----------------------------------------------------------------------------------------------
//	-----------------------------------------------------------------------------------------------
//	-----------------------------------------------------------------------------------------------

// ************************************
// Pointers
// ************************************


/// Returns the Player object this class is associated with
CvPlayer* CvDiplomacyAI::GetPlayer()
{
	return m_pPlayer;
}
const CvPlayer* CvDiplomacyAI::GetPlayer() const
{
	return m_pPlayer;
}
/// Returns the Team ID this AI's player is associated with
TeamTypes CvDiplomacyAI::GetTeam() const
{
	return m_pPlayer->getTeam();
}


// ************************************
// Helper Functions
// ************************************


/// Is this a valid player to be looking at for diplomacy purposes? (e.g. are they alive, do we know them, etc.)
bool CvDiplomacyAI::IsPlayerValid(PlayerTypes eOtherPlayer, bool bMyTeamIsValid /* = false = */ ) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS) return false;

	// Alive?
	if (!GET_PLAYER(eOtherPlayer).isAlive())
	{
		return false;
	}

	// REALLY Alive? (For some reason a player can be "alive" but have no Cities, Units, etc... grrrr)
	if (GET_PLAYER(eOtherPlayer).getNumCities() <= 0)
	{
		return false;
	}

	// A player we've met?
	if (!GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(eOtherPlayer).getTeam()))
	{
		return false;
	}

	// On our team?
	if (!bMyTeamIsValid)
	{
		if (GET_PLAYER(eOtherPlayer).getTeam() == GetTeam())
		{
			return false;
		}
	}

	return true;
}

/// Returns the number of valid major civs
int CvDiplomacyAI::GetNumValidMajorCivs() const
{
	int iCount = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		if (IsPlayerValid(ePlayer) && GET_PLAYER(ePlayer).isMajorCiv())
		{
			iCount++;
		}
	}

	return iCount;
}

/// Returns a vector containing pointers to all valid major civs
vector<PlayerTypes> CvDiplomacyAI::GetAllValidMajorCivs() const
{
	vector<PlayerTypes> result;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		if (IsPlayerValid(ePlayer) && GET_PLAYER(ePlayer).isMajorCiv())
			result.push_back(ePlayer);
	}
	
	return result;
}

//	-----------------------------------------------------------------------------------------------

/// Determine if we're at war with a player
bool CvDiplomacyAI::IsAtWar(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_PLAYERS) return false;
	return GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if we're always at war with a player
bool CvDiplomacyAI::IsAlwaysAtWar(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_PLAYERS) return false;

	if (GetTeam() == GET_PLAYER(eOtherPlayer).getTeam())
		return false;

	if (eOtherPlayer == BARBARIAN_PLAYER)
		return true;

	if (GET_PLAYER(eOtherPlayer).isMinorCiv() && GET_PLAYER(eOtherPlayer).GetMinorCivAI()->IsPermanentWar(GetTeam()))
		return true;

	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
		return true;

	return GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE) && IsAtWar(eOtherPlayer);
}

/// Determine if a player is a teammate (returns false for ourselves!)
bool CvDiplomacyAI::IsTeammate(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS || eOtherPlayer == GetID()) return false;
	return GetTeam() == GET_PLAYER(eOtherPlayer).getTeam();
}

/// Determine if a player is on a team we've met
bool CvDiplomacyAI::IsHasMet(PlayerTypes eOtherPlayer, bool bMyTeamIsValid /* = false */) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS) return false;

	if (GetTeam() == GET_PLAYER(eOtherPlayer).getTeam())
		return bMyTeamIsValid;

	return GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if a player's team has a Defensive Pact with our team
bool CvDiplomacyAI::IsHasDefensivePact(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;
	return GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if a player's team has a Research Agreement with our team
bool CvDiplomacyAI::IsHasResearchAgreement(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;
	return GET_TEAM(GetTeam()).IsHasResearchAgreement(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if we have an embassy with a player's team
bool CvDiplomacyAI::IsHasEmbassy(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;
	return GET_TEAM(GetTeam()).HasEmbassyAtTeam(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if we have Open Borders with a player's team (we can enter their territory)
bool CvDiplomacyAI::IsHasOpenBorders(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS) return false;

	if (GET_PLAYER(eOtherPlayer).isMinorCiv())
	{
		return GET_PLAYER(eOtherPlayer).GetMinorCivAI()->IsPlayerHasOpenBorders(GetID());
	}

	return GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).IsAllowsOpenBordersToTeam(GetTeam());
}

/// Determine if we're a player's vassal
bool CvDiplomacyAI::IsVassal(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;

	return GET_TEAM(GetTeam()).IsVassal(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Determine if we're a player's master
bool CvDiplomacyAI::IsMaster(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;

	return GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).IsVassal(GetTeam());
}

/// Determine if our current vassalage agreement with this player is voluntary (functions in either direction)
bool CvDiplomacyAI::IsVoluntaryVassalage(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return false;

	if (IsVassal(eOtherPlayer) && GET_TEAM(GetTeam()).IsVoluntaryVassal(GET_PLAYER(eOtherPlayer).getTeam())) 
		return true;

	if (IsMaster(eOtherPlayer) && GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).IsVoluntaryVassal(GetTeam())) 
		return true;
	
	return false;
}

/// Which players would we go to war with if we went to war with ePlayer?
vector<PlayerTypes> CvDiplomacyAI::GetLinkedWarPlayers(PlayerTypes eOtherPlayer, bool bIgnoreDefensivePacts, bool bIncludeMinors, bool bIncludeUnmet) const
{
	vector<PlayerTypes> result;
	vector<PlayerTypes> vMinorsToCheck;
	int iLoopUntil = bIncludeMinors ? MAX_CIV_PLAYERS : MAX_MAJOR_CIVS;

	for (int iPlayerLoop = 0; iPlayerLoop < iLoopUntil; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isBarbarian())
			continue;

		if (GET_PLAYER(eLoopPlayer).getNumCities() <= 0)
			continue;

		if (GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
			continue;

		if (!bIncludeMinors && GET_PLAYER(eLoopPlayer).isMinorCiv())
			continue;

		if (!bIncludeUnmet && !IsHasMet(eLoopPlayer))
			continue;

		if (eLoopPlayer != eOtherPlayer && GET_PLAYER(eLoopPlayer).isAlive())
		{
			// Teammate?
			if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(eOtherPlayer))
			{
				result.push_back(eLoopPlayer);
			}
			else if (GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				// Defensive Pact?
				if (!bIgnoreDefensivePacts && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsHasDefensivePact(eOtherPlayer))
				{
					result.push_back(eLoopPlayer);
				}
				// Master?
				else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsMaster(eOtherPlayer))
				{
					result.push_back(eLoopPlayer);
				}
				// Vassal?
				else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsVassal(eOtherPlayer))
				{
					result.push_back(eLoopPlayer);
				}
			}
			else if (bIncludeMinors)
			{
				PlayerTypes eAlly = GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly();

				if (eAlly == NO_PLAYER || GET_PLAYER(eAlly).getTeam() == GetTeam())
					continue;

				vMinorsToCheck.push_back(eAlly);
			}
		}
	}

	// Since we can't declare war on a vassal without also DoW'ing the master, we need to check the master team's DPs and vassals too
	if (GET_PLAYER(eOtherPlayer).IsVassalOfSomeone())
	{
		TeamTypes eMasterTeam = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetMaster();
		vector<PlayerTypes> vMasterTeam = GET_TEAM(eMasterTeam).getPlayers();
		PlayerTypes eMasterPlayer = NO_PLAYER;

		for (size_t i=0; i<vMasterTeam.size(); i++)
		{
			if (!GET_PLAYER(vMasterTeam[i]).isAlive())
				continue;

			eMasterPlayer = vMasterTeam[i];
			break;
		}

		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
				continue;

			if (!bIncludeUnmet && !IsHasMet(eLoopPlayer))
				continue;

			if (eLoopPlayer != eOtherPlayer && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				if ((!bIgnoreDefensivePacts && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsHasDefensivePact(eMasterPlayer)) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsVassal(eMasterPlayer))
				{
					// Make sure not to include them more than once!
					if (std::find(result.begin(), result.end(), eLoopPlayer) == result.end())
					{
						result.push_back(eLoopPlayer);
					}
				}
			}
		}
	}

	// Include any City-State allies of any majors we'd go to war with!
	if (bIncludeMinors)
	{
		for (std::vector<PlayerTypes>::iterator it = vMinorsToCheck.begin(); it != vMinorsToCheck.end(); it++)
		{
			PlayerTypes eAlly = GET_PLAYER(*it).GetMinorCivAI()->GetAlly();

			if (std::find(result.begin(), result.end(), eAlly) != result.end())
			{
				result.push_back(*it);
			}
		}
	}

	return result;
}


// ************************************
// Personality Values
// ************************************

/// Returns a personality weight with a small random element
int CvDiplomacyAI::GetRandomPersonalityWeight(int iOriginalValue, int& iSeed)
{
	int iMin = /*1*/ GC.getDIPLO_PERSONALITY_FLAVOR_MIN_VALUE();
	int iMax = /*10*/ GC.getDIPLO_PERSONALITY_FLAVOR_MAX_VALUE();
	int iPlusMinus = /*2*/ GC.getFLAVOR_RANDOMIZATION_RANGE();

	if (GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		iPlusMinus *= 2;
	}

	// Player ID (used for randomization below)
	int ID = (int) GetID();

	// Error handling to prevent out of bounds values
	if (iMin < 1 || iMin > 20)
	{
		iMin = 1;
	}
	if (iMax < 1 || iMax > 20)
	{
		iMax = 10;
	}
	if (iMin > iMax)
	{
		iMin = iMax;
	}
	if (iPlusMinus < 0)
	{
		iPlusMinus *= -1;
	}
	if (iOriginalValue < iMin)
	{
		iOriginalValue = iMin;
	}
	else if (iOriginalValue > iMax)
	{
		iOriginalValue = iMax;
	}

	// Increment the random seed (and make sure it's > 0)
	if (iSeed < 0)
	{
		iSeed = 0;
	}

	iSeed += (iOriginalValue + iPlusMinus + ID) * 200;

	// Randomize!
	int iAdjust = GC.getGame().getSmallFakeRandNum((iPlusMinus * 2 + 1), (iOriginalValue * iSeed * ID));
	int iRtnValue = iOriginalValue + iAdjust - iPlusMinus;

	return range(iRtnValue, iMin, iMax);
}

//	-----------------------------------------------------------------------------------------------

/// Initializes Personality Values for this player (XML value + random element)
void CvDiplomacyAI::DoInitializePersonality()
{
	// AI Player
	if (!GetPlayer()->isHuman())
	{
		const CvLeaderHeadInfo& playerLeaderInfo = GetPlayer()->getLeaderInfo();
		int iSeed = 0;

		m_iVictoryCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetVictoryCompetitiveness(), iSeed);
		m_iWonderCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetWonderCompetitiveness(), iSeed);
		m_iMinorCivCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetMinorCivCompetitiveness(), iSeed);
		m_iBoldness = GetRandomPersonalityWeight(playerLeaderInfo.GetBoldness(), iSeed);
		m_iDiploBalance = GetRandomPersonalityWeight(playerLeaderInfo.GetDiploBalance(), iSeed);
		m_iWarmongerHate = GetRandomPersonalityWeight(playerLeaderInfo.GetWarmongerHate(), iSeed);
		m_iDenounceWillingness = GetRandomPersonalityWeight(playerLeaderInfo.GetDenounceWillingness(), iSeed);
		m_iDoFWillingness = GetRandomPersonalityWeight(playerLeaderInfo.GetDoFWillingness(), iSeed);
		m_iLoyalty = GetRandomPersonalityWeight(playerLeaderInfo.GetLoyalty(), iSeed);
		m_iNeediness = GetRandomPersonalityWeight(playerLeaderInfo.GetNeediness(), iSeed);
		m_iForgiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetForgiveness(), iSeed);
		m_iChattiness = GetRandomPersonalityWeight(playerLeaderInfo.GetChattiness(), iSeed);
		m_iMeanness = GetRandomPersonalityWeight(playerLeaderInfo.GetMeanness(), iSeed);

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_aiPersonalityMajorCivApproachBiases[iApproachLoop] = GetRandomPersonalityWeight(playerLeaderInfo.GetMajorCivApproachBias(iApproachLoop), iSeed);
		}

		for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_aiPersonalityMinorCivApproachBiases[iApproachLoop] = GetRandomPersonalityWeight(playerLeaderInfo.GetMinorCivApproachBias(iApproachLoop), iSeed);
		}
	}
	// Human player
	else
	{
		int iDefaultFlavorValue = /*5*/ GC.getGame().GetDefaultFlavorValue();

		m_iVictoryCompetitiveness = iDefaultFlavorValue;
		m_iWonderCompetitiveness = iDefaultFlavorValue;
		m_iMinorCivCompetitiveness = iDefaultFlavorValue;
		m_iBoldness = iDefaultFlavorValue;
		m_iDiploBalance = iDefaultFlavorValue;
		m_iWarmongerHate = iDefaultFlavorValue;
		m_iDenounceWillingness = iDefaultFlavorValue;
		m_iDoFWillingness = iDefaultFlavorValue;
		m_iLoyalty = iDefaultFlavorValue;
		m_iNeediness = iDefaultFlavorValue;
		m_iForgiveness = iDefaultFlavorValue;
		m_iChattiness = iDefaultFlavorValue;
		m_iMeanness = iDefaultFlavorValue;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_aiPersonalityMajorCivApproachBiases[iApproachLoop] = iDefaultFlavorValue;
		}

		for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_aiPersonalityMinorCivApproachBiases[iApproachLoop] = iDefaultFlavorValue;
		}
	}

	// Now that we've picked our flavors, select a Diplo Personality.
	DoInitializeDiploPersonalityType();
	LogPersonality();

	// Initialize a few static values here
	SetPlayerMilitaryStrengthComparedToUs(GetID(), STRENGTH_AVERAGE);
	SetPlayerEconomicStrengthComparedToUs(GetID(), STRENGTH_AVERAGE);
	SetPlayerTargetValue(GetID(), TARGET_VALUE_AVERAGE);
	SetWarGoal(BARBARIAN_PLAYER, WAR_GOAL_CONQUEST);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsTeammate(eLoopPlayer))
		{
			if (GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				m_aeMajorCivApproach[(int)eLoopPlayer] = MAJOR_CIV_APPROACH_FRIENDLY;
			}
			else if (GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				m_aeMinorCivApproach[(int)eLoopPlayer] = MINOR_CIV_APPROACH_PROTECTIVE;
			}
		}
	}
}

//	-----------------------------------------------------------------------------------------------

/// Select our Diplo Personality for this game (affects sensitivity to a specific victory condition and other things)
void CvDiplomacyAI::DoInitializeDiploPersonalityType()
{
	// Human player - pick a default personality based on leader traits
	if (GetPlayer()->isHuman())
	{
		if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_CONQUEROR);
		}
		else if (GetPlayer()->GetPlayerTraits()->IsNerd())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_SCIENTIST);
		}
		else if (GetPlayer()->GetPlayerTraits()->IsTourism())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_CULTURAL);
		}
		else if (GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_DIPLOMAT);
		}
		else if (GetPlayer()->GetPlayerTraits()->IsExpansionist())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_CONQUEROR);
		}
		else if (GetPlayer()->GetPlayerTraits()->IsSmaller())
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_SCIENTIST);
		}
		else
		{
			SetDiploPersonalityType(DIPLO_PERSONALITY_CONQUEROR);
		}
		return;
	}

	// AI player - score personalities based on flavors
	int iConquerorWeight = 0;
	int iDiplomatWeight = 0;
	int iCulturalWeight = 0;
	int iScientistWeight = 0;

	int ID = (int) GetID();
	int iRandom = 4;

	// Add more randomness if Random Personalities is active
	if (GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		iRandom *= 2;
	}

	// Random seed to ensure the fake RNG doesn't return the same value repeatedly
	int iSeed = 1;

	CvFlavorManager* pFlavorMgr = GetPlayer()->GetFlavorManager();

	// Weight for conquest
	iConquerorWeight += GetBoldness();
	iConquerorWeight += GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);
	iConquerorWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));
	iConquerorWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));
	iConquerorWeight += GC.getGame().getSmallFakeRandNum(iRandom, ((GetBoldness() * GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR) * iSeed) + ID));
	iSeed += (iConquerorWeight * iRandom * ID);
	iSeed *= 2;

	// Weight for diplomacy
	iDiplomatWeight += GetDoFWillingness();
	iDiplomatWeight += GetLoyalty();
	iDiplomatWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DIPLOMACY"));
	iDiplomatWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GOLD"));
	iDiplomatWeight += GC.getGame().getSmallFakeRandNum(iRandom, ((GetDoFWillingness() * GetLoyalty() * iSeed) + ID));
	iSeed += (iDiplomatWeight * iRandom * ID) + iConquerorWeight;
	iSeed *= 2;

	// Weight for culture
	iCulturalWeight += GetWonderCompetitiveness();
	iCulturalWeight += GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_FRIENDLY);
	iCulturalWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_WONDER"));
	iCulturalWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));
	iCulturalWeight += GC.getGame().getSmallFakeRandNum(iRandom, ((GetWonderCompetitiveness() * GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_FRIENDLY) * iSeed) + ID));
	iSeed += (iCulturalWeight * iRandom * ID) + iConquerorWeight + iDiplomatWeight;
	iSeed *= 2;

	// Weight for science
	iScientistWeight += GetDiploBalance();
	iScientistWeight += GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_NEUTRAL);
	iScientistWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SCIENCE"));
	iScientistWeight += pFlavorMgr->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH"));
	iScientistWeight += GC.getGame().getSmallFakeRandNum(iRandom, ((GetDiploBalance() * GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_NEUTRAL) * iSeed) + ID));

	// Add weight for leader traits
	if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
	{
		iConquerorWeight += 4;
	}
	if (GetPlayer()->GetPlayerTraits()->IsDiplomat())
	{
		iDiplomatWeight += 4;
	}
	if (GetPlayer()->GetPlayerTraits()->IsTourism())
	{
		iCulturalWeight += 4;
	}
	if (GetPlayer()->GetPlayerTraits()->IsNerd())
	{
		iScientistWeight += 4;
	}
	if (GetPlayer()->GetPlayerTraits()->IsExpansionist())
	{
		iConquerorWeight += 2;
		iCulturalWeight -= 2;
		iScientistWeight -= 2;
	}
	if (GetPlayer()->GetPlayerTraits()->IsSmaller())
	{
		iConquerorWeight -= 2;
		iCulturalWeight += 2;
		iScientistWeight += 2;
	}

	// Insufficient minor civs?
	if (GC.getGame().GetNumMinorCivsEver() < GC.getGame().countMajorCivsEverAlive())
	{
		iDiplomatWeight -= 4;

		if (GC.getGame().GetNumMinorCivsEver() == 0)
		{
			iDiplomatWeight -= 4;
		}
	}

	bool bTie = false;
	int iBestWeight = 0;
	DiploPersonalityTypes eBestPersonality = NO_DIPLO_PERSONALITY_TYPE;
	
	if (iConquerorWeight > iBestWeight)
	{
		iBestWeight = iConquerorWeight;
		eBestPersonality = DIPLO_PERSONALITY_CONQUEROR;
	}

	if (iDiplomatWeight > iBestWeight)
	{
		iBestWeight = iDiplomatWeight;
		eBestPersonality = DIPLO_PERSONALITY_DIPLOMAT;
		bTie = false;
	}
	else if (iDiplomatWeight == iBestWeight)
	{
		bTie = true;
	}

	if (iCulturalWeight > iBestWeight)
	{
		iBestWeight = iCulturalWeight;
		eBestPersonality = DIPLO_PERSONALITY_CULTURAL;
		bTie = false;
	}
	else if (iCulturalWeight == iBestWeight)
	{
		bTie = true;
	}

	if (iScientistWeight > iBestWeight)
	{
		iBestWeight = iScientistWeight;
		eBestPersonality = DIPLO_PERSONALITY_SCIENTIST;
		bTie = false;
	}
	else if (iScientistWeight == iBestWeight)
	{
		bTie = true;
	}

	// In the event of a tie, use the civ's leader traits
	if (bTie)
	{
		if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		{
			eBestPersonality = DIPLO_PERSONALITY_CONQUEROR;
		}
		else if (GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			eBestPersonality = DIPLO_PERSONALITY_DIPLOMAT;
		}
		else if (GetPlayer()->GetPlayerTraits()->IsTourism())
		{
			eBestPersonality = DIPLO_PERSONALITY_CULTURAL;
		}
		else
		{
			eBestPersonality = DIPLO_PERSONALITY_SCIENTIST;
		}
	}

	SetDiploPersonalityType(eBestPersonality);
}

//	-----------------------------------------------------------------------------------------------

/// How much does this AI leader get angry when another player is competing for Victory?
int CvDiplomacyAI::GetVictoryCompetitiveness() const
{
	return m_iVictoryCompetitiveness;
}

/// How much does this AI leader get angry when they're beaten to a World Wonder?
int CvDiplomacyAI::GetWonderCompetitiveness() const
{
	return m_iWonderCompetitiveness;
}

/// How much does this AI leader get angry when another player is befriending "their" minor civs?
int CvDiplomacyAI::GetMinorCivCompetitiveness() const
{
	return m_iMinorCivCompetitiveness;
}

/// How likely is this AI leader to take risks / go for World Conquest?
int CvDiplomacyAI::GetBoldness() const
{
	return m_iBoldness;
}

/// How much does this AI leader want to maintain a balance of power in the world?
int CvDiplomacyAI::GetDiploBalance() const
{
	return m_iDiploBalance;
}

/// How much does this AI leader get angry when someone's being a warmonger?
int CvDiplomacyAI::GetWarmongerHate() const
{
	return m_iWarmongerHate;
}

/// How much is this AI leader willing to work with someone AGAINST another player?
int CvDiplomacyAI::GetDenounceWillingness() const
{
	return m_iDenounceWillingness;
}

/// How much is this AI leader willing to befriend other players?
int CvDiplomacyAI::GetDoFWillingness() const
{
	return m_iDoFWillingness;
}

/// How likely is this AI leader to refrain from backstabbing their friends?
int CvDiplomacyAI::GetLoyalty() const
{
	return m_iLoyalty;
}

/// How much does this AI leader want the support of its friends in rough times?
int CvDiplomacyAI::GetNeediness() const
{
	return m_iNeediness;
}

/// How willing is this AI leader to overlook transgressions against them?
int CvDiplomacyAI::GetForgiveness() const
{
	return m_iForgiveness;
}

/// How much does this AI leader like to pop up and talk?
int CvDiplomacyAI::GetChattiness() const
{
	return m_iChattiness;
}

/// How much does this AI leader like to talk smack / bully others?
int CvDiplomacyAI::GetMeanness() const
{
	return m_iMeanness;
}

/// What is this AI leader's bias towards a particular Major Civ Approach?
int CvDiplomacyAI::GetPersonalityMajorCivApproachBias(MajorCivApproachTypes eApproach) const
{
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return 0;
	return m_aiPersonalityMajorCivApproachBiases[(int)eApproach];
}

/// What is this AI leader's bias towards a particular Minor Civ Approach?
int CvDiplomacyAI::GetPersonalityMinorCivApproachBias(MinorCivApproachTypes eApproach) const
{
	if (eApproach < 0 || eApproach >= NUM_MINOR_CIV_APPROACHES) return 0;
	return m_aiPersonalityMinorCivApproachBiases[(int)eApproach];
}

//	-----------------------------------------------------------------------------------------------

/// What is this AI leader's Diplomatic Personality Type?
DiploPersonalityTypes CvDiplomacyAI::GetDiploPersonalityType() const
{
	return (DiploPersonalityTypes) m_eDiploPersonalityType;
}

/// Sets this AI leader's Diplomatic Personality Type
void CvDiplomacyAI::SetDiploPersonalityType(DiploPersonalityTypes eDiploPersonality)
{
	if (eDiploPersonality < NO_DIPLO_PERSONALITY_TYPE || eDiploPersonality >= NUM_DIPLO_PERSONALITY_TYPES) return;
	m_eDiploPersonalityType = eDiploPersonality;
}

/// Is this AI leader naturally inclined to be aggressive and covetous of others' possessions?
bool CvDiplomacyAI::IsConqueror() const
{
	return GetDiploPersonalityType() == DIPLO_PERSONALITY_CONQUEROR;
}

/// Is this AI leader naturally focused on forging friendships and allying City-States?
bool CvDiplomacyAI::IsDiplomat() const
{
	return GetDiploPersonalityType() == DIPLO_PERSONALITY_DIPLOMAT;
}

/// Is this AI leader naturally focused on spreading its culture across the world?
bool CvDiplomacyAI::IsCultural() const
{
	return GetDiploPersonalityType() == DIPLO_PERSONALITY_CULTURAL;
}

/// Is this AI leader naturally focused on their civilization's technological advancement?
bool CvDiplomacyAI::IsScientist() const
{
	return GetDiploPersonalityType() == DIPLO_PERSONALITY_SCIENTIST;
}


// ************************************
// Memory Management
// ************************************

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Diplomatic Interactions
// ------------------------------------

/// We made a public declaration, so keep a record of it
void CvDiplomacyAI::DoAddNewDeclarationToLog(PublicDeclarationTypes eDeclaration, int iData1, int iData2, PlayerTypes eMustHaveMetPlayer, bool bActive)
{
	//if (eDeclaration < 0 || eDeclaration >= NUM_PUBLIC_DECLARATION_TYPES) return;

	// Bump current entries back so we can put the new one at index 0
	for (int iI = MAX_DIPLO_LOG_STATEMENTS - 1; iI > 0; iI--)
	{
		// Nothing in this entry to move?
		if (m_aDeclarationsLog[iI-1].m_eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
		{
			m_aDeclarationsLog[iI].m_eDeclaration = m_aDeclarationsLog[iI-1].m_eDeclaration;
			m_aDeclarationsLog[iI].m_iData1 = m_aDeclarationsLog[iI-1].m_iData1;
			m_aDeclarationsLog[iI].m_iData2 = m_aDeclarationsLog[iI-1].m_iData2;
			m_aDeclarationsLog[iI].m_eMustHaveMetPlayer = m_aDeclarationsLog[iI-1].m_eMustHaveMetPlayer;
			m_aDeclarationsLog[iI].m_bActive = m_aDeclarationsLog[iI-1].m_bActive;
			m_aDeclarationsLog[iI].m_iTurn = m_aDeclarationsLog[iI-1].m_iTurn;
		}
	}

	m_aDeclarationsLog[0].m_eDeclaration = eDeclaration;
	m_aDeclarationsLog[0].m_iData1 = iData1;
	m_aDeclarationsLog[0].m_iData2 = iData2;
	m_aDeclarationsLog[0].m_eMustHaveMetPlayer = eMustHaveMetPlayer;
	m_aDeclarationsLog[0].m_bActive = bActive;
	m_aDeclarationsLog[0].m_iTurn = 0;
}

/// Returns the DeclarationLogType associated with the index passed in
PublicDeclarationTypes CvDiplomacyAI::GetDeclarationLogTypeForIndex(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return NO_PUBLIC_DECLARATION_TYPE;
	return m_aDeclarationsLog[iIndex].m_eDeclaration;
}

/// Returns the DeclarationLog iData1 number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogData1ForIndex(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return -1;
	return m_aDeclarationsLog[iIndex].m_iData1;
}

/// Returns the DeclarationLog iData2 number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogData2ForIndex(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return -1;
	return m_aDeclarationsLog[iIndex].m_iData2;
}

/// Does whoever is listening to our declaration have to have met someone?
PlayerTypes CvDiplomacyAI::GetDeclarationLogMustHaveMetPlayerForIndex(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return NO_PLAYER;
	return m_aDeclarationsLog[iIndex].m_eMustHaveMetPlayer;
}

/// Returns the DeclarationLog iData2 number associated with the index passed in
bool CvDiplomacyAI::IsDeclarationLogForIndexActive(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return false;
	return m_aDeclarationsLog[iIndex].m_bActive;
}

/// Make Declaration invalid (so that it doesn't appear for new players we meet, for example)
void CvDiplomacyAI::DoMakeDeclarationInactive(PublicDeclarationTypes eDeclaration, int iData1, int iData2)
{
	//if (eDeclaration < 0 || eDeclaration >= NUM_DIPLO_LOG_STATEMENT_TYPES) return;

	for (int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
	{
		// DeclarationType match?
		if (m_aDeclarationsLog[iLoop].m_eDeclaration == eDeclaration)
		{
			// iData1 match?
			if (m_aDeclarationsLog[iLoop].m_iData1 == iData1)
			{
				// iData2 match?
				if (m_aDeclarationsLog[iLoop].m_iData2 == iData2)
				{
					m_aDeclarationsLog[iLoop].m_bActive = false;
				}
			}
		}
	}
}

/// Returns the DeclarationLog turn number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogTurnForIndex(int iIndex)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return -1;
	return m_aDeclarationsLog[iIndex].m_iTurn;
}

/// Sets the DeclarationLog turn number associated with the index passed in
void CvDiplomacyAI::SetDeclarationLogTurnForIndex(int iIndex, int iNewValue)
{
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return;
	m_aDeclarationsLog[iIndex].m_iTurn = max(iNewValue, 0);
}

/// Changes the DeclarationLog turn number associated with the index passed in
void CvDiplomacyAI::ChangeDeclarationLogTurnForIndex(int iIndex, int iChange)
{
	SetDeclarationLogTurnForIndex(iIndex, GetDeclarationLogTurnForIndex(iIndex) + iChange);
}

/// We talked to someone, so keep a record of it
void CvDiplomacyAI::DoAddNewStatementToDiploLog(PlayerTypes ePlayer, DiploStatementTypes eNewDiploLogStatement)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	//if (eNewDiploLogStatement < 0 || eNewDiploLogStatement >= NUM_DIPLO_LOG_STATEMENT_TYPES) return;

	// Bump current entries back so we can put the new one at index 0
	for (int iI = MAX_DIPLO_LOG_STATEMENTS - 1; iI > 0; iI--)
	{
		// Nothing in this entry to move?
		if (m_aaDiploStatementsLog[ePlayer][iI-1].m_eDiploLogStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			m_aaDiploStatementsLog[ePlayer][iI].m_eDiploLogStatement = m_aaDiploStatementsLog[ePlayer][iI-1].m_eDiploLogStatement;
			m_aaDiploStatementsLog[ePlayer][iI].m_iTurn = m_aaDiploStatementsLog[ePlayer][iI-1].m_iTurn;
		}
	}

	m_aaDiploStatementsLog[ePlayer][0].m_eDiploLogStatement = eNewDiploLogStatement;
	m_aaDiploStatementsLog[ePlayer][0].m_iTurn = 0;
}

/// Returns the DiploLogStatementType associated with the index passed in
DiploStatementTypes CvDiplomacyAI::GetDiploLogStatementTypeForIndex(PlayerTypes ePlayer, int iIndex)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DIPLO_STATEMENT_TYPE;
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return NO_DIPLO_STATEMENT_TYPE;
	return m_aaDiploStatementsLog[ePlayer][iIndex].m_eDiploLogStatement;
}

/// Returns the DiploLogStatement turn number associated with the index passed in
int CvDiplomacyAI::GetDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return -1;
	return m_aaDiploStatementsLog[ePlayer][iIndex].m_iTurn;
}

/// Sets the DiploLogStatement turn number associated with the index passed in
void CvDiplomacyAI::SetDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex, int iNewValue)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	//if (iIndex < 0 || iIndex >= MAX_DIPLO_LOG_STATEMENTS) return;
	m_aaDiploStatementsLog[ePlayer][iIndex].m_iTurn = max(iNewValue, 0);
}

/// Changes the DiploLogStatement turn number associated with the index passed in
void CvDiplomacyAI::ChangeDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex, int iChange)
{
	SetDiploLogStatementTurnForIndex(ePlayer, iIndex, GetDiploLogStatementTurnForIndex(ePlayer, iIndex) + iChange);
}

/// How long has it been since we sent eDiploLogStatement?
int CvDiplomacyAI::GetNumTurnsSinceStatementSent(PlayerTypes ePlayer, DiploStatementTypes eDiploLogStatement)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return MAX_TURNS_SAFE_ESTIMATE;
	//if (eDiploLogStatement < 0 || eDiploLogStatement >= NUM_DIPLO_LOG_STATEMENT_TYPES) return MAX_TURNS_SAFE_ESTIMATE;

	int iMostRecentTurn = MAX_TURNS_SAFE_ESTIMATE;

	for (int iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		DiploStatementTypes eLoopStatement = GetDiploLogStatementTypeForIndex(ePlayer, iI);

		if (eLoopStatement != NO_DIPLO_STATEMENT_TYPE && eLoopStatement == eDiploLogStatement)
		{
			int iLoopTurnNum = GetDiploLogStatementTurnForIndex(ePlayer, iI);

			if (iMostRecentTurn == MAX_TURNS_SAFE_ESTIMATE || iLoopTurnNum > iMostRecentTurn)
			{
				iMostRecentTurn = iLoopTurnNum;

				// Now break out, otherwise we'll find later entries and think it's been longer since we sent something than it really has been!
				break;
			}
		}
	}

	return iMostRecentTurn;
}

#if defined(MOD_ACTIVE_DIPLOMACY)
/// How long has it been since we sent something?
int CvDiplomacyAI::GetNumTurnsSinceSomethingSent(PlayerTypes ePlayer)
{
	//if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return MAX_TURNS_SAFE_ESTIMATE;

	int iMostRecentTurn = MAX_TURNS_SAFE_ESTIMATE;

	for (int iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		DiploStatementTypes eLoopStatement = GetDiploLogStatementTypeForIndex(ePlayer, iI);

		if (eLoopStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			int iLoopTurnNum = GetDiploLogStatementTurnForIndex(ePlayer, iI);

			if (iMostRecentTurn == MAX_TURNS_SAFE_ESTIMATE || iLoopTurnNum > iMostRecentTurn)
			{
				iMostRecentTurn = iLoopTurnNum;

				// Now break out, otherwise we'll find later entries and think it's been longer since we sent something than it really has been!
				break;
			}
		}
	}

	return iMostRecentTurn;
}
#endif

/// Have we approached another civ about attacking their protected minor?
bool CvDiplomacyAI::HasSentAttackProtectedMinorTaunt(PlayerTypes ePlayer, PlayerTypes eMinor)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return false;
	return m_aabSentAttackMessageToMinorCivProtector[(int)ePlayer][iArrayIndex];
}

/// Set flag for whether we have sent a message to ePlayer about attacking their protected eMinor
void CvDiplomacyAI::SetSentAttackProtectedMinorTaunt(PlayerTypes ePlayer, PlayerTypes eMinor, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return;
	m_aabSentAttackMessageToMinorCivProtector[(int)ePlayer][iArrayIndex] = bValue;
}

/// Reset whether we have approached another civ about attacking a protected minor (ie. once peace is made with the minor)
void CvDiplomacyAI::ResetSentAttackProtectedMinorTaunts(PlayerTypes eMinor)
{
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		SetSentAttackProtectedMinorTaunt((PlayerTypes)iI, eMinor, false);
	}
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Victory Competition
// ------------------------------------

/// Are we competing to win this game?
bool CvDiplomacyAI::IsCompetingForVictory() const
{
	return m_bCompetingForVictory;
}

void CvDiplomacyAI::SetCompetingForVictory(bool bValue)
{
	m_bCompetingForVictory = bValue;
}

/// What victory condition are we focusing on?
VictoryFocusTypes CvDiplomacyAI::GetVictoryFocus() const
{
	return (VictoryFocusTypes) m_eVictoryFocus;
}

void CvDiplomacyAI::SetVictoryFocus(VictoryFocusTypes eFocus)
{
	if (eFocus < 0 || eFocus >= NUM_VICTORY_FOCUS_TYPES) return;
	m_eVictoryFocus = eFocus;
}

/// Are we extra aggressive towards this player because they're close to victory?
bool CvDiplomacyAI::IsEndgameAggressiveTo(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abEndgameAggressiveTo[(int)ePlayer];
}

void CvDiplomacyAI::SetEndgameAggressiveTo(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abEndgameAggressiveTo[(int)ePlayer] = bValue;
}

/// Is this player expanding recklessly?
bool CvDiplomacyAI::IsPlayerRecklessExpander(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abRecklessExpander[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerRecklessExpander(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abRecklessExpander[(int)ePlayer] = bValue;
}

/// Is this player spamming World Wonders?
bool CvDiplomacyAI::IsPlayerWonderSpammer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWonderSpammer[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerWonderSpammer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWonderSpammer[(int)ePlayer] = bValue;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Opinion & Approach
// ------------------------------------

/// What is our Diplomatic Opinion of this Major Civ?
MajorCivOpinionTypes CvDiplomacyAI::GetMajorCivOpinion(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_OPINION;
	return (MajorCivOpinionTypes) m_aeMajorCivOpinion[(int)ePlayer];
}

/// Sets what our Diplomatic Opinion of a Major Civ is
void CvDiplomacyAI::SetMajorCivOpinion(PlayerTypes ePlayer, MajorCivOpinionTypes eOpinion)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eOpinion < 0 || eOpinion >= NUM_MAJOR_CIV_OPINIONS) return;
	m_aeMajorCivOpinion[(int)ePlayer] = eOpinion;
}

/// What is our cached opinion weight for this Major Civ?
int CvDiplomacyAI::GetCachedOpinionWeight(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiCachedOpinionWeight[(int)ePlayer];
}

/// Sets our cached opinion weight for this Major Civ
void CvDiplomacyAI::SetCachedOpinionWeight(PlayerTypes ePlayer, int iWeight)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiCachedOpinionWeight[(int)ePlayer] = range(iWeight, SHRT_MIN, SHRT_MAX);
}

/// What is our Diplomatic Approach towards this Major Civ?
MajorCivApproachTypes CvDiplomacyAI::GetMajorCivApproach(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_APPROACH;
	return (MajorCivApproachTypes) m_aeMajorCivApproach[(int)ePlayer];
}

void CvDiplomacyAI::SetMajorCivApproach(PlayerTypes ePlayer, MajorCivApproachTypes eApproach)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS || GetTeam() == GET_PLAYER(ePlayer).getTeam()) return;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return;
	m_aeMajorCivApproach[(int)ePlayer] = eApproach;
}

/// What is our Strategic Diplomatic Approach towards this Major Civ?
MajorCivApproachTypes CvDiplomacyAI::GetMajorCivStrategicApproach(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_APPROACH;
	return (MajorCivApproachTypes) m_aeMajorCivStrategicApproach[(int)ePlayer];
}

void CvDiplomacyAI::SetMajorCivStrategicApproach(PlayerTypes ePlayer, MajorCivApproachTypes eApproach)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return;
	m_aeMajorCivStrategicApproach[(int)ePlayer] = eApproach;
}

MajorCivApproachTypes CvDiplomacyAI::GetSurfaceApproach(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_APPROACH;

	// Always friendly if we have a Declaration of Friendship
	if (IsDoFAccepted(ePlayer))
		return MAJOR_CIV_APPROACH_FRIENDLY;

	MajorCivApproachTypes eRealApproach = GetMajorCivApproach(ePlayer);

	// Pick a surface approach to disguise our war plans
	if (eRealApproach == MAJOR_CIV_APPROACH_WAR)
	{
		MajorCivApproachTypes eSurfaceApproach = GetHighestValueApproach(ePlayer, /*bExcludeWar*/ true, /*bIncludeOverrides*/ true);

		// If we were just denounced or they ended our friendship, can't be better than GUARDED
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncingPlayer(GetPlayer()->GetID()) || (IsDoFBroken(ePlayer) && GetTurnsSinceDoFBroken(ePlayer) <= 1))
		{
			if (eSurfaceApproach > MAJOR_CIV_APPROACH_GUARDED)
			{
				eSurfaceApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
		}

		// Don't pretend to be afraid if we're not
		if (eSurfaceApproach == MAJOR_CIV_APPROACH_AFRAID)
		{
			return MAJOR_CIV_APPROACH_GUARDED;
		}

		// Deceptive = Friendly
		if (eSurfaceApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
		{
			return MAJOR_CIV_APPROACH_FRIENDLY;
		}

		return eSurfaceApproach;
	}
	// Deceptive = Friendly
	else if (eRealApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
	{
		return MAJOR_CIV_APPROACH_FRIENDLY;
	}

	return eRealApproach;
}

int CvDiplomacyAI::GetPlayerApproachValue(PlayerTypes ePlayer, MajorCivApproachTypes eApproach) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return 0;
	return m_aaiApproachValues[(int)ePlayer][(int)eApproach];
}

void CvDiplomacyAI::SetPlayerApproachValue(PlayerTypes ePlayer, MajorCivApproachTypes eApproach, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return;
	m_aaiApproachValues[(int)ePlayer][(int)eApproach] = max(iValue, 0);
}

MajorCivApproachTypes CvDiplomacyAI::GetHighestValueApproach(PlayerTypes ePlayer, bool bExcludeWar, bool bIncludeOverrides) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_APPROACH;

	MajorCivApproachTypes eBestApproach = MAJOR_CIV_APPROACH_NEUTRAL;
	int iHighestValue = 0;

	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

		if (bExcludeWar && eLoopApproach == MAJOR_CIV_APPROACH_WAR)
			continue;

		int iValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
		if (iValue > iHighestValue)
		{
			eBestApproach = eLoopApproach;
			iHighestValue = iValue;
		}
	}

	if (bIncludeOverrides)
	{
		if (eBestApproach == MAJOR_CIV_APPROACH_WAR || eBestApproach == MAJOR_CIV_APPROACH_HOSTILE)
		{
			if (!IsUntrustworthy(ePlayer))
			{
				if (WasResurrectedBy(ePlayer))
				{
					eBestApproach = MAJOR_CIV_APPROACH_GUARDED;
				}
				else if (IsPlayerLiberatedCapital(ePlayer) && eBestApproach == MAJOR_CIV_APPROACH_HOSTILE)
				{
					eBestApproach = MAJOR_CIV_APPROACH_GUARDED;
				}
				else if (IsCityRecentlyLiberatedBy(ePlayer) && !IsEndgameAggressiveTo(ePlayer) && GetPlayer()->getCitiesLost() > 0)
				{
					eBestApproach = MAJOR_CIV_APPROACH_GUARDED;
				}
			}
		}
		if (eBestApproach == MAJOR_CIV_APPROACH_FRIENDLY || eBestApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
		{
			if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer) || IsUntrustworthy(ePlayer))
			{
				eBestApproach = (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY) ? MAJOR_CIV_APPROACH_GUARDED : MAJOR_CIV_APPROACH_NEUTRAL;
			}
		}
	}

	return eBestApproach;
}

PlayerTypes CvDiplomacyAI::GetPlayerWithHighestApproachValue(MajorCivApproachTypes eApproach, vector<PlayerTypes>& vPlayersToExclude) const
{
	if (GetPlayer()->isHuman() || GetPlayer()->getCapitalCity() == NULL || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
		return NO_PLAYER;

	PlayerTypes eBestPlayer = NO_PLAYER;
	int iHighestValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (IsAlwaysAtWar(eLoopPlayer))
			continue;

		if (std::find(vPlayersToExclude.begin(), vPlayersToExclude.end(), eLoopPlayer) != vPlayersToExclude.end())
			continue;

		if (IsPlayerValid(eLoopPlayer))
		{
			int iValue = GetPlayerApproachValue(eLoopPlayer, eApproach);
			if (iValue > iHighestValue)
			{
				eBestPlayer = eLoopPlayer;
				iHighestValue = iValue;
			}
		}
	}

	return eBestPlayer;
}

int CvDiplomacyAI::GetPlayerStrategicApproachValue(PlayerTypes ePlayer, MajorCivApproachTypes eApproach) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return 0;
	return m_aaiStrategicApproachValues[(int)ePlayer][(int)eApproach];
}

void CvDiplomacyAI::SetPlayerStrategicApproachValue(PlayerTypes ePlayer, MajorCivApproachTypes eApproach, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return;
	m_aaiStrategicApproachValues[(int)ePlayer][(int)eApproach] = max(iValue, 0);
}

PlayerTypes CvDiplomacyAI::GetPlayerWithHighestStrategicApproachValue(MajorCivApproachTypes eApproach, vector<PlayerTypes>& vPlayersToExclude) const
{
	if (GetPlayer()->isHuman() || GetPlayer()->getCapitalCity() == NULL || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
		return NO_PLAYER;

	PlayerTypes eBestPlayer = NO_PLAYER;
	int iHighestValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
			continue;

		if (IsAlwaysAtWar(eLoopPlayer))
			continue;

		if (std::find(vPlayersToExclude.begin(), vPlayersToExclude.end(), eLoopPlayer) != vPlayersToExclude.end())
			continue;

		if (IsPlayerValid(eLoopPlayer))
		{
			int iValue = GetPlayerStrategicApproachValue(eLoopPlayer, eApproach);
			if (iValue > iHighestValue)
			{
				eBestPlayer = eLoopPlayer;
				iHighestValue = iValue;
			}
		}
	}

	return eBestPlayer;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Minor Civs
// ------------------------------------

/// What is our Diplomatic Approach towards this Minor Civ?
MinorCivApproachTypes CvDiplomacyAI::GetMinorCivApproach(PlayerTypes eMinor) const
{
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return NO_MINOR_CIV_APPROACH;
	return (MinorCivApproachTypes) m_aeMinorCivApproach[iArrayIndex];
}

/// Sets what our Diplomatic Approach is towards a Minor Civ
void CvDiplomacyAI::SetMinorCivApproach(PlayerTypes eMinor, MinorCivApproachTypes eApproach)
{
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return;
	if (GetTeam() == GET_PLAYER(eMinor).getTeam()) return;
	if (eApproach < NO_MINOR_CIV_APPROACH || eApproach >= NUM_MINOR_CIV_APPROACHES) return;
	m_aeMinorCivApproach[iArrayIndex] = eApproach;
}

/// Is there a City-State we're targeting for bullying, backed with force?
PlayerTypes CvDiplomacyAI::GetCSBullyTargetPlayer() const
{
	return (PlayerTypes) m_eCSBullyTarget;
}

/// Sets a City-State we're targeting for bullying, backed with force
void CvDiplomacyAI::SetCSBullyTargetPlayer(PlayerTypes ePlayer)
{
	if (ePlayer < MAX_MAJOR_CIVS || ePlayer >= MAX_CIV_PLAYERS) return;
	m_eCSBullyTarget = ePlayer;
}

/// Is there a City-State we're targeting for war?
PlayerTypes CvDiplomacyAI::GetCSWarTargetPlayer() const
{
	return (PlayerTypes) m_eCSWarTarget;
}

/// Sets a City-State we're targeting for war
void CvDiplomacyAI::SetCSWarTargetPlayer(PlayerTypes ePlayer)
{
	if (ePlayer < MAX_MAJOR_CIVS || ePlayer >= MAX_CIV_PLAYERS) return;
	m_eCSWarTarget = ePlayer;
}

/// Does this AI want to connect to a minor with a route?
bool CvDiplomacyAI::IsWantToRouteConnectToMinor(PlayerTypes eMinor)
{
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return false;
	return m_abWantToRouteToMinor[iArrayIndex];
}

/// Sets if this AI want to connect to a minor with a route
void CvDiplomacyAI::SetWantToRouteConnectToMinor(PlayerTypes eMinor, bool bValue)
{
	int iArrayIndex = (int)eMinor - MAX_MAJOR_CIVS;
	if (iArrayIndex < 0 || iArrayIndex >= MAX_MINOR_CIVS) return;
	m_abWantToRouteToMinor[iArrayIndex] = bValue;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Planning Exchanges
// ------------------------------------

bool CvDiplomacyAI::IsMajorCompetitor(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abMajorCompetitor[(int)ePlayer];
}

void CvDiplomacyAI::SetMajorCompetitor(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abMajorCompetitor[(int)ePlayer] = bValue;
}

bool CvDiplomacyAI::IsStrategicTradePartner(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abStrategicTradePartner[(int)ePlayer];
}

void CvDiplomacyAI::SetStrategicTradePartner(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abStrategicTradePartner[(int)ePlayer] = bValue;
}

/// Does this AI want to make a Declaration of Friendship with ePlayer?
bool CvDiplomacyAI::IsWantsDoFWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsDoFWithPlayer[(int)ePlayer];
}

/// Sets if this AI wants to make a Declaration of Friendship with ePlayer
void CvDiplomacyAI::SetWantsDoFWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWantsDoFWithPlayer[(int)ePlayer] = bValue;
}

/// Does this AI want to make a Defensive Pact with ePlayer?
bool CvDiplomacyAI::IsWantsDefensivePactWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsDefensivePactWithPlayer[(int)ePlayer];
}

/// Sets if this AI wants to make a Defensive Pact with ePlayer
void CvDiplomacyAI::SetWantsDefensivePactWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWantsDefensivePactWithPlayer[(int)ePlayer] = bValue;
}

/// Does this AI want to cancel a Declaration of Friendship with ePlayer?
bool CvDiplomacyAI::IsWantsToEndDoFWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsToEndDoFWithPlayer[(int)ePlayer];
}

/// Sets if this AI wants to cancel a Declaration of Friendship with ePlayer
void CvDiplomacyAI::SetWantsToEndDoFWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWantsToEndDoFWithPlayer[(int)ePlayer] = bValue;
}

/// Does this AI want to cancel a Defensive Pact with ePlayer?
bool CvDiplomacyAI::IsWantsToEndDefensivePactWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsToEndDefensivePactWithPlayer[(int)ePlayer];
}

/// Sets if this AI wants to cancel a Defensive Pact with ePlayer
void CvDiplomacyAI::SetWantsToEndDefensivePactWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWantsToEndDefensivePactWithPlayer[(int)ePlayer] = bValue;
}

/// Does this AI want to make a Research Agreement with ePlayer?
bool CvDiplomacyAI::IsWantsResearchAgreementWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsResearchAgreementWithPlayer[(int)ePlayer];
}

/// Sets if this AI wants to make a Research Agreement with ePlayer
void CvDiplomacyAI::SetWantsResearchAgreementWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (IsHasResearchAgreement(ePlayer))
	{
		m_abWantsResearchAgreementWithPlayer[(int)ePlayer] = false;
		return;
	}

	if (bValue != IsWantsResearchAgreementWithPlayer(ePlayer))
	{
		m_abWantsResearchAgreementWithPlayer[(int)ePlayer] = bValue;

		if (bValue)
		{
			// Start saving the Gold
			int iGoldAmount = GC.getGame().GetGameDeals().GetTradeItemGoldCost(TRADE_ITEM_RESEARCH_AGREEMENT, GetID(), ePlayer);
			GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MAJOR_CIV_TRADE, iGoldAmount, /*Priority*/ 1);

			LogWantRA(ePlayer);
		}
		else
		{
			GetPlayer()->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_MAJOR_CIV_TRADE);
		}
	}
}

/// How many different players does this AI want a RA with?
int CvDiplomacyAI::GetNumResearchAgreementsWanted() const
{
	int iNum = 0;

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsWantsResearchAgreementWithPlayer(eLoopPlayer))
			iNum++;
	}

	return iNum;
}

/// Who is our most valuable friend?
PlayerTypes CvDiplomacyAI::GetMostValuableFriend() const
{
	return (PlayerTypes) m_eMostValuableFriend;
}

void CvDiplomacyAI::SetMostValuableFriend(PlayerTypes ePlayer)
{
	if (ePlayer < NO_PLAYER || ePlayer >= MAX_MAJOR_CIVS) return;
	m_eMostValuableFriend = ePlayer;
}

/// Who is our most valuable friend?
PlayerTypes CvDiplomacyAI::GetMostValuableAlly() const
{
	return (PlayerTypes) m_eMostValuableAlly;
}

void CvDiplomacyAI::SetMostValuableAlly(PlayerTypes ePlayer)
{
	if (ePlayer < NO_PLAYER || ePlayer >= MAX_MAJOR_CIVS) return;
	m_eMostValuableAlly = ePlayer;
}

/// Who are our biggest competitors?
PlayerTypes CvDiplomacyAI::GetBiggestCompetitor() const
{
	return (PlayerTypes) m_eBiggestCompetitor;
}

void CvDiplomacyAI::SetBiggestCompetitor(PlayerTypes ePlayer)
{
	if (ePlayer < NO_PLAYER || ePlayer >= MAX_MAJOR_CIVS) return;
	m_eBiggestCompetitor = ePlayer;
}

PlayerTypes CvDiplomacyAI::GetPrimeLeagueCompetitor() const
{
	return (PlayerTypes) m_ePrimeLeagueCompetitor;
}

void CvDiplomacyAI::SetPrimeLeagueCompetitor(PlayerTypes ePlayer)
{
	if (ePlayer < NO_PLAYER || ePlayer >= MAX_MAJOR_CIVS) return;
	m_ePrimeLeagueCompetitor = ePlayer;
}

/// Is there a player we're targeting to make a demand from, backed with force?
PlayerTypes CvDiplomacyAI::GetDemandTargetPlayer() const
{
	return (PlayerTypes) m_eDemandTargetPlayer;
}

/// Sets a player we're targeting to make a demand from, backed with force
void CvDiplomacyAI::SetDemandTargetPlayer(PlayerTypes ePlayer)
{
	if (ePlayer < NO_PLAYER || ePlayer >= MAX_MAJOR_CIVS) return;
	m_eDemandTargetPlayer = ePlayer;
}

/// Did we end a Declaration of Friendship with someone early this turn?
bool CvDiplomacyAI::HasEndedFriendshipThisTurn() const
{
	return m_bEndedFriendshipThisTurn;
}

/// Sets if we ended a Declaration of Friendship with someone early this turn
void CvDiplomacyAI::SetEndedFriendshipThisTurn(bool bValue)
{
	m_bEndedFriendshipThisTurn = bValue;
}

/// Are we avoiding deals? Temporary non-serialized value, used to avoid constant iterating over players...
bool CvDiplomacyAI::IsAvoidDeals() const
{
	return m_bAvoidDeals;
}

void CvDiplomacyAI::SetAvoidDeals(bool bValue)
{
	m_bAvoidDeals = bValue;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Exchanges
// ------------------------------------

/// Have we accepted ePlayer's request to work with us?
bool CvDiplomacyAI::IsDoFAccepted(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetDoFAcceptedTurn(ePlayer) != -1;
}

/// We made a Declaration of Friendship with someone, handle everything that means
void CvDiplomacyAI::SetDoFAccepted(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue != IsDoFAccepted(ePlayer))
	{
		m_pPlayer->recomputeGreatPeopleModifiers();

		// Someone made a DoF, send out notifications to everyone
		if (bValue)
		{
			SetDoFAcceptedTurn(ePlayer, GC.getGame().getGameTurn());
			SetDoFBroken(ePlayer, false, true);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFBroken(GetID(), false, true);

			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF");
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_S");
			for (int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer)
			{
				PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
				CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
				CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
				if (iCurPlayer != ePlayer && iCurPlayer != GetID() && pNotifications)
				{
					const char* strThisPlayerName;
					const char* strOtherPlayerName;

					CvTeam* pCurTeam = &GET_TEAM(kCurPlayer.getTeam());

					// Have we met these guys yet?
					bool bHasMetThisTeam = pCurTeam->isHasMet(GetTeam()) || GET_PLAYER(eCurPlayer).isObserver();
					if (bHasMetThisTeam)
						strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
					else
						strThisPlayerName = "TXT_KEY_UNMET_PLAYER";

					bool bHasMetOtherTeam = pCurTeam->isHasMet(GET_PLAYER(ePlayer).getTeam()) || GET_PLAYER(eCurPlayer).isObserver();
					if (bHasMetOtherTeam)
						strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
					else
						strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";

					//Only display notification if we've met both of the players.
					if (bHasMetThisTeam && bHasMetOtherTeam)
					{
						Localization::String tempInfoStr = strText;
						tempInfoStr << strThisPlayerName << strOtherPlayerName;
						Localization::String tempSummaryStr = strSummary;
						tempSummaryStr << strThisPlayerName << strOtherPlayerName;
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, tempInfoStr.toUTF8(), tempSummaryStr.toUTF8(), -1, -1, GetID(), ePlayer);
					}
				}
			}

			// Cancel any coop wars against the player we've befriended
			for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
			{
				PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;

				if (IsPlayerValid(eThirdParty, true) && eThirdParty != GetID())
				{
					CoopWarStates eCoopWarState = GetCoopWarState(eThirdParty, ePlayer);
					if (eCoopWarState == COOP_WAR_STATE_PREPARING || eCoopWarState == COOP_WAR_STATE_READY)
					{
						GET_PLAYER(eThirdParty).GetDiplomacyAI()->SetPlayerBrokenCoopWarPromise(GetID(), true);
						GET_PLAYER(eThirdParty).GetDiplomacyAI()->ChangeCoopWarScore(GetID(), -2);
						GET_PLAYER(eThirdParty).GetDiplomacyAI()->ChangeRecentAssistValue(GetID(), 300);
					}
					SetCoopWarState(eThirdParty, ePlayer, NO_COOP_WAR_STATE);
					GET_PLAYER(eThirdParty).GetDiplomacyAI()->SetCoopWarState(GetID(), ePlayer, NO_COOP_WAR_STATE);
				}
			}
		}
		else
		{
			SetDoFAcceptedTurn(ePlayer, -1);
		}
	}
}

/// How many Declarations of Friendship do we currently have with other players?
int CvDiplomacyAI::GetNumDoF(bool bVassalageException)
{
	int iRtnValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (bVassalageException)
		{
			if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
			{
				continue;
			}
			if (IsVassal(eLoopPlayer))
			{
				continue;
			}
		}

		if (IsPlayerValid(eLoopPlayer) && IsDoFAccepted(eLoopPlayer))
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

bool CvDiplomacyAI::IsDoFMessageTooSoon(PlayerTypes ePlayer) const
{
	// Already have a DoF?
	if (IsDoFAccepted(ePlayer))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return false;
}

int CvDiplomacyAI::GetDoFAcceptedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiDoFAcceptedTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetDoFAcceptedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDoFAcceptedTurn[(int)ePlayer] = max(iTurn, -1);
}

int CvDiplomacyAI::GetTurnsSinceBefriendedPlayer(PlayerTypes ePlayer) const
{
	if (!IsDoFAccepted(ePlayer))
		return -1;

	return (GC.getGame().getGameTurn() - GetDoFAcceptedTurn(ePlayer));
}

/// Returns the type of Declaration of Friendship that could potentially be made with this player (based on previous relationship)
DoFLevelTypes CvDiplomacyAI::GetDoFType(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DOF_TYPE;
	return (DoFLevelTypes) m_aeDoFType[(int)ePlayer];
}

/// Sets the future type of Declaration of Friendship that could potentially be made with this player (based on previous relationship)
void CvDiplomacyAI::SetDoFType(PlayerTypes ePlayer, DoFLevelTypes eDoFLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eDoFLevel < 0 || eDoFLevel >= NUM_DOF_TYPES) return;
	m_aeDoFType[(int)ePlayer] = eDoFLevel;
}

/// Have we denounced ePlayer?
bool CvDiplomacyAI::IsDenouncedPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetDenouncedPlayerTurn(ePlayer) != -1;
}

/// Sets whether we've denounced ePlayer
void CvDiplomacyAI::SetDenouncedPlayer(PlayerTypes ePlayer, bool bValue)
{
	if (bValue)
	{
		SetDenouncedPlayerTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetDenouncedPlayerTurn(ePlayer, -1);
	}

	m_pPlayer->recomputeGreatPeopleModifiers();
}

/// Have we been denounced by ePlayer?
bool CvDiplomacyAI::IsDenouncedByPlayer(PlayerTypes ePlayer) const
{
	return GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID());
}

/// Too soon for ePlayer to denounce us?
bool CvDiplomacyAI::IsDenounceMessageTooSoon(PlayerTypes ePlayer) const
{
	// They already denounced us?
	if (IsDenouncedByPlayer(ePlayer))
		return true;

	// Observers can't do this!
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't denounce if always at war
	if (IsAlwaysAtWar(ePlayer))
		return true;

	return false;
}

int CvDiplomacyAI::GetDenouncedPlayerTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiDenouncedPlayerTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetDenouncedPlayerTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDenouncedPlayerTurn[(int)ePlayer] = max(iTurn, -1);
}

int CvDiplomacyAI::GetTurnsSinceDenouncedPlayer(PlayerTypes ePlayer) const
{
	if (!IsDenouncedPlayer(ePlayer))
		return -1;

	return (GC.getGame().getGameTurn() - GetDenouncedPlayerTurn(ePlayer));
}

/// Denouncing this turn?
bool CvDiplomacyAI::IsDenouncingPlayer(PlayerTypes ePlayer) const
{
	int iTurn = GC.getGame().getGameTurn();

	if (GetDenouncedPlayerTurn(ePlayer) == iTurn)
		return true;

	if ((GetDenouncedPlayerTurn(ePlayer) == (iTurn - 1)) && (iTurn > 0))
		return true;

	return false;
}

/// How many players have we currently denounced?
int CvDiplomacyAI::GetNumDenouncements()
{
	int iRtnValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv() && IsDenouncedPlayer(eLoopPlayer))
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

/// How many players have denounced US?
int CvDiplomacyAI::GetNumDenouncementsOfPlayer()
{
	int iRtnValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv() && IsDenouncedByPlayer(eLoopPlayer))
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

/// Is this AI unable to match the deal offer of ePlayer?
bool CvDiplomacyAI::IsCantMatchDeal(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abCantMatchDeal[(int)ePlayer];
}

/// Sets if this AI is unable to match the deal offer of ePlayer
void CvDiplomacyAI::SetCantMatchDeal(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abCantMatchDeal[(int)ePlayer] = bValue;
}

/// Returns the number of demands ePlayer has ever made of us
int CvDiplomacyAI::GetNumDemandEverMade(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiDemandEverMade[(int)ePlayer];
}

/// Sets the number of demands this player has made towards us
void CvDiplomacyAI::SetNumDemandEverMade(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDemandEverMade[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetDemandMadeTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetDemandMadeTurn(ePlayer, -1);
		SetDemandTooSoonNumTurns(ePlayer, -1);
	}
}

void CvDiplomacyAI::ChangeNumDemandEverMade(PlayerTypes ePlayer, int iChange)
{
	SetNumDemandEverMade(ePlayer, GetNumDemandEverMade(ePlayer) + iChange);
}

/// Returns if ePlayer has ever made a demand of us
bool CvDiplomacyAI::IsDemandEverMade(PlayerTypes ePlayer) const
{
	return GetNumDemandEverMade(ePlayer) > 0;
}

/// On what turn did ePlayer most recently make a demand of us?
int CvDiplomacyAI::GetDemandMadeTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiDemandMadeTurn[(int)ePlayer];
}

/// Sets on what turn ePlayer most recently made a demand of us
void CvDiplomacyAI::SetDemandMadeTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDemandMadeTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Returns the amount of turns required before the next demand might be accepted
int CvDiplomacyAI::GetDemandTooSoonNumTurns(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiDemandTooSoonNumTurns[(int)ePlayer];
}

/// Sets the amount of turns required before the next demand might be accepted
void CvDiplomacyAI::SetDemandTooSoonNumTurns(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDemandTooSoonNumTurns[(int)ePlayer] = range(iValue, -1, CHAR_MAX);
}

/// Has it been too soon since the last demand made?
bool CvDiplomacyAI::IsDemandTooSoon(PlayerTypes ePlayer) const
{
	int iDemandTooSoonNumTurns = GetDemandTooSoonNumTurns(ePlayer);

	// Haven't gotten a demand before
	if (iDemandTooSoonNumTurns == -1 || GetDemandMadeTurn(ePlayer) == -1)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - GetDemandMadeTurn(ePlayer);

	if (iTurnDifference < iDemandTooSoonNumTurns)
		return true;

	return false;
}

/// Returns the value of recent trades
int CvDiplomacyAI::GetRecentTradeValue(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiTradeValue[(int)ePlayer];
}

/// Sets the value of recent trades
void CvDiplomacyAI::SetRecentTradeValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iMaxOpinionValue = min(USHRT_MAX,(/*5*/ GC.getDEAL_VALUE_PER_OPINION_WEIGHT() * /*40*/ -GC.getOPINION_WEIGHT_TRADE_MAX()));
	m_aiTradeValue[(int)ePlayer] = range(iValue, 0, iMaxOpinionValue);
}

/// Changes the value of recent trades
void CvDiplomacyAI::ChangeRecentTradeValue(PlayerTypes ePlayer, int iChange)
{
	SetRecentTradeValue(ePlayer, GetRecentTradeValue(ePlayer) + iChange);
}

/// Returns the value of combat damage inflicted on a common enemy
int CvDiplomacyAI::GetCommonFoeValue(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiCommonFoeValue[(int)ePlayer];
}

/// Sets the value of combat damage inflicted on a common enemy
void CvDiplomacyAI::SetCommonFoeValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iMaxOpinionValue = min(USHRT_MAX, (GC.getCOMMON_FOE_VALUE_PER_OPINION_WEIGHT() * -GC.getOPINION_WEIGHT_COMMON_FOE_MAX()));
	m_aiCommonFoeValue[(int)ePlayer] = range(iValue, 0, iMaxOpinionValue);
}

/// Changes the value of combat damage inflicted on a common enemy
void CvDiplomacyAI::ChangeCommonFoeValue(PlayerTypes ePlayer, int iChange)
{
	if (iChange > 0)
	{
		// If we're at permanent war anyway, this means nothing.
		if (IsAlwaysAtWar(ePlayer))
			return;

		// Capitulated vassals don't care.
		if (MOD_DIPLOMACY_CIV4_FEATURES && !GetPlayer()->isHuman() && IsVassal(ePlayer) && !IsVoluntaryVassalage(ePlayer))
		{
			return;
		}
	}

	SetCommonFoeValue(ePlayer, GetCommonFoeValue(ePlayer) + iChange);
}

/// Returns the value of diplomatic assistance given
int CvDiplomacyAI::GetRecentAssistValue(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiAssistValue[(int)ePlayer];
}

/// Sets the value of diplomatic assistance given
void CvDiplomacyAI::SetRecentAssistValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iMaxOpinionValue = min(SHRT_MAX,(GC.getASSIST_VALUE_PER_OPINION_WEIGHT() * GC.getOPINION_WEIGHT_ASSIST_MAX()));
	m_aiAssistValue[(int)ePlayer] = range(iValue, -iMaxOpinionValue, iMaxOpinionValue);
}

/// Changes the value of diplomatic assistance given
void CvDiplomacyAI::ChangeRecentAssistValue(PlayerTypes ePlayer, int iChange)
{
	SetRecentAssistValue(ePlayer, GetRecentAssistValue(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Coop Wars
// ------------------------------------

CoopWarStates CvDiplomacyAI::GetCoopWarState(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer) const
{
	if (eAllyPlayer < 0 || eAllyPlayer >= MAX_MAJOR_CIVS) return NO_COOP_WAR_STATE;
	if (eTargetPlayer < 0 || eTargetPlayer >= MAX_MAJOR_CIVS) return NO_COOP_WAR_STATE;
	return (CoopWarStates) m_aaeCoopWarState[(int)eAllyPlayer][(int)eTargetPlayer];
}

void CvDiplomacyAI::SetCoopWarState(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer, CoopWarStates eNewState)
{
	if (eAllyPlayer < 0 || eAllyPlayer >= MAX_MAJOR_CIVS) return;
	if (eTargetPlayer < 0 || eTargetPlayer >= MAX_MAJOR_CIVS) return;

	if (eNewState != GetCoopWarState(eAllyPlayer, eTargetPlayer))
	{
		m_aaeCoopWarState[(int)eAllyPlayer][(int)eTargetPlayer] = eNewState;

		if (eNewState != NO_COOP_WAR_STATE)
		{
			SetCoopWarStateChangeTurn(eAllyPlayer, eTargetPlayer, GC.getGame().getGameTurn());

			if (eNewState == COOP_WAR_STATE_ONGOING)
			{
				ChangeCoopWarScore(eAllyPlayer, 1);
			}

			if (eNewState >= COOP_WAR_STATE_PREPARING)
			{
				vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
				vector<PlayerTypes> vTargetTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getPlayers();
				for (size_t i=0; i<vOurTeam.size(); i++)
				{
					for (size_t j=0; j<vTargetTeam.size(); j++)
					{
						GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->SetWantsDoFWithPlayer(vTargetTeam[j], false);
						GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->SetWantsDefensivePactWithPlayer(vTargetTeam[j], false);
					}
				}
			}
		}
		else
		{
			SetCoopWarStateChangeTurn(eAllyPlayer, eTargetPlayer, -1);
		}

		LogCoopWar(eAllyPlayer, eTargetPlayer, eNewState);
	}
}

/// Are we locked into a war with ePlayer?
bool CvDiplomacyAI::IsLockedIntoCoopWar(PlayerTypes ePlayer) const
{
	if (!IsAtWar(ePlayer))
		return false;

	if (GET_TEAM(GetTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(ePlayer).getTeam()) > 0)
		return true;

	CoopWarStates eCoopWarState = GetGlobalCoopWarAgainstState(ePlayer);
	if (eCoopWarState == COOP_WAR_STATE_PREPARING || eCoopWarState == COOP_WAR_STATE_READY)
		return true;

/*
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Vassals will never want peace with a player if their master is at war with a player.
	if (MOD_DIPLOMACY_CIV4_FEATURES && GetPlayer()->IsVassalOfSomeone())
	{
		TeamTypes eMasterTeam = GET_TEAM(GetTeam()).GetMaster();
		if (eMasterTeam != NO_TEAM && GET_TEAM(eMasterTeam).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		{
			return true;
		}
	}
#endif
*/

	return false;
}

/// What is our highest coop war state WITH this player against another player?
CoopWarStates CvDiplomacyAI::GetGlobalCoopWarWithState(PlayerTypes ePlayer) const
{
	CoopWarStates eBestState = NO_COOP_WAR_STATE;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			CoopWarStates eCoopWarState = GetCoopWarState(ePlayer, eLoopPlayer);
			if (eCoopWarState >= COOP_WAR_STATE_PREPARING && eCoopWarState > eBestState)
			{
				eBestState = eCoopWarState;
			}
		}
	}

	return eBestState;
}

/// What is our highest coop war state with another player AGAINST this player?
CoopWarStates CvDiplomacyAI::GetGlobalCoopWarAgainstState(PlayerTypes ePlayer) const
{
	CoopWarStates eBestState = NO_COOP_WAR_STATE;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != GetID())
		{
			CoopWarStates eCoopWarState = GetCoopWarState(eLoopPlayer, ePlayer);
			if (eCoopWarState >= COOP_WAR_STATE_PREPARING && eCoopWarState > eBestState)
			{
				eBestState = eCoopWarState;
			}
		}
	}

	return eBestState;
}

/// How many players are we currently planning a coop war against?
int CvDiplomacyAI::GetNumCoopWarTargets()
{
	int iCount = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GetGlobalCoopWarAgainstState(eLoopPlayer) >= COOP_WAR_STATE_PREPARING)
		{
			iCount++;
		}
	}

	return iCount;
}

int CvDiplomacyAI::GetCoopWarStateChangeTurn(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer) const
{
	if (eAllyPlayer < 0 || eAllyPlayer >= MAX_MAJOR_CIVS) return -1;
	if (eTargetPlayer < 0 || eTargetPlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aaiCoopWarStateChangeTurn[(int)eAllyPlayer][(int)eTargetPlayer];
}

void CvDiplomacyAI::SetCoopWarStateChangeTurn(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer, int iTurn)
{
	if (eAllyPlayer < 0 || eAllyPlayer >= MAX_MAJOR_CIVS) return;
	if (eTargetPlayer < 0 || eTargetPlayer >= MAX_MAJOR_CIVS) return;
	m_aaiCoopWarStateChangeTurn[(int)eAllyPlayer][(int)eTargetPlayer] = iTurn;
}

/// Has ePlayer asked to start a coop war against eTargetPlayer lately?
bool CvDiplomacyAI::IsCoopWarMessageTooSoon(PlayerTypes eAskingPlayer, PlayerTypes eTargetPlayer) const
{
	CoopWarStates eCoopWarState = GetCoopWarState(eAskingPlayer, eTargetPlayer);

	if (eCoopWarState == COOP_WAR_STATE_REJECTED || eCoopWarState == COOP_WAR_STATE_WARNED_TARGET)
		return true;

	return false;
}

int CvDiplomacyAI::GetCoopWarScore(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiCoopWarScore[(int)ePlayer];
}

void CvDiplomacyAI::SetCoopWarScore(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiCoopWarScore[(int)ePlayer] = range(iValue, CHAR_MIN, CHAR_MAX);
}

void CvDiplomacyAI::ChangeCoopWarScore(PlayerTypes ePlayer, int iChange)
{
	SetCoopWarScore(ePlayer, GetCoopWarScore(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// War
// ------------------------------------

/// Does this AI believe it's sane to attack ePlayer?
bool CvDiplomacyAI::IsSaneDiplomaticTarget(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;
	return m_abSaneDiplomaticTarget[(int)ePlayer];
}

/// Sets if this AI believes it's sane to attack ePlayer
void CvDiplomacyAI::SetSaneDiplomaticTarget(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_abSaneDiplomaticTarget[(int)ePlayer] = bValue;
}

bool CvDiplomacyAI::IsWarSane(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
	for (size_t i=0; i<vOurTeam.size(); i++)
	{
		if (GET_PLAYER(vOurTeam[i]).isAlive())
		{
			if (!GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->IsSaneDiplomaticTarget(ePlayer))
				return false;
		}
	}

	return true;
}

/// Is this AI potentially willing to attack ePlayer if someone else asks them to?
bool CvDiplomacyAI::IsPotentialWarTarget(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;
	return m_abPotentialWarTarget[(int)ePlayer];
}

/// Sets if this AI is potentially willing to attack ePlayer if someone else asks them to
void CvDiplomacyAI::SetPotentialWarTarget(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_abPotentialWarTarget[(int)ePlayer] = bValue;
}

/// Reset potential war targets
void CvDiplomacyAI::DoResetPotentialWarTargets()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		SetPotentialWarTarget(eLoopPlayer, false);
	}
}

/// Does this AI want to sneak attack ePlayer?
bool CvDiplomacyAI::IsWantsSneakAttack(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abWantsSneakAttack[(int)ePlayer];
}

/// Sets if this AI wants to sneak attack ePlayer
void CvDiplomacyAI::SetWantsSneakAttack(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abWantsSneakAttack[(int)ePlayer] = bValue;
}

/// Are we building up for an attack on ePlayer?
bool CvDiplomacyAI::IsArmyInPlaceForAttack(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;
	return m_abArmyInPlaceForAttack[(int)ePlayer];
}

/// Sets whether or not we're building up for an attack on ePlayer
void CvDiplomacyAI::SetArmyInPlaceForAttack(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_abArmyInPlaceForAttack[(int)ePlayer] = bValue;
}

/// Did this AI want to start the war it's currently in with ePlayer?
bool CvDiplomacyAI::IsAggressor(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;
	return m_abAggressor[(int)ePlayer];
}

/// Sets if this AI wanted to start the war it's currently in with ePlayer
void CvDiplomacyAI::SetAggressor(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_abAggressor[(int)ePlayer] = bValue;
}

/// How many turns have we been at war with this player?
int CvDiplomacyAI::GetPlayerNumTurnsAtWar(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiPlayerNumTurnsAtWar[(int)ePlayer];
}

/// Sets how many turns we've been at war with this player
void CvDiplomacyAI::SetPlayerNumTurnsAtWar(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiPlayerNumTurnsAtWar[(int)ePlayer] = max(iValue, 0);
}

/// Sets how many turns we've been at war with this player
void CvDiplomacyAI::ChangePlayerNumTurnsAtWar(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsAtWar(ePlayer, GetPlayerNumTurnsAtWar(ePlayer) + iChange);
}

/// How many turns have we been at war with this Team?
int CvDiplomacyAI::GetTeamNumTurnsAtWar(TeamTypes eTeam) const
{
	if (eTeam < 0 || eTeam >= MAX_CIV_TEAMS) return 0;

	int iMaxTurns = 0;

	vector<PlayerTypes> vTeamPlayers = GET_TEAM(eTeam).getPlayers();
	for (size_t i = 0; i < vTeamPlayers.size(); i++)
	{
		PlayerTypes ePlayer = (PlayerTypes) vTeamPlayers[i];
		if (GET_PLAYER(ePlayer).isAlive() && GetPlayerNumTurnsAtWar(ePlayer) > iMaxTurns)
		{
			iMaxTurns = GetPlayerNumTurnsAtWar(ePlayer);
		}
	}
	
	return iMaxTurns;
}

/// How many turns have passed since we captured a city from this player?
int CvDiplomacyAI::GetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiPlayerNumTurnsSinceCityCapture[(int)ePlayer];
}

/// Sets how many turns have passed since we captured a city from this player
void CvDiplomacyAI::SetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiPlayerNumTurnsSinceCityCapture[(int)ePlayer] = max(iValue, 0);
}

/// Sets how many turns have passed since we captured a city from this player
void CvDiplomacyAI::ChangePlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsSinceCityCapture(ePlayer, GetPlayerNumTurnsSinceCityCapture(ePlayer) + iChange);
}

/// How many times have we gone to war with ePlayer?
int CvDiplomacyAI::GetNumWarsFought(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiNumWarsFought[(int)ePlayer];
}

/// Sets how many times we have gone to war with ePlayer
void CvDiplomacyAI::SetNumWarsFought(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiNumWarsFought[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Updates how many times we have gone to war with ePlayer
void CvDiplomacyAI::ChangeNumWarsFought(PlayerTypes ePlayer, int iChange)
{
	SetNumWarsFought(ePlayer, GetNumWarsFought(ePlayer) + iChange);
}

/// How many times has ePlayer declared war on us?
int CvDiplomacyAI::GetNumWarsDeclaredOnUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumWarsDeclaredOnUs[(int)ePlayer];
}

/// Sets how many times ePlayer has declared war on us
void CvDiplomacyAI::SetNumWarsDeclaredOnUs(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumWarsDeclaredOnUs[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many times ePlayer has declared war on us
void CvDiplomacyAI::ChangeNumWarsDeclaredOnUs(PlayerTypes ePlayer, int iChange)
{
	SetNumWarsDeclaredOnUs(ePlayer, GetNumWarsDeclaredOnUs(ePlayer) + iChange);
}

/// How many times has this player captured one of our cities?
int CvDiplomacyAI::GetNumCitiesCapturedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiNumCitiesCaptured[(int)ePlayer];
}

/// Sets how many times this player has razed one of our cities
void CvDiplomacyAI::SetNumCitiesCapturedBy(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiNumCitiesCaptured[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many times this player has captured one of our cities
void CvDiplomacyAI::ChangeNumCitiesCapturedBy(PlayerTypes ePlayer, int iChange)
{
	SetNumCitiesCapturedBy(ePlayer, GetNumCitiesCapturedBy(ePlayer) + iChange);
}

/// What is the value of stuff (Units & Cities) lost in a war against a particular player?
int CvDiplomacyAI::GetWarValueLost(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiWarValueLost[(int)ePlayer];
}

/// Sets the value of stuff (Units & Cities) lost in a war against a particular player
void CvDiplomacyAI::SetWarValueLost(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiWarValueLost[(int)ePlayer] = max(iValue, 0);
}

/// Changes the value of stuff (Units & Cities) lost in a war against a particular player
void CvDiplomacyAI::ChangeWarValueLost(PlayerTypes ePlayer, int iChange)
{
	SetWarValueLost(ePlayer, GetWarValueLost(ePlayer) + iChange);

	if (iChange > 0 && GET_PLAYER(ePlayer).isMajorCiv())
	{
		// Loop through all the other major civs that we've met
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (eLoopPlayer != GetID() && IsPlayerValid(eLoopPlayer, true) && GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				// Are they at war with me too? Then they're happy that this player damaged us!
				if (IsAtWar(eLoopPlayer))
				{
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeCommonFoeValue(ePlayer, iChange);
				}
			}
		}
	}
}

/// How much damage have we taken in a war against a particular player?
int CvDiplomacyAI::GetWarDamageValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiWarDamageValue[(int)ePlayer];
}

/// Sets how much damage we have taken in a war against a particular player
void CvDiplomacyAI::SetWarDamageValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiWarDamageValue[(int)ePlayer] = range(iValue, 0, USHRT_MAX);
}

/// How much damage have we taken in a war against a particular player? (Used for UI)
WarDamageLevelTypes CvDiplomacyAI::GetWarDamageLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return WAR_DAMAGE_LEVEL_NONE;

	WarDamageLevelTypes eWarDamageLevel = WAR_DAMAGE_LEVEL_NONE;
	int iWarDamageValue = GetWarDamageValue(ePlayer);

	if (iWarDamageValue >= /*90*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED())
		eWarDamageLevel = WAR_DAMAGE_LEVEL_CRIPPLED;
	else if (iWarDamageValue >= /*65*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS())
		eWarDamageLevel = WAR_DAMAGE_LEVEL_SERIOUS;
	else if (iWarDamageValue >= /*35*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MAJOR())
		eWarDamageLevel = WAR_DAMAGE_LEVEL_MAJOR;
	else if (iWarDamageValue >= /*15*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MINOR())
		eWarDamageLevel = WAR_DAMAGE_LEVEL_MINOR;

	return eWarDamageLevel;
}

/// What is the state of war with this player?
WarStateTypes CvDiplomacyAI::GetWarState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_WAR_STATE_TYPE;
	return (WarStateTypes) m_aeWarState[(int)ePlayer];
}

void CvDiplomacyAI::SetWarState(PlayerTypes ePlayer, WarStateTypes eWarState)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eWarState < NO_WAR_STATE_TYPE || eWarState >= NUM_WAR_STATES) return;
	m_aeWarState[(int)ePlayer] = eWarState;
}

/// Overall assessment of whether we're winning or losing all the wars we are in
StateAllWars CvDiplomacyAI::GetStateAllWars() const
{
	return (StateAllWars) m_eStateAllWars;
}

/// Sets our overall assessment of whether we're winning or losing all the wars we are in
void CvDiplomacyAI::SetStateAllWars(StateAllWars eState)
{
	if (eState < 0 || eState >= NUM_STATES_ALL_WARS) return;
	m_eStateAllWars = eState;
}

/// What is the Projection of war with this player?
WarProjectionTypes CvDiplomacyAI::GetWarProjection(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_WAR_PROJECTION_TYPE;
	return (WarProjectionTypes) m_aeWarProjection[(int)ePlayer];
}

/// Sets what our Projection of war with this player is
void CvDiplomacyAI::SetWarProjection(PlayerTypes ePlayer, WarProjectionTypes eWarProjection)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eWarProjection < 0 || eWarProjection >= NUM_WAR_PROJECTION_TYPES) return;
	m_aeWarProjection[(int)ePlayer] = eWarProjection;
}

/// What is the Goal of war with this player?
WarGoalTypes CvDiplomacyAI::GetWarGoal(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_PLAYERS) return NO_WAR_GOAL_TYPE;
	return (WarGoalTypes) m_aeWarGoal[(int)ePlayer];
}

/// Sets what the Goal of war is with this player
void CvDiplomacyAI::SetWarGoal(PlayerTypes ePlayer, WarGoalTypes eWarGoal)
{
	if (ePlayer < 0 || ePlayer >= MAX_PLAYERS) return;
	if (eWarGoal < NO_WAR_GOAL_TYPE || eWarGoal >= NUM_WAR_GOALS) return;
	m_aeWarGoal[(int)ePlayer] = eWarGoal;

	if (eWarGoal == WAR_GOAL_PEACE)
		ChangeWantPeaceCounter(ePlayer, 1);
	else
		SetWantPeaceCounter(ePlayer, 0);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Peace
// ------------------------------------

/// How many turns have we been at peace with this player?
int CvDiplomacyAI::GetPlayerNumTurnsAtPeace(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiPlayerNumTurnsAtPeace[(int)ePlayer];
}

/// Sets how many turns we've been at peace with this player
void CvDiplomacyAI::SetPlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiPlayerNumTurnsAtPeace[(int)ePlayer] = max(iValue, 0);
}

/// Updates how many turns we've been at peace with this player
void CvDiplomacyAI::ChangePlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsAtPeace(ePlayer, GetPlayerNumTurnsAtPeace(ePlayer) + iChange);
}

/// What are we willing to give up to ePlayer to make peace?
PeaceTreatyTypes CvDiplomacyAI::GetTreatyWillingToOffer(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PEACE_TREATY_TYPE;
	return (PeaceTreatyTypes) m_aePeaceTreatyWillingToOffer[(int)ePlayer];
}

/// Sets what we are willing to give up to ePlayer to make peace
void CvDiplomacyAI::SetTreatyWillingToOffer(PlayerTypes ePlayer, PeaceTreatyTypes eTreaty)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eTreaty < NO_PEACE_TREATY_TYPE || eTreaty >= NUM_PEACE_TREATY_TYPES) return;
	m_aePeaceTreatyWillingToOffer[(int)ePlayer] = eTreaty;
}

/// What are we willing to accept from ePlayer to make peace?
PeaceTreatyTypes CvDiplomacyAI::GetTreatyWillingToAccept(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PEACE_TREATY_TYPE;
	return (PeaceTreatyTypes) m_aePeaceTreatyWillingToAccept[(int)ePlayer];
}

/// Sets what we are willing to accept from ePlayer to make peace
void CvDiplomacyAI::SetTreatyWillingToAccept(PlayerTypes ePlayer, PeaceTreatyTypes eTreaty)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eTreaty < NO_PEACE_TREATY_TYPE || eTreaty >= NUM_PEACE_TREATY_TYPES) return;
	m_aePeaceTreatyWillingToAccept[(int)ePlayer] = eTreaty;
}

/// How long have we wanted to make peace with ePlayer?
int CvDiplomacyAI::GetWantPeaceCounter(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiWantPeaceCounter[(int)ePlayer];
}

/// Sets how long we've wanted to make peace with ePlayer
void CvDiplomacyAI::SetWantPeaceCounter(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiWantPeaceCounter[(int)ePlayer] = max(iValue, 0);
}

/// Changes how long we've wanted to make peace with ePlayer
void CvDiplomacyAI::ChangeWantPeaceCounter(PlayerTypes ePlayer, int iChange)
{
	SetWantPeaceCounter(ePlayer, GetWantPeaceCounter(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Backstabbing Penalties
// ------------------------------------

/// Have we ever betrayed one of our friends?
bool CvDiplomacyAI::IsBackstabber() const
{
	return m_bBackstabber;
}

void CvDiplomacyAI::SetBackstabber(bool bValue)
{
	m_bBackstabber = bValue;
}

/// Do we personally think this player a backstabber? If so, then his word isn't worth much
bool CvDiplomacyAI::IsUntrustworthyFriend(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abUntrustworthyFriend[(int)ePlayer];
}

/// Sets if we personally think this player is a backstabber
void CvDiplomacyAI::SetUntrustworthyFriend(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abUntrustworthyFriend[(int)ePlayer] = bValue;
}
	
/// Is this player a backstabber according to anyone on our team? This is a separate cached value to prevent endless iterating across all players.
bool CvDiplomacyAI::IsUntrustworthy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
	for (size_t i=0; i<vOurTeam.size(); i++)
	{
		if (GET_PLAYER(vOurTeam[i]).isAlive() && !GET_PLAYER(vOurTeam[i]).isHuman())
		{
			if (GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->IsUntrustworthyFriend(ePlayer))
				return true;
		}
	}

	return false;
}

bool CvDiplomacyAI::WasEverBackstabbedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abEverBackstabbedBy[(int)ePlayer];
}

void CvDiplomacyAI::SetEverBackstabbedBy(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abEverBackstabbedBy[(int)ePlayer] = bValue;
}

void CvDiplomacyAI::SetBackstabbedBy(PlayerTypes ePlayer, bool bValue, bool bFromWar)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
	vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
	for (size_t i=0; i<vOurTeam.size(); i++)
	{
		for (size_t j=0; j<vTheirTeam.size(); j++)
		{
			GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->SetEverBackstabbedBy((PlayerTypes)vTheirTeam[j], bValue);
		}
	}
	if (bValue)
	{
		// All AI players must re-evaluate the trustworthiness of other players.
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				if (GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(ePlayer).getTeam())
				{
					if (bFromWar)
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoUpdateConquestStats();

					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(vTheirTeam, bFromWar);
				}
				else
				{
					vector<PlayerTypes> v = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetAllValidMajorCivs();
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(v, bFromWar);
				}
			}
		}
	}
}

/// Returns if ePlayer broke our Declaration of Friendship
bool CvDiplomacyAI::IsDoFBroken(PlayerTypes ePlayer) const
{
	return GetDoFBrokenTurn(ePlayer) != -1;
}

/// Our Declaration of Friendship with ePlayer has been broken, handle everything that means
void CvDiplomacyAI::SetDoFBroken(PlayerTypes ePlayer, bool bValue, bool bSkipTraitorUpdate)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue != IsDoFBroken(ePlayer))
	{
		// Someone broke a DoF, send out notifications to everyone
		if (bValue)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetEndedFriendshipThisTurn(true);

			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_BROKEN");
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_S_BROKEN");
			for (int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer)
			{
				PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
				CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
				CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
				if (iCurPlayer != ePlayer && iCurPlayer !=GetID() && pNotifications)
				{
					const char* strThisPlayerName;
					const char* strOtherPlayerName;

					CvTeam* pCurTeam = &GET_TEAM(kCurPlayer.getTeam());

					// Have we met these guys yet?
					bool bHasMetThisTeam = pCurTeam->isHasMet(GetTeam()) || GET_PLAYER(eCurPlayer).isObserver();
					if (bHasMetThisTeam)
						strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
					else
						strThisPlayerName = "TXT_KEY_UNMET_PLAYER";

					bool bHasMetOtherTeam = pCurTeam->isHasMet(GET_PLAYER(ePlayer).getTeam()) || GET_PLAYER(eCurPlayer).isObserver();
					if (bHasMetOtherTeam)
						strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
					else
						strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";

					//Only display notification if we've met both of the players.
					if (bHasMetThisTeam && bHasMetOtherTeam)
					{
						Localization::String tempInfoStr = strText;
						tempInfoStr << strThisPlayerName << strOtherPlayerName;
						Localization::String tempSummaryStr = strSummary;
						tempSummaryStr << strThisPlayerName << strOtherPlayerName;
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, tempInfoStr.toUTF8(), tempSummaryStr.toUTF8(), -1, -1, GetID(), ePlayer);
					}
				}
			}

			if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
				return;

			if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
				return;

			SetDoFBrokenTurn(ePlayer, GC.getGame().getGameTurn());

			if (!bSkipTraitorUpdate)
			{
				vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
				
				// All AI players must re-evaluate the trustworthiness of other players.
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
					
					if (GET_PLAYER(eLoopPlayer).isMajorCiv())
					{
						if (GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(ePlayer).getTeam())
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(vTheirTeam);
						}
						else
						{
							vector<PlayerTypes> v = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetAllValidMajorCivs();
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(v);
						}
					}
				}
			}
		}
		else
		{
			SetDoFBrokenTurn(ePlayer, -1);
		}
	}
}

/// On what turn did ePlayer break our Declaration of Friendship?
int CvDiplomacyAI::GetDoFBrokenTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiDoFBrokenTurn[(int)ePlayer];
}

/// Sets on what turn ePlayer broke our Declaration of Friendship
void CvDiplomacyAI::SetDoFBrokenTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiDoFBrokenTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since ePlayer broke our Declaration of Friendship?
int CvDiplomacyAI::GetTurnsSinceDoFBroken(PlayerTypes ePlayer) const
{
	if (!IsDoFBroken(ePlayer))
		return -1;

	return (GC.getGame().getGameTurn() - GetDoFBrokenTurn(ePlayer));
}

/// Did this player denounce us while we had a DoF?
bool CvDiplomacyAI::IsFriendDenouncedUs(PlayerTypes ePlayer) const
{
	return GetFriendDenouncedUsTurn(ePlayer) != -1;
}

/// Sets if this player denounced us while we had a DoF
void CvDiplomacyAI::SetFriendDenouncedUs(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue)
	{
		if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
			return;

		if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			return;

		SetFriendDenouncedUsTurn(ePlayer, GC.getGame().getGameTurn());
		SetBackstabbedBy(ePlayer, true);
	}
	else
	{
		SetFriendDenouncedUsTurn(ePlayer, -1);
	}
}

/// On what turn did this player denounce us while we had a DoF?
int CvDiplomacyAI::GetFriendDenouncedUsTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiFriendDenouncedUsTurn[(int)ePlayer];
}

/// Sets on what turn this player denounced us while we had a DoF
void CvDiplomacyAI::SetFriendDenouncedUsTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiFriendDenouncedUsTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many former friends have denounced US???
int CvDiplomacyAI::GetNumFriendsDenouncedBy()
{
	int iNum = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsFriendDenouncedUs(eLoopPlayer))
			iNum++;
	}

	return iNum;
}

/// How many friends have WE denounced?
int CvDiplomacyAI::GetWeDenouncedFriendCount()
{
	int iNum = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDenouncedUs(GetID()))
			iNum++;
	}

	return iNum;
}

/// Did this player declare war on us while we had a DoF?
bool CvDiplomacyAI::IsFriendDeclaredWarOnUs(PlayerTypes ePlayer) const
{
	return GetFriendDeclaredWarOnUsTurn(ePlayer) != -1;
}

/// Sets if this player declared war on us while we had a DoF
void CvDiplomacyAI::SetFriendDeclaredWarOnUs(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue)
	{
		if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
			return;

		if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			return;

		SetFriendDeclaredWarOnUsTurn(ePlayer, GC.getGame().getGameTurn());
		SetBackstabbedBy(ePlayer, true);

		// If they didn't backstab in reaction to our backstabbing, mark them as a serial backstabber
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsUntrustworthy(GetID()))
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetBackstabber(true);
		}
	}
	else
	{
		SetFriendDeclaredWarOnUsTurn(ePlayer, -1);
	}
}

/// On what turn did this player declare war on us when we had a DoF?
int CvDiplomacyAI::GetFriendDeclaredWarOnUsTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiFriendDeclaredWarOnUsTurn[(int)ePlayer];
}

/// Sets on what turn this player declared war on us while we had a DoF
void CvDiplomacyAI::SetFriendDeclaredWarOnUsTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiFriendDeclaredWarOnUsTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many friends have WE Declared War on?
int CvDiplomacyAI::GetWeDeclaredWarOnFriendCount()
{
	int iNum = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDeclaredWarOnUs(GetID()))
			iNum++;
	}

	return iNum;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Warmongering Penalties
// ------------------------------------

/// How many Minors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumMinorsAttacked[(int)ePlayer];
}

/// Sets how many Minors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumMinorsAttacked[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many Minors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer, int iChange, TeamTypes eAttackedTeam)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	// Disregard our own warmongering
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
		return;

	// Disregard if we're also at war with this team
	if (GET_TEAM(GetTeam()).isAtWar(eAttackedTeam))
		return;
	
	// Don't apply warmongering if we haven't met the attacker (otherwise that's cheating)
	if (!IsHasMet(ePlayer))
		return;

	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// Ignore our master's warmongering
		if (IsVassal(ePlayer))
			return;

		// Don't count this if the player declaring war is a vassal because he can't declare war himself
		if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			return;
	}

	SetOtherPlayerNumMinorsAttacked(ePlayer, GetOtherPlayerNumMinorsAttacked(ePlayer) + iChange);

	int iWarmongerValue = CvDiplomacyAIHelpers::GetWarmongerOffset(NULL, ePlayer, GetID(), WARMONGER_MINOR_ATTACKED);
	ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarmongerValue * 100);

	DoUpdateWarmongerThreats(true);
}

/// How many Minors have we seen this Player conquer?
int CvDiplomacyAI::GetPlayerNumMinorsConquered(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumMinorsConquered[(int)ePlayer];
}

/// Sets how many Minors we have seen this Player conquer
void CvDiplomacyAI::SetPlayerNumMinorsConquered(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumMinorsConquered[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// How many Majors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumMajorsAttacked[(int)ePlayer];
}

/// Sets how many Majors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumMajorsAttacked[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many Majors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer, int iChange, TeamTypes eAttackedTeam)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	// Disregard our own warmongering
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
		return;

	// Disregard if we're also at war with this team
	if (GET_TEAM(GetTeam()).isAtWar(eAttackedTeam))
		return;
	
	// Don't apply warmongering if we haven't met the attacker (otherwise that's cheating)
	if (!IsHasMet(ePlayer))
		return;

	// War declarations between humans don't apply warmongering except for the attacked team and their DPs/vassals (prevents exploit)
	if (eAttackedTeam != GetTeam() && !GET_TEAM(GetTeam()).IsHasDefensivePact(eAttackedTeam) && !GET_TEAM(GetTeam()).IsVassal(eAttackedTeam) && GET_PLAYER(ePlayer).isHuman() && GET_TEAM(eAttackedTeam).isHuman())
		return;

	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// Ignore our master's warmongering
		if (IsVassal(ePlayer))
			return;

		// Don't count this if the player declaring war is a vassal because he can't declare war himself
		if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			return;
	}

	// If we're planning a coop war with this guy against someone on the attacked team (or this guy is a vassal/master/DP of that team), we don't care.
	for (int iAttackedPlayer = 0; iAttackedPlayer < MAX_MAJOR_CIVS; iAttackedPlayer++)
	{
		PlayerTypes eAttackedPlayer = (PlayerTypes) iAttackedPlayer;
		TeamTypes eTeam = GET_PLAYER(eAttackedPlayer).getTeam();

		if (eTeam == eAttackedTeam || GET_TEAM(eTeam).IsHasDefensivePact(eAttackedTeam) || GET_TEAM(eTeam).IsVassal(eAttackedTeam) || GET_TEAM(eAttackedTeam).IsVassal(eTeam))
		{
			if (!GetPlayer()->isHuman())
			{
				if (IsWantsSneakAttack(eAttackedPlayer))
					return;

				if (IsArmyInPlaceForAttack(eAttackedPlayer))
					return;

				if (GetMajorCivApproach(eAttackedPlayer) == MAJOR_CIV_APPROACH_WAR)
					return;
			}

			CoopWarStates eCoopWarState = GetCoopWarState(ePlayer, eAttackedPlayer);
			if (eCoopWarState >= COOP_WAR_STATE_PREPARING)
			{
				return;
			}
		}
	}

	SetOtherPlayerNumMajorsAttacked(ePlayer, GetOtherPlayerNumMajorsAttacked(ePlayer) + iChange);

	int iWarmongerValue = CvDiplomacyAIHelpers::GetWarmongerOffset(NULL, ePlayer, GetID(), WARMONGER_MAJOR_ATTACKED);
	ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarmongerValue * 100);

	DoUpdateWarmongerThreats(true);
}

/// How many Majors have we seen this Player conquer?
int CvDiplomacyAI::GetPlayerNumMajorsConquered(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumMajorsConquered[(int)ePlayer];
}

/// Sets how many Majors we have seen this Player conquer
void CvDiplomacyAI::SetPlayerNumMajorsConquered(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumMajorsConquered[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Get the amount of warmongerishness felt toward this player
int CvDiplomacyAI::GetOtherPlayerWarmongerAmountTimes100(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiWarmongerAmountTimes100[(int)ePlayer];
}

int CvDiplomacyAI::GetOtherPlayerWarmongerAmount(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return GetOtherPlayerWarmongerAmountTimes100(ePlayer) / 100;
}

/// Change the amount of warmongerishness felt toward this player
void CvDiplomacyAI::SetOtherPlayerWarmongerAmountTimes100(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiWarmongerAmountTimes100[(int)ePlayer] = max(iValue, 0);
}

void CvDiplomacyAI::ChangeOtherPlayerWarmongerAmountTimes100(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerWarmongerAmountTimes100(ePlayer, GetOtherPlayerWarmongerAmountTimes100(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Aggressive Postures
// ------------------------------------

/// How aggressively are this player's military Units positioned in relation to us?
AggressivePostureTypes CvDiplomacyAI::GetMilitaryAggressivePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aeMilitaryAggressivePosture[(int)ePlayer];
}

/// Sets how aggressively this player has stationed his military Units in relation to us
void CvDiplomacyAI::SetMilitaryAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (ePosture < 0 || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aeMilitaryAggressivePosture[(int)ePlayer] = ePosture;
}

/// How aggressively were this player's military Units positioned in relation to us last turn?
AggressivePostureTypes CvDiplomacyAI::GetLastTurnMilitaryAggressivePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aeLastTurnMilitaryAggressivePosture[(int)ePlayer];
}

/// Sets how aggressively this player had stationed his military Units in relation to us last turn
void CvDiplomacyAI::SetLastTurnMilitaryAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (ePosture < 0 || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aeLastTurnMilitaryAggressivePosture[(int)ePlayer] = ePosture;
}

/// How aggressively has this player settled in relation to us?
AggressivePostureTypes CvDiplomacyAI::GetExpansionAggressivePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aeExpansionAggressivePosture[(int)ePlayer];
}

/// Sets how aggressively this player has settled in relation to us
void CvDiplomacyAI::SetExpansionAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (ePosture < 0 || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aeExpansionAggressivePosture[(int)ePlayer] = ePosture;
}

/// How aggressively is ePlayer buying land near us?
AggressivePostureTypes CvDiplomacyAI::GetPlotBuyingAggressivePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aePlotBuyingAggressivePosture[(int)ePlayer];
}

/// Sets how aggressively this player has bought land near us
void CvDiplomacyAI::SetPlotBuyingAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (ePosture < 0 || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aePlotBuyingAggressivePosture[(int)ePlayer] = ePosture;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Dispute Levels
// ------------------------------------

/// What is our level of Dispute with a player over Land?
DisputeLevelTypes CvDiplomacyAI::GetLandDisputeLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_DISPUTE_LEVEL;
	return (DisputeLevelTypes) m_aeLandDisputeLevel[(int)ePlayer];
}

/// Sets what our level of Dispute is with a player over Land
void CvDiplomacyAI::SetLandDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eDisputeLevel < 0 || eDisputeLevel >= NUM_DISPUTE_LEVELS) return;
	m_aeLandDisputeLevel[(int)ePlayer] = eDisputeLevel;
}

/// Returns an integer that increases as the number and severity of land disputes rises
int CvDiplomacyAI::GetTotalLandDisputeLevel()
{
	int iRtnValue = 0; // slewis added, to fix a compile error. I'm guessing zero is correct.

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			switch (GetLandDisputeLevel(ePlayer))
			{
			case DISPUTE_LEVEL_FIERCE:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_FIERCE();
				break;
			case DISPUTE_LEVEL_STRONG:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_STRONG();
				break;
			case DISPUTE_LEVEL_WEAK:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_WEAK();
				break;
			}
		}
	}
	return iRtnValue;
}

/// What was our level of Dispute with a player over Land last turn?
DisputeLevelTypes CvDiplomacyAI::GetLastTurnLandDisputeLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DISPUTE_LEVEL;
	return (DisputeLevelTypes) m_aeLastTurnLandDisputeLevel[(int)ePlayer];
}

/// Sets what our level of Dispute was with a player over Land last turn
void CvDiplomacyAI::SetLastTurnLandDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eDisputeLevel < 0 || eDisputeLevel >= NUM_DISPUTE_LEVELS) return;
	m_aeLastTurnLandDisputeLevel[(int)ePlayer] = eDisputeLevel;
}

/// What is our level of Dispute with a player over Victory?
DisputeLevelTypes CvDiplomacyAI::GetVictoryDisputeLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DISPUTE_LEVEL;
	return (DisputeLevelTypes) m_aeVictoryDisputeLevel[(int)ePlayer];
}

/// Sets what our level of Dispute is with a player over Victory
void CvDiplomacyAI::SetVictoryDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eDisputeLevel < 0 || eDisputeLevel >= NUM_DISPUTE_LEVELS) return;
	m_aeVictoryDisputeLevel[(int)ePlayer] = eDisputeLevel;
}

/// What is our level of Desire to block this player over Victory?
BlockLevelTypes CvDiplomacyAI::GetVictoryBlockLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_BLOCK_LEVEL;
	return (BlockLevelTypes) m_aeVictoryBlockLevel[(int)ePlayer];
}

/// Sets what our level of Desire is to block a player over Victory
void CvDiplomacyAI::SetVictoryBlockLevel(PlayerTypes ePlayer, BlockLevelTypes eBlockLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eBlockLevel < 0 || eBlockLevel >= NUM_BLOCK_LEVELS) return;
	m_aeVictoryBlockLevel[(int)ePlayer] = eBlockLevel;
}

/// What is our level of Dispute with a player over World Wonders?
DisputeLevelTypes CvDiplomacyAI::GetWonderDisputeLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DISPUTE_LEVEL;
	return (DisputeLevelTypes) m_aeWonderDisputeLevel[(int)ePlayer];
}

/// Sets what our level of Dispute is with a player over World Wonders
void CvDiplomacyAI::SetWonderDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eDisputeLevel < 0 || eDisputeLevel >= NUM_DISPUTE_LEVELS) return;
	m_aeWonderDisputeLevel[(int)ePlayer] = eDisputeLevel;
}

/// What is our level of Dispute with a player over Minor Civ Friendship?
DisputeLevelTypes CvDiplomacyAI::GetMinorCivDisputeLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_DISPUTE_LEVEL;
	return (DisputeLevelTypes) m_aeMinorCivDisputeLevel[(int)ePlayer];
}

/// Sets what our level of Dispute is with a player over Minor Civ Friendship
void CvDiplomacyAI::SetMinorCivDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eDisputeLevel < 0 || eDisputeLevel >= NUM_DISPUTE_LEVELS) return;
	m_aeMinorCivDisputeLevel[(int)ePlayer] = eDisputeLevel;
}

/// What is our level of Desire to block this player over Technology?
BlockLevelTypes CvDiplomacyAI::GetTechBlockLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_BLOCK_LEVEL;
	return (BlockLevelTypes) m_aeTechBlockLevel[(int)ePlayer];
}

/// Sets what our level of Desire is to block a player over Technology
void CvDiplomacyAI::SetTechBlockLevel(PlayerTypes ePlayer, BlockLevelTypes eBlockLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eBlockLevel < 0 || eBlockLevel >= NUM_BLOCK_LEVELS) return;
	m_aeTechBlockLevel[(int)ePlayer] = eBlockLevel;
}

/// What is our level of Desire to block this player over Social Policies?
BlockLevelTypes CvDiplomacyAI::GetPolicyBlockLevel(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_BLOCK_LEVEL;
	return (BlockLevelTypes) m_aePolicyBlockLevel[(int)ePlayer];
}

/// Sets what our level of Desire is to block a player over Social Policies
void CvDiplomacyAI::SetPolicyBlockLevel(PlayerTypes ePlayer, BlockLevelTypes eBlockLevel)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eBlockLevel < 0 || eBlockLevel >= NUM_BLOCK_LEVELS) return;
	m_aePolicyBlockLevel[(int)ePlayer] = eBlockLevel;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Threat Levels
// ------------------------------------

/// How threatening is this player militarily?
ThreatTypes CvDiplomacyAI::GetMilitaryThreat(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_THREAT_VALUE;
	return (ThreatTypes) m_aeMilitaryThreat[(int)ePlayer];
}

/// Set how threatening this player is militarily
void CvDiplomacyAI::SetMilitaryThreat(PlayerTypes ePlayer, ThreatTypes eMilitaryThreat)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eMilitaryThreat < 0 || eMilitaryThreat >= NUM_THREAT_VALUES) return;
	m_aeMilitaryThreat[(int)ePlayer] = eMilitaryThreat;
}

/// How much of a threat are these guys to run amok and break everything?
ThreatTypes CvDiplomacyAI::GetWarmongerThreat(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_THREAT_VALUE;
	return (ThreatTypes) m_aeWarmongerThreat[(int)ePlayer];
}

/// Sets how much of a threat these guys are to run amok and break everything
void CvDiplomacyAI::SetWarmongerThreat(PlayerTypes ePlayer, ThreatTypes eWarmongerThreat)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eWarmongerThreat < 0 || eWarmongerThreat >= NUM_THREAT_VALUES) return;
	m_aeWarmongerThreat[(int)ePlayer] = eWarmongerThreat;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Strength Assessments
// ------------------------------------

/// What is our assessment of this player's overall Military Strength?
StrengthTypes CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_STRENGTH_VALUE;
	return (StrengthTypes) m_aeMilitaryStrengthComparedToUs[(int)ePlayer];
}

/// Sets what our assessment is of this player's overall Military Strength
void CvDiplomacyAI::SetPlayerMilitaryStrengthComparedToUs(PlayerTypes ePlayer, StrengthTypes eMilitaryStrength)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eMilitaryStrength < 0 || eMilitaryStrength >= NUM_STRENGTH_VALUES) return;
	m_aeMilitaryStrengthComparedToUs[(int)ePlayer] = eMilitaryStrength;
}

/// What is our assessment of this player's overall Economic Strength?
StrengthTypes CvDiplomacyAI::GetPlayerEconomicStrengthComparedToUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_STRENGTH_VALUE;
	return (StrengthTypes) m_aeEconomicStrengthComparedToUs[(int)ePlayer];
}

/// Sets what our assessment is of this player's overall Economic Strength
void CvDiplomacyAI::SetPlayerEconomicStrengthComparedToUs(PlayerTypes ePlayer, StrengthTypes eEconomicStrength)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eEconomicStrength < 0 || eEconomicStrength >= NUM_STRENGTH_VALUES) return;
	m_aeEconomicStrengthComparedToUs[(int)ePlayer] = eEconomicStrength;
}

/// What is our assessment of this player's value as a military target?
TargetValueTypes CvDiplomacyAI::GetPlayerTargetValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return NO_TARGET_VALUE;
	return (TargetValueTypes) m_aeTargetValue[(int)ePlayer];
}

/// Sets what our assessment is of this player's value as a military target
void CvDiplomacyAI::SetPlayerTargetValue(PlayerTypes ePlayer, TargetValueTypes eTargetValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eTargetValue < 0 || eTargetValue >= NUM_TARGET_VALUES) return;
	m_aeTargetValue[(int)ePlayer] = eTargetValue;
}

/// Is this player an easy attack target?
bool CvDiplomacyAI::IsEasyTarget(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;

	// If we're someone's vassal, they're not an easy target (unless we're at war).
	if (!IsAtWar(ePlayer) && GetPlayer()->IsVassalOfSomeone())
		return false;

	return m_abEasyTarget[(int)ePlayer];
}

/// Sets whether or not this player is an easy attack target
void CvDiplomacyAI::SetEasyTarget(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_abEasyTarget[(int)ePlayer] = bValue;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Promises
// ------------------------------------

// ////////////////////////////////////
// Military Promise
// ////////////////////////////////////

/// What is the state of ePlayer's military promise to us?
PromiseStates CvDiplomacyAI::GetPlayerMilitaryPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeMilitaryPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's military promise to us
void CvDiplomacyAI::SetPlayerMilitaryPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerMilitaryPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		if (ePromiseState != NO_PROMISE_STATE)
		{
			if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			{
				return;
			}

			if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
			{
				return;
			}
		}

		m_aeMilitaryPromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerMilitaryPromiseTurn(ePlayer, GC.getGame().getGameTurn());
		}
		else
		{
			SetPlayerMilitaryPromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's military promise to us change?
int CvDiplomacyAI::GetPlayerMilitaryPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiMilitaryPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's military promise to us changed
void CvDiplomacyAI::SetPlayerMilitaryPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiMilitaryPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did ePlayer make a military promise to us?
bool CvDiplomacyAI::IsPlayerMadeMilitaryPromise(PlayerTypes ePlayer) const
{
	return GetPlayerMilitaryPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did ePlayer ignore a military promise to us?
bool CvDiplomacyAI::IsPlayerIgnoredMilitaryPromise(PlayerTypes ePlayer) const
{
	return GetPlayerMilitaryPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did ePlayer break a military promise to us?
bool CvDiplomacyAI::IsPlayerBrokenMilitaryPromise(PlayerTypes ePlayer) const
{
	return GetPlayerMilitaryPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// Return the number of turns since ePlayer has made a military promise to us
int CvDiplomacyAI::GetPlayerMadeMilitaryPromise(PlayerTypes ePlayer)
{
	// Did they make a military promise?
	if (!IsPlayerMadeMilitaryPromise(ePlayer))
		return -1;

	int iTurnDifference = GC.getGame().getGameTurn() - GetPlayerMilitaryPromiseTurn(ePlayer);

	// this promise does not scale with gamespeed!
	return std::max(/*20*/GC.getMOVE_TROOPS_MEMORY_TURN_EXPIRATION() - iTurnDifference, 0);
}

// ////////////////////////////////////
// Expansion Promise
// ////////////////////////////////////

/// What is the state of ePlayer's expansion promise to us?
PromiseStates CvDiplomacyAI::GetPlayerExpansionPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeExpansionPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's expansion promise to us
void CvDiplomacyAI::SetPlayerExpansionPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerExpansionPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeExpansionPromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerExpansionPromiseTurn(ePlayer, GC.getGame().getGameTurn());

			if (ePromiseState == PROMISE_STATE_MADE)
			{
				SetPlayerExpansionPromisePosture(ePlayer, GetExpansionAggressivePosture(ePlayer));
				SetNoExpansionPromiseClosestCities(ePlayer, GetClosestCityPair(ePlayer));
				SetEverMadeExpansionPromise(ePlayer, true);
			}
			else
			{
				SetPlayerExpansionPromisePosture(ePlayer, NO_AGGRESSIVE_POSTURE_TYPE);
				SetNoExpansionPromiseClosestCities(ePlayer, make_pair(-1,-1));

				// They ignored or broke an expansion promise! Cancel any commitment not to settle near them!
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(GetID()) && !GetPlayer()->isHuman())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerExpansionPromiseState(GetID(), NO_PROMISE_STATE);
				}
			}
		}
		else
		{
			SetPlayerExpansionPromiseTurn(ePlayer, -1);
			SetPlayerExpansionPromisePosture(ePlayer, NO_AGGRESSIVE_POSTURE_TYPE);
			SetNoExpansionPromiseClosestCities(ePlayer, make_pair(-1,-1));
		}
	}
}

/// Did ePlayer make an expansion promise to us?
bool CvDiplomacyAI::IsPlayerMadeExpansionPromise(PlayerTypes ePlayer) const
{
	return GetPlayerExpansionPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did ePlayer ignore our request for them to make an expansion promise?
bool CvDiplomacyAI::IsPlayerIgnoredExpansionPromise(PlayerTypes ePlayer) const
{
	return GetPlayerExpansionPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did ePlayer break an expansion promise to us?
bool CvDiplomacyAI::IsPlayerBrokenExpansionPromise(PlayerTypes ePlayer) const
{
	return GetPlayerExpansionPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// Which players have we agreed to avoid settling near?
vector<PlayerTypes> CvDiplomacyAI::GetPlayersWithNoSettlePolicy() const
{
	vector<PlayerTypes> result;
	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayer;

		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(GetID()))
			result.push_back(ePlayer);
		else if (IsTeammate(ePlayer) && GET_PLAYER(ePlayer).isHuman())
			result.push_back(ePlayer);
	}
	
	return result;
}

/// On what turn did the state of ePlayer's expansion promise to us change?
int CvDiplomacyAI::GetPlayerExpansionPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiExpansionPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's expansion promise to us changed
void CvDiplomacyAI::SetPlayerExpansionPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiExpansionPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Return the number of turns since ePlayer has made an expansion promise to us
int CvDiplomacyAI::GetPlayerMadeExpansionPromise(PlayerTypes ePlayer) const
{
	if (!IsPlayerMadeExpansionPromise(ePlayer))
		return -1;

	int iTurnDifference = GC.getGame().getGameTurn() - GetPlayerExpansionPromiseTurn(ePlayer);
	int iTimeOutTurns = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;
	
	int iValue = (iTimeOutTurns - iTurnDifference);
	if (iValue > 0)
	{
		return iValue;
	}
	return -1;
}

/// Has ePlayer asked about us not settling near him lately?
bool CvDiplomacyAI::IsDontSettleMessageTooSoon(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(GetID()))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return false;
}

/// What was the expansion aggressive posture of ePlayer when they made an expansion promise to us?
AggressivePostureTypes CvDiplomacyAI::GetPlayerExpansionPromisePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aeExpansionPromisePosture[(int)ePlayer];
}

/// Sets the expansion aggressive posture of ePlayer when they make an expansion promise to us
void CvDiplomacyAI::SetPlayerExpansionPromisePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePosture < NO_AGGRESSIVE_POSTURE_TYPE || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aeExpansionPromisePosture[(int)ePlayer] = ePosture;
}

/// Returns integers corresponding to the closest pair of cities between us when ePlayer made an expansion promise to us
pair<int,int> CvDiplomacyAI::GetNoExpansionPromiseClosestCities(PlayerTypes eOtherPlayer) const
{
	pair<int, int> errValue(-1, -1);
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return errValue;
	return m_aNoExpansionPromise[(int)eOtherPlayer];
}

/// Sets integers corresponding to the closest pair of cities between us when ePlayer makes an expansion promise to us
void CvDiplomacyAI::SetNoExpansionPromiseClosestCities(PlayerTypes eOtherPlayer, pair<int,int> value)
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_MAJOR_CIVS) return;
	m_aNoExpansionPromise[(int)eOtherPlayer] = value;
}

/// Returns integers corresponding to the closest pair of cities between us last round
pair<int,int> CvDiplomacyAI::GetLastTurnClosestCityPair(PlayerTypes eOtherPlayer) const
{
	pair<int, int> errValue(-1, -1);
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS) return errValue;
	return m_aLastTurnEmpireDistance[(int)eOtherPlayer];
}

/// Sets integers corresponding to the closest pair of cities between us last round
void CvDiplomacyAI::SetLastTurnClosestCityPair(PlayerTypes eOtherPlayer, pair<int,int> value)
{
	if (eOtherPlayer < 0 || eOtherPlayer >= MAX_CIV_PLAYERS) return;
	m_aLastTurnEmpireDistance[(int)eOtherPlayer] = value;
}

/// Did this player ever make an expansion promise to us?
bool CvDiplomacyAI::EverMadeExpansionPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abEverMadeExpansionPromise[(int)ePlayer];
}

/// Sets if this player ever made an expansion promise to us
void CvDiplomacyAI::SetEverMadeExpansionPromise(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abEverMadeExpansionPromise[(int)ePlayer] = bValue;
}

// ////////////////////////////////////
// Border Promise
// ////////////////////////////////////

/// What is the state of ePlayer's border promise to us?
PromiseStates CvDiplomacyAI::GetPlayerBorderPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeBorderPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's border promise to us
void CvDiplomacyAI::SetPlayerBorderPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerBorderPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeBorderPromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerBorderPromiseTurn(ePlayer, GC.getGame().getGameTurn());

			if (ePromiseState == PROMISE_STATE_MADE)
			{
				SetPlayerBorderPromisePosture(ePlayer, GetPlotBuyingAggressivePosture(ePlayer));
				SetEverMadeBorderPromise(ePlayer, true);
			}
			else
			{
				SetPlayerBorderPromisePosture(ePlayer, NO_AGGRESSIVE_POSTURE_TYPE);

				// They ignored or broke a border promise! Cancel any commitment not to buy land near them!
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeBorderPromise(GetID()) && !GetPlayer()->isHuman())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBorderPromiseState(GetID(), NO_PROMISE_STATE);
				}
			}
		}
		else
		{
			SetPlayerBorderPromiseTurn(ePlayer, -1);
			SetPlayerBorderPromisePosture(ePlayer, NO_AGGRESSIVE_POSTURE_TYPE);
		}
	}
}

/// Did ePlayer make a border promise to us?
bool CvDiplomacyAI::IsPlayerMadeBorderPromise(PlayerTypes ePlayer) const
{
	return GetPlayerBorderPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did ePlayer ignore our request for them to make a border promise?
bool CvDiplomacyAI::IsPlayerIgnoredBorderPromise(PlayerTypes ePlayer) const
{
	return GetPlayerBorderPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did ePlayer break a border promise to us?
bool CvDiplomacyAI::IsPlayerBrokenBorderPromise(PlayerTypes ePlayer) const
{
	return GetPlayerBorderPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// On what turn did the state of ePlayer's border promise to us change?
int CvDiplomacyAI::GetPlayerBorderPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiBorderPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's border promise to us changed
void CvDiplomacyAI::SetPlayerBorderPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiBorderPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Return the number of turns since ePlayer has made a border promise to us
int CvDiplomacyAI::GetPlayerMadeBorderPromise(PlayerTypes ePlayer) const
{
	if (!IsPlayerMadeBorderPromise(ePlayer))
		return -1;

	int iTurnDifference = GC.getGame().getGameTurn() - GetPlayerBorderPromiseTurn(ePlayer);
	int iTimeOutTurns = (GC.getBORDER_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;
	
	int iValue = (iTimeOutTurns - iTurnDifference);
	if (iValue > 0)
	{
		return iValue;
	}
	return -1;
}

/// What was the plot buying aggressive posture of ePlayer when they made a border promise to us?
AggressivePostureTypes CvDiplomacyAI::GetPlayerBorderPromisePosture(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_AGGRESSIVE_POSTURE_TYPE;
	return (AggressivePostureTypes) m_aeBorderPromisePosture[(int)ePlayer];
}

/// Sets the plot buying aggressive posture of ePlayer when they make a border promise to us
void CvDiplomacyAI::SetPlayerBorderPromisePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePosture < NO_AGGRESSIVE_POSTURE_TYPE || ePosture >= NUM_AGGRESSIVE_POSTURE_TYPES) return;
	m_aeBorderPromisePosture[(int)ePlayer] = ePosture;
}

/// Did this player ever make a border promise to us?
bool CvDiplomacyAI::EverMadeBorderPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abEverMadeBorderPromise[(int)ePlayer];
}

/// Sets if this player ever made a border promise with us
void CvDiplomacyAI::SetEverMadeBorderPromise(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abEverMadeBorderPromise[(int)ePlayer] = bValue;
}

// ////////////////////////////////////
// Bully City-State Promise
// ////////////////////////////////////

/// What is the state of ePlayer's bully city-state promise to us
PromiseStates CvDiplomacyAI::GetPlayerBullyCityStatePromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeBullyCityStatePromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's bully city-state promise to us
void CvDiplomacyAI::SetPlayerBullyCityStatePromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerBullyCityStatePromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeBullyCityStatePromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerBullyCityStatePromiseTurn(ePlayer, GC.getGame().getGameTurn());

			// They ignored or broke a promise to stop bullying our protected City-States! Cancel any commitment not to attack theirs!
			if (ePromiseState != PROMISE_STATE_MADE && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeBullyCityStatePromise(GetID()) && !GetPlayer()->isHuman())
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBullyCityStatePromiseState(GetID(), NO_PROMISE_STATE);
			}
		}
		else
		{
			SetPlayerBullyCityStatePromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's bully city-state promise to us change?
int CvDiplomacyAI::GetPlayerBullyCityStatePromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiBullyCityStatePromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's bully city-state promise to us changed
void CvDiplomacyAI::SetPlayerBullyCityStatePromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiBullyCityStatePromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player promise to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerMadeBullyCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerBullyCityStatePromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did this player ignore our request to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerIgnoredBullyCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerBullyCityStatePromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did this player break a promise to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerBrokenBullyCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerBullyCityStatePromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

// ////////////////////////////////////
// Attack City-State Promise
// ////////////////////////////////////

/// What is the state of ePlayer's attack city-state promise to us
PromiseStates CvDiplomacyAI::GetPlayerAttackCityStatePromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeAttackCityStatePromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's attack city-state promise to us
void CvDiplomacyAI::SetPlayerAttackCityStatePromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerAttackCityStatePromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		// Vassals can't backstab...and humans can't backstab other humans
		if (ePromiseState == PROMISE_STATE_BROKEN)
		{
			if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
			{
				return;
			}

			if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
			{
				return;
			}
		}

		m_aeAttackCityStatePromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerAttackCityStatePromiseTurn(ePlayer, GC.getGame().getGameTurn());

			// They ignored or broke a promise to stop bullying our protected City-States! Cancel any commitment not to attack theirs!
			if (ePromiseState != PROMISE_STATE_MADE && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeAttackCityStatePromise(GetID()) && !GetPlayer()->isHuman())
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerAttackCityStatePromiseState(GetID(), NO_PROMISE_STATE);
			}
		}
		else
		{
			SetPlayerAttackCityStatePromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's attack city-state promise to us change?
int CvDiplomacyAI::GetPlayerAttackCityStatePromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiAttackCityStatePromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's attack city-state promise to us changed
void CvDiplomacyAI::SetPlayerAttackCityStatePromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiAttackCityStatePromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player promise to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerMadeAttackCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerAttackCityStatePromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did this player ignore our request to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerIgnoredAttackCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerAttackCityStatePromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did this player break a promise to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerBrokenAttackCityStatePromise(PlayerTypes ePlayer) const
{
	return GetPlayerAttackCityStatePromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

// ////////////////////////////////////
// Spy Promise
// ////////////////////////////////////

/// What is the state of ePlayer's spy promise to us
PromiseStates CvDiplomacyAI::GetPlayerSpyPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeSpyPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's spy promise to us
void CvDiplomacyAI::SetPlayerSpyPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerSpyPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeSpyPromiseState[(int)ePlayer] = ePromiseState;

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerSpyPromiseTurn(ePlayer, GC.getGame().getGameTurn());

			// They ignored or broke a promise to stop spying on us! Cancel any commitment not to spy on them!
			if (ePromiseState != PROMISE_STATE_MADE && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeSpyPromise(GetID()) && !GetPlayer()->isHuman())
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerSpyPromiseState(GetID(), NO_PROMISE_STATE);
			}
		}
		else
		{
			SetPlayerSpyPromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's spy promise to us change?
int CvDiplomacyAI::GetPlayerSpyPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiSpyPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's spy promise to us changed
void CvDiplomacyAI::SetPlayerSpyPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiSpyPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player promise to stop spying on us?
bool CvDiplomacyAI::IsPlayerMadeSpyPromise(PlayerTypes ePlayer) const
{
	return GetPlayerSpyPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did this player ignore our request to stop spying on us?
bool CvDiplomacyAI::IsPlayerIgnoredSpyPromise(PlayerTypes ePlayer) const
{
	return GetPlayerSpyPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did this player break a promise to stop spying on us?
bool CvDiplomacyAI::IsPlayerBrokenSpyPromise(PlayerTypes ePlayer) const
{
	return GetPlayerSpyPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// Has ePlayer asked us not to spy on him lately?
bool CvDiplomacyAI::IsStopSpyingMessageTooSoon(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeSpyPromise(GetID()))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return false;
}

// ////////////////////////////////////
// Religious Conversion Promise
// ////////////////////////////////////

/// What is the state of ePlayer's no convert promise to us
PromiseStates CvDiplomacyAI::GetPlayerNoConvertPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeNoConvertPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's no convert promise to us
void CvDiplomacyAI::SetPlayerNoConvertPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerNoConvertPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeNoConvertPromiseState[(int)ePlayer] = ePromiseState;

		// Reset the ability to ask the promise again
		if (eCurrentState == PROMISE_STATE_MADE)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerAskedNotToConvert(GetID(), false);
		}

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerNoConvertPromiseTurn(ePlayer, GC.getGame().getGameTurn());

			// They ignored or broke a promise to stop converting our cities! Cancel any commitment not to convert theirs!
			if (ePromiseState != PROMISE_STATE_MADE && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoConvertPromise(GetID()) && !GetPlayer()->isHuman())
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerNoConvertPromiseState(GetID(), NO_PROMISE_STATE);
			}
		}
		else
		{
			SetPlayerNoConvertPromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's no convert promise to us change?
int CvDiplomacyAI::GetPlayerNoConvertPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiNoConvertPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's no convert promise to us changed
void CvDiplomacyAI::SetPlayerNoConvertPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNoConvertPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player promise to stop converting our cities?
bool CvDiplomacyAI::IsPlayerMadeNoConvertPromise(PlayerTypes ePlayer) const
{
	return GetPlayerNoConvertPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did this player ignore our request to stop converting our cities?
bool CvDiplomacyAI::IsPlayerIgnoredNoConvertPromise(PlayerTypes ePlayer) const
{
	return GetPlayerNoConvertPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did this player break a promise to stop converting our cities?
bool CvDiplomacyAI::IsPlayerBrokenNoConvertPromise(PlayerTypes ePlayer) const
{
	return GetPlayerNoConvertPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// Has ePlayer asked us to stop sending missionaries and prophets to their cities?
bool CvDiplomacyAI::IsPlayerAskedNotToConvert(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// Can't ask if we've already promised
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoConvertPromise(GetID()))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return m_abAskedNotToConvert[(int)ePlayer];
}

/// Sets if ePlayer asked us to stop sending missionaries and prophets to their cities
void CvDiplomacyAI::SetPlayerAskedNotToConvert(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abAskedNotToConvert[(int)ePlayer] = bValue;
}

/// Has this player ever converted one of our cities (if we care)?
bool CvDiplomacyAI::HasEverConvertedCity(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abEverConvertedCity[(int)ePlayer];
}

/// Sets if this player has ever converted one of our cities (if we care)
void CvDiplomacyAI::SetEverConvertedCity(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abEverConvertedCity[(int)ePlayer] = bValue;
}

// ////////////////////////////////////
// Digging Promise
// ////////////////////////////////////

/// What is the state of ePlayer's no digging promise to us
PromiseStates CvDiplomacyAI::GetPlayerNoDiggingPromiseState(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PROMISE_STATE;
	return (PromiseStates) m_aeNoDiggingPromiseState[(int)ePlayer];
}

/// Sets the state of ePlayer's no digging promise to us
void CvDiplomacyAI::SetPlayerNoDiggingPromiseState(PlayerTypes ePlayer, PromiseStates ePromiseState)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (ePromiseState < NO_PROMISE_STATE || ePromiseState >= NUM_PROMISE_STATES) return;

	PromiseStates eCurrentState = GetPlayerNoDiggingPromiseState(ePlayer);
	if (eCurrentState != ePromiseState)
	{
		m_aeNoDiggingPromiseState[(int)ePlayer] = ePromiseState;

		// Reset the ability to ask the promise again
		if (eCurrentState == PROMISE_STATE_MADE)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerAskedNotToDig(GetID(), false);
		}

		if (ePromiseState != NO_PROMISE_STATE)
		{
			SetPlayerNoDiggingPromiseTurn(ePlayer, GC.getGame().getGameTurn());

			// They ignored or broke a promise to stop digging up our artifacts! Cancel any commitment not to dig up theirs!
			if (ePromiseState != PROMISE_STATE_MADE && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoDiggingPromise(GetID()) && !GetPlayer()->isHuman())
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerNoDiggingPromiseState(GetID(), NO_PROMISE_STATE);
			}
		}
		else
		{
			SetPlayerNoDiggingPromiseTurn(ePlayer, -1);
		}
	}
}

/// On what turn did the state of ePlayer's no digging promise to us change?
int CvDiplomacyAI::GetPlayerNoDiggingPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiNoDiggingPromiseTurn[(int)ePlayer];
}

/// Sets on what turn the state of ePlayer's no digging promise to us changed
void CvDiplomacyAI::SetPlayerNoDiggingPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNoDiggingPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player promise to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerMadeNoDiggingPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetPlayerNoDiggingPromiseState(ePlayer) == PROMISE_STATE_MADE;
}

/// Did this player ignore our request to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerIgnoredNoDiggingPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetPlayerNoDiggingPromiseState(ePlayer) == PROMISE_STATE_IGNORED;
}

/// Did this player break a promise to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerBrokenNoDiggingPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetPlayerNoDiggingPromiseState(ePlayer) == PROMISE_STATE_BROKEN;
}

/// Has ePlayer asked us to stop digging up their artifacts?
bool CvDiplomacyAI::IsPlayerAskedNotToDig(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// Can't ask if we've already promised
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoDiggingPromise(GetID()))
		return true;

	// Can't ask if we're their teammate or vassal - promise is automatic
	if (IsTeammate(ePlayer) || IsVassal(ePlayer))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return m_abAskedNotToDig[(int)ePlayer];
}

/// Sets if ePlayer asked us to stop digging up their artifacts
void CvDiplomacyAI::SetPlayerAskedNotToDig(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abAskedNotToDig[(int)ePlayer] = bValue;
}

// ////////////////////////////////////
// Coop War Promise
// ////////////////////////////////////

/// Did this player break a coop war promise to us?
bool CvDiplomacyAI::IsPlayerBrokenCoopWarPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return GetPlayerBrokenCoopWarPromiseTurn(ePlayer) != -1;
}

/// Sets if this player broke a coop war promise to us
void CvDiplomacyAI::SetPlayerBrokenCoopWarPromise(PlayerTypes ePlayer, bool bValue)
{
	if (bValue)
	{
		SetPlayerBrokenCoopWarPromiseTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetPlayerBrokenCoopWarPromiseTurn(ePlayer, -1);
	}
}

/// On what turn did ePlayer break a coop war promise to us?
int CvDiplomacyAI::GetPlayerBrokenCoopWarPromiseTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiBrokenCoopWarPromiseTurn[(int)ePlayer];
}

/// Sets on what turn ePlayer broke a coop war promise with us
void CvDiplomacyAI::SetPlayerBrokenCoopWarPromiseTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiBrokenCoopWarPromiseTurn[(int)ePlayer] = max(iTurn, -1);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Event Flags
// ------------------------------------

/// Did this player return our capital to us?
bool CvDiplomacyAI::IsPlayerReturnedCapital(PlayerTypes ePlayer, bool bForPenaltyReduction) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	if (!bForPenaltyReduction)
	{
		if (IsCapitalCapturedBy(ePlayer, false, true, true))
		{
			return false;
		}
	}

	return m_abReturnedCapital[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerReturnedCapital(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abReturnedCapital[(int)ePlayer] = bValue;
}

/// Did this player return our Holy City to us?
bool CvDiplomacyAI::IsPlayerReturnedHolyCity(PlayerTypes ePlayer, bool bForPenaltyReduction) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	if (!bForPenaltyReduction)
	{
		if (IsCapitalCapturedBy(ePlayer, false, true, true))
		{
			return false;
		}

		if (IsHolyCityCapturedBy(ePlayer, false, true, true))
		{
			return false;
		}
	}

	return m_abReturnedHolyCity[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerReturnedHolyCity(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abReturnedHolyCity[(int)ePlayer] = bValue;
}

/// Returns if ePlayer liberated our capital
bool CvDiplomacyAI::IsPlayerLiberatedCapital(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	if (IsCapitalCapturedBy(ePlayer, false, true, true))
	{
		return false;
	}

	return m_abLiberatedCapital[(int)ePlayer];
}

/// Sets if ePlayer liberated our capital
void CvDiplomacyAI::SetPlayerLiberatedCapital(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abLiberatedCapital[(int)ePlayer] = bValue;
}

/// Returns if ePlayer liberated our Holy City
bool CvDiplomacyAI::IsPlayerLiberatedHolyCity(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	if (IsCapitalCapturedBy(ePlayer, false, true, true))
	{
		return false;
	}

	if (IsHolyCityCapturedBy(ePlayer, false, true, true))
	{
		return false;
	}

	return m_abLiberatedHolyCity[(int)ePlayer];
}

/// Sets if ePlayer liberated our Holy City
void CvDiplomacyAI::SetPlayerLiberatedHolyCity(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abLiberatedHolyCity[(int)ePlayer] = bValue;
}

/// Has ePlayer ever asked about working with us?
bool CvDiplomacyAI::IsDoFEverAsked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abDoFEverAsked[(int)ePlayer];
}

/// Sets if this player has ever asked to make a DoF with us
void CvDiplomacyAI::SetDoFEverAsked(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abDoFEverAsked[(int)ePlayer] = bValue;
}

/// Returns if ePlayer captured our capital
bool CvDiplomacyAI::IsPlayerCapturedCapital(PlayerTypes ePlayer, bool bEver) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// If they resurrected us or peacefully gave us our independence, we'll forgive the penalty if we have our capital back.
	if (!bEver)
	{
		if (!m_pPlayer->IsHasLostCapital())
		{
			if (WasResurrectedBy(ePlayer))
				return false;

			if (IsMasterLiberatedMeFromVassalage(ePlayer) || (GetVassalagePeacefullyRevokedTurn(ePlayer) > -1))
				return false;
		}
	}

	return m_abCapturedCapital[(int)ePlayer];
}

/// Sets if ePlayer captured our capital
void CvDiplomacyAI::SetPlayerCapturedCapital(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abCapturedCapital[(int)ePlayer] = bValue;
}

/// Returns if this player's original capital was captured by ePlayer
bool CvDiplomacyAI::IsCapitalCapturedBy(PlayerTypes ePlayer, bool bCurrently, bool bTeammates, bool bCheckEver) const
{
	if (!bCurrently && IsPlayerCapturedCapital(ePlayer, bCheckEver))
		return true;

	CvPlot *pOriginalCapitalPlot = GC.getMap().plot(m_pPlayer->GetOriginalCapitalX(), m_pPlayer->GetOriginalCapitalY());
	if (pOriginalCapitalPlot != NULL && pOriginalCapitalPlot->isCity())
	{
		if (bTeammates)
		{
			if (GET_PLAYER(pOriginalCapitalPlot->getOwner()).getTeam() == GET_PLAYER(ePlayer).getTeam())
				return true;
		}
		else
		{
			if (pOriginalCapitalPlot->getOwner() == ePlayer)
				return true;
		}
	}
	else if (bCurrently) // They deleted it somehow? Modmod?
	{
		return false;
	}

	if (bTeammates && !bCurrently)
	{
		vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
		for (size_t i=0; i<vTheirTeam.size(); i++)
		{
			if (IsPlayerCapturedCapital(vTheirTeam[i], bCheckEver))
				return true;
		}
	}

	return false;
}

/// Returns if ePlayer captured our Holy City
bool CvDiplomacyAI::IsPlayerCapturedHolyCity(PlayerTypes ePlayer, bool bEver) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// If they resurrected us or peacefully gave us our independence, we'll forgive the penalty if we have our Holy City back.
	if (!bEver)
	{
		if (!m_pPlayer->IsHasLostHolyCity())
		{
			if (WasResurrectedBy(ePlayer))
				return false;

			if (IsMasterLiberatedMeFromVassalage(ePlayer) || (GetVassalagePeacefullyRevokedTurn(ePlayer) > -1))
				return false;
		}
	}

	return m_abCapturedHolyCity[(int)ePlayer];
}

/// Sets if ePlayer captured our Holy City
void CvDiplomacyAI::SetPlayerCapturedHolyCity(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abCapturedHolyCity[(int)ePlayer] = bValue;
}

/// Returns if this player's Holy City was captured by ePlayer
bool CvDiplomacyAI::IsHolyCityCapturedBy(PlayerTypes ePlayer, bool bCurrently, bool bTeammates, bool bCheckEver) const
{
	if (!bCurrently && IsPlayerCapturedHolyCity(ePlayer, bCheckEver))
		return true;

	CvPlot *pHolyCityPlot = GC.getMap().plot(m_pPlayer->GetLostHolyCityX(), m_pPlayer->GetLostHolyCityY());
	if (pHolyCityPlot != NULL && pHolyCityPlot->isCity())
	{
		if (pHolyCityPlot->getPlotCity()->GetCityReligions()->IsHolyCityForReligion(GetPlayer()->GetReligions()->GetCurrentReligion(false)))
		{
			if (bCurrently) // Holy City status hasn't been removed yet...
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		if (bTeammates)
		{
			if (GET_PLAYER(pHolyCityPlot->getOwner()).getTeam() == GET_PLAYER(ePlayer).getTeam())
				return true;
		}
		else
		{
			if (pHolyCityPlot->getOwner() == ePlayer)
				return true;
		}
	}
	else if (bCurrently) // It's no longer a city? Must have been destroyed...
	{
		return false;
	}

	if (bTeammates && !bCurrently)
	{
		vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
		for (size_t i=0; i<vTheirTeam.size(); i++)
		{
			if (IsPlayerCapturedHolyCity(vTheirTeam[i], bCheckEver))
				return true;
		}
	}

	return false;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// # of times/points counters
// ------------------------------------

/// Returns the number of cities liberated by ePlayer
int CvDiplomacyAI::GetNumCitiesLiberatedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumCitiesLiberated[(int)ePlayer];
}

/// Sets the number of cities liberated by ePlayer
void CvDiplomacyAI::SetNumCitiesLiberatedBy(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumCitiesLiberated[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetLiberatedCitiesTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetLiberatedCitiesTurn(ePlayer, -1);
	}
}

/// Changes the number of cities liberated by ePlayer
void CvDiplomacyAI::ChangeNumCitiesLiberatedBy(PlayerTypes ePlayer, int iChange)
{
	SetNumCitiesLiberatedBy(ePlayer, GetNumCitiesLiberatedBy(ePlayer) + iChange);
}

/// How many civilians has this player returned to us?
int CvDiplomacyAI::GetNumCiviliansReturnedToMe(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumCiviliansReturnedToMe[(int)ePlayer];
}

/// Sets how many civilians this player has returned to us
void CvDiplomacyAI::SetNumCiviliansReturnedToMe(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumCiviliansReturnedToMe[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetCiviliansReturnedToMeTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetCiviliansReturnedToMeTurn(ePlayer, -1);
	}
}

/// Changes how many civilians this player has returned to us
void CvDiplomacyAI::ChangeNumCiviliansReturnedToMe(PlayerTypes ePlayer, int iChange)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	SetNumCiviliansReturnedToMe(ePlayer, GetNumCiviliansReturnedToMe(ePlayer) + iChange);

	if (iChange > 0)
	{
		if (!GC.getGame().IsComplimentMessagesDisabled() && !GC.getGame().IsAllDiploStatementsDisabled())
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
				// TODO: what about GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true)?
				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE, -1);
			}
			else
			{
				if (!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
				{
					if (GC.getGame().getActivePlayer() == ePlayer)
					{
						GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
						const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
						gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
					}
				}
			}
#else
			if (!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
			{
				if (GC.getGame().getActivePlayer() == ePlayer)
				{
					GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
					gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
#endif
		}
	}
}

/// How many times has this player shared intrigue with us?
int CvDiplomacyAI::GetNumTimesIntrigueSharedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesIntrigueSharedBy[(int)ePlayer];
}

/// Sets how many times this player shared intrigue with us
void CvDiplomacyAI::SetNumTimesIntrigueSharedBy(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesIntrigueSharedBy[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetIntrigueSharedTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetIntrigueSharedTurn(ePlayer, -1);
	}
}

/// Changes how many times this player shared intrigue with us
void CvDiplomacyAI::ChangeNumTimesIntrigueSharedBy(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesIntrigueSharedBy(ePlayer, GetNumTimesIntrigueSharedBy(ePlayer) + iChange);
}

/// How many landmarks has this player built in my territory?
int CvDiplomacyAI::GetNumLandmarksBuiltForMe(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumLandmarksBuiltForMe[(int)ePlayer];
}

/// Sets how many landmarks have been built by ePlayer in my territory
void CvDiplomacyAI::SetNumLandmarksBuiltForMe(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumLandmarksBuiltForMe[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetLandmarksBuiltForMeTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetLandmarksBuiltForMeTurn(ePlayer, -1);
	}
}

/// Changes how many landmarks have been built by ePlayer in my territory
void CvDiplomacyAI::ChangeNumLandmarksBuiltForMe(PlayerTypes ePlayer, int iChange)
{
	SetNumLandmarksBuiltForMe(ePlayer, GetNumLandmarksBuiltForMe(ePlayer) + iChange);
}

/// How many times has ePlayer been caught plotting against us?
int CvDiplomacyAI::GetNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiTheyPlottedAgainstUs[(int)ePlayer];
}

/// Sets how many times ePlayer was caught plotting against us
void CvDiplomacyAI::SetNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTheyPlottedAgainstUs[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetPlottedAgainstUsTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetPlottedAgainstUsTurn(ePlayer, -1);
	}
}

/// Changes how many times ePlayer was caught plotting against us
void CvDiplomacyAI::ChangeNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesTheyPlottedAgainstUs(ePlayer, GetNumTimesTheyPlottedAgainstUs(ePlayer) + iChange);
	
	if (iChange > 0 && GetRecentAssistValue(ePlayer) < 0)
	{
		SetRecentAssistValue(ePlayer, 0);
	}
}

/// How many times has this player razed one of our cities?
int CvDiplomacyAI::GetNumTimesRazed(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesRazed[(int)ePlayer];
}

/// Sets how many times this player has razed one of our cities
void CvDiplomacyAI::SetNumTimesRazed(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesRazed[(int)ePlayer] = range(iValue, 0, USHRT_MAX);
}

/// Changes how many times this player has razed one of our cities
void CvDiplomacyAI::ChangeNumTimesRazed(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesRazed(ePlayer, GetNumTimesRazed(ePlayer) + iChange);
}

/// How many times has this player plundered one of our Trade Routes?
int CvDiplomacyAI::GetNumTradeRoutesPlundered(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTradeRoutesPlundered[(int)ePlayer];
}

/// Sets how many times this player has plundered one of our Trade Routes
void CvDiplomacyAI::SetNumTradeRoutesPlundered(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTradeRoutesPlundered[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetPlunderedTradeRouteTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetPlunderedTradeRouteTurn(ePlayer, -1);
	}
}

/// Changes how many times this player has plundered one of our Trade Routes
void CvDiplomacyAI::ChangeNumTradeRoutesPlundered(PlayerTypes ePlayer, int iChange)
{
	SetNumTradeRoutesPlundered(ePlayer, GetNumTradeRoutesPlundered(ePlayer) + iChange);
}

/// How many World Wonders has ePlayer beaten us to?
int CvDiplomacyAI::GetNumWondersBeatenTo(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumWondersBeatenTo[(int)ePlayer];
}

/// Sets how many World Wonders ePlayer has beaten us to
void CvDiplomacyAI::SetNumWondersBeatenTo(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumWondersBeatenTo[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many World Wonders ePlayer has beaten us to
void CvDiplomacyAI::ChangeNumWondersBeatenTo(PlayerTypes ePlayer, int iChange)
{
	SetNumWondersBeatenTo(ePlayer, GetNumWondersBeatenTo(ePlayer) + iChange);
}

/// How many times has this player stolen our territory?
int CvDiplomacyAI::GetNumTimesCultureBombed(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesCultureBombed[(int)ePlayer];
}

/// Sets how many times this player has dug up our artifacts
void CvDiplomacyAI::SetNumTimesCultureBombed(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesCultureBombed[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many times this player has stolen our territory
void CvDiplomacyAI::ChangeNumTimesCultureBombed(PlayerTypes ePlayer, int iChange)
{
	// No diplomacy penalties for stealing territory while at war.
	if (IsAtWar(ePlayer) && !GetPlayer()->isHuman())
		return;

	SetNumTimesCultureBombed(ePlayer, GetNumTimesCultureBombed(ePlayer) + iChange);
}

/// How many times has ePlayer lowered our influence with a Minor Civ?
int CvDiplomacyAI::GetNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiTheyLoweredOurInfluence[(int)ePlayer];
}

/// Sets how many times ePlayer has lowered our influence with a Minor Civ
void CvDiplomacyAI::SetNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTheyLoweredOurInfluence[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many times ePlayer has lowered our influence with a Minor Civ
void CvDiplomacyAI::ChangeNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesTheyLoweredOurInfluence(ePlayer, GetNumTimesTheyLoweredOurInfluence(ePlayer) + iChange);
}

/// How many protected Minors have we seen this Player bully?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumProtectedMinorsBullied[(int)ePlayer];
}

/// Sets how many protected Minors we have seen this Player bully
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumProtectedMinorsBullied[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many protected Minors we have seen this Player bully
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsBullied(ePlayer, GetOtherPlayerNumProtectedMinorsBullied(ePlayer) + iChange);
}

/// How many protected Minors have we seen this player attack?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumProtectedMinorsAttacked[(int)ePlayer];
}

/// Sets how many protected Minors we have seen this player attack
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumProtectedMinorsAttacked[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many protected Minors we have seen this player attack
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsAttacked(ePlayer, GetOtherPlayerNumProtectedMinorsAttacked(ePlayer) + iChange);
}

/// How many protected Minors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumProtectedMinorsKilled[(int)ePlayer];
}

/// Sets how many protected Minors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumProtectedMinorsKilled[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many protected Minors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsKilled(ePlayer, GetOtherPlayerNumProtectedMinorsKilled(ePlayer) + iChange);
}

/// How many times has this player converted the religion of our cities? (if we care)
int CvDiplomacyAI::GetNegativeReligiousConversionPoints(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNegativeReligiousConversionPoints[(int)ePlayer];
}

/// Sets how many times this player has converted the religion of our cities (if we care)
void CvDiplomacyAI::SetNegativeReligiousConversionPoints(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNegativeReligiousConversionPoints[(int)ePlayer] = range(iValue, 0, USHRT_MAX);

	if (iValue > 0)
	{
		SetReligiousConversionTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetReligiousConversionTurn(ePlayer, -1);
	}
}

/// Changes how many times this player has converted the religion of our cities (if we care)
void CvDiplomacyAI::ChangeNegativeReligiousConversionPoints(PlayerTypes ePlayer, int iChange)
{
	SetNegativeReligiousConversionPoints(ePlayer, GetNegativeReligiousConversionPoints(ePlayer) + iChange);

	if (iChange > 0)
	{
		SetEverConvertedCity(ePlayer, true);

		// Reset the ability to ask for a promise
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerAskedNotToConvert(ePlayer, false);

		// You broke the promise you made!
		if (IsPlayerMadeNoConvertPromise(ePlayer))
		{
			SetPlayerNoConvertPromiseState(ePlayer, PROMISE_STATE_BROKEN);
		}
	}
}

/// How many times has this player robbed us?
int CvDiplomacyAI::GetNumTimesRobbedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesRobbedBy[(int)ePlayer];
}

/// Sets how many times this player has robbed us
void CvDiplomacyAI::SetNumTimesRobbedBy(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesRobbedBy[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetRobbedTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetRobbedTurn(ePlayer, -1);
	}
}

/// Changes how many times this player has robbed us
void CvDiplomacyAI::ChangeNumTimesRobbedBy(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesRobbedBy(ePlayer, GetNumTimesRobbedBy(ePlayer) + iChange);
}

/// How many times has ePlayer lowered our Minor Civ influence in a coup?
int CvDiplomacyAI::GetNumTimesPerformedCoupAgainstUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiPerformedCoupAgainstUs[(int)ePlayer];
}

/// Sets how many times ePlayer has lowered our Minor Civ influence in a coup
void CvDiplomacyAI::SetNumTimesPerformedCoupAgainstUs(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPerformedCoupAgainstUs[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue > 0)
	{
		SetPerformedCoupTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetPerformedCoupTurn(ePlayer, -1);
	}
}

/// Changes how many times ePlayer has lowered our Minor Civ influence in a coup
void CvDiplomacyAI::ChangeNumTimesPerformedCoupAgainstUs(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesPerformedCoupAgainstUs(ePlayer, GetNumTimesPerformedCoupAgainstUs(ePlayer) + iChange);
}

/// How much support or opposition did we have for their most recent World Congress proposal?
int CvDiplomacyAI::GetLikedTheirProposalValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiLikedTheirProposalValue[(int)ePlayer];
}

void CvDiplomacyAI::SetLikedTheirProposalValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiLikedTheirProposalValue[(int)ePlayer] = range(iValue, CHAR_MIN, UCHAR_MAX);
}

/// How much support or opposition did they give to our most recent World Congress proposal?
int CvDiplomacyAI::GetSupportedOurProposalValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiSupportedOurProposalValue[(int)ePlayer];
}

void CvDiplomacyAI::SetSupportedOurProposalValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	int iSetValue = range(iValue, -100, 100);
	int iCurrentValue = GetSupportedOurProposalValue(ePlayer);

	// The easy cases
	if (iCurrentValue == 0 || IsTeammate(ePlayer))
	{
		m_aiSupportedOurProposalValue[(int)ePlayer] = iSetValue;
	}
	// Remember previous support or opposition! This will get a little complicated, but it makes the AI smarter.
	else if (iSetValue != 0)
	{
		int iTurn;
		int iDuration;

		// Previously opposed us
		if (iCurrentValue > 0)
		{
			iDuration = AdjustModifierDuration(false, /*30*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			iTurn = IsFoiledOurProposalAndThenSupportedUs(ePlayer) ? GetTheySupportedOurProposalTurn(ePlayer) : GetTheyFoiledOurProposalTurn(ePlayer);
			if (iTurn < 0)
				return;
		}
		// Previously supported us
		else
		{
			iDuration = AdjustModifierDuration(true, /*30*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			iTurn = IsSupportedOurProposalAndThenFoiledUs(ePlayer) ? GetTheyFoiledOurProposalTurn(ePlayer) : GetTheySupportedOurProposalTurn(ePlayer);
			if (iTurn < 0)
				return;
		}

		// Reduction to duration? Do not apply the forgiveness mod if the new value is positive!
		if (iCurrentValue > 0 && IsFoiledOurProposalAndThenSupportedUs(ePlayer) && iSetValue < 0)
		{
			int iDurationMod = (GetForgiveness() - 5) * 2;
			iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
			iDurationMod /= 100;
			if (iDurationMod > 0)
			{
				iDuration -= iDurationMod;
			}
		}
		// Likewise, do not apply the boldness mod if the new value is negative!
		else if (iCurrentValue < 0 && IsSupportedOurProposalAndThenFoiledUs(ePlayer) && iSetValue > 0)
		{
			int iDurationMod = (GetBoldness() - 5) * 2;
			iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
			iDurationMod /= 100;
			if (iDurationMod > 0)
			{
				iDuration -= iDurationMod;
			}
		}

		int iTurnsPassed = (GC.getGame().getGameTurn()+1) - iTurn;
		int iDurationPercent = (iTurnsPassed * 100) / max(iDuration,1);
		int iPercentageLeft = 100 - iDurationPercent;

		// Calculate the opinion modifier!
		int iMinOpinionWeight = iCurrentValue > 0 ? max(0, /*10*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL()) : min(0, /*-10*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL());
		int iMaxOpinionWeight = iCurrentValue > 0 ? max(0, /*60*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_MAX()) : min(0, /*-60*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_MAX());
		int iDifference = iMaxOpinionWeight - iMinOpinionWeight;
		int iAwardPercentage = iCurrentValue > 0 ? min(100, (iCurrentValue * max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT()))) : min(100, (-iCurrentValue * max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT())));

		int iOpinionWeight = iMinOpinionWeight;
		iOpinionWeight += (iDifference * iAwardPercentage) / 100;

		// Now we scale the value by how much of the modifier timer has passed
		iOpinionWeight *= iPercentageLeft;
		iOpinionWeight /= 100;

		// Now reverse the calculation to find the corresponding current value %
		int iNewCurrentValue;
		iOpinionWeight -= iMinOpinionWeight;

		// Did this bring us down to zero?
		if (iOpinionWeight <= 0 && iCurrentValue > 0)
		{
			iNewCurrentValue = 0;
		}
		else if (iOpinionWeight >= 0 && iCurrentValue < 0)
		{
			iNewCurrentValue = 0;
		}
		else
		{
			int iNewAwardPercentage = (iOpinionWeight * 100) / max(1, iDifference);
			iNewCurrentValue = iNewAwardPercentage / max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT());
		}

		// Then add the scaled current value to the new value to get the sum
		iSetValue += iNewCurrentValue;
		m_aiSupportedOurProposalValue[(int)ePlayer] = range(iSetValue, -100, 100);
	}
}

/// Helper functions so the AI can remember recent World Congress diplomacy
bool CvDiplomacyAI::IsSupportedOurProposalAndThenFoiledUs(PlayerTypes ePlayer) const
{
	if (GetTheyFoiledOurProposalTurn(ePlayer) > -1 && GetSupportedOurProposalValue(ePlayer) < 0)
		return true;

	return false;
}

bool CvDiplomacyAI::IsFoiledOurProposalAndThenSupportedUs(PlayerTypes ePlayer) const
{
	if (GetTheySupportedOurProposalTurn(ePlayer) > -1 && GetSupportedOurProposalValue(ePlayer) > 0)
		return true;

	return false;
}

/// How much support did they give to us when we succeeded in becoming World Congress host?
int CvDiplomacyAI::GetSupportedOurHostingValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiSupportedOurHostingValue[(int)ePlayer];
}

void CvDiplomacyAI::SetSupportedOurHostingValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiSupportedOurHostingValue[(int)ePlayer] = range(iValue, 0, 100);
}

/// How many negative points does this player have for digging up our artifacts?
int CvDiplomacyAI::GetNegativeArchaeologyPoints(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNegativeArchaeologyPoints[(int)ePlayer];
}

/// Sets how many negative points this player has for digging up our artifacts
void CvDiplomacyAI::SetNegativeArchaeologyPoints(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNegativeArchaeologyPoints[(int)ePlayer] = range(iValue, 0, USHRT_MAX);
}

/// Changes how many negative points this player has for digging up our artifacts
void CvDiplomacyAI::ChangeNegativeArchaeologyPoints(PlayerTypes ePlayer, int iChange)
{
	SetNegativeArchaeologyPoints(ePlayer, GetNegativeArchaeologyPoints(ePlayer) + iChange);

	if (iChange > 0)
	{
		ChangeNumArtifactsEverDugUp(ePlayer, 1);
	}
}

/// How many times has this player dug up our artifacts?
int CvDiplomacyAI::GetNumArtifactsEverDugUp(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiArtifactsEverDugUp[(int)ePlayer];
}

/// Sets how many times this player has dug up our artifacts
void CvDiplomacyAI::SetNumArtifactsEverDugUp(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiArtifactsEverDugUp[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

#if !defined(NO_ACHIEVEMENTS)
	if (!GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman() && ePlayer == GC.getGame().getActivePlayer())
	{
		if (iValue >= 5)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_XP2_34);
		}
	}
#endif
}

/// Changes how many times this player has dug up our artifacts
void CvDiplomacyAI::ChangeNumArtifactsEverDugUp(PlayerTypes ePlayer, int iChange)
{
	SetNumArtifactsEverDugUp(ePlayer, GetNumArtifactsEverDugUp(ePlayer) + iChange);

	if (iChange > 0)
	{
		// Reset the ability to ask for a promise
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerAskedNotToDig(GetID(), false);

		// You broke the promise you made!
		if (IsPlayerMadeNoDiggingPromise(ePlayer))
		{
			SetPlayerNoDiggingPromiseState(ePlayer, PROMISE_STATE_BROKEN);
		}
	}
}

/// How many times has this player nuked us?
int CvDiplomacyAI::GetNumTimesNuked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesNuked[(int)ePlayer];
}

/// Sets how many times this player has nuked us
void CvDiplomacyAI::SetNumTimesNuked(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesNuked[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);
}

/// Changes how many times this player has nuked us
void CvDiplomacyAI::ChangeNumTimesNuked(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesNuked(ePlayer, GetNumTimesNuked(ePlayer) + iChange);

	// and do diplo...
	if (iChange > 0)
	{
		SetBackstabbedBy(ePlayer, true);

		int iWarmongerValue = CvDiplomacyAIHelpers::GetWarmongerOffset(NULL, ePlayer, GetID(), WARMONGER_NUKED_PLAYER);
		ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarmongerValue * 100);

		DoUpdateWarmongerThreats(true);

		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (eLoopPlayer == GetID() || GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
				continue;

			if (!IsHasMet(eLoopPlayer) || !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasMet(eLoopPlayer))
				continue;

			int iWarmongerValue = CvDiplomacyAIHelpers::GetWarmongerOffset(NULL, ePlayer, eLoopPlayer, WARMONGER_NUKED_PLAYER);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarmongerValue * 100);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoUpdateWarmongerThreats(true);
		}
	}
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Turn Counters
// ------------------------------------

/// Did ePlayer bring us back to life?
bool CvDiplomacyAI::WasResurrectedBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_aiResurrectedOnTurn[(int)ePlayer] != -1;
}

/// Did ePlayer bring us back to life on this turn?
bool CvDiplomacyAI::WasResurrectedThisTurnBy(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_aiResurrectedOnTurn[(int)ePlayer] == GC.getGame().getGameTurn();
}

/// Sets if this player brought us back to life
void CvDiplomacyAI::SetResurrectedBy(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue)
	{
		m_aiResurrectedOnTurn[(int)ePlayer] = GC.getGame().getGameTurn();
	}
	else
	{
		m_aiResurrectedOnTurn[(int)ePlayer] = -1;
	}
}

/// Were we ever resurrected by anyone?
bool CvDiplomacyAI::WasResurrectedByAnyone() const
{
	return (GET_TEAM(GetTeam()).GetLiberatedByTeam() != NO_TEAM);
}

/// On what turn did this player most recently liberate one of our cities?
int CvDiplomacyAI::GetLiberatedCitiesTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiLiberatedCitiesTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently liberated one of our cities
void CvDiplomacyAI::SetLiberatedCitiesTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiLiberatedCitiesTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player recently liberate one of our cities?
bool CvDiplomacyAI::IsCityRecentlyLiberatedBy(PlayerTypes ePlayer) const
{
	int iTurn = GetLiberatedCitiesTurn(ePlayer);

	if (iTurn <= -1)
		return false;

	// Anti-exploit - no bonuses under these conditions!
	if (IsUntrustworthy(ePlayer))
		return false;

	if (IsCapitalCapturedBy(ePlayer))
		return false;

	if (IsHolyCityCapturedBy(ePlayer))
		return false;

	if (GetNumCitiesCapturedBy(ePlayer) >= GetNumCitiesLiberatedBy(ePlayer))
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iTurn;
	if (iTurnDifference < 20)
		return true;

	return false;
}

/// On what turn did this player most recently return a civilian to us?
int CvDiplomacyAI::GetCiviliansReturnedToMeTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiCiviliansReturnedToMeTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently returned a civilian to us
void CvDiplomacyAI::SetCiviliansReturnedToMeTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiCiviliansReturnedToMeTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did this player most recently share intrigue with us?
int CvDiplomacyAI::GetIntrigueSharedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiIntrigueSharedTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently shared intrigue with us
void CvDiplomacyAI::SetIntrigueSharedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiIntrigueSharedTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Did this player forgive us for spying on them?
bool CvDiplomacyAI::IsPlayerForgaveForSpying(PlayerTypes ePlayer) const
{
	return GetForgaveForSpyingTurn(ePlayer) != -1;
}

/// Sets if this player forgave us for spying on them
void CvDiplomacyAI::SetPlayerForgaveForSpying(PlayerTypes ePlayer, bool bValue)
{
	if (bValue)
	{
		SetForgaveForSpyingTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetForgaveForSpyingTurn(ePlayer, -1);
	}
}

/// On what turn did this player most recently forgive us for spying?
int CvDiplomacyAI::GetForgaveForSpyingTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPlayerForgaveForSpyingTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently forgave us for spying
void CvDiplomacyAI::SetForgaveForSpyingTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPlayerForgaveForSpyingTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did this player most recently build a landmark for me? 
int CvDiplomacyAI::GetLandmarksBuiltForMeTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiLandmarksBuiltForMeTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently built a landmark for me
void CvDiplomacyAI::SetLandmarksBuiltForMeTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiLandmarksBuiltForMeTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did we most recently catch this player plotting against us?
int CvDiplomacyAI::GetPlottedAgainstUsTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPlottedAgainstUsTurn[(int)ePlayer];
}

/// Sets on what turn we most recently caught this player plotting against us
void CvDiplomacyAI::SetPlottedAgainstUsTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPlottedAgainstUsTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did this player most recently plunder one of our trade routes?
int CvDiplomacyAI::GetPlunderedTradeRouteTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPlunderedTradeRouteTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently plundered one of our trade routes
void CvDiplomacyAI::SetPlunderedTradeRouteTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPlunderedTradeRouteTurn[(int)ePlayer] = max(iTurn, -1);
}

int CvDiplomacyAI::GetOtherPlayerSidedWithProtectedMinorTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiSidedWithProtectedMinorTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetOtherPlayerSidedWithProtectedMinorTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiSidedWithProtectedMinorTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Are we angry about ePlayer choosing to side with one of their protected minors that we attacked/bullied?
bool CvDiplomacyAI::IsAngryAboutSidedWithProtectedMinor(PlayerTypes ePlayer) const
{
	return GetOtherPlayerSidedWithProtectedMinorTurn(ePlayer) != -1;
}

int CvDiplomacyAI::GetOtherPlayerBulliedProtectedMinorTurn(PlayerTypes ePlayer) const
{
	if (GetOtherPlayerProtectedMinorBullied(ePlayer) == NO_PLAYER)
		return -1;

	return m_aiBulliedProtectedMinorTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetOtherPlayerBulliedProtectedMinorTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiBulliedProtectedMinorTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Are we angry about ePlayer bullying one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorBullied(PlayerTypes ePlayer) const
{
	// Anger over attacked/killed city-states trumps this, don't stack
	if (IsAngryAboutProtectedMinorKilled(ePlayer) || IsAngryAboutProtectedMinorAttacked(ePlayer))
		return false;

	int iMostRecentBullyTurn = GetOtherPlayerBulliedProtectedMinorTurn(ePlayer);
	if (iMostRecentBullyTurn == -1)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iMostRecentBullyTurn;
	if (iTurnDifference < /*30*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN())
	{
		return true;
	}

	return false;
}

int CvDiplomacyAI::GetOtherPlayerAttackedProtectedMinorTurn(PlayerTypes ePlayer) const
{
	if (GetOtherPlayerProtectedMinorAttacked(ePlayer) == NO_PLAYER)
		return -1;

	return m_aiAttackedProtectedMinorTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetOtherPlayerAttackedProtectedMinorTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiAttackedProtectedMinorTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Are we angry about ePlayer attacking one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorAttacked(PlayerTypes ePlayer) const
{
	// Anger over killed city-states trumps this, don't stack
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
		return false;

	return GetOtherPlayerAttackedProtectedMinorTurn(ePlayer) != -1;
}

int CvDiplomacyAI::GetOtherPlayerKilledProtectedMinorTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	if (GetOtherPlayerProtectedMinorKilled(ePlayer) == NO_PLAYER)
		return -1;

	return m_aiKilledProtectedMinorTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetOtherPlayerKilledProtectedMinorTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiKilledProtectedMinorTurn[(int)ePlayer] = max(iTurn, -1);
}

/// Are we angry about ePlayer killing one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorKilled(PlayerTypes ePlayer) const
{
	int iTurn = GetOtherPlayerKilledProtectedMinorTurn(ePlayer);
	if (iTurn <= -1)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iTurn;

	if (iTurnDifference < /*50*/ GC.getOPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN())
		return true;

	return false;
}

/// On what turn did this player most recently convert one of our cities?
int CvDiplomacyAI::GetReligiousConversionTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiReligiousConversionTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently converted one of our cities
void CvDiplomacyAI::SetReligiousConversionTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiReligiousConversionTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did this player most recently steal from us?
int CvDiplomacyAI::GetRobbedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiTimesRobbedTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently stole from us
void CvDiplomacyAI::SetRobbedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTimesRobbedTurn[(int)ePlayer] = max(iTurn, -1);
}

/// On what turn did this player most recently lower our Minor Civ influence in a coup?
int CvDiplomacyAI::GetPerformedCoupTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPerformedCoupTurn[(int)ePlayer];
}

/// Sets on what turn this player most recently lowered our Minor Civ influence in a coup
void CvDiplomacyAI::SetPerformedCoupTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPerformedCoupTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since we really liked this player's proposal to the World Congress?
int CvDiplomacyAI::GetWeLikedTheirProposalTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiWeLikedTheirProposalTurn[(int)ePlayer];
}

/// Sets how many turns it has been since we really liked this player's proposal to the World Congress
void CvDiplomacyAI::SetWeLikedTheirProposalTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiWeLikedTheirProposalTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since we really disliked this player's proposal to the World Congress?
int CvDiplomacyAI::GetWeDislikedTheirProposalTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiWeDislikedTheirProposalTurn[(int)ePlayer];
}

/// Sets how many turns it has been since we really disliked this player's proposal to the World Congress
void CvDiplomacyAI::SetWeDislikedTheirProposalTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiWeDislikedTheirProposalTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since they supported our proposal to the World Congress?
int CvDiplomacyAI::GetTheySupportedOurProposalTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiTheySupportedOurProposalTurn[(int)ePlayer];
}

/// Sets how many turns it has been since they supported our proposal to the World Congress
void CvDiplomacyAI::SetTheySupportedOurProposalTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTheySupportedOurProposalTurn[(int)ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since they foiled our proposal to the World Congress?
int CvDiplomacyAI::GetTheyFoiledOurProposalTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiTheyFoiledOurProposalTurn[(int)ePlayer];
}

/// Sets how many turns it has been since they foiled our proposal to the World Congress
void CvDiplomacyAI::SetTheyFoiledOurProposalTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTheyFoiledOurProposalTurn[ePlayer] = max(iTurn, -1);
}

/// How many turns has it been since they supported relocating the World Congress to our lands?
int CvDiplomacyAI::GetTheySupportedOurHostingTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiTheySupportedOurHostingTurn[(int)ePlayer];
}

/// Sets how many turns it has been since they supported relocating the World Congress to our lands
void CvDiplomacyAI::SetTheySupportedOurHostingTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiTheySupportedOurHostingTurn[(int)ePlayer] = max(iTurn, -1);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Player-Specific Memory Values
// ------------------------------------

/// Who was the last Minor ePlayer bullied that we were protecting?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorBullied(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PLAYER;
	return (PlayerTypes) m_aeProtectedMinorBullied[(int)ePlayer];
}

/// Sets who the last Minor that ePlayer bullied that we were protecting is
void CvDiplomacyAI::SetOtherPlayerProtectedMinorBullied(PlayerTypes ePlayer, PlayerTypes eBulliedPlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if ((eBulliedPlayer != NO_PLAYER && eBulliedPlayer < MAX_MAJOR_CIVS) || eBulliedPlayer >= MAX_CIV_PLAYERS) return;
	m_aeProtectedMinorBullied[(int)ePlayer] = eBulliedPlayer;
}

/// Who was the last Minor ePlayer attacked that we were protecting?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorAttacked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PLAYER;
	return (PlayerTypes) m_aeProtectedMinorAttacked[(int)ePlayer];
}

/// Sets who the last Minor that ePlayer attacked that we were protecting is
void CvDiplomacyAI::SetOtherPlayerProtectedMinorAttacked(PlayerTypes ePlayer, PlayerTypes eAttackedPlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if ((eAttackedPlayer != NO_PLAYER && eAttackedPlayer < MAX_MAJOR_CIVS) || eAttackedPlayer >= MAX_CIV_PLAYERS) return;
	m_aeProtectedMinorAttacked[(int)ePlayer] = eAttackedPlayer;
}

/// Who was the last Minor ePlayer killed that we were protecting?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorKilled(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_PLAYER;
	return (PlayerTypes) m_aeProtectedMinorKilled[(int)ePlayer];
}

/// Sets who the last Minor that ePlayer killed that we were protecting is
void CvDiplomacyAI::SetOtherPlayerProtectedMinorKilled(PlayerTypes ePlayer, PlayerTypes eKilledPlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if ((eKilledPlayer != NO_PLAYER && eKilledPlayer < MAX_MAJOR_CIVS) || eKilledPlayer >= MAX_CIV_PLAYERS) return;
	m_aeProtectedMinorKilled[(int)ePlayer] = eKilledPlayer;
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// Guesses
// ------------------------------------

// ////////////////////////////////////
// Guesses about other players' feelings towards us
// ////////////////////////////////////

/// Returns our guess as to another player's Diplomatic Opinion towards us
MajorCivOpinionTypes CvDiplomacyAI::GetOpinionTowardsUsGuess(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_OPINION;
	return (MajorCivOpinionTypes) m_aeOpinionTowardsUsGuess[(int)ePlayer];
}

/// Sets our guess as to another player's Diplomatic Opinion towards us
void CvDiplomacyAI::SetOpinionTowardsUsGuess(PlayerTypes ePlayer, MajorCivOpinionTypes eOpinion)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eOpinion < 0 || eOpinion >= NUM_MAJOR_CIV_OPINIONS) return;
	m_aeOpinionTowardsUsGuess[(int)ePlayer] = eOpinion;
}

/// Returns our guess as to another player's true Diplomatic Approach towards us
MajorCivApproachTypes CvDiplomacyAI::GetApproachTowardsUsGuess(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return NO_MAJOR_CIV_APPROACH;
	return (MajorCivApproachTypes) m_aeApproachTowardsUsGuess[(int)ePlayer];
}

/// Sets our guess as to another player's true Diplomatic Approach towards us
void CvDiplomacyAI::SetApproachTowardsUsGuess(PlayerTypes ePlayer, MajorCivApproachTypes eApproach)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return;
	m_aeApproachTowardsUsGuess[(int)ePlayer] = eApproach;
}

/// Returns how long we've thought ePlayer has had his true Diplomatic Approach towards us
int CvDiplomacyAI::GetApproachTowardsUsGuessCounter(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aeApproachTowardsUsGuessCounter[(int)ePlayer];
}

/// Sets how long we've thought ePlayer has had his true Diplomatic Approach towards us
void CvDiplomacyAI::SetApproachTowardsUsGuessCounter(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aeApproachTowardsUsGuessCounter[(int)ePlayer] = range(iValue, 0, CHAR_MAX);
}

/// Changes how long we've thought ePlayer has had his true Diplomatic Approach towards us
void CvDiplomacyAI::ChangeApproachTowardsUsGuessCounter(PlayerTypes ePlayer, int iChange)
{
	SetApproachTowardsUsGuessCounter(ePlayer, GetApproachTowardsUsGuessCounter(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------

// ------------------------------------
// C4DF Values
// ------------------------------------

bool CvDiplomacyAI::IsShareOpinionAccepted(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abShareOpinionAccepted[(int)ePlayer];
}

void CvDiplomacyAI::SetShareOpinionAccepted(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abShareOpinionAccepted[(int)ePlayer] = bValue;
}

bool CvDiplomacyAI::IsShareOpinionEverAsked(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abShareOpinionEverAsked[(int)ePlayer];
}

void CvDiplomacyAI::SetShareOpinionEverAsked(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abShareOpinionEverAsked[(int)ePlayer] = bValue;
}

bool CvDiplomacyAI::IsPlayerMoveTroopsRequestAccepted(PlayerTypes ePlayer) const
{
	return GetPlayerMoveTroopsRequestAcceptedTurn(ePlayer) != -1;
}

void CvDiplomacyAI::SetPlayerMoveTroopsRequestAccepted(PlayerTypes ePlayer, bool bValue)
{
	if (bValue)
	{
		SetPlayerMoveTroopsRequestAcceptedTurn(ePlayer, GC.getGame().getGameTurn());
	}
	else
	{
		SetPlayerMoveTroopsRequestAcceptedTurn(ePlayer, -1);
	}
}

int CvDiplomacyAI::GetPlayerMoveTroopsRequestAcceptedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiMoveTroopsRequestAcceptedTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerMoveTroopsRequestAcceptedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiMoveTroopsRequestAcceptedTurn[(int)ePlayer] = max(iTurn, -1);
}

bool CvDiplomacyAI::IsTooSoonForMoveTroopsRequest(PlayerTypes ePlayer) const
{
	if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetID()))
		return true;

	// Observer can't ask this
	if (!GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).isObserver())
		return true;

	// Can't ask this while at war
	if (IsAtWar(ePlayer))
		return true;

	return false;
}

/// Is this AI offering a gift to ePlayer?
bool CvDiplomacyAI::IsOfferingGift(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abOfferingGift[(int)ePlayer];
}

/// Sets if this AI is offering a gift to ePlayer
void CvDiplomacyAI::SetOfferingGift(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abOfferingGift[(int)ePlayer] = bValue;
}

/// Did this AI offer a gift to ePlayer?
bool CvDiplomacyAI::IsOfferedGift(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abOfferedGift[(int)ePlayer];
}

/// Sets if this AI offered a gift to ePlayer
void CvDiplomacyAI::SetOfferedGift(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abOfferedGift[(int)ePlayer] = bValue;
}

int CvDiplomacyAI::GetHelpRequestAcceptedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiHelpRequestAcceptedTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetHelpRequestAcceptedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiHelpRequestAcceptedTurn[(int)ePlayer] = max(iTurn, -1);
}

int CvDiplomacyAI::GetHelpRequestTooSoonNumTurns(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiHelpRequestTooSoonNumTurns[(int)ePlayer];
}

void CvDiplomacyAI::SetHelpRequestTooSoonNumTurns(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiHelpRequestTooSoonNumTurns[(int)ePlayer] = range(iValue, -1, CHAR_MAX);
}

bool CvDiplomacyAI::IsHelpRequestTooSoon(PlayerTypes ePlayer) const
{
	int iHelpRequestAcceptedTurn = GetHelpRequestAcceptedTurn(ePlayer);
	int iHelpRequestTooSoonNumTurns = GetHelpRequestTooSoonNumTurns(ePlayer);

	// Haven't gotten a help request before
	if (iHelpRequestAcceptedTurn == -1 || iHelpRequestTooSoonNumTurns == -1)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iHelpRequestAcceptedTurn;

	if (iTurnDifference < iHelpRequestTooSoonNumTurns)
		return true;

	return false;
}

/// Are we targeting this player's vassal for war?
bool CvDiplomacyAI::IsTargetingVassal(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abTargetingVassal[(int)ePlayer];
}

void CvDiplomacyAI::SetTargetingVassal(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abTargetingVassal[(int)ePlayer] = bValue;
}

/// Returns if we accepted a demand from ePlayer while we were his vassal
bool CvDiplomacyAI::IsHasPaidTributeTo(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	if (IsVassal(ePlayer))
	{
		return m_abHasPaidTributeTo[(int)ePlayer];
	}

	return false;
}

/// Sets if we accepted a demand from ePlayer while we were his vassal
void CvDiplomacyAI::SetHasPaidTributeTo(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abHasPaidTributeTo[(int)ePlayer] = bValue;
}

/// How many times did ePlayer demand from us while we were his vassal?
int CvDiplomacyAI::GetNumTimesDemandedWhileVassal(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiNumTimesDemandedWhenVassal[(int)ePlayer];
}

/// Sets how many times ePlayer demanded from us while we were his vassal
void CvDiplomacyAI::SetNumTimesDemandedWhileVassal(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiNumTimesDemandedWhenVassal[(int)ePlayer] = range(iValue, 0, UCHAR_MAX);

	if (iValue <= 0)
	{
		SetHasPaidTributeTo(ePlayer, false);
	}
}

/// Changes how many times ePlayer demanded from us while we were his vassal
void CvDiplomacyAI::ChangeNumTimesDemandedWhileVassal(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesDemandedWhileVassal(ePlayer, GetNumTimesDemandedWhileVassal(ePlayer) + iChange);
}

/// Returns value of vassal protection given
int CvDiplomacyAI::GetVassalProtectValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiPlayerVassalageProtectValue[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalProtectValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iMaxOpinionValue = min(SHRT_MAX, (GC.getVASSALAGE_PROTECT_VALUE_PER_OPINION_WEIGHT() * -GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX()));
	m_aiPlayerVassalageProtectValue[(int)ePlayer] = range(iValue, 0, iMaxOpinionValue);
}

void CvDiplomacyAI::ChangeVassalProtectValue(PlayerTypes ePlayer, int iChange)
{
	SetVassalProtectValue(ePlayer, GetVassalProtectValue(ePlayer) + iChange);
}

/// Returns value of failed vassal protection
int CvDiplomacyAI::GetVassalFailedProtectValue(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiPlayerVassalageFailedProtectValue[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalFailedProtectValue(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	int iMaxOpinionValue = min(SHRT_MAX, (GC.getVASSALAGE_FAILED_PROTECT_VALUE_PER_OPINION_WEIGHT() * GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX()));
	m_aiPlayerVassalageFailedProtectValue[(int)ePlayer] = range(iValue, 0, iMaxOpinionValue);
}

void CvDiplomacyAI::ChangeVassalFailedProtectValue(PlayerTypes ePlayer, int iChange)
{
	SetVassalFailedProtectValue(ePlayer, GetVassalFailedProtectValue(ePlayer) + iChange);
}

bool CvDiplomacyAI::IsMasterLiberatedMeFromVassalage(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abMasterLiberatedMeFromVassalage[(int)ePlayer];
}

void CvDiplomacyAI::SetMasterLiberatedMeFromVassalage(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abMasterLiberatedMeFromVassalage[(int)ePlayer] = bValue;
}

int CvDiplomacyAI::GetVassalagePeacefullyRevokedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPlayerVassalagePeacefullyRevokedTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalagePeacefullyRevokedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPlayerVassalagePeacefullyRevokedTurn[(int)ePlayer] = max(iTurn, -1);
}

int CvDiplomacyAI::GetVassalageForcefullyRevokedTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiPlayerVassalageForcefullyRevokedTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalageForcefullyRevokedTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiPlayerVassalageForcefullyRevokedTurn[(int)ePlayer] = max(iTurn, -1);
}

bool CvDiplomacyAI::IsPlayerBrokenVassalAgreement(PlayerTypes ePlayer) const
{
	return GetPlayerBrokenVassalAgreementTurn(ePlayer) != -1;
}

void CvDiplomacyAI::SetPlayerBrokenVassalAgreement(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	if (bValue)
	{
		if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
			return;

		SetPlayerBrokenVassalAgreementTurn(ePlayer, GC.getGame().getGameTurn());
		SetBackstabbedBy(ePlayer, true);
	}
	else
	{
		SetPlayerBrokenVassalAgreementTurn(ePlayer, -1);
	}
}

int CvDiplomacyAI::GetPlayerBrokenVassalAgreementTurn(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
	return m_aiBrokenVassalAgreementTurn[(int)ePlayer];
}

void CvDiplomacyAI::SetPlayerBrokenVassalAgreementTurn(PlayerTypes ePlayer, int iTurn)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiBrokenVassalAgreementTurn[(int)ePlayer] = max(iTurn, -1);
}

bool CvDiplomacyAI::IsVassalTaxRaised(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abVassalTaxRaised[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalTaxRaised(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abVassalTaxRaised[(int)ePlayer] = bValue;
}

bool CvDiplomacyAI::IsVassalTaxLowered(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	return m_abVassalTaxLowered[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalTaxLowered(PlayerTypes ePlayer, bool bValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_abVassalTaxLowered[(int)ePlayer] = bValue;
}

int CvDiplomacyAI::GetVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiVassalGoldPerTurnCollectedSinceVassalStarted[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiVassalGoldPerTurnCollectedSinceVassalStarted[(int)ePlayer] = max(iValue, 0);
}

void CvDiplomacyAI::ChangeVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer, int iChange)
{
	SetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer, GetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer) + iChange);
}

int CvDiplomacyAI::GetVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	return m_aiVassalGoldPerTurnTaxedSinceVassalStarted[(int)ePlayer];
}

void CvDiplomacyAI::SetVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	m_aiVassalGoldPerTurnTaxedSinceVassalStarted[(int)ePlayer] = max(iValue, 0);
}

void CvDiplomacyAI::ChangeVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer, int iChange)
{
	SetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer, GetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer) + iChange);
}

//	-----------------------------------------------------------------------------------------------


// ************************************
// Turn Stuff
// ************************************


/// Runs every turn! The order matters for a lot of this stuff, so be VERY careful about moving anything around (!)
void CvDiplomacyAI::DoTurn(DiplomacyMode eDiploMode, PlayerTypes ePlayer)
{
	//set this for one iteration, reset below
	m_eDiploMode = eDiploMode;
	m_eTargetPlayer = ePlayer;

	SetEndedFriendshipThisTurn(false);

	// War Damage
	DoWarValueLostDecay();
	DoUpdateWarDamage();
	DoUpdateConquestStats();

	// Coop Wars
	DoUpdateCoopWarStates();

	// Victory Competition
	DoUpdateCompetingForVictory();
	DoUpdateVictoryFocus();
	DoUpdateRecklessExpanders();
	DoUpdateWonderSpammers();
	DoUpdateTechBlockLevels();
	DoUpdatePolicyBlockLevels();
	DoUpdateVictoryDisputeLevels();
	DoUpdateVictoryBlockLevels();

	// Military Stuff
	DoUpdateWarStates();
	DoUpdatePlayerMilitaryStrengths();
	DoUpdatePlayerEconomicStrengths();
	DoUpdateMilitaryThreats();
	DoUpdateWarmongerThreats();
	DoUpdatePlayerTargetValues();
	DoUpdateWarProjections();
	GetPlayer()->cacheGoldRate();
	GetPlayer()->DoTestEmpireInBadShapeForWar();
	DoUpdateEasyTargets();
	DoUpdateWarGoals();
	DoUpdatePeaceTreatyWillingness();

	// Aggressive Postures
	DoUpdateMilitaryAggressivePostures();
	DoUpdateExpansionAggressivePostures();
	DoUpdatePlotBuyingAggressivePostures();

	// Dispute Levels
	DoUpdateLandDisputeLevels();
	DoUpdateWonderDisputeLevels();
	DoUpdateMinorCivDisputeLevels();

	// Look at the situation
	DoTestPromises(); // Has any player gone back on any promises he made?
	DoTestBackstabbingPenalties(); // Have any backstabbing penalties expired?
	DoTestUntrustworthyFriends(); // Do we consider any players backstabbers?

	// Sanity Checks
	DoUpdateSaneDiplomaticTargets();
	
	// Our guess as to other players' diplomatic stances
	//DoUpdateOpinionTowardsUsGuesses();
	//DoUpdateApproachTowardsUsGuesses();

	// Player Opinion & Approach
	DoUpdateOpinions();
	DoUpdateGlobalPolitics();

	// These functions actually DO things, and we don't want the shadow AI behind a human player doing things for him
	if(!GetPlayer()->isHuman())
	{
		DoDetermineTaxRateForVassals();
		DoUpdateDemands();
		MakeWar();
		DoMakePeaceWithMinors();
		DoMakePeaceWithVassals();
		DoContactMinorCivs();
		DoContactMajorCivs();
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			GC.getGame().GetGameDeals().DoCancelAllProposedMPDealsWithPlayer(GetID(), DIPLO_AI_PLAYERS);
		}
		else
		{
			GC.getGame().GetGameDeals().DoCancelAllProposedDealsWithPlayer(GetID());	//Proposed deals with AI players are purely transitional.
		}
#else
		GC.getGame().GetGameDeals().DoCancelAllProposedDealsWithPlayer(GetID());	//Proposed deals with AI players are purely transitional.
#endif
	}

	// Update Counters
	DoCounters();

	// Logging
	LogStatus();
	LogWarStatus();
	LogStatements();

	//reset to default
	m_eDiploMode = DIPLO_ALL_PLAYERS;
	m_eTargetPlayer = NO_PLAYER;
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// WAR DAMAGE DECAY
// ////////////////////////////////////

/// Every turn we're at peace war damage goes down a bit
void CvDiplomacyAI::DoWarValueLostDecay()
{
	//we want to do this only once per turn
	if (m_eDiploMode == DIPLO_SPECIFIC_PLAYER)
		return;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(eLoopPlayer, true))
			continue;

		int iValue = GetWarValueLost(eLoopPlayer);

		// War damage we've suffered goes down by 1/50th every turn while at war (slower, but necessary to bring chance of white peace)
		if (IsAtWar(eLoopPlayer))
		{
			if (iValue > 0)
			{
				int iChange = max((iValue/50), 1); // Must go down by at least 1
				ChangeWarValueLost(eLoopPlayer, -iChange);
			}
		}
		// Goes down by 1/10th every turn while at peace
		else
		{
			if (iValue > 0)
			{
				int iChange = max((iValue/10), 1); // Must go down by at least 1
				ChangeWarValueLost(eLoopPlayer, -iChange);
			}
		}
	}
}

/// Updates how much damage we have taken in wars against all players
void CvDiplomacyAI::DoUpdateWarDamage()
{
	// Calculate the value of what we have currently - this is invariant so we will just do it once
	int iCurrentValue = 0;
	int iTypicalLandPower = GetPlayer()->GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_LAND);
	int iTypicalNavalPower = GetPlayer()->GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_SEA);
	int iTypicalAirPower = GetPlayer()->GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_AIR);
	int iValueLoop;

	// City value
	for (CvCity* pLoopCity = GetPlayer()->firstCity(&iValueLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iValueLoop))
	{
		int iCityValue = /*175*/ GC.getWAR_DAMAGE_LEVEL_CITY_WEIGHT();
		iCityValue += (pLoopCity->getPopulation() * /*150*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
		iCityValue += (pLoopCity->getNumWorldWonders() * /*200*/ GC.getWAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER());

		// Multipliers
		// Our original capital!
		if (pLoopCity->IsOriginalCapitalForPlayer(GetID()))
		{
			iCityValue *= 200;
			iCityValue /= 100;
		}
		// Another major's original capital, or our Holy City
		else if (pLoopCity->IsOriginalMajorCapital() || pLoopCity->GetCityReligions()->IsHolyCityForReligion(GetPlayer()->GetReligions()->GetCurrentReligion(false)))
		{
			iCityValue *= 150;
			iCityValue /= 100;
		}
		// A City-State's capital
		else if (pLoopCity->IsOriginalMinorCapital())
		{
			iCityValue *= 115;
			iCityValue /= 100;
		}

		iCurrentValue += iCityValue;
	}

	// Unit value
	for (CvUnit* pLoopUnit = GetPlayer()->firstUnit(&iValueLoop); pLoopUnit != NULL; pLoopUnit = GetPlayer()->nextUnit(&iValueLoop))
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
		if (pkUnitInfo)
		{
			int iUnitValue = (pkUnitInfo->GetPower() * 100);

			if (iUnitValue > 0)
			{
				// Compare to strongest unit we can build in that domain, for an apples to apples comparison
				// Best unit that can be currently built in a domain is given a value of 100
				DomainTypes eDomain = (DomainTypes) pkUnitInfo->GetDomainType();

				if (eDomain == DOMAIN_AIR)
				{
					if (iTypicalAirPower > 0)
					{
						iUnitValue /= iTypicalAirPower;
					}
					else
					{
						iUnitValue = /*100*/ GC.getDEFAULT_WAR_VALUE_FOR_UNIT();
					}
				}
				else if (eDomain == DOMAIN_SEA)
				{
					if (iTypicalNavalPower > 0)
					{
						iUnitValue /= iTypicalNavalPower;
					}
					else
					{
						iUnitValue = /*100*/ GC.getDEFAULT_WAR_VALUE_FOR_UNIT();
					}
				}
				else
				{
					if (iTypicalLandPower > 0)
					{
						iUnitValue /= iTypicalLandPower;
					}
					else
					{
						iUnitValue = /*100*/ GC.getDEFAULT_WAR_VALUE_FOR_UNIT();
					}
				}

				iCurrentValue += iUnitValue;
			}
		}
	}

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsHasMet(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isAlive())
		{
			int iWarValueLost = GetWarValueLost(eLoopPlayer);
			int iValueLostRatio = 0;

			if (iWarValueLost > 0)
			{
				if (iCurrentValue > 0)
				{
					iValueLostRatio = ((iWarValueLost * 100) / (iCurrentValue + iWarValueLost));
				}
				else
				{
					iValueLostRatio = iWarValueLost;
				}
			}

			SetWarDamageValue(eLoopPlayer, iValueLostRatio);
		}
		else
		{
			SetWarDamageValue(eLoopPlayer, 0);
		}
	}
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// COOP WARS
// ////////////////////////////////////

/// Updates our coop war states for the turn
void CvDiplomacyAI::DoUpdateCoopWarStates()
{
	int iGameTurn = GC.getGame().getGameTurn();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer == GetID())
			continue;

		if (!GET_PLAYER(eLoopPlayer).isAlive())
			continue;

		if (!IsHasMet(eLoopPlayer, true))
			continue;

		for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
		{
			PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;

			if (!GET_PLAYER(eThirdParty).isAlive())
				continue;

			if (GET_PLAYER(eThirdParty).getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
				continue;

			if (!IsHasMet(eThirdParty))
				continue;

			CoopWarStates eCoopWarState = GetCoopWarState(eLoopPlayer, eThirdParty);
			int iTurn = GetCoopWarStateChangeTurn(eLoopPlayer, eThirdParty);
			if (iTurn < 0 || eCoopWarState == NO_COOP_WAR_STATE)
				continue;

			int iTurnDifference = iGameTurn - iTurn;

			if (eCoopWarState == COOP_WAR_STATE_REJECTED || eCoopWarState == COOP_WAR_STATE_WARNED_TARGET)
			{
				if (iTurnDifference >= 30)
				{
					SetCoopWarState(eLoopPlayer, eThirdParty, NO_COOP_WAR_STATE);
				}
			}
			else if (eCoopWarState == COOP_WAR_STATE_PREPARING)
			{
				if (CanStartCoopWar(eLoopPlayer, eThirdParty))
				{
					if (iTurnDifference >= 10)
					{
						SetCoopWarState(eLoopPlayer, eThirdParty, COOP_WAR_STATE_READY);
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eThirdParty, COOP_WAR_STATE_READY);
						eCoopWarState = COOP_WAR_STATE_READY;
					}
				}
				else
				{
					SetCoopWarState(eLoopPlayer, eThirdParty, NO_COOP_WAR_STATE);
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eThirdParty, NO_COOP_WAR_STATE);
				}
			}

			if (eCoopWarState == COOP_WAR_STATE_READY)
			{
				if (CanStartCoopWar(eLoopPlayer, eThirdParty))
				{
					DoStartCoopWar(eLoopPlayer, eThirdParty);
				}
				else
				{
					SetCoopWarState(eLoopPlayer, eThirdParty, NO_COOP_WAR_STATE);
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eThirdParty, NO_COOP_WAR_STATE);
				}					
			}
		}
	}
}

/// Can we initiate our planned coop war with eAllyPlayer against eTargetPlayer?
bool CvDiplomacyAI::CanStartCoopWar(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer)
{
	// Do we even have a coop war plan to begin with?
	CoopWarStates eCoopWarState = GetCoopWarState(eAllyPlayer, eTargetPlayer);
	if (eCoopWarState != COOP_WAR_STATE_PREPARING && eCoopWarState != COOP_WAR_STATE_READY)
		return false;

	// If we somehow got here and we're at war with our ally or our friendship was broken, no dice. (failsafe)
	if (IsAtWar(eAllyPlayer) || IsDoFBroken(eAllyPlayer) || GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsDoFBroken(GetID()))
		return false;

	// Make sure the target is still valid
	if (!IsValidCoopWarTarget(eTargetPlayer, true))
		return false;
	if (!GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsValidCoopWarTarget(eTargetPlayer, true))
		return false;

	// Must be able to declare war on the target (or be already at war)
	if (!IsAtWar(eTargetPlayer) && !GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), GetID()))
	{
		return false;
	}
	if (!GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsAtWar(eTargetPlayer) && !GET_TEAM(GET_PLAYER(eAllyPlayer).getTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), eAllyPlayer))
	{
		return false;
	}

	return true;
}

/// Starts a coop war
void CvDiplomacyAI::DoStartCoopWar(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer)
{
	// Our declaration
	if (IsAtWar(eTargetPlayer) || DeclareWar(eTargetPlayer))
	{
		if (!GetPlayer()->isHuman())
		{
			GetPlayer()->GetMilitaryAI()->RequestCityAttack(eTargetPlayer, 3, GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(eTargetPlayer));
		}

		// Their war declaration
		if (GET_PLAYER(eAllyPlayer).IsAtWarWith(eTargetPlayer) || GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->DeclareWar(eTargetPlayer))
		{
			if (!GET_PLAYER(eAllyPlayer).isHuman())
			{
				GET_PLAYER(eAllyPlayer).GetMilitaryAI()->RequestCityAttack(eTargetPlayer, 3, GET_PLAYER(eAllyPlayer).HasAnyOffensiveOperationsAgainstPlayer(eTargetPlayer));
			}

			int iMyTurnsAtWar = GetTeamNumTurnsAtWar(GET_PLAYER(eTargetPlayer).getTeam());
			int iTheirTurnsAtWar = GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->GetTeamNumTurnsAtWar(GET_PLAYER(eTargetPlayer).getTeam());
			int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH() - max(iMyTurnsAtWar, iTheirTurnsAtWar);

			if (iLockedTurns > 0)
			{
				GET_TEAM(GetTeam()).ChangeNumTurnsLockedIntoWar(GET_PLAYER(eTargetPlayer).getTeam(), iLockedTurns);
				GET_TEAM(GET_PLAYER(eAllyPlayer).getTeam()).ChangeNumTurnsLockedIntoWar(GET_PLAYER(eTargetPlayer).getTeam(), iLockedTurns);
			}

			SetCoopWarState(eAllyPlayer, eTargetPlayer, COOP_WAR_STATE_ONGOING);
			GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, COOP_WAR_STATE_ONGOING);
		}
		else
		{
			CvAssertMsg(false, "ERROR: Unable to start coop war!");
			SetCoopWarState(eAllyPlayer, eTargetPlayer, NO_COOP_WAR_STATE);
			GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, NO_COOP_WAR_STATE);
		}
	}
	else
	{
		CvAssertMsg(false, "ERROR: Unable to start coop war!");
		SetCoopWarState(eAllyPlayer, eTargetPlayer, NO_COOP_WAR_STATE);
		GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, NO_COOP_WAR_STATE);
	}
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// VICTORY COMPETITION
// ////////////////////////////////////

/// Is this player currently competing to win? Determines whether Victory Dispute/Block penalties apply.
void CvDiplomacyAI::DoUpdateCompetingForVictory()
{
	// Vassals do not compete for victory.
	if (GetPlayer()->IsVassalOfSomeone())
	{
		SetCompetingForVictory(false);
	}
	// If we were resurrected by anyone, we're not competing for victory.
	else if (WasResurrectedByAnyone())
	{
		SetCompetingForVictory(false);
	}
	// If we've lost our original capital, we're not competing for victory.
	else if (GetPlayer()->IsHasLostCapital())
	{
		SetCompetingForVictory(false);
	}
	// Victory competition is disabled by game options
	else if (!GC.getGame().IsVictoryCompetitionEnabled())
	{
		SetCompetingForVictory(false);
	}
	else
	{
		SetCompetingForVictory(true);
	}
	
	if (IsEndgameAggressive())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (!IsPlayerValid(eLoopPlayer))
			{
				SetEndgameAggressiveTo(eLoopPlayer, false);
				continue;
			}

			if (WasResurrectedBy(eLoopPlayer))
			{
				SetEndgameAggressiveTo(eLoopPlayer, false);
				continue;
			}

			if (GET_PLAYER(eLoopPlayer).isHuman() && GC.getGame().IsAIPassiveTowardsHumans() && !IsAtWar(eLoopPlayer))
			{
				SetEndgameAggressiveTo(eLoopPlayer, false);
				continue;
			}

			if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition())
			{
				SetEndgameAggressiveTo(eLoopPlayer, true);
			}
			else
			{
				SetEndgameAggressiveTo(eLoopPlayer, false);
			}
		}
	}
	else
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			SetEndgameAggressiveTo(eLoopPlayer, false);
		}
	}
}

/// Are we extra aggressive towards players that are close to victory in general?
bool CvDiplomacyAI::IsEndgameAggressive() const
{
	if (!IsCompetingForVictory())
		return false;

	return GC.getGame().IsEndgameAggressionEnabled();
}

/// What should our victory focus be? (i.e. What victory condition should we be sensitive to)
void CvDiplomacyAI::DoUpdateVictoryFocus()
{
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
	{
		SetVictoryFocus(VICTORY_FOCUS_DOMINATION);
		return;
	}

	// Let's check if we're close to winning.
	// Pick the easiest victory condition to win with first.
	if (IsCloseToSSVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_SCIENCE);
		return;
	}
	else if (IsCloseToDominationVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_DOMINATION);
		return;
	}
	else if (IsCloseToCultureVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_SCIENCE);
		return;
	}
	else if (IsCloseToDiploVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_DIPLOMATIC);
		return;
	}

	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	bool bDontCareAboutWinning = (!IsCompetingForVictory() || eMyGrandStrategy == NO_AIGRANDSTRATEGY || GetPlayer()->GetGrandStrategyAI()->GetGrandStrategyPriority(eMyGrandStrategy) <= 500);

	// AI isn't too focused on victory in the early game
	if (IsGoingForWorldConquest() && GetPlayer()->GetCurrentEra() < 2)
	{
		bDontCareAboutWinning = true;
	}
	else if (GetPlayer()->GetCurrentEra() < 3)
	{
		bDontCareAboutWinning = true;
	}

	// If we don't care about winning, default to our diplomatic personality
	if (bDontCareAboutWinning)
	{
		switch (GetDiploPersonalityType())
		{
		case DIPLO_PERSONALITY_CONQUEROR:
			SetVictoryFocus(VICTORY_FOCUS_DOMINATION);
			break;
		case DIPLO_PERSONALITY_DIPLOMAT:
			SetVictoryFocus(VICTORY_FOCUS_DIPLOMATIC);
			break;
		case DIPLO_PERSONALITY_CULTURAL:
			SetVictoryFocus(VICTORY_FOCUS_CULTURE);
			break;
		case DIPLO_PERSONALITY_SCIENTIST:
			SetVictoryFocus(VICTORY_FOCUS_SCIENCE);
			break;
		}
		return;
	}

	// We care about winning, so Grand Strategy AI decides
	if (IsGoingForWorldConquest())
	{
		SetVictoryFocus(VICTORY_FOCUS_DOMINATION);
		return;
	}
	else if (IsGoingForDiploVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_DIPLOMATIC);
		return;
	}
	else if (IsGoingForCultureVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_CULTURE);
		return;
	}
	else if (IsGoingForSpaceshipVictory())
	{
		SetVictoryFocus(VICTORY_FOCUS_SCIENCE);
		return;
	}

	// By default we go for conquest
	SetVictoryFocus(VICTORY_FOCUS_DOMINATION);
}

/// Do we consider any players to be expanding too recklessly?
void CvDiplomacyAI::DoUpdateRecklessExpanders()
{
	// We're not competing for victory, so we don't care.
	if (!IsCompetingForVictory() || GC.getGame().countMajorCivsAlive() < 2)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
			SetPlayerRecklessExpander(ePlayer, false);
		}
		return;
	}

	// Calculate the global averages
	int iMedianNumCities = GC.getGame().CalculateMedianNumCities();
	int iMedianNumPlots = GC.getGame().CalculateMedianNumPlots();
	double fTotalNumCities = 0;
	double fTotalNumPlots = 0;
	int iNumPlayers = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pPlayer = &GET_PLAYER(eLoopPlayer);

		// Dead or no cities
		if (!pPlayer->isMajorCiv() || !pPlayer->isAlive() || pPlayer->getNumCities() == 0)
			continue;

		iNumPlayers++;
		fTotalNumCities += pPlayer->getNumCities();
		fTotalNumPlots += pPlayer->getTotalLand();
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			// If the player has too few cities, don't worry about it
			int iNumCities = GET_PLAYER(ePlayer).getNumCities();
			int iNumPlots = GET_PLAYER(ePlayer).getTotalLand();
			if (iNumCities < 4)
			{
				SetPlayerRecklessExpander(ePlayer, false);
				continue;
			}

			// If the player is too far away from us, we don't care
			if (GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
			{
				SetPlayerRecklessExpander(ePlayer, false);
				continue;
			}

			// If we have at least as many cities OR land as them, don't worry about it
			if (iNumCities <= GetPlayer()->getNumCities())
			{
				SetPlayerRecklessExpander(ePlayer, false);
				continue;
			}

			if (iNumPlots <= GetPlayer()->getTotalLand())
			{
				SetPlayerRecklessExpander(ePlayer, false);
				continue;
			}

			// If this guy's military is as strong as ours, then it probably means he's just stronger than us
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) >= STRENGTH_AVERAGE)
			{
				SetPlayerRecklessExpander(ePlayer, false);
				continue;
			}

			// What's the global average, not counting this player?
			double fAverageNumCities = ((fTotalNumCities - iNumCities) / max(1, iNumPlayers));
			double fAverageNumPlots = ((fTotalNumPlots - iNumPlots) / max(1, iNumPlayers));

			// Do they have way more cities than the average player in the game?
			if ((iNumCities*100) > (iMedianNumCities * /*200*/ GC.getRECKLESS_EXPANDER_CITIES_THRESHOLD()))
			{
				// Must also have at least 50% more than the global average, just to prevent anything stupid
				if (iNumCities > (fAverageNumCities * 1.5))
				{
					SetPlayerRecklessExpander(ePlayer, true);
					continue;
				}
			}

			// Do they have way more land than the average player in the game?
			if ((iNumPlots*100) > (iMedianNumPlots * /*250*/ GC.getRECKLESS_EXPANDER_LAND_THRESHOLD()))
			{
				// Must also have at least 50% more than the global average, just to prevent anything stupid
				if (iNumPlots > (fAverageNumPlots * 1.5))
				{
					SetPlayerRecklessExpander(ePlayer, true);
					continue;
				}
			}

			SetPlayerRecklessExpander(ePlayer, false);
		}
		else
		{
			SetPlayerRecklessExpander(ePlayer, false);
		}
	}
}

void CvDiplomacyAI::DoUpdateWonderSpammers()
{
	// We're not competing for victory, so we don't care.
	if (!IsCompetingForVictory() || GC.getGame().countMajorCivsAlive() < 2)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
			SetPlayerWonderSpammer(ePlayer, false);
		}
		return;
	}

	int iMedianNumWonders = GC.getGame().CalculateMedianNumWondersConstructed();
	double fAverageNumWonders = 0;
	int iNumPlayers = 0;

	// Calculate the global average
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pPlayer = &GET_PLAYER(eLoopPlayer);

		// Only major civs who have built Wonders are counted
		if (!pPlayer->isMajorCiv() || pPlayer->GetWondersConstructed() <= 0)
			continue;

		iNumPlayers++;
		fAverageNumWonders += pPlayer->GetWondersConstructed();
	}

	// Find the mean value
	fAverageNumWonders /= max(1, iNumPlayers);

	bool bCultural = GetPlayer()->GetPlayerTraits()->IsTourism() || GetVictoryFocus() == VICTORY_FOCUS_CULTURE;
	bool bConqueror = GetPlayer()->GetPlayerTraits()->IsWarmonger() || GetVictoryFocus() == VICTORY_FOCUS_DOMINATION;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			// Up to two Wonders is always okay.
			int iNumWonders = GET_PLAYER(ePlayer).GetWondersConstructed();
			if (iNumWonders <= 2)
			{
				SetPlayerWonderSpammer(ePlayer, false);
				continue;
			}

			// If we're not a cultural civ, we only care about this if they're nearby
			PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);

			if (!bCultural)
			{
				if (bConqueror)
				{
					if (eProximity < PLAYER_PROXIMITY_CLOSE)
					{
						SetPlayerWonderSpammer(ePlayer, false);
						continue;
					}
				}
				else
				{
					if (eProximity < PLAYER_PROXIMITY_NEIGHBORS)
					{
						SetPlayerWonderSpammer(ePlayer, false);
						continue;
					}
				}
			}

			// Must have built several more Wonders than the median player in this game
			if (iNumWonders > (iMedianNumWonders + /*3*/ GC.getWONDER_SPAMMER_THRESHOLD()))
			{
				// Must also have at least 50% more than the global average, just to prevent anything stupid
				if (iNumWonders > (fAverageNumWonders * 1.5))
				{
					SetPlayerWonderSpammer(ePlayer, true);
					continue;
				}
			}

			SetPlayerRecklessExpander(ePlayer, false);
		}
		else
		{
			SetPlayerWonderSpammer(ePlayer, false);
		}
	}
}

void CvDiplomacyAI::DoUpdateTechBlockLevels()
{
	if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
		return;

	// We must be competing for victory to care about this.
	if (!IsCompetingForVictory())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
			SetTechBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
		}
		return;
	}

	int iOurTechs = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iDiploBalance = GetDiploBalance();
	int iTechMod = 0;

	if (IsScientist())
	{
		iTechMod++;
	}
	else if (GetPlayer()->GetPlayerTraits()->IsNerd())
	{
		iTechMod++;
	}

	VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	bool bSpaceshipValid = (eSpaceshipVictory != NO_VICTORY && GC.getGame().isVictoryValid(eSpaceshipVictory));

	if (!bSpaceshipValid)
	{
		iTechMod--;
	}
	else if (GetPlayer()->GetCurrentEra() >= 3 && IsGoingForSpaceshipVictory())
	{
		iTechMod++;
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (WasResurrectedBy(ePlayer))
			continue;

		if (!IsPlayerValid(ePlayer))
		{
			SetTechBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}

		if (bSpaceshipValid && IsEndgameAggressiveTo(ePlayer))
		{
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToSSVictory())
			{
				SetTechBlockLevel(ePlayer, BLOCK_LEVEL_FIERCE);
				continue;
			}
		}

		int iTechDifference = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown() - iOurTechs;

		// Tied pre-Medieval era? Disregard.
		if (iTechDifference == 0 && GetPlayer()->GetCurrentEra() < 2)
		{
			SetTechBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}

		// Anything that modifies tech competitiveness?
		iTechDifference += iTechMod;

		if (!IsUntrustworthy(ePlayer) && !IsDenouncedPlayer(ePlayer) && !IsDenouncedByPlayer(ePlayer))
		{
			// Reduce if we have a Research Agreement
			if (IsHasResearchAgreement(ePlayer))
			{
				iTechDifference--;
			}
			// Reduce if we're friends and they can trade tech to us
			if (IsDoFAccepted(ePlayer) && IsHasEmbassy(ePlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasEmbassy(GetID()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isTechTrading())
			{
				iTechDifference--;
			}
			// Reduce if we have a Defensive Pact - we value military protection
			if (IsHasDefensivePact(ePlayer))
			{
				iTechDifference--;
			}
		}

		if (iTechDifference > 0)
		{
			BlockLevelTypes eBlockLevel = BLOCK_LEVEL_NONE;

			// Multiply by DiploBalance flavor - we want to maintain a balance of power in the world...with us in the lead, of course
			iTechDifference *= iDiploBalance;
			iTechDifference += (GC.getGame().getHandicapInfo().getAIDeclareWarProb() / 50);

			if (iTechDifference >= /*30*/ GC.getTECH_BLOCK_FIERCE_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_FIERCE;
			else if (iTechDifference >= /*20*/ GC.getTECH_BLOCK_STRONG_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_STRONG;
			else if (iTechDifference >= /*10*/ GC.getTECH_BLOCK_WEAK_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_WEAK;

			SetTechBlockLevel(ePlayer, eBlockLevel);
		}
		else
		{
			SetTechBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
		}
	}
}

void CvDiplomacyAI::DoUpdatePolicyBlockLevels()
{
	if (GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
		return;

	// We must be competing for victory to care about this.
	if (!IsCompetingForVictory())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
		}
		return;
	}

	int iOurPolicies = GetPlayer()->GetPlayerPolicies()->GetNumPoliciesOwned(true, true, true);
	int iDiploBalance = GetDiploBalance();
	int iPolicyMod = 0;

	if (IsCultural())
	{
		iPolicyMod++;
	}
	else if (GetPlayer()->GetPlayerTraits()->IsTourism())
	{
		iPolicyMod++;
	}

	VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	bool bCultureValid = (eCulturalVictory != NO_VICTORY && GC.getGame().isVictoryValid(eCulturalVictory));

	if (!bCultureValid)
	{
		iPolicyMod--;
	}
	else if (GetPlayer()->GetCurrentEra() >= 3 && IsGoingForCultureVictory())
	{
		iPolicyMod++;
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (WasResurrectedBy(ePlayer))
			continue;

		if (!IsPlayerValid(ePlayer))
		{
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}

		if (bCultureValid && IsEndgameAggressiveTo(ePlayer))
		{
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToCultureVictory())
			{
				SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_FIERCE);
				continue;
			}
		}

		int iPolicyDifference = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumPoliciesOwned(true, true, true) - iOurPolicies;

		// For Policies, if we're ahead, never apply penalties.
		if (iPolicyDifference < 0)
		{
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}
		// Tied pre-Medieval era? Disregard.
		else if (iPolicyDifference == 0 && GetPlayer()->GetCurrentEra() < 2)
		{
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}
		// Sanity check for early game.
		else if (iOurPolicies <= 1 && iPolicyDifference <= 1)
		{
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			continue;
		}

		// Anything that modifies policy competitiveness?
		iPolicyDifference += iPolicyMod;

		if (iPolicyDifference > 0)
		{
			BlockLevelTypes eBlockLevel = BLOCK_LEVEL_NONE;

			// Multiply by DiploBalance flavor - we want to maintain a balance of power in the world...with us in the lead, of course
			iPolicyDifference *= iDiploBalance;
			iPolicyDifference += (GC.getGame().getHandicapInfo().getAIDeclareWarProb() / 70);

			if (iPolicyDifference >= /*24*/ GC.getPOLICY_BLOCK_FIERCE_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_FIERCE;
			else if (iPolicyDifference >= /*16*/ GC.getPOLICY_BLOCK_STRONG_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_STRONG;
			else if (iPolicyDifference >= /*8*/ GC.getPOLICY_BLOCK_WEAK_THRESHOLD())
				eBlockLevel = BLOCK_LEVEL_WEAK;

			SetPolicyBlockLevel(ePlayer, eBlockLevel);
		}
		else
		{
			SetPolicyBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
		}
	}
}

/// Updates what our level of Dispute is with all players over Victory
void CvDiplomacyAI::DoUpdateVictoryDisputeLevels()
{
	//Don't do this at the start of the game.
	if (GC.getGame().getGameTurn() <= 150)
		return;

	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	bool bDontCare = (!IsCompetingForVictory() || eMyGrandStrategy == NO_AIGRANDSTRATEGY || GetPlayer()->GetGrandStrategyAI()->GetGrandStrategyPriority(eMyGrandStrategy) <= 500);

	if (bDontCare)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			SetVictoryDisputeLevel(eLoopPlayer, DISPUTE_LEVEL_NONE);
		}
		return;
	}

	// Loop through all (valid) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv())
		{
			AIGrandStrategyTypes eTheirGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer);
			if (eTheirGrandStrategy == NO_AIGRANDSTRATEGY)
			{
				SetVictoryDisputeLevel(eLoopPlayer, DISPUTE_LEVEL_NONE);
				continue;
			}
			if (!IsAtWar(eLoopPlayer) && GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_ALLY)
			{
				SetVictoryDisputeLevel(eLoopPlayer, DISPUTE_LEVEL_NONE);
				continue;
			}

			DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
			int iVictoryDisputeWeight = 0;

			// Does the other player's (estimated) Grand Strategy match our own?
			if (GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer) == eMyGrandStrategy)
			{
				switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
				{
				case GUESS_CONFIDENCE_POSITIVE:
					iVictoryDisputeWeight += /*25*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_POSITIVE();
					break;
				case GUESS_CONFIDENCE_LIKELY:
					iVictoryDisputeWeight += /*15*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_LIKELY();
					break;
				case GUESS_CONFIDENCE_UNSURE:
					iVictoryDisputeWeight += /*5*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_UNSURE();
					break;
				}
			}

			// Reduce competitiveness in earlier eras
			int iEraReduction = (6 - GET_PLAYER(eLoopPlayer).GetCurrentEra());
			iVictoryDisputeWeight -= iEraReduction;

			if (iVictoryDisputeWeight > 0)
			{
				// Add weight for Player's competitiveness (1 - 10)
				iVictoryDisputeWeight *= GetVictoryCompetitiveness();
				iVictoryDisputeWeight += (GC.getGame().getHandicapInfo().getAIDeclareWarProb() / 70);

				// Now see what our new Dispute Level should be
				if (iVictoryDisputeWeight >= /*80*/ GC.getVICTORY_DISPUTE_FIERCE_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_FIERCE;
				else if (iVictoryDisputeWeight >= /*50*/ GC.getVICTORY_DISPUTE_STRONG_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_STRONG;
				else if (iVictoryDisputeWeight >= /*30*/ GC.getVICTORY_DISPUTE_WEAK_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_WEAK;
			}

			// Actually set the Level
			SetVictoryDisputeLevel(eLoopPlayer, eDisputeLevel);
		}
		else
		{
			SetVictoryDisputeLevel(eLoopPlayer, DISPUTE_LEVEL_NONE);
		}
	}
}

/// Updates what our level of Dispute is with all players over Victory
void CvDiplomacyAI::DoUpdateVictoryBlockLevels()
{
	//Don't do this at the start of the game.
	if (GC.getGame().getGameTurn() <= 150)
		return;

	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	bool bDontCare = (!IsCompetingForVictory() || eMyGrandStrategy == NO_AIGRANDSTRATEGY || GetPlayer()->GetGrandStrategyAI()->GetGrandStrategyPriority(eMyGrandStrategy) <= 500);

	if (bDontCare)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
		}
		return;
	}

	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");
	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");
	AIGrandStrategyTypes eUNGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");
	AIGrandStrategyTypes eSpaceshipGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	// Loop through all (valid) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv())
		{
			AIGrandStrategyTypes eTheirGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer);
			if (eTheirGrandStrategy == NO_AIGRANDSTRATEGY)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			if (!IsAtWar(eLoopPlayer) && GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}

			BlockLevelTypes eBlockLevel = BLOCK_LEVEL_NONE;
			int iVictoryBlockWeight = 0;

			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			bool bLeagueCompetitor = false;
			bool bSpaceRace = false;
			bool bCulture = false;
			bool bWar = false;

			if (pLeague != NULL)
			{
				int iVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);
				int iNeededVotes = GC.getGame().GetVotesNeededForDiploVictory();

				if (iNeededVotes > 0)
				{
					// 33% there? Close!
					if (iVotes >= (iNeededVotes / 3))
					{
						bLeagueCompetitor = true;
					}
				}
			}

			int iProjectCount = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetSSProjectCount();
			if (iProjectCount > 0)
			{
				bSpaceRace = true;
			}
			else
			{
				int iTheirTechNum = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
				int iNumOtherPlayers = 0;
				int iNumPlayersAheadInTech = 0;

				for (int iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
				{
					PlayerTypes eOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

					if (GET_PLAYER(eOtherPlayer).getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
						continue;

					if (!IsPlayerValid(eOtherPlayer))
						continue;

					iNumOtherPlayers++;
					int iNumTechs = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
					if (iTheirTechNum > iNumTechs)
					{
						iNumPlayersAheadInTech++;
					}
				}
				if (iNumPlayersAheadInTech >= iNumOtherPlayers)
				{
					bSpaceRace = true;
				}
				if (GetTechBlockLevel(eLoopPlayer) >= BLOCK_LEVEL_STRONG)
				{
					bSpaceRace = true;
				}
			}
			if (bSpaceRace)
			{
				iVictoryBlockWeight += iProjectCount * 10;
			}

			if (GetWarmongerThreat(eLoopPlayer) >= THREAT_SEVERE || (GetPlayerNumMajorsConquered(eLoopPlayer) >= (GC.getGame().countMajorCivsEverAlive() / 3)))
			{
				bWar = true;
			}

			if (IsPlayerWonderSpammer(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetCulture()->GetNumCivsInfluentialOn() > 1)
			{
				bCulture = true;
			}
			else if (GetPolicyBlockLevel(eLoopPlayer) >= BLOCK_LEVEL_STRONG)
			{
				bCulture = true;
			}

			if ((eConquestGrandStrategy == eTheirGrandStrategy) && !bWar)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			if ((eCultureGrandStrategy == eTheirGrandStrategy) && !bCulture)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			if ((eUNGrandStrategy == eTheirGrandStrategy) && !bLeagueCompetitor)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			if ((eSpaceshipGrandStrategy == eTheirGrandStrategy) && !bSpaceRace)
			{
				SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
				continue;
			}

			// Does the other player's (estimated) Grand Strategy differ from ours? If so, how positive are we about this?
			if (eTheirGrandStrategy != eMyGrandStrategy)
			{
				switch (GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
				{
				case GUESS_CONFIDENCE_POSITIVE:
					iVictoryBlockWeight += /*20*/ GC.getVICTORY_BLOCK_GRAND_STRATEGY_DIFFERENCE_POSITIVE();
					break;
				case GUESS_CONFIDENCE_LIKELY:
					iVictoryBlockWeight += /*15*/ GC.getVICTORY_BLOCK_GRAND_STRATEGY_DIFFERENCE_LIKELY();
					break;
				case GUESS_CONFIDENCE_UNSURE:
					iVictoryBlockWeight += /*5*/ GC.getVICTORY_BLOCK_GRAND_STRATEGY_DIFFERENCE_UNSURE();
					break;
				}
			}

			if (iVictoryBlockWeight > 0)
			{
				// Add weight for Player's victory competitiveness, meanness and diplobalance desires (1 - 10)
				// Average of each is 5, and era goes up by one throughout game.
				iVictoryBlockWeight += (GetVictoryCompetitiveness() + GetMeanness() + GetDiploBalance() + GET_PLAYER(eLoopPlayer).GetCurrentEra());
				iVictoryBlockWeight += (GC.getGame().getHandicapInfo().getAIDeclareWarProb() / 50);

				// Now see what our new Block Level should be
				if (iVictoryBlockWeight >= /*40*/ GC.getVICTORY_BLOCK_FIERCE_THRESHOLD())
				{
					eBlockLevel = BLOCK_LEVEL_FIERCE;
				}
				else if (iVictoryBlockWeight >= /*30*/ GC.getVICTORY_BLOCK_STRONG_THRESHOLD())
				{			
					eBlockLevel = BLOCK_LEVEL_STRONG;
				}
				else if (iVictoryBlockWeight >= /*20*/ GC.getVICTORY_BLOCK_WEAK_THRESHOLD())
				{		
					eBlockLevel = BLOCK_LEVEL_WEAK;
				}
			}

			// Actually set the new level
			SetVictoryBlockLevel(eLoopPlayer, eBlockLevel);
		}
		else
		{
			SetVictoryBlockLevel(eLoopPlayer, BLOCK_LEVEL_NONE);
		}
	}
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// MILITARY STUFF
// ////////////////////////////////////

/// Updates what the state of war is with all players
void CvDiplomacyAI::DoUpdateWarStates()
{
	// Reset overall war state
	int iStateAllWars = 0;   // Used to assess overall war state in this function
	SetStateAllWars(STATE_ALL_WARS_NEUTRAL);
	ReligionTypes eMyReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// War?
		if (IsPlayerValid(eLoopPlayer) && IsAtWar(eLoopPlayer))
		{
			WarStateTypes eWarState = NO_WAR_STATE_TYPE;
			ReligionTypes eTheirReligion = GET_PLAYER(eLoopPlayer).GetReligions()->GetCurrentReligion(false);

			// Evaluate our danger and their danger from this war
			int iOurDanger = 1;
			int iTheirDanger = 1;
			int iNumOurCities = 0;
			int iNumTheirCities = 0;
			bool bSeriousDangerUs = false;
			bool bSeriousDangerThem = false;
			int iLoop;
			for (CvCity* pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))
			{
				iNumOurCities++;
				int iDangerMod = 0;

				if (pLoopCity->isInDangerOfFalling())
				{
					iDangerMod += 3;
					bSeriousDangerUs = true;
				}

				else if (pLoopCity->isUnderSiege() || pLoopCity->IsBlockadedWaterAndLand())
				{
					iDangerMod += 2;
					if (pLoopCity->IsBlockadedWaterAndLand() || pLoopCity->getDamage() >= (pLoopCity->GetMaxHitPoints()/2))
					{
						if (pLoopCity->isCapital() || pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)))
						{
							bSeriousDangerUs = true;
						}
					}
				}

				else if (pLoopCity->IsInDanger(eLoopPlayer))
					iDangerMod += 1;

				//look at the tactical map (is it up to date?)
				CvTacticalDominanceZone* pLandZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
				CvTacticalDominanceZone* pWaterZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
				if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
					iDangerMod++;
				if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
					iDangerMod++;
				
				if (pLoopCity->isCapital())
					iDangerMod *= 3;
				else if (pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)) || pLoopCity->getNumWorldWonders() > 0)
					iDangerMod *= 2;
				else if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion() || pLoopCity->getNumNationalWonders() > 0)
				{
					if (iDangerMod > 0)
						iDangerMod++;
				}
				
				iOurDanger += iDangerMod;
			}

			iOurDanger *= 100;
			iOurDanger /= max(1, iNumOurCities);

			for (CvCity* pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))
			{
				CvPlot* pCityPlot = pLoopCity->plot();
				if (pCityPlot == NULL)
					continue;

				iNumTheirCities++;

				// Can we actually see this city's danger status?
				if (HasVisibilityOfEnemyCityDanger(pLoopCity))
				{
					int iDangerMod = 0;

					if (pLoopCity->isInDangerOfFalling())
					{
						iDangerMod += 3;
						bSeriousDangerThem = true;
					}

					else if (pLoopCity->isUnderSiege() || pLoopCity->IsBlockadedWaterAndLand())
					{
						iDangerMod += 2;
						if (pLoopCity->IsBlockadedWaterAndLand() || pLoopCity->getDamage() >= (pLoopCity->GetMaxHitPoints()/2))
						{
							if (pLoopCity->isCapital() || pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)))
							{
								bSeriousDangerThem = true;
							}
						}
					}

					else if (pLoopCity->IsInDanger(m_pPlayer->GetID()))
						iDangerMod += 1;

					//look at the tactical map (is it up to date?)
					CvTacticalDominanceZone* pLandZone = GET_PLAYER(eLoopPlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
					CvTacticalDominanceZone* pWaterZone = GET_PLAYER(eLoopPlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
					
					if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
						iDangerMod++;
					if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
						iDangerMod++;
					
					if (pLoopCity->isCapital())
						iDangerMod *= 3;
					else if (pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)) || pLoopCity->getNumWorldWonders() > 0)
						iDangerMod *= 2;
					else if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion())
					{
						if (iDangerMod > 0)
							iDangerMod++;
					}

					iTheirDanger += iDangerMod;
				}
			}

			iTheirDanger *= 100;
			iTheirDanger /= max(1, iNumTheirCities);

			int iDangerPercent = iTheirDanger * 100;
			iDangerPercent /= max(1, iOurDanger);

			// First consider serious danger - overrides danger percent comparison!
			if (bSeriousDangerUs && !bSeriousDangerThem)
			{
				eWarState = WAR_STATE_DEFENSIVE;
			}
			else if (!bSeriousDangerUs && bSeriousDangerThem)
			{
				eWarState = WAR_STATE_OFFENSIVE;
			}
			else if (bSeriousDangerUs && bSeriousDangerThem)
			{
				eWarState = WAR_STATE_STALEMATE;
			}

			// Which of us has more city danger?
			if (eWarState == NO_WAR_STATE_TYPE)
			{
				if (iDangerPercent < 100)
				{
					eWarState = WAR_STATE_DEFENSIVE;
				}
				else if (iDangerPercent == 100)
				{
					eWarState = WAR_STATE_STALEMATE;
				}
				else if (iDangerPercent > 100)
				{
					eWarState = WAR_STATE_OFFENSIVE;
				}
			}

			int WarScore = GetWarScore(eLoopPlayer);
			if (m_pPlayer->GetCulture()->GetWarWeariness() > 0 && m_pPlayer->IsEmpireVeryUnhappy())
			{
				if (WarScore < 0)
				{
					WarScore *= 2;
				}
				else
				{
					WarScore /= 2;
				}
			}
			if (WarScore >= 50 && eWarState == WAR_STATE_OFFENSIVE)
			{
				eWarState = WAR_STATE_NEARLY_WON;
			}
			else if (WarScore <= -50 && eWarState == WAR_STATE_DEFENSIVE)
			{
				eWarState = WAR_STATE_NEARLY_DEFEATED;
			}

			//Exceptions?

			//If low warscore and it has been a while since either side captured a city, let's bring it down to calm.
			if ((GetPlayerNumTurnsSinceCityCapture(eLoopPlayer) >= 10) && (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetID()) >= 10))
			{
				if (WarScore <= 15 && WarScore >= -15)
					eWarState = WAR_STATE_CALM;
			}

			// If this is a major power, determine what the impact of this war is on our global situation
			if (GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				if (eWarState == WAR_STATE_NEARLY_WON)
				{
					iStateAllWars += 4;
				}
				else if (eWarState == WAR_STATE_OFFENSIVE)
				{
					iStateAllWars += 3;
				}
				else if (eWarState == WAR_STATE_DEFENSIVE)
				{
					iStateAllWars -= 1;

					// If we are defensive in this war and our capital has been damaged, overall state should be defensive
					CvCity *pCapital = m_pPlayer->getCapitalCity();
					if (pCapital && pCapital->getDamage() > 0)
					{
						SetStateAllWars(STATE_ALL_WARS_LOSING);
					}
				}
				// If nearly defeated in any war, overall state should be defensive
				else if (eWarState == WAR_STATE_NEARLY_DEFEATED)
				{
					SetStateAllWars(STATE_ALL_WARS_LOSING);
				}
			}

			SetWarState(eLoopPlayer, eWarState);
		}
		// Not at war
		else
		{
			SetWarState(eLoopPlayer, NO_WAR_STATE_TYPE);
		}
	}

	// Finalize overall assessment
	if (iStateAllWars < 0 || GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		SetStateAllWars(STATE_ALL_WARS_LOSING);
	}
	else if (iStateAllWars > 0)
	{
		SetStateAllWars(STATE_ALL_WARS_WINNING);
	}
}

bool CvDiplomacyAI::HasVisibilityOfEnemyCityDanger(CvCity* pCity) const
{
	if (pCity == NULL)
		return false;

	CvPlot* pCityPlot = pCity->plot();
	if (pCityPlot == NULL)
		return false;

	TeamTypes eMyTeam = GetTeam();

	// City plot is visible?
	if (pCityPlot->isVisible(eMyTeam))
		return true;

	// Not revealed?
	if (!pCityPlot->isRevealed(eMyTeam))
		return false;

	// Adjacent visible?
	if (pCityPlot->isAdjacentVisible(eMyTeam))
		return true;

	// Near one of our cities?
	// Assume that the AI has a good idea of what's going on within 8 tiles if the city plot is revealed
	// This is "cheating" on a technical level but due to limitations it will have to do ... fairer than letting them see everywhere, and humans can intuit the same knowledge by looking at city HP, etc.
	if (GetPlayer()->GetCityDistanceInPlots(pCityPlot) <= 8)
		return true;

	// Nearby units?
	int iVisionBonus = !GetPlayer()->isHuman() ? GC.getGame().getHandicapInfo().getAIVisionBonus() : 0;
	int iUnitLoop;
	for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))
	{
		// Disregard trade/blind units
		if (pLoopUnit->isTrade() || pLoopUnit->visibilityRange() <= 0)
			continue;

		// Smaller sight radius for units
		int iRadius = 6;
		iRadius += iVisionBonus;

		// VP Special: Coastal units have a harder time seeing what's going on in non-coastal cities
		if (MOD_BALANCE_CORE && pLoopUnit->getDomainType() == DOMAIN_SEA && !pCity->isCoastal())
		{
			iRadius = 3;
		}

		if (plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pCityPlot->getX(), pCityPlot->getY()) <= iRadius)
		{
			return true;
		}
	}

	return false;
}

/// What is the integer value of how well we think the war with ePlayer is going?
int CvDiplomacyAI::GetWarScore(PlayerTypes ePlayer, bool bUsePeacetimeCalculation /* = false */, bool bDebug /* = false */)
{
	if ((int)ePlayer < 0 || (int)ePlayer >= MAX_CIV_PLAYERS) return 0;

	//If this is a prewar calc, use power estimates (should give us a better idea of how a war might go).
	if (bUsePeacetimeCalculation)
	{
		int iWarScore = 0;
		int iWarScoreModifier = 0;

		switch (GetPlayer()->GetProximityToPlayer(ePlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWarScoreModifier += 30;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWarScoreModifier += 10;
			break;
		case PLAYER_PROXIMITY_FAR:
			iWarScoreModifier += -10;
			break;
		case PLAYER_PROXIMITY_DISTANT:
			iWarScoreModifier += -30;
			break;
		}

		// Their Military Strength compared to us
		switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
		{
		case STRENGTH_PATHETIC:
			iWarScore += 40;
			break;
		case STRENGTH_WEAK:
			iWarScore += 20;
			break;
		case STRENGTH_POOR:
			iWarScore += 10;
			break;
		case STRENGTH_AVERAGE:
			iWarScore += 0;
			break;
		case STRENGTH_STRONG:
			iWarScore += -10;
			break;
		case STRENGTH_POWERFUL:
			iWarScore += -20;
			break;
		case STRENGTH_IMMENSE:
			iWarScore += -40;
			break;
		}

		// Their Economic Strength compared to us
		switch (GetPlayerEconomicStrengthComparedToUs(ePlayer))
		{
		case STRENGTH_PATHETIC:
			iWarScore += 20;
			break;
		case STRENGTH_WEAK:
			iWarScore += 10;
			break;
		case STRENGTH_POOR:
			iWarScore += 5;
			break;
		case STRENGTH_AVERAGE:
			iWarScore += 0;
			break;
		case STRENGTH_STRONG:
			iWarScore += -5;
			break;
		case STRENGTH_POWERFUL:
			iWarScore += -10;
			break;
		case STRENGTH_IMMENSE:
			iWarScore += -20;
			break;
		}

		// What is our opinion of them?
		switch (GetMajorCivOpinion(ePlayer))
		{
		case MAJOR_CIV_OPINION_ALLY:
			iWarScore += -20;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			iWarScore += -10;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iWarScore += -5;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			iWarScore += 0;
			break;
		case MAJOR_CIV_OPINION_COMPETITOR:
			iWarScore += 5;
			break;
		case MAJOR_CIV_OPINION_ENEMY:
			iWarScore += 10;
			break;
		case MAJOR_CIV_OPINION_UNFORGIVABLE:
			iWarScore += 20;
			break;
		}

		// How much of a warmonger are they?
		switch (GetWarmongerThreat(ePlayer))
		{
		case THREAT_NONE:
			iWarScore += -20;
			break;
		case THREAT_MINOR:
			iWarScore += -10;
			break;
		case THREAT_MAJOR:
			iWarScore += 10;
			break;
		case THREAT_SEVERE:
			iWarScore += 15;
			break;
		case THREAT_CRITICAL:
			iWarScore += 20;
			break;
		}

		iWarScore *= (100 + iWarScoreModifier);
		iWarScore /= 100;

		return iWarScore;
	}
	else
	{
		int iWarScore = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarDamageValue(GetID());
		int iTheirWarScore = GetWarDamageValue(ePlayer);
		int iAverageScore = 0;

		if (iWarScore == iTheirWarScore)
		{
			iAverageScore = 0;
		}
		else if (iWarScore > iTheirWarScore)
		{
			iAverageScore = iWarScore - iTheirWarScore;
		}
		else if (iTheirWarScore > iWarScore)
		{
			iAverageScore = iTheirWarScore - iWarScore;
			iAverageScore *= -1;
		}

		//Doubled because of the 'average' above.
		iAverageScore *= 2;

		if (iAverageScore != 0)
		{
			int iWarDurationUs = (GetPlayerNumTurnsSinceCityCapture(ePlayer) / 5);
			int iWarDurationThem = (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetID()) / 5);

			if (iAverageScore > 0)
			{
				iAverageScore = max((iAverageScore - iWarDurationUs), 0);
			}
			else if (iAverageScore < 0)
			{
				iAverageScore = min((iAverageScore + iWarDurationThem), 0);
			}

			if (iAverageScore >= 100)
			{
				iAverageScore = 100;
			}
			else if (iAverageScore <= -100)
			{
				iAverageScore = -100;
			}
		}
	
		if (bDebug && GC.getAILogging())
		{
			CvString strMsg;
			strMsg.Format("turn %d - war score for %d against player %d is %d / %d\n", GC.getGame().getGameTurn(), m_pPlayer->GetID(), ePlayer, iWarScore, iTheirWarScore );
			OutputDebugString(strMsg.c_str());
		}

		return iAverageScore;
	}
}

int CvDiplomacyAI::GetHighestWarscore(bool bOnlyCurrentWars /* = true */)
{
	int iHighestWarscore = 0;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			if (bOnlyCurrentWars && !IsAtWar(eLoopPlayer))
				continue;

			int iWarscore = GetWarScore(eLoopPlayer);
			if (iWarscore > iHighestWarscore)
			{
				iHighestWarscore = iWarscore;
			}
		}
	}

	iHighestWarscore *= GetPlayer()->GetPositiveWarScoreTourismMod();
	iHighestWarscore /= 100;

	return iHighestWarscore;
}

PlayerTypes CvDiplomacyAI::GetHighestWarscorePlayer(bool bOnlyCurrentWars /* = true */)
{
	int iHighestWarscore = 0;
	PlayerTypes eBestPlayer = NO_PLAYER;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			if (bOnlyCurrentWars && !IsAtWar(eLoopPlayer))
				continue;

			int iWarscore = GetWarScore(eLoopPlayer);
			if (iWarscore >= iHighestWarscore)
			{
				if (iWarscore == 100 && iHighestWarscore == 100 && eBestPlayer != NO_PLAYER)
				{
					// At 100 with multiple civs?
					if (IsCapitalCapturedBy(eLoopPlayer, true, false))
					{
						eBestPlayer = eLoopPlayer;
						continue;
					}
					else if (IsHolyCityCapturedBy(eLoopPlayer, true, false) && !IsCapitalCapturedBy(eBestPlayer, true, false))
					{
						eBestPlayer = eLoopPlayer;
						continue;
					}
					else if (IsEndgameAggressiveTo(eLoopPlayer) && !IsEndgameAggressiveTo(eBestPlayer))
					{
						eBestPlayer = eLoopPlayer;
						continue;
					}

					// The weakest civ is the one we are most willing to stay at war with.
					if (GetPlayerTargetValue(eLoopPlayer) > GetPlayerTargetValue(eBestPlayer))
					{
						eBestPlayer = eLoopPlayer;
					}
					else if (GetPlayerTargetValue(eLoopPlayer) == GetPlayerTargetValue(eBestPlayer))
					{
						if (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) < GetPlayerMilitaryStrengthComparedToUs(eBestPlayer))
						{
							eBestPlayer = eLoopPlayer;
						}
					}
				}
				else if (iWarscore > iHighestWarscore)
				{
					eBestPlayer = eLoopPlayer;
					iHighestWarscore = iWarscore;
				}
			}
		}
	}

	return eBestPlayer;
}

/// Updates what our assessment is of all players' overall Military Strength
void CvDiplomacyAI::DoUpdatePlayerMilitaryStrengths()
{
	int iBase = /*30*/ GC.getMILITARY_STRENGTH_BASE();
	int iMilitaryStrength = iBase + GetPlayer()->GetMilitaryMight();
	int iHumanStrengthMod = GetPlayer()->isHuman() ? 0 : max(0, GC.getGame().getHandicapInfo().getAIHumanStrengthMod()); // Ranges from 0 (Settler) to 80 (Deity)

	// Modify our strength based on military rating (combat skill)
	iMilitaryStrength *= ComputeRatingStrengthAdjustment(GetID());
	iMilitaryStrength /= 100;

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer, /*bMyTeamIsValid*/ true) && ePlayer != GetID())
		{
			int iOtherPlayerMilitaryStrength = GET_PLAYER(ePlayer).GetMilitaryMight() + iBase;

			// If we're an AI evaluating a human, modify their strength estimate based on difficulty level (not if they're a vassal, though)
			if (!GetPlayer()->isHuman() && !GET_PLAYER(ePlayer).IsVassalOfSomeone() && !GET_PLAYER(ePlayer).IsNoNewWars() && GetWarState(ePlayer) < WAR_STATE_OFFENSIVE)
			{
				iOtherPlayerMilitaryStrength *= GET_PLAYER(ePlayer).isHuman() ? (100 + iHumanStrengthMod) : 100;
				iOtherPlayerMilitaryStrength /= 100;
			}

			// Modify their strength based on military rating (combat skill)
			iOtherPlayerMilitaryStrength *= ComputeRatingStrengthAdjustment(ePlayer);
			iOtherPlayerMilitaryStrength /= 100;

			int iDPUs = 0;
			int iDPThem = 0;

			for (int iPlayerLoop2 = 0; iPlayerLoop2 < MAX_MAJOR_CIVS; iPlayerLoop2++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop2;

				if (IsPlayerValid(eLoopPlayer, /*bMyTeamIsValid*/ true) && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer && eLoopPlayer != GetID())
				{
					// If this guy isn't near either of us, ignore them.
					if (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(GetID()) < PLAYER_PROXIMITY_CLOSE && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
					{
						continue;
					}

					bool bCountDefensivePact = (!IsAtWar(ePlayer) || IsAtWar(eLoopPlayer));

					if (GET_PLAYER(ePlayer).isMajorCiv())
					{
						if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(ePlayer) || (bCountDefensivePact && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsHasDefensivePact(ePlayer)))
						{
							int iLoopPlayerStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

							// If we're an AI evaluating a human, modify their strength estimate based on difficulty level if they're reasonably strong
							if (!GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE)
							{
								iLoopPlayerStrength *= GET_PLAYER(eLoopPlayer).isHuman() ? (100 + iHumanStrengthMod) : 100;
								iLoopPlayerStrength /= 100;
							}

							// Modify their strength estimate based on military rating (combat skill)
							iLoopPlayerStrength *= ComputeRatingStrengthAdjustment(eLoopPlayer);
							iLoopPlayerStrength /= 100;

							// Count teammates twice, they're more likely to defend each other
							if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(ePlayer))
							{
								iLoopPlayerStrength *= 2;
							}

							iDPThem += iLoopPlayerStrength;
						}
					}

					bCountDefensivePact = (!IsAtWar(ePlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsAtWar(ePlayer));

					if (IsTeammate(eLoopPlayer) || (bCountDefensivePact && IsHasDefensivePact(eLoopPlayer)) || GetCoopWarState(eLoopPlayer, ePlayer) >= COOP_WAR_STATE_PREPARING)
					{
						int iLoopPlayerStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

						// If we're an AI evaluating a human, modify their strength estimate based on difficulty level if they're reasonably strong
						if (!GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE)
						{
							iLoopPlayerStrength *= GET_PLAYER(eLoopPlayer).isHuman() ? (100 + iHumanStrengthMod) : 100;
							iLoopPlayerStrength /= 100;
						}

						// Modify their strength estimate based on military rating (combat skill)
						iLoopPlayerStrength *= ComputeRatingStrengthAdjustment(eLoopPlayer);
						iLoopPlayerStrength /= 100;

						// Count teammates twice, they're more likely to defend each other
						if (IsTeammate(eLoopPlayer))
						{
							iLoopPlayerStrength *= 2;
						}

						iDPUs += iLoopPlayerStrength;
					}
					if (MOD_DIPLOMACY_CIV4_FEATURES)
					{
						if (GET_PLAYER(ePlayer).isMajorCiv())
						{
							if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsMaster(eLoopPlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(eLoopPlayer))
							{
								int iLoopPlayerStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

								// If we're an AI evaluating a human, modify their strength estimate based on difficulty level if they're reasonably strong
								if (!GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE)
								{
									iLoopPlayerStrength *= GET_PLAYER(eLoopPlayer).isHuman() ? (100 + iHumanStrengthMod) : 100;
									iLoopPlayerStrength /= 100;
								}

								// Modify their strength estimate based on military rating (combat skill)
								iLoopPlayerStrength *= ComputeRatingStrengthAdjustment(eLoopPlayer);
								iLoopPlayerStrength /= 100;

								iDPThem += iLoopPlayerStrength;
							}
						}
						if (IsMaster(eLoopPlayer) || IsVassal(eLoopPlayer))
						{
							int iLoopPlayerStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

							// If we're an AI evaluating a human, modify their strength estimate based on difficulty level if they're reasonably strong
							if (!GetPlayer()->isHuman() && !GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE)
							{
								iLoopPlayerStrength *= GET_PLAYER(eLoopPlayer).isHuman() ? (100 + iHumanStrengthMod) : 100;
								iLoopPlayerStrength /= 100;
							}

							// Modify their strength estimate based on military rating (combat skill)
							iLoopPlayerStrength *= ComputeRatingStrengthAdjustment(eLoopPlayer);
							iLoopPlayerStrength /= 100;

							iDPUs += iLoopPlayerStrength;
						}
					}
				}
			}
			if (iDPThem > 0)
			{
				iOtherPlayerMilitaryStrength += (iDPThem / 10);
			}
			if (iDPUs > 0)
			{
				iMilitaryStrength += (iDPUs / 10);
			}

			// Example: If another player has double the Military strength of us, the Ratio will be 200
			int iMilitaryRatio = iOtherPlayerMilitaryStrength * /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / max(1,iMilitaryStrength);

			// Now do the final assessment
			StrengthTypes eMilitaryStrength = STRENGTH_PATHETIC;
			if (iMilitaryRatio >= /*300*/ GC.getMILITARY_STRENGTH_IMMENSE_THRESHOLD())
				eMilitaryStrength = STRENGTH_IMMENSE;
			else if (iMilitaryRatio >= /*200*/ GC.getMILITARY_STRENGTH_POWERFUL_THRESHOLD())
				eMilitaryStrength = STRENGTH_POWERFUL;
			else if (iMilitaryRatio >= /*125*/ GC.getMILITARY_STRENGTH_STRONG_THRESHOLD())
				eMilitaryStrength = STRENGTH_STRONG;
			else if (iMilitaryRatio >= /*75*/ GC.getMILITARY_STRENGTH_AVERAGE_THRESHOLD())
				eMilitaryStrength = STRENGTH_AVERAGE;
			else if (iMilitaryRatio >= /*50*/ GC.getMILITARY_STRENGTH_POOR_THRESHOLD())
				eMilitaryStrength = STRENGTH_POOR;
			else if (iMilitaryRatio >= /*33*/ GC.getMILITARY_STRENGTH_WEAK_THRESHOLD())
				eMilitaryStrength = STRENGTH_WEAK;

			// Set the value
			SetPlayerMilitaryStrengthComparedToUs(ePlayer, eMilitaryStrength);
		}
	}
}

/// Modify military strength based on skill rating
int CvDiplomacyAI::ComputeRatingStrengthAdjustment(PlayerTypes ePlayer)
{
	if (!GET_PLAYER(ePlayer).isMajorCiv())
		return 100;
	
	int iCivRating = GET_PLAYER(ePlayer).GetMilitaryRating();
	int iAverageRating = ComputeAverageMajorMilitaryRating(/*eExcludedPlayer*/ ePlayer);

	// There are no other players - don't adjust
	if (iAverageRating == -1)
		return 100;

	// Calculate the percentage difference from the average
	int iPercentageDifference = ((iCivRating - iAverageRating) * 100) / max(iAverageRating, 1);
	if (iPercentageDifference < 0)
		iPercentageDifference *= -1; // need the absolute value

	int iRtnValue = 100;

	// If above average, apply the % difference as a positive modifier to strength, cap above at +100%
	if (iCivRating > iAverageRating)
	{
		iRtnValue = min((100 + iPercentageDifference), 200);
	}
	// If below average, apply half the % difference as a negative modifier to strength, cap below at -50%
	else if (iCivRating < iAverageRating)
	{
		iPercentageDifference /= 2;
		iRtnValue = max((100 - iPercentageDifference), 50);
	}

	return iRtnValue;
}

/// What is the average (living) major civ's military rating?
int CvDiplomacyAI::ComputeAverageMajorMilitaryRating(PlayerTypes eExcludedPlayer /* = NO_PLAYER */)
{
	int iTotalRating = 0;
	int iNumCivs = 0;
	
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (eLoopPlayer == eExcludedPlayer)
			continue;
		
		if (GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv())
		{
			iTotalRating += GET_PLAYER(eLoopPlayer).GetMilitaryRating();
			iNumCivs++;
		}
	}

	if (iNumCivs == 0)
		return -1;
	
	return (iTotalRating / iNumCivs);
}

/// Updates what our assessment is of all players' overall Economic Strength
void CvDiplomacyAI::DoUpdatePlayerEconomicStrengths()
{
	// My strength
	int iEconomicStrength = max(GetPlayer()->GetEconomicMight(), 1);

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer, /*bMyTeamIsValid*/ true) && ePlayer != GetID())
		{
			int iEconomicRatio = GET_PLAYER(ePlayer).GetEconomicMight() * /*100*/ GC.getECONOMIC_STRENGTH_RATIO_MULTIPLIER() / iEconomicStrength;

			// Now do the final assessment
			StrengthTypes eEconomicStrength = STRENGTH_PATHETIC;
			if (iEconomicRatio >= /*300*/ GC.getECONOMIC_STRENGTH_IMMENSE_THRESHOLD())
				eEconomicStrength = STRENGTH_IMMENSE;
			else if (iEconomicRatio >= /*200*/ GC.getECONOMIC_STRENGTH_POWERFUL_THRESHOLD())
				eEconomicStrength = STRENGTH_POWERFUL;
			else if (iEconomicRatio >= /*125*/ GC.getECONOMIC_STRENGTH_STRONG_THRESHOLD())
				eEconomicStrength = STRENGTH_STRONG;
			else if (iEconomicRatio >= /*75*/ GC.getECONOMIC_STRENGTH_AVERAGE_THRESHOLD())
				eEconomicStrength = STRENGTH_AVERAGE;
			else if (iEconomicRatio >= /*50*/ GC.getECONOMIC_STRENGTH_POOR_THRESHOLD())
				eEconomicStrength = STRENGTH_POOR;
			else if (iEconomicRatio >= /*33*/ GC.getECONOMIC_STRENGTH_WEAK_THRESHOLD())
				eEconomicStrength = STRENGTH_WEAK;

			// Set the value
			SetPlayerEconomicStrengthComparedToUs(ePlayer, eEconomicStrength);
		}
	}
}

/// Updates how threatening each player is militarily
void CvDiplomacyAI::DoUpdateMilitaryThreats()
{
	int iMyMilitaryStrength = GetPlayer()->GetMilitaryMight();

	// Adjust my strength based on military skill rating
	iMyMilitaryStrength *= ComputeRatingStrengthAdjustment(GetID());
	iMyMilitaryStrength /= 100;

	int iCityLoop;
	int iHumanStrengthMod = GetPlayer()->isHuman() ? 0 : max(0, GC.getGame().getHandicapInfo().getAIHumanStrengthMod()); // Ranges from 0 (Settler) to 80 (Deity)
	int iNumMajorsEver = max(1, GC.getGame().countMajorCivsEverAlive());
	int iNumMinorsEver = max(1, GC.getGame().GetNumMinorCivsEver());

	// Calculate the strength of our cities
	for (CvCity* pLoopCity = GetPlayer()->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iCityLoop))
	{
		int iCityStrengthMod = pLoopCity->GetPower();
		iCityStrengthMod *= (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage());
		iCityStrengthMod /= pLoopCity->GetMaxHitPoints();

		iCityStrengthMod *= /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD();
		iCityStrengthMod /= 100;

		iMyMilitaryStrength += iCityStrengthMod;
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			if (GetWarState(ePlayer) == WAR_STATE_NEARLY_WON)
			{
				SetMilitaryThreat(ePlayer, THREAT_NONE);
				return;
			}
			else if (GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED)
			{
				SetMilitaryThreat(ePlayer, THREAT_CRITICAL);
				return;
			}

			// Don't even evaluate pathetic opponents
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) == STRENGTH_PATHETIC)
			{
				SetMilitaryThreat(ePlayer, THREAT_NONE);
				return;
			}

			int iMilitaryThreat = GET_PLAYER(ePlayer).GetMilitaryMight();

			// Human? Strength perception is modified...
			if (GET_PLAYER(ePlayer).isHuman() && !GET_PLAYER(ePlayer).IsVassalOfSomeone() && !GET_PLAYER(ePlayer).IsNoNewWars())
			{
				if (!IsAtWar(ePlayer) || GetWarState(ePlayer) < WAR_STATE_OFFENSIVE)
				{
					iMilitaryThreat *= (100 + iHumanStrengthMod);
					iMilitaryThreat /= 100;
				}
			}

			// Adjust their strength based on military skill rating
			iMilitaryThreat *= ComputeRatingStrengthAdjustment(ePlayer);
			iMilitaryThreat /= 100;

			for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				int iCityStrengthMod = pLoopCity->GetPower();
				iCityStrengthMod *= (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage());
				iCityStrengthMod /= pLoopCity->GetMaxHitPoints();

				iCityStrengthMod *= /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD();
				iCityStrengthMod /= 100;

				iMilitaryThreat += iCityStrengthMod;
			}

			// At war: what is the current status of things?
			if (IsAtWar(ePlayer))
			{
				// War State
				switch (GetWarState(ePlayer))
				{
				case WAR_STATE_OFFENSIVE:
					iMilitaryThreat *= /*50*/ GC.getMILITARY_THREAT_WAR_STATE_OFFENSIVE();
					iMilitaryThreat /= 100;
					break;
				case WAR_STATE_CALM:
					iMilitaryThreat *= /*100*/ GC.getMILITARY_THREAT_WAR_STATE_CALM();
					iMilitaryThreat /= 100;
					break;
				case WAR_STATE_STALEMATE:
					iMilitaryThreat *= /*130*/ GC.getMILITARY_THREAT_WAR_STATE_STALEMATE();
					iMilitaryThreat /= 100;
					break;
				case WAR_STATE_DEFENSIVE:
					iMilitaryThreat *= /*180*/ GC.getMILITARY_THREAT_WAR_STATE_DEFENSIVE();
					iMilitaryThreat /= 100;
					break;
				}
			}
			// Don't factor in # of players attacked or at war with now if we ARE at war with this guy already
			else
			{
				iMilitaryThreat *= (100 + (GetPlayerNumMajorsConquered(ePlayer) * /*200*/ GC.getMILITARY_THREAT_PER_MAJOR_CONQUERED() / iNumMajorsEver));
				iMilitaryThreat /= 100;

				iMilitaryThreat *= (100 + (GetPlayerNumMinorsConquered(ePlayer) * /*100*/ GC.getMILITARY_THREAT_PER_MINOR_CONQUERED() / iNumMinorsEver));
				iMilitaryThreat /= 100;

				// Reduce the Threat (dramatically) if the player is already at war with other players
				int iWarCount = GET_PLAYER(ePlayer).GetNumDangerousMajorsAtWarWith(false, true);
				if (iWarCount > 0)
				{
					int iAtWarMod = max(-90, (/*-30*/ GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * iWarCount));
					iMilitaryThreat *= (100 + iAtWarMod);
					iMilitaryThreat /= 100;
				}
			}

			// Factor in distance
			switch (GET_PLAYER(ePlayer).GetProximityToPlayer(GetID()))
			{
			case PLAYER_PROXIMITY_NEIGHBORS:
				iMilitaryThreat *= /*150*/ GC.getMILITARY_THREAT_NEIGHBORS();
				iMilitaryThreat /= 100;
				break;
			case PLAYER_PROXIMITY_CLOSE:
				iMilitaryThreat *= /*100*/ GC.getMILITARY_THREAT_CLOSE();
				iMilitaryThreat /= 100;
				break;
			case PLAYER_PROXIMITY_FAR:
				iMilitaryThreat *= /*50*/ GC.getMILITARY_THREAT_FAR();
				iMilitaryThreat /= 100;
				break;
			case PLAYER_PROXIMITY_DISTANT:
				iMilitaryThreat *= /*25*/ GC.getMILITARY_THREAT_DISTANT();
				iMilitaryThreat /= 100;
				break;
			}

			ThreatTypes eThreat = THREAT_NONE;

			iMilitaryThreat *= /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER();
			iMilitaryThreat /= max(1, iMyMilitaryStrength);

			// Now do the final assessment
			if (iMilitaryThreat >= /*300*/ GC.getMILITARY_THREAT_CRITICAL_THRESHOLD())
				eThreat = THREAT_CRITICAL;
			else if (iMilitaryThreat >= /*200*/ GC.getMILITARY_THREAT_SEVERE_THRESHOLD())
				eThreat = THREAT_SEVERE;
			else if (iMilitaryThreat >= /*125*/ GC.getMILITARY_THREAT_MAJOR_THRESHOLD())
				eThreat = THREAT_MAJOR;
			else if (iMilitaryThreat >= /*100*/ GC.getMILITARY_THREAT_MINOR_THRESHOLD())
				eThreat = THREAT_MINOR;

			// If they're doing poorly, don't overestimate them.
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING && eThreat >= THREAT_SEVERE)
			{
				eThreat = THREAT_MAJOR;
			}

			if (IsAtWar(ePlayer))
			{
				// If we're doing well in our war against them, they can't be a critical threat.
				if (GetWarState(ePlayer) >= WAR_STATE_OFFENSIVE && eThreat >= THREAT_SEVERE)
				{
					eThreat = THREAT_MAJOR;
				}
				// But if we're doing poorly, don't underestimate them.
				else if (GetWarState(ePlayer) <= WAR_STATE_DEFENSIVE && eThreat < THREAT_SEVERE)
				{
					eThreat = THREAT_SEVERE;
				}
			}

			// Set the Threat
			SetMilitaryThreat(ePlayer, eThreat);
		}
		else
		{
			SetMilitaryThreat(ePlayer, THREAT_NONE);
		}
	}
}

/// Updates how much of a threat each player is to run amok and break everything
void CvDiplomacyAI::DoUpdateWarmongerThreats(bool bUpdateOnly)
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			if (MOD_DIPLOMACY_CIV4_FEATURES)
			{
				// Our master and all vassals don't pose any warmongering threat to us.
				if (IsVassal(eLoopPlayer) || GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
				{
					SetWarmongerThreat(eLoopPlayer, THREAT_NONE);
					continue;
				}
			}

			// Do warmonger decay
			int iDecayValue = !bUpdateOnly ? (/*200*/ GC.getWARMONGER_THREAT_PER_TURN_DECAY() * 100) : 0;

			if (!bUpdateOnly)
			{
				int iDecayModifier = 100;

				// INCREASE if he's big and nasty, less so if he's not.
				switch (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer))
				{
				case STRENGTH_IMMENSE:
				case STRENGTH_POWERFUL:
					iDecayModifier = /*75*/ GC.getWARMONGER_THREAT_APPROACH_DECAY_SMALL();
					break;
				case STRENGTH_AVERAGE:
				case STRENGTH_STRONG:
					iDecayModifier = /*150*/ GC.getWARMONGER_THREAT_APPROACH_DECAY_MEDIUM();
					break;
				case STRENGTH_WEAK:
				case STRENGTH_POOR:
				case STRENGTH_PATHETIC:
					iDecayModifier = /*225*/ GC.getWARMONGER_THREAT_APPROACH_DECAY_LARGE();
					break;
				default:
					break;
				}

				if (GC.getGame().GetGameLeagues()->IsWorldWar(GetID()) > 0)
				{
					iDecayModifier *= /*200*/ GC.getWARMONGER_THREAT_PER_TURN_DECAY_INCREASED();
					iDecayModifier /= 100;
				}
				else if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(GetID()) > 0)
				{
					iDecayModifier *= /*50*/ GC.getWARMONGER_THREAT_PER_TURN_DECAY_DECREASED();
					iDecayModifier /= 100;
				}

				iDecayValue *= iDecayModifier;
				iDecayValue /= 100;

				iDecayValue = min(iDecayValue, -100); // Make sure it decays by at least -1 every turn

				ChangeOtherPlayerWarmongerAmountTimes100(eLoopPlayer, iDecayValue); 
			}

			ThreatTypes eThreatType = THREAT_NONE;
			int iThreatValue = GetOtherPlayerWarmongerScore(eLoopPlayer);

			// Now do the final assessment
			if (iThreatValue >= /*160*/ GC.getWARMONGER_THREAT_CRITICAL_THRESHOLD())
				eThreatType = THREAT_CRITICAL;
			else if (iThreatValue >= /*80*/ GC.getWARMONGER_THREAT_SEVERE_THRESHOLD())
				eThreatType = THREAT_SEVERE;
			else if (iThreatValue >= /*40*/ GC.getWARMONGER_THREAT_MAJOR_THRESHOLD())
				eThreatType = THREAT_MAJOR;
			else if (iThreatValue >= /*10*/ GC.getWARMONGER_THREAT_MINOR_THRESHOLD())
				eThreatType = THREAT_MINOR;

			// Also test % of players killed (in case we're on a map with very few players or something)
			int iNumPlayersEver = GC.getGame().countMajorCivsEverAlive();
			int iNumPlayersKilled = GetPlayerNumMajorsConquered(eLoopPlayer) + (GetPlayerNumMinorsConquered(eLoopPlayer)/2);

			if (eThreatType != THREAT_CRITICAL && iNumPlayersEver <= 4 && iNumPlayersKilled > 0)
			{
				int iPlayersKilledPercent = iNumPlayersKilled * 100 / max(1, iNumPlayersEver);

				if (iPlayersKilledPercent >= /*40*/ GC.getWARMONGER_THREAT_CRITICAL_PERCENT_THRESHOLD())
					eThreatType = THREAT_CRITICAL;

				else if (iPlayersKilledPercent >= /*25*/ GC.getWARMONGER_THREAT_SEVERE_PERCENT_THRESHOLD())
					eThreatType = THREAT_SEVERE;
			}

			// Set the Threat
			bool bUpdateLogsSpecial = false;
			if (eThreatType != GetWarmongerThreat(eLoopPlayer))
			{
				SetWarmongerThreat(eLoopPlayer, eThreatType);
				bUpdateLogsSpecial = true;
			}

			// Skip updating the logs if threat is zero and nothing has changed
			if (!bUpdateLogsSpecial && eThreatType == THREAT_NONE && GetOtherPlayerWarmongerAmount(eLoopPlayer) == 0)
				continue;

			LogMajorCivWarmongerUpdate(eLoopPlayer, iDecayValue, bUpdateLogsSpecial);
		}
		else
		{
			SetWarmongerThreat(eLoopPlayer, THREAT_NONE);
		}
	}
}

/// Updates what our assessment is of all players' value as a military target
void CvDiplomacyAI::DoUpdatePlayerTargetValues()
{
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			TargetValueTypes eTargetValue = NO_TARGET_VALUE;

			int iMyMilitaryStrength = GetPlayerOverallStrengthEstimate(GetID(), ePlayer, true);
			int iOtherPlayerMilitaryStrength = GetPlayerOverallStrengthEstimate(ePlayer, GetID(), false);

			// Example: If another player has double the Military strength of us, the Ratio will be 200
			int iMilitaryRatio = iOtherPlayerMilitaryStrength * /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / max(1,iMyMilitaryStrength);

			// Factor in distance
			switch (GetPlayer()->GetProximityToPlayer(ePlayer))
			{
			case PLAYER_PROXIMITY_NEIGHBORS:
				iMilitaryRatio += /*-10*/ GC.getTARGET_NEIGHBORS();
				break;
			case PLAYER_PROXIMITY_CLOSE:
				iMilitaryRatio += /*0*/ GC.getTARGET_CLOSE();
				break;
			case PLAYER_PROXIMITY_FAR:
				iMilitaryRatio += /*30*/ GC.getTARGET_FAR();
				break;
			case PLAYER_PROXIMITY_DISTANT:
				iMilitaryRatio += /*80*/ GC.getTARGET_DISTANT();
				break;
			}

			// Now do the final assessment
			if (iMilitaryRatio >= /*200*/ GC.getTARGET_IMPOSSIBLE_THRESHOLD())
				eTargetValue = TARGET_VALUE_IMPOSSIBLE;
			else if (iMilitaryRatio >= /*125*/ GC.getTARGET_BAD_THRESHOLD())
				eTargetValue = TARGET_VALUE_BAD;
			else if (iMilitaryRatio >= /*80*/ GC.getTARGET_AVERAGE_THRESHOLD())
				eTargetValue = TARGET_VALUE_AVERAGE;
			else if (iMilitaryRatio >= /*50*/ GC.getTARGET_FAVORABLE_THRESHOLD())
				eTargetValue = TARGET_VALUE_FAVORABLE;
			else
				eTargetValue = TARGET_VALUE_SOFT;

			// Set the value
			SetPlayerTargetValue(ePlayer, eTargetValue);
		}
	}
}

int CvDiplomacyAI::GetPlayerOverallStrengthEstimate(PlayerTypes ePlayer, PlayerTypes eComparedToPlayer, bool bSelfEvaluation)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	if (eComparedToPlayer < 0 || eComparedToPlayer >= MAX_CIV_PLAYERS) return 0;

	int iHumanStrengthMod = max(0, GC.getGame().getHandicapInfo().getAIHumanStrengthMod()); // Ranges from 0 (Settler) to 80 (Deity)

	// First calculate this power's military power
	int iStrengthEstimate = GET_PLAYER(ePlayer).GetMilitaryMight();

	// Human? Strength perception is modified...
	if (GET_PLAYER(ePlayer).isHuman() && !bSelfEvaluation && !GET_PLAYER(ePlayer).IsVassalOfSomeone() && !GET_PLAYER(ePlayer).IsNoNewWars())
	{
		if (!GET_PLAYER(ePlayer).IsAtWarWith(eComparedToPlayer) || GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetWarState(ePlayer) < WAR_STATE_OFFENSIVE)
		{
			iStrengthEstimate *= (100 + iHumanStrengthMod);
			iStrengthEstimate /= 100;
		}
	}

	// Major Civ? Modify their strength estimate based on military rating (combat skill)
	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		iStrengthEstimate *= ComputeRatingStrengthAdjustment(ePlayer);
		iStrengthEstimate /= 100;
	}

	// Now add in this player's economic power
	iStrengthEstimate += GET_PLAYER(ePlayer).GetEconomicMight();

	// City Defensive Strength
	int iCityLoop = 0;
	for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
	{
		int iHitpoints = pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage();
		int iPower = (pLoopCity->GetPower() * iHitpoints) / pLoopCity->GetMaxHitPoints();
		iStrengthEstimate += (iPower * /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD()) / 100;
	}

	// Decrease target value if the player is already at war with other players
	int iWarCount = (bSelfEvaluation && !GetPlayer()->isHuman()) ? GET_PLAYER(ePlayer).GetNumDangerousMajorsAtWarWith(true, true) : GET_PLAYER(ePlayer).GetNumDangerousMajorsAtWarWith(false, true);

	// Reduce by 1 if WE'RE already at war with him or he with us
	if (GET_PLAYER(ePlayer).IsAtWarWith(eComparedToPlayer))
		iWarCount--;

	if (iWarCount > 0)
	{
		int iScale = max(20, 100 - iWarCount * /*30*/ GC.getTARGET_ALREADY_WAR_EACH_PLAYER());
		iStrengthEstimate *= iScale;
		iStrengthEstimate /= 100;
	}

	// Who else would we go to war with?
	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		vector<PlayerTypes> vPlayersToCheck;

		if (GET_PLAYER(eComparedToPlayer).isMajorCiv())
		{
			vector<PlayerTypes> vLinkedWarPlayers = bSelfEvaluation ? GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetLinkedWarPlayers(ePlayer, false, true, true) : GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetLinkedWarPlayers(ePlayer, false, true, false);

			// If this is a self-evaluation, also factor in our coop wars
			if (bSelfEvaluation)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(eComparedToPlayer).getTeam())
					{
						if (GetCoopWarState(eLoopPlayer, eComparedToPlayer) >= COOP_WAR_STATE_PREPARING)
						{
							if (std::find(vLinkedWarPlayers.begin(), vLinkedWarPlayers.end(), eLoopPlayer) == vLinkedWarPlayers.end())
							{
								vLinkedWarPlayers.push_back(eLoopPlayer);
							}
						}
					}
				}
			}

			for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
			{
				vPlayersToCheck.push_back(*it);
			}
		}
		else
		{
			vector<PlayerTypes> vLinkedWarPlayers = GET_TEAM(GetTeam()).getPlayers();
			vector<PlayerTypes> vMinorsToCheck;

			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(eComparedToPlayer).getTeam())
				{
					if (GET_PLAYER(eLoopPlayer).isMajorCiv())
					{
						if (IsMaster(eLoopPlayer) || IsVassal(eLoopPlayer))
						{
							vLinkedWarPlayers.push_back(eLoopPlayer);
						}
					}
					else if (GET_PLAYER(eLoopPlayer).isMinorCiv())
					{
						PlayerTypes eAlly = GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly();

						if (eAlly == NO_PLAYER || GET_PLAYER(eAlly).getTeam() == GetTeam())
							continue;

						vMinorsToCheck.push_back(eAlly);
					}
				}
			}

			for (std::vector<PlayerTypes>::iterator it = vMinorsToCheck.begin(); it != vMinorsToCheck.end(); it++)
			{
				PlayerTypes eAlly = GET_PLAYER(*it).GetMinorCivAI()->GetAlly();

				if (std::find(vLinkedWarPlayers.begin(), vLinkedWarPlayers.end(), eAlly) != vLinkedWarPlayers.end())
				{
					vLinkedWarPlayers.push_back(*it);
				}
			}

			for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
			{
				vPlayersToCheck.push_back(*it);
			}
		}

		for (std::vector<PlayerTypes>::iterator it = vPlayersToCheck.begin(); it != vPlayersToCheck.end(); it++)
		{
			int iThirdPartyValue = 0;
			StrengthTypes eThirdPartyStrength = GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(*it);
			PlayerProximityTypes eThirdPartyProximity = GET_PLAYER(*it).GetProximityToPlayer(eComparedToPlayer);

			// Major civ?
			if (GET_PLAYER(*it).isMajorCiv())
			{
				// If this guy is doing very badly, he's not going to be good backup
				if (GET_PLAYER(*it).IsNoNewWars())
					continue;

				// How strong is this friend compared to the other guy?
				switch (eThirdPartyStrength)
				{
				case STRENGTH_PATHETIC:
					iThirdPartyValue = /*0*/ GC.getTARGET_MAJOR_BACKUP_PATHETIC();
					break;
				case STRENGTH_WEAK:
					iThirdPartyValue = /*5*/ GC.getTARGET_MAJOR_BACKUP_WEAK();
					break;
				case STRENGTH_POOR:
					iThirdPartyValue = /*10*/ GC.getTARGET_MAJOR_BACKUP_POOR();
					break;
				case STRENGTH_AVERAGE:
					iThirdPartyValue = /*15*/ GC.getTARGET_MAJOR_BACKUP_AVERAGE();
					break;
				case STRENGTH_STRONG:
					iThirdPartyValue = /*25*/ GC.getTARGET_MAJOR_BACKUP_STRONG();
					break;
				case STRENGTH_POWERFUL:
					iThirdPartyValue = /*35*/ GC.getTARGET_MAJOR_BACKUP_POWERFUL();
					break;
				case STRENGTH_IMMENSE:
					iThirdPartyValue = /*50*/ GC.getTARGET_MAJOR_BACKUP_IMMENSE();
					break;
				}

				// How close is this friend to the other guy?
				switch (eThirdPartyProximity)
				{
				case PLAYER_PROXIMITY_DISTANT:
					iThirdPartyValue *= /*0*/ GC.getTARGET_MAJOR_BACKUP_DISTANT();
					break;
				case PLAYER_PROXIMITY_FAR:
					iThirdPartyValue *= /*50*/ GC.getTARGET_MAJOR_BACKUP_FAR();
					break;
				case PLAYER_PROXIMITY_CLOSE:
					iThirdPartyValue *= /*100*/ GC.getTARGET_MAJOR_BACKUP_CLOSE();
					break;
				case PLAYER_PROXIMITY_NEIGHBORS:
					iThirdPartyValue *= /*200*/ GC.getTARGET_MAJOR_BACKUP_NEIGHBORS();
					break;
				}

				iThirdPartyValue /= 100;

				// Calculate this player's perceived military power
				int iMight = GET_PLAYER(*it).GetMilitaryMight();

				// Human? Strength perception is modified...
				if (GET_PLAYER(*it).isHuman() && !GET_PLAYER(*it).IsVassalOfSomeone())
				{
					if (!GET_PLAYER(*it).IsAtWarWith(eComparedToPlayer) || GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetWarState(*it) < WAR_STATE_OFFENSIVE)
					{
						iMight *= (100 + iHumanStrengthMod);
						iMight /= 100;
					}
				}

				// Modify based on military rating (combat skill)
				iMight *= ComputeRatingStrengthAdjustment(*it);
				iMight /= 100;

				// Reduce if the third party is already at war with other players
				int iThirdPartyWarCount = (bSelfEvaluation && !GET_PLAYER(*it).isHuman()) ? GET_PLAYER(*it).GetNumDangerousMajorsAtWarWith(true, true) : GET_PLAYER(*it).GetNumDangerousMajorsAtWarWith(false, true);

				if (GET_PLAYER(eComparedToPlayer).IsAtWarWith(*it))
					iThirdPartyWarCount--;

				if (iThirdPartyWarCount > 0)
				{
					int iScale = max(20, 100 - iThirdPartyWarCount * /*30*/ GC.getTARGET_ALREADY_WAR_EACH_PLAYER());
					iMight *= iScale;
					iMight /= 100;
				}

				// Add a % of the military might of this friend in to the overall eval
				iStrengthEstimate += (iThirdPartyValue * iMight / 100);
			}
			else
			{
				// Ignore if they're already at war with somebody else
				int iThirdPartyWarCount = GET_PLAYER(*it).GetNumDangerousMajorsAtWarWith(false, false) > 0;

				if (GET_PLAYER(eComparedToPlayer).IsAtWarWith(*it))
					iThirdPartyWarCount--;

				if (iThirdPartyWarCount > 0)
					continue;

				// How strong is this City-State ally compared to the other guy?
				switch (eThirdPartyStrength)
				{
				case STRENGTH_PATHETIC:
					iThirdPartyValue = /*0*/ GC.getTARGET_MINOR_BACKUP_PATHETIC();
					break;
				case STRENGTH_WEAK:
					iThirdPartyValue = /*0*/ GC.getTARGET_MINOR_BACKUP_WEAK();
					break;
				case STRENGTH_POOR:
					iThirdPartyValue = /*0*/ GC.getTARGET_MINOR_BACKUP_POOR();
					break;
				case STRENGTH_AVERAGE:
					iThirdPartyValue = /*15*/ GC.getTARGET_MINOR_BACKUP_AVERAGE();
					break;
				case STRENGTH_STRONG:
					iThirdPartyValue = /*25*/ GC.getTARGET_MINOR_BACKUP_STRONG();
					break;
				case STRENGTH_POWERFUL:
					iThirdPartyValue = /*35*/ GC.getTARGET_MINOR_BACKUP_POWERFUL();
					break;
				case STRENGTH_IMMENSE:
					iThirdPartyValue = /*50*/ GC.getTARGET_MINOR_BACKUP_IMMENSE();
					break;
				}

				// How close is this City-State ally to the other guy?
				switch (eThirdPartyProximity)
				{
				case PLAYER_PROXIMITY_DISTANT:
					iThirdPartyValue *= /*0*/ GC.getTARGET_MINOR_BACKUP_DISTANT();
					break;
				case PLAYER_PROXIMITY_FAR:
					iThirdPartyValue *= /*0*/ GC.getTARGET_MINOR_BACKUP_FAR();
					break;
				case PLAYER_PROXIMITY_CLOSE:
					iThirdPartyValue *= /*50*/ GC.getTARGET_MINOR_BACKUP_CLOSE();
					break;
				case PLAYER_PROXIMITY_NEIGHBORS:
					iThirdPartyValue *= /*100*/ GC.getTARGET_MINOR_BACKUP_NEIGHBORS();
					break;
				}

				iThirdPartyValue /= 100;

				// Add a % of the military might of this City-State ally in to the overall eval
				iStrengthEstimate += (iThirdPartyValue * GET_PLAYER(*it).GetMilitaryMight() / 100);
			}
		}
	}
	// If this City-State has an ally, assume they'll defend it.
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		PlayerTypes eAlly = GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly();

		if (GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->IsPlayerValid(eAlly))
		{
			vector<PlayerTypes> vAllyTeam = GET_TEAM(GET_PLAYER(eAlly).getTeam()).getPlayers();
			for (size_t i=0; i<vAllyTeam.size(); i++)
			{
				PlayerTypes eAllyPlayer = (PlayerTypes) vAllyTeam[i];
				CvPlayerAI& kPlayer = GET_PLAYER(eAllyPlayer);

				if (!kPlayer.isAlive())
					continue;

				if (kPlayer.getNumCities() <= 0)
					continue;

				if (kPlayer.IsNoNewWars())
					continue;

				int iThirdPartyValue = 0;
				StrengthTypes eThirdPartyStrength = GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eAllyPlayer);
				PlayerProximityTypes eThirdPartyProximity = kPlayer.GetProximityToPlayer(eComparedToPlayer);

				// How strong is this friend compared to the other guy?
				switch (eThirdPartyStrength)
				{
				case STRENGTH_PATHETIC:
					iThirdPartyValue = /*0*/ GC.getTARGET_MAJOR_BACKUP_PATHETIC();
					break;
				case STRENGTH_WEAK:
					iThirdPartyValue = /*5*/ GC.getTARGET_MAJOR_BACKUP_WEAK();
					break;
				case STRENGTH_POOR:
					iThirdPartyValue = /*10*/ GC.getTARGET_MAJOR_BACKUP_POOR();
					break;
				case STRENGTH_AVERAGE:
					iThirdPartyValue = /*15*/ GC.getTARGET_MAJOR_BACKUP_AVERAGE();
					break;
				case STRENGTH_STRONG:
					iThirdPartyValue = /*25*/ GC.getTARGET_MAJOR_BACKUP_STRONG();
					break;
				case STRENGTH_POWERFUL:
					iThirdPartyValue = /*35*/ GC.getTARGET_MAJOR_BACKUP_POWERFUL();
					break;
				case STRENGTH_IMMENSE:
					iThirdPartyValue = /*50*/ GC.getTARGET_MAJOR_BACKUP_IMMENSE();
					break;
				}

				// How close is this friend to the other guy?
				switch (eThirdPartyProximity)
				{
				case PLAYER_PROXIMITY_DISTANT:
					iThirdPartyValue *= /*0*/ GC.getTARGET_MAJOR_BACKUP_DISTANT();
					break;
				case PLAYER_PROXIMITY_FAR:
					iThirdPartyValue *= /*50*/ GC.getTARGET_MAJOR_BACKUP_FAR();
					break;
				case PLAYER_PROXIMITY_CLOSE:
					iThirdPartyValue *= /*100*/ GC.getTARGET_MAJOR_BACKUP_CLOSE();
					break;
				case PLAYER_PROXIMITY_NEIGHBORS:
					iThirdPartyValue *= /*200*/ GC.getTARGET_MAJOR_BACKUP_NEIGHBORS();
					break;
				}

				iThirdPartyValue /= 100;

				// Calculate this player's perceived military power
				int iMight = kPlayer.GetMilitaryMight();

				// Human? Strength perception is modified...
				if (kPlayer.isHuman() && !kPlayer.IsVassalOfSomeone())
				{
					if (!kPlayer.IsAtWarWith(eComparedToPlayer) || GET_PLAYER(eComparedToPlayer).GetDiplomacyAI()->GetWarState(eAllyPlayer) < WAR_STATE_OFFENSIVE)
					{
						iMight *= (100 + iHumanStrengthMod);
						iMight /= 100;
					}
				}

				// Modify based on military rating (combat skill)
				iMight *= ComputeRatingStrengthAdjustment(eAllyPlayer);
				iMight /= 100;

				// Add a % of the military might of this friend in to the overall eval
				iStrengthEstimate += (iThirdPartyValue * iMight / 100);
			}
		}
	}

	return iStrengthEstimate;
}

/// Updates what the Projection of war is with all players
void CvDiplomacyAI::DoUpdateWarProjections()
{
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			int iWarScore = IsAtWar(eLoopPlayer) ? GetWarScore(eLoopPlayer) : GetWarScore(eLoopPlayer, /*bUsePeacetimeCalculation*/ true);
			WarProjectionTypes eWarProjection = WAR_PROJECTION_UNKNOWN;

			if (iWarScore >= /*60*/ GC.getWAR_PROJECTION_THRESHOLD_VERY_GOOD())
				eWarProjection = WAR_PROJECTION_VERY_GOOD;
			else if (iWarScore >= /*30*/ GC.getWAR_PROJECTION_THRESHOLD_GOOD())
				eWarProjection = WAR_PROJECTION_GOOD;
			else if (iWarScore <= /*-50*/ GC.getWAR_PROJECTION_THRESHOLD_DESTRUCTION())
				eWarProjection = WAR_PROJECTION_DESTRUCTION;
			else if (iWarScore <= /*-30*/ GC.getWAR_PROJECTION_THRESHOLD_DEFEAT())
				eWarProjection = WAR_PROJECTION_DEFEAT;
			else if (iWarScore <= /*0*/ GC.getWAR_PROJECTION_THRESHOLD_STALEMATE())
				eWarProjection = WAR_PROJECTION_STALEMATE;

			// If they're a bad target then the best we can do is unknown
			if (eWarProjection >= WAR_PROJECTION_GOOD && GetPlayerTargetValue(eLoopPlayer) <= TARGET_VALUE_BAD)
			{
				eWarProjection = WAR_PROJECTION_UNKNOWN;
			}
			if (IsAtWar(eLoopPlayer) && (eWarProjection < WAR_PROJECTION_STALEMATE))
			{
				MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WINNING_WARS");

				// Can't be imminent destruction if we are winning wars.		
				if (GetPlayer()->GetMilitaryAI()->IsUsingStrategy(eStrategy))
				{
					eWarProjection = WAR_PROJECTION_STALEMATE;
				}
				// Can't be imminent destruction if none of our cities is in danger at the moment
				else if (GetNumberOfThreatenedCities(eLoopPlayer) == 0)
				{
					eWarProjection = WAR_PROJECTION_STALEMATE;
				}
			}

			// Set the War Projection
			SetWarProjection(eLoopPlayer, eWarProjection);
		}
		else
		{
			SetWarProjection(eLoopPlayer, WAR_PROJECTION_UNKNOWN);
		}
	}
}

int CvDiplomacyAI::GetNumberOfThreatenedCities(PlayerTypes ePlayer)
{
	int iCountCitiesInDanger = 0;

	int iCityLoop;
	for (const CvCity* pFriendlyCity = GetPlayer()->firstCity(&iCityLoop); pFriendlyCity != NULL; pFriendlyCity = GetPlayer()->nextCity(&iCityLoop))
	{
		if (pFriendlyCity->IsInDanger(ePlayer))
			iCountCitiesInDanger++;
	}

	return iCountCitiesInDanger;
}

/// Updates whether all players are easy attack targets
void CvDiplomacyAI::DoUpdateEasyTargets()
{
	int iCurrentWars = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			// First check the war state
			WarStateTypes eWarState = GetWarState(ePlayer);

			if (eWarState == WAR_STATE_NEARLY_WON)
			{
				SetEasyTarget(ePlayer, true);
				continue;
			}

			if (eWarState == WAR_STATE_DEFENSIVE || eWarState == WAR_STATE_NEARLY_DEFEATED)
			{
				SetEasyTarget(ePlayer, false);
				continue;
			}

			// If we're doing very badly, they can't be an easy target
			if (GetPlayer()->IsNoNewWars())
			{
				SetEasyTarget(ePlayer, false);
				continue;
			}

			// Nuclear Gandhi sees vulnerability in his opponents...
			if (GC.getGame().IsNuclearGandhiEnabled() && !GetPlayer()->isHuman() && GetPlayer()->GetPlayerTraits()->GetCityUnhappinessModifier() != 0 && GetPlayer()->getNumNukeUnits() > 0)
			{
				SetEasyTarget(ePlayer, true);
				continue;
			}

			// If they're too dangerous, they can't be an easy target
			if (GetMilitaryThreat(ePlayer) >= THREAT_SEVERE)
			{
				SetEasyTarget(ePlayer, false);
				continue;
			}

			// If they're too far away, they can't be an easy target
			if (GetPlayer()->GetProximityToPlayer(ePlayer) <= PLAYER_PROXIMITY_FAR)
			{
				SetEasyTarget(ePlayer, false);
				continue;
			}

			// If we've been at war for a while without capturing any of their cities, they can't be an easy target
			if (GetPlayerNumTurnsAtWar(ePlayer) >= 30 && GetPlayerNumTurnsSinceCityCapture(ePlayer) >= 30)
			{
				SetEasyTarget(ePlayer, false);
				continue;
			}

			// Minor civ
			if (GET_PLAYER(ePlayer).isMinorCiv())
			{
				if (GetBoldness() > 6)
				{
					if (GetPlayerTargetValue(ePlayer) >= TARGET_VALUE_AVERAGE)
					{
						SetEasyTarget(ePlayer, true);
						continue;
					}
					else
					{
						SetEasyTarget(ePlayer, false);
						continue;
					}
				}
				else
				{
					if (GetPlayerTargetValue(ePlayer) >= TARGET_VALUE_FAVORABLE)
					{
						SetEasyTarget(ePlayer, true);
						continue;
					}
					else
					{
						SetEasyTarget(ePlayer, false);
						continue;
					}
				}
			}

			// If we're at a stalemate or defensive in a war against any other players, they can't be an easy target
			bool bValueSet = false;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Don't look at the guy we're already thinking about
				if (IsPlayerValid(eLoopPlayer) && ePlayer != eLoopPlayer && IsAtWar(eLoopPlayer))
				{
					// Ignore phony wars
					if (IsPhonyWar(ePlayer))
					{
						continue;
					}

					if (GET_PLAYER(ePlayer).isMinorCiv()) // caution requirement is lower for City-States
					{
						if (GetWarState(eLoopPlayer) <= WAR_STATE_DEFENSIVE)
						{
							SetEasyTarget(ePlayer, false);
							bValueSet = true;
							break;
						}
					}
					else
					{
						if (GetWarState(eLoopPlayer) <= WAR_STATE_DEFENSIVE)
						{
							SetEasyTarget(ePlayer, false);
							bValueSet = true;
							break;
						}
						else if (!GET_PLAYER(eLoopPlayer).IsNoNewWars() && GetWarState(eLoopPlayer) <= WAR_STATE_CALM) // if we're at a stalemate in this war, don't open ourselves up to dogpiling
						{
							SetEasyTarget(ePlayer, false);
							bValueSet = true;
							break;
						}
					}
				}
			}

			if (bValueSet)
				continue;

			// They're doing very badly! Let's strike!
			if (GET_PLAYER(ePlayer).IsNoNewWars())
			{
				SetEasyTarget(ePlayer, true);
				continue;
			}

			// Okay, now let's compare our strengths...
			StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
			StrengthTypes eEconomicStrength = GetPlayerEconomicStrengthComparedToUs(ePlayer);

			if (GetPlayerTargetValue(ePlayer) == TARGET_VALUE_SOFT || GetWarProjection(ePlayer) == WAR_PROJECTION_VERY_GOOD || eMilitaryStrength == STRENGTH_PATHETIC || eEconomicStrength == STRENGTH_PATHETIC)
			{
				SetEasyTarget(ePlayer, true);
				continue;
			}

			// More likely to attack players who are unhappy, if we're not.
			bool bUnhappinessBoost = (GET_PLAYER(ePlayer).IsEmpireUnhappy() && !GetPlayer()->IsEmpireUnhappy());

			bool bWantsConquest = (IsGoingForWorldConquest() || IsCloseToDominationVictory());
			bWantsConquest |= (GetWarProjection(ePlayer) == WAR_PROJECTION_GOOD && GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE);
			bWantsConquest |= IsLockedIntoCoopWar(ePlayer);
			bWantsConquest |= IsPlayerRecklessExpander(ePlayer);
			bWantsConquest |= IsPlayerWonderSpammer(ePlayer);
			bWantsConquest |= IsEndgameAggressiveTo(ePlayer);
			bWantsConquest |= (GetBiggestCompetitor() == ePlayer);

			bool bAlreadyAtWar = !IsAtWar(ePlayer) && iCurrentWars > 0;

			// Compare military and economic strengths to look for opportunities to strike
			// We sense more opportunities to attack people we want to conquer, or those who are unhappy
			if (!bAlreadyAtWar && (bWantsConquest || bUnhappinessBoost))
			{
				if (eMilitaryStrength <= STRENGTH_POOR && eEconomicStrength <= STRENGTH_STRONG)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
				if (eMilitaryStrength <= STRENGTH_WEAK && eEconomicStrength <= STRENGTH_POWERFUL)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
				if (eEconomicStrength <= STRENGTH_POOR && eMilitaryStrength <= STRENGTH_STRONG)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
				if (eEconomicStrength <= STRENGTH_WEAK && eMilitaryStrength <= STRENGTH_POWERFUL)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
			}
			else
			{
				if (eMilitaryStrength <= STRENGTH_WEAK && eEconomicStrength <= STRENGTH_AVERAGE)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
				if (eEconomicStrength <= STRENGTH_WEAK && eMilitaryStrength <= STRENGTH_AVERAGE)
				{
					SetEasyTarget(ePlayer, true);
					continue;
				}
			}

			SetEasyTarget(ePlayer, false);
		}
		else
		{
			SetEasyTarget(ePlayer, false);
		}
	}
}

/// Updates what the Goal of war is with all players
void CvDiplomacyAI::DoUpdateWarGoals()
{
	CvCity* pCapital = GetPlayer()->getCapitalCity();

	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE) || pCapital == NULL)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if (IsAtWar(eLoopPlayer))
			{
				SetWarGoal(eLoopPlayer, WAR_GOAL_CONQUEST);
			}
			else
			{
				SetWarGoal(eLoopPlayer, NO_WAR_GOAL_TYPE);
			}
		}
		return;
	}

	bool bMakePeaceWithAllMinors = false;
	bool bWorldConquest = (IsGoingForWorldConquest() || IsCloseToDominationVictory());

	// If a major civ is giving us trouble, don't waste our time fighting City-States...
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if (IsPlayerValid(eLoopPlayer) && IsAtWar(eLoopPlayer))
		{
			if (!IsPhonyWar(eLoopPlayer) && GetWarState(eLoopPlayer) <= WAR_STATE_DEFENSIVE)
			{
				bMakePeaceWithAllMinors = true;
				break;
			}
		}
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			// We're someone's vassal?
			if (GetPlayer()->IsVassalOfSomeone())
			{
				if (IsAtWar(ePlayer))
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				else
					SetWarGoal(ePlayer, NO_WAR_GOAL_TYPE);

				continue;
			}

			WarGoalTypes eCurrentGoal = GetWarGoal(ePlayer);
			bool bMajor = GET_PLAYER(ePlayer).isMajorCiv();

			// Not at war? If our goal is PREPARE or DEMAND, then leave it be...otherwise reset it
			if (!IsAtWar(ePlayer))
			{
				if (eCurrentGoal != WAR_GOAL_PREPARE && eCurrentGoal != WAR_GOAL_DEMAND)
				{
					SetWarGoal(ePlayer, NO_WAR_GOAL_TYPE);
				}
				continue;
			}

			int iWarScore = GetWarScore(ePlayer);
			bool bCapturedKeyCity = IsCapitalCapturedBy(ePlayer, true, false) || IsHolyCityCapturedBy(ePlayer, true, false);
			bool bPhonyWar = IsPhonyWar(ePlayer);
			bool bWarApproach = bMajor ? GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_WAR : GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_CONQUEST;

			bool bReadyForVassalage = false;
			if (bMajor)
			{
				if (!bCapturedKeyCity && iWarScore >= 90 && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canBecomeVassal(GetTeam()))
				{
					if (!bWorldConquest || GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
					{
						bReadyForVassalage = true;
					}
				}
			}

			bool bConsiderPeace = GetWarState(ePlayer) <= WAR_STATE_DEFENSIVE;
			bConsiderPeace |= bReadyForVassalage;
			bConsiderPeace |= GetStateAllWars() == STATE_ALL_WARS_LOSING;
			bConsiderPeace |= GetPlayer()->IsEmpireVeryUnhappy();
			bConsiderPeace |= GetPlayerNumTurnsAtWar(ePlayer) >= 30 && GetPlayerNumTurnsSinceCityCapture(ePlayer) >= 30;
			bConsiderPeace |= bMajor && GetPlayer()->GetCulture()->GetWarWeariness() > GetPlayerNumTurnsAtWar(ePlayer);
			bConsiderPeace |= bMajor && bPhonyWar;

			bool bCriticalState = GetPlayer()->IsEmpireSuperUnhappy();
			bCriticalState |= GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED;

			if (pCapital->isInDangerOfFalling())
			{
				bCriticalState = true;
			}
			else if (pCapital->getDamage() >= (pCapital->GetMaxHitPoints()*2/3))
			{
				bCriticalState = true;
			}
			else if (pCapital->isUnderSiege() || pCapital->IsBlockadedWaterAndLand())
			{
				bConsiderPeace = true;
			}

			// If game options are configured in such a way that making peace with this player would lock us out of Domination Victory, let's not make peace (unless we have to).
			if (bWorldConquest && eCurrentGoal != WAR_GOAL_PEACE && !bCriticalState && GC.getGame().WouldMakingPeacePreventDominationVictory(GetID(), ePlayer))
			{
				SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				continue;
			}

			// Locked into war?
			if (GetPlayer()->IsAITeammateOfHuman())
			{
				SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				continue;
			}
			else if (IsLockedIntoCoopWar(ePlayer))
			{
				if (GetGlobalCoopWarAgainstState(ePlayer) >= COOP_WAR_STATE_PREPARING) // Coop war? We're out for conquest!
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				}
				else if (!bWarApproach) // If we were bribed into war or something, let's just damage.
				{
					SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
				}
				continue;
			}
			// Peace blocked for some other reason?
			else if (!GET_TEAM(GetTeam()).canChangeWarPeace(GET_PLAYER(ePlayer).getTeam()))
			{
				// Is this a City-State?
				if (!bMajor)
				{
					if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsPermanentWar(GetTeam()))
					{
						SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					}
					else if (GetPeaceBlockReason(ePlayer) == 7) // We are at war with their ally...we have bigger fish to fry
					{
						SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
					}
					continue;
				}

				// Must be some game options thing...go for conquest
				SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				continue;
			}
			// Too soon to make peace?
			else if (GetPeaceBlockReason(ePlayer) == 3 && !bCriticalState)
			{
				if (bWarApproach || IsAggressor(ePlayer))
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
				}
				else
				{
					SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
				}
				continue;
			}

			// If our situation is critical, we want to make peace
			if (bCriticalState)
			{
				SetWarGoal(ePlayer, WAR_GOAL_PEACE);
				continue;
			}

			// City-State
			if (!bMajor)
			{
				// If this is a City-State and we're preoccupied or not in good shape, let's peace out.
				if (bMakePeaceWithAllMinors || bConsiderPeace)
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// Conquest is always our goal with City-States if we have the right approach
				if (bWarApproach)
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					continue;
				}

				// Positive war state? Let's conquer them.
				if (GetWarState(ePlayer) >= WAR_STATE_OFFENSIVE)
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					continue;
				}

				// Otherwise, just damage
				SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
				continue;
			}

			// Okay, so this is a major civ and we're not locked into war, we have some choice here...
			if (!bConsiderPeace)
			{
				// We hate them and want to destroy them!
				if (IsWantsToConquer(ePlayer) || IsUntrustworthy(ePlayer) || bCapturedKeyCity)
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					continue;
				}

				SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
			}
			// Let's consider peace.
			else
			{
				// But not if we're about to win!
				if (!bReadyForVassalage && GetWarState(ePlayer) == WAR_STATE_NEARLY_WON)
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					continue;
				}

				// Our capital is at half or less HP! Let's make peace.
				if (pCapital->getDamage() >= (pCapital->GetMaxHitPoints()/2))
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// We don't want to be at war anymore, so let's open ourselves to peace.
				if (bPhonyWar || bReadyForVassalage)
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// Approach isn't war anymore and we're at a stalemate, let's make peace.
				if (!bWarApproach && GetWarState(ePlayer) <= WAR_STATE_STALEMATE)
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// We're very unhappy and war weary, let's make peace.
				if (GetPlayer()->GetCulture()->GetWarWeariness() > 0 && GetPlayer()->IsEmpireVeryUnhappy())
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// We're losing all our wars, let's make peace.
				if (GetStateAllWars() == STATE_ALL_WARS_LOSING)
				{
					SetWarGoal(ePlayer, WAR_GOAL_PEACE);
					continue;
				}

				// We're losing too much, let's make peace.
				if (iWarScore <= 0)
				{
					int iWarScoreWeWantPeace = (GetMeanness() * -9);
					iWarScoreWeWantPeace += GetPlayerNumTurnsAtWar(ePlayer);

					if (iWarScoreWeWantPeace >= iWarScore)
					{
						SetWarGoal(ePlayer, WAR_GOAL_PEACE);
						continue;
					}
				}
				// We're winning, but we'd like to get back to peace.
				else
				{
					int iWarScoreWeWantPeace = ((10 - GetDiploBalance()) * 9); // 10 minus because higher value = more likely status quo
					iWarScoreWeWantPeace += GetPlayerNumTurnsAtWar(ePlayer) * -1;

					if (iWarScoreWeWantPeace <= iWarScore)
					{
						SetWarGoal(ePlayer, WAR_GOAL_PEACE);
						continue;
					}
				}

				// No reason to stop? Check if we still want conquest...
				if (IsWantsToConquer(ePlayer) || IsUntrustworthy(ePlayer) || bCapturedKeyCity)
				{
					SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
					continue;
				}

				// Otherwise, let's just damage them.
				SetWarGoal(ePlayer, WAR_GOAL_DAMAGE);
			}
		}
		// Catch the "complete kills" case
		else if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).getTeam() != GetTeam() && IsAtWar(ePlayer))
		{
			SetWarGoal(ePlayer, WAR_GOAL_CONQUEST);
		}
		// Not a valid player
		else
		{
			SetWarGoal(ePlayer, NO_WAR_GOAL_TYPE);
		}
	}
}

bool CvDiplomacyAI::IsPeaceBlocked(PlayerTypes ePlayer) const
{
	return GetPeaceBlockReason(ePlayer) > 0;
}

int CvDiplomacyAI::GetPeaceBlockReason(PlayerTypes ePlayer) const
{
	if (!IsAtWar(ePlayer))
		return 0;

	if (ePlayer == BARBARIAN_PLAYER)
		return 0;

	// Blocked by game options
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
	{
		return 1;
	}

	// One of us is someone's vassal!
	if (GetPlayer()->IsVassalOfSomeone())
	{
		return 2;
	}
	if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
	{
		return 2;
	}

	// Too soon to make peace
	if (GET_PLAYER(ePlayer).isMajorCiv() && GetPlayerNumTurnsAtWar(ePlayer) < GD_INT_GET(WAR_MAJOR_MINIMUM_TURNS))
	{
		return 3;
	}
	if (GET_PLAYER(ePlayer).isMinorCiv() && GetPlayerNumTurnsAtWar(ePlayer) < GD_INT_GET(WAR_MINOR_MINIMUM_TURNS))
	{
		return 3;
	}

	// Enemy captured a city and wants peace right away? Not if we can retaliate ...
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetID()) <= 1 && CountUnitsAroundEnemyCities(ePlayer,3)>1)
	{
		return 4;
	}

	// AI teammate of human
	if (GetPlayer()->IsAITeammateOfHuman())
	{
		return 5;
	}

	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		// City-State is at permanent war!
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsPermanentWar(GetTeam()))
			return 6;

		// Can't make peace with a City-State if at war with their ally!
		PlayerTypes eAlly = GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly();

		if (IsAtWar(eAlly))
			return 7;
	}

	// Locked into war?
	if (GET_TEAM(GetTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(ePlayer).getTeam()) > 0)
	{
		return 8;
	}

	// Some other reason?
	if (!GET_TEAM(GetTeam()).canChangeWarPeace(GET_PLAYER(ePlayer).getTeam()))
	{
		return 9;
	}

	return 0; // No reason we're peace blocked
}

/// How many of our units are near ePlayer's cities?
int CvDiplomacyAI::CountUnitsAroundEnemyCities(PlayerTypes ePlayer, int iTurnRange) const
{
	if (ePlayer == NO_PLAYER)
		return 0;

	int iCount = 0;
	int iUnitLoop;
	for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))
	{
		if (!pLoopUnit->IsCanAttack() || pLoopUnit->isDelayedDeath() || pLoopUnit->isProjectedToDieNextTurn())
			continue;

		if (GET_PLAYER(ePlayer).GetCityDistancePathLength(pLoopUnit->plot()) < iTurnRange)
			iCount++;
	}

	return iCount;
}

/// Updates what peace treaties we're willing to offer and accept
void CvDiplomacyAI::DoUpdatePeaceTreatyWillingness()
{
	// Humans can decide this themselves!
	if (GetPlayer()->isHuman())
		return;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer) && IsAtWar(ePlayer))
		{
			// Do we actually want peace with this player?
			if (!IsWantsPeaceWithPlayer(ePlayer))
			{
				SetTreatyWillingToOffer(ePlayer, NO_PEACE_TREATY_TYPE);
				SetTreatyWillingToAccept(ePlayer, NO_PEACE_TREATY_TYPE);
				continue;
			}

			PeaceTreatyTypes eTreatyWillingToOffer = PEACE_TREATY_WHITE_PEACE;
			PeaceTreatyTypes eTreatyWillingToAccept = PEACE_TREATY_WHITE_PEACE;
			int iWillingToOfferScore = 0;
			int iWillingToAcceptScore = 0;

			// What we're willing to offer/accept in a peace treaty.
			int iWarScore = GetWarScore(ePlayer);

			// Negative Warscore? Offer more.
			if (iWarScore < 0)
			{
				iWillingToOfferScore -= iWarScore;
			}
			// Positive Warscore? Accept more.
			else
			{
				iWillingToAcceptScore += iWarScore;
			}

			// War Weary? We're more willing to make peace.
			if (MOD_BALANCE_CORE_HAPPINESS && GetPlayer()->GetCulture()->GetWarWeariness() > 0)
			{
				if (iWarScore <= 0)
				{
					iWillingToOfferScore += (GetPlayer()->GetCulture()->GetWarWeariness());
				}
				else
				{
					iWillingToAcceptScore -= (GetPlayer()->GetCulture()->GetWarWeariness());
				}
			}

			// Do the final assessment
			if (iWillingToOfferScore >= /*100*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_UN_SURRENDER())
				eTreatyWillingToOffer = PEACE_TREATY_UNCONDITIONAL_SURRENDER;
			else if (iWillingToOfferScore >= /*90*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_CAPITULATION())
				eTreatyWillingToOffer = PEACE_TREATY_CAPITULATION;
			else if (iWillingToOfferScore >= /*80*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_CESSION())
				eTreatyWillingToOffer = PEACE_TREATY_CESSION;
			else if (iWillingToOfferScore >= /*70*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SURRENDER())
				eTreatyWillingToOffer = PEACE_TREATY_SURRENDER;
			else if (iWillingToOfferScore >= /*60*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SUBMISSION())
				eTreatyWillingToOffer = PEACE_TREATY_SUBMISSION;
			else if (iWillingToOfferScore >= /*40*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_BACKDOWN())
				eTreatyWillingToOffer = PEACE_TREATY_BACKDOWN;
			else if (iWillingToOfferScore >= /*30*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SETTLEMENT())
				eTreatyWillingToOffer = PEACE_TREATY_SETTLEMENT;
			else if (iWillingToOfferScore >= /*15*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_ARMISTICE())
				eTreatyWillingToOffer = PEACE_TREATY_ARMISTICE;

			// Do the final assessment
			if (iWillingToAcceptScore >= /*100*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_UN_SURRENDER())
				eTreatyWillingToAccept = PEACE_TREATY_UNCONDITIONAL_SURRENDER;
			else if (iWillingToAcceptScore >= /*90*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CAPITULATION())
				eTreatyWillingToAccept = PEACE_TREATY_CAPITULATION;
			else if (iWillingToAcceptScore >= /*80*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CESSION())
				eTreatyWillingToAccept = PEACE_TREATY_CESSION;
			else if (iWillingToAcceptScore >= /*70*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SURRENDER())
				eTreatyWillingToAccept = PEACE_TREATY_SURRENDER;
			else if (iWillingToAcceptScore >= /*60*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SUBMISSION())
				eTreatyWillingToAccept = PEACE_TREATY_SUBMISSION;
			else if (iWillingToAcceptScore >= /*40*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_BACKDOWN())
				eTreatyWillingToAccept = PEACE_TREATY_BACKDOWN;
			else if (iWillingToAcceptScore >= /*30*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SETTLEMENT())
				eTreatyWillingToAccept = PEACE_TREATY_SETTLEMENT;
			else if (iWillingToAcceptScore >= /*15*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_ARMISTICE())
				eTreatyWillingToAccept = PEACE_TREATY_ARMISTICE;

			bool bCriticalState = GetPlayer()->IsEmpireSuperUnhappy();
			bCriticalState |= (GetStateAllWars() == STATE_ALL_WARS_LOSING);

			// Our capital is in danger!
			CvCity* pCapital = GetPlayer()->getCapitalCity();
			if (pCapital != NULL)
			{
				if (pCapital->isInDangerOfFalling())
				{
					bCriticalState = true;
				}
				else if (pCapital->getDamage() >= (pCapital->GetMaxHitPoints()/2))
				{
					bCriticalState = true;
				}
			}

			// If we're in a critical state, always accept a white peace.
			if (bCriticalState)
			{
				if (eTreatyWillingToOffer <= PEACE_TREATY_WHITE_PEACE)
					eTreatyWillingToOffer = PEACE_TREATY_WHITE_PEACE;

				eTreatyWillingToAccept = PEACE_TREATY_WHITE_PEACE;
			}

			SetTreatyWillingToOffer(ePlayer, eTreatyWillingToOffer);
			SetTreatyWillingToAccept(ePlayer, eTreatyWillingToAccept);
		}
		else
		{
			SetTreatyWillingToOffer(ePlayer, NO_PEACE_TREATY_TYPE);
			SetTreatyWillingToAccept(ePlayer, NO_PEACE_TREATY_TYPE);
		}
	}
}

/// Do we actually want peace with ePlayer?
bool CvDiplomacyAI::IsWantsPeaceWithPlayer(PlayerTypes ePlayer) const
{
	if (ePlayer == BARBARIAN_PLAYER)
		return false;

	if (!IsAtWar(ePlayer))
		return false;

	int iPeaceBlockReason = GetPeaceBlockReason(ePlayer);

	if (iPeaceBlockReason > 0)
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;
			CvString strPeaceBlockReason;

			switch (iPeaceBlockReason)
			{
			case 1:
				strPeaceBlockReason.Format("We are always at war with this player!");
				break;
			case 2:
				strPeaceBlockReason.Format("One of us is a vassal!");
				break;
			case 3:
				strPeaceBlockReason.Format("Too early to make peace!");
				break;
			case 4:
				strPeaceBlockReason.Format("Our city was just captured, and we have units near the enemy's cities!");
				break;
			case 5:
				strPeaceBlockReason.Format("AI teammates of humans can't make peace on their own!");
				break;
			case 6:
				strPeaceBlockReason.Format("City-State is at permanent war with us!");
				break;
			case 7:
				strPeaceBlockReason.Format("We're at war with this City-State's ally!");
				break;
			case 8:
				strPeaceBlockReason.Format("Locked into coop/3rd party war for %d more turns!", GET_TEAM(GetTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(ePlayer).getTeam()));
				break;
			case 9:
				strPeaceBlockReason.Format("Cannot change war/peace status!");
				break;
			default:
				strPeaceBlockReason.Format("Undefined reason!");
				break;
			}

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("PEACE BLOCKED! ");
			strOutBuf += strPeaceBlockReason;

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return false;
	}

	// Evaluate our danger and their danger from this war
	int iWarScore = GetPlayer()->GetDiplomacyAI()->GetWarScore(ePlayer);
	int iOurDanger = 0;
	int iTheirDanger = 0;
	bool bSeriousDangerUs = false;
	bool bSeriousDangerThem = false;
	ReligionTypes eMyReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);	
	ReligionTypes eTheirReligion = GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false);
	int iLoop;
	for (CvCity* pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))
	{
		int iDangerMod = 0;

		if (pLoopCity->isInDangerOfFalling())
		{
			iDangerMod += 3;
			bSeriousDangerUs = true;
		}

		else if (pLoopCity->isUnderSiege() || pLoopCity->IsBlockadedWaterAndLand())
		{
			iDangerMod += 2;

			if (pLoopCity->IsBlockadedWaterAndLand() || pLoopCity->getDamage() >= (pLoopCity->GetMaxHitPoints()/2))
			{
				if (pLoopCity->isCapital() || pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)))
				{
					bSeriousDangerUs = true;
				}
			}
		}

		else if (pLoopCity->IsInDanger(ePlayer))
			iDangerMod += 1;

		//look at the tactical map (is it up to date?)
		CvTacticalDominanceZone* pLandZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
		CvTacticalDominanceZone* pWaterZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
		if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
			iDangerMod++;
		if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
			iDangerMod++;
		
		if (pLoopCity->isCapital())
			iDangerMod *= 3;
		else if (pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)) || pLoopCity->getNumWorldWonders() > 0)
			iDangerMod *= 2;
		else if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion() || pLoopCity->getNumNationalWonders() > 0)
		{
			if (iDangerMod > 0)
				iDangerMod++;
		}
		
		iOurDanger += iDangerMod;
	}

	for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
	{
		// Can we actually see this city's danger status?
		if (HasVisibilityOfEnemyCityDanger(pLoopCity))
		{
			int iDangerMod = 0;

			if (pLoopCity->isInDangerOfFalling())
			{
				iDangerMod += 3;
				bSeriousDangerThem = true;
			}

			else if (pLoopCity->isUnderSiege() || pLoopCity->IsBlockadedWaterAndLand())
			{
				iDangerMod += 2;

				if (pLoopCity->IsBlockadedWaterAndLand() || pLoopCity->getDamage() >= (pLoopCity->GetMaxHitPoints()/2))
				{
					if (pLoopCity->isCapital() || pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)))
					{
						bSeriousDangerThem = true;
					}
				}
			}

			else if (pLoopCity->IsInDanger(m_pPlayer->GetID()))
				iDangerMod += 1;

			//look at the tactical map (is it up to date?)
			CvTacticalDominanceZone* pLandZone = GET_PLAYER(ePlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
			CvTacticalDominanceZone* pWaterZone = GET_PLAYER(ePlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
			
			if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iDangerMod++;
			if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iDangerMod++;
			
			if (pLoopCity->isCapital())
				iDangerMod *= 3;
			else if (pLoopCity->IsOriginalMajorCapital() || (eMyReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eMyReligion)) || (eTheirReligion != NO_RELIGION && pLoopCity->GetCityReligions()->IsHolyCityForReligion(eTheirReligion)) || pLoopCity->getNumWorldWonders() > 0)
				iDangerMod *= 2;
			else if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				if (iDangerMod > 0)
					iDangerMod++;
			}

			iTheirDanger += iDangerMod;
		}
	}

	// Don't make peace if we're about to score!
	if (!bSeriousDangerUs && bSeriousDangerThem)
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("No peace! We're about to score, and we're not in serious danger!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return false;
	}

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		if ((iWarScore <= -90 && iOurDanger > 0) || (iWarScore <= -50 && bSeriousDangerUs))
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strOutBuf;
				CvString strBaseString;
				CvString playerName;
				CvString otherPlayerName;
				CvString strLogName;

				// Find the name of this civ and city
				playerName = m_pPlayer->getCivilizationShortDescription();

				// Open the log file
				if (GC.getPlayerAndCityAILogSplit())
				{
					strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
				}
				else
				{
					strLogName = "DiplomacyAI_Peace_Log.csv";
				}

				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

				// Get the leading info for this line
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
				strBaseString += playerName + " VS. " + otherPlayerName;

				strOutBuf.Format("War score is terrible and we're in danger, so we're willing to make peace!");

				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}

		return true;
	}

	// If our war goal isn't to make peace, don't consider peace.
	if (GetWarGoal(ePlayer) != WAR_GOAL_PEACE)
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("Our war goal isn't PEACE!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return false;
	}

	// Want peace with a minor civ - do it right away!
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("Our war goal with this minor is PEACE!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return true;
	}

	// Phony war - we want peace
	if (IsPhonyWar(ePlayer))
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("We don't care about this war!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return true;
	}

	bool bReadyForVassalage = false;
	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		if (!IsCapitalCapturedBy(ePlayer, false, true) && !IsHolyCityCapturedBy(ePlayer, false, true) && !IsEndgameAggressiveTo(ePlayer) && iWarScore >= 90 && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canBecomeVassal(GetTeam()))
		{
			if (!(GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || IsGoingForWorldConquest() || IsCloseToDominationVictory()) || GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
			{
				bReadyForVassalage = true;
			}
		}
	}

	// Ready to make this player our vassal - want peace
	if (bReadyForVassalage)
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("We're ready to vassalize this major civ!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return true;
	}

	int iWantPeace = 0;
	int iRequestPeaceTurnThreshold = /*11*/ GC.getREQUEST_PEACE_TURN_THRESHOLD() - m_pPlayer->GetMilitaryAI()->GetNumberCivsAtWarWith(false);

	// Danger considerations
	int iOurMultiplier = 1;
	int iTheirMultiplier = 1;

	if (GetStateAllWars() != STATE_ALL_WARS_LOSING || GetWarState(ePlayer) == WAR_STATE_NEARLY_WON)
	{
		if (IsEasyTarget(ePlayer))
		{
			iOurMultiplier++;
		}
		if (GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer))
		{
			iOurMultiplier++;
		}
		if (GetWarState(ePlayer) == WAR_STATE_NEARLY_WON)
		{
			iOurMultiplier++;
		}
	}
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetStateAllWars() != STATE_ALL_WARS_LOSING || GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED)
	{
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsEasyTarget(GetPlayer()->GetID()))
		{
			iTheirMultiplier++;
		}
		if (GetPlayer()->GetMilitaryAI()->HaveCityExposedToEnemy(ePlayer))
		{
			iTheirMultiplier++;
		}
		if (GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED)
		{
			iTheirMultiplier++;
		}
	}

	// They're in danger and we're not? Let's hold out longer!
	if (iOurDanger == 0 && iTheirDanger > 0)
	{
		if (GetPlayerNumTurnsSinceCityCapture(ePlayer) < 30 || iOurMultiplier > 2 || bSeriousDangerThem)
		{
			iWantPeace -= (5 * iTheirDanger * iOurMultiplier);
		}
		else
		{
			iWantPeace -= (2 * iTheirDanger * iOurMultiplier);
		}
	}
	// We're in danger and they're not? Let's hold out less!
	else if (iOurDanger > 0 && iTheirDanger == 0)
	{
		if (iWarScore < -15 || iTheirMultiplier > 2 || bSeriousDangerUs)
		{
			iWantPeace += (5 * iOurDanger * iTheirMultiplier);
		}
		else
		{
			iWantPeace += (2 * iOurDanger * iTheirMultiplier);
		}
	}
	// We're both in danger - how much?
	else
	{
		iWantPeace -= (2 * iTheirDanger * iOurMultiplier);
		iWantPeace += (2 * iOurDanger * iTheirMultiplier);
	}

	// Negative warscore means we're losing, so peace desire is higher!
	if (iWarScore < 0)
	{
		iWantPeace += (iWarScore / -10);
	}
	// Positive warscore means we are winning - let's ride this out until we get a good peace deal.
	else if (iWarScore > 0)
	{
		//If we get a bonus from high warscore, let's not end early!
		if (m_pPlayer->GetPositiveWarScoreTourismMod() > 0 && GET_PLAYER(GetPlayer()->GetDiplomacyAI()->GetHighestWarscorePlayer()).getTeam() == GET_PLAYER(ePlayer).getTeam())
		{
			iWantPeace -= (iWarScore / 10);
		}
		else
		{
			iWantPeace += (iWarScore / 15);
			//At 100? Let's end this (unless we can ride this out!
			if (iWarScore == 100)
				iWantPeace += 20;
		}
	}

	int iWarWeariness = m_pPlayer->GetCulture()->GetWarWeariness();
	iWantPeace += (iWarWeariness / 4);

	if (iWarWeariness > 0 && m_pPlayer->IsEmpireUnhappy())
	{
		iWantPeace += (iWarWeariness / 3);
	}

	// If they're about to win the game, let's hold out for a lot longer.
	if (IsEndgameAggressiveTo(ePlayer))
	{
		iWantPeace -= 20;
	}

	// Was a city recently captured?
	if (GetPlayerNumTurnsSinceCityCapture(ePlayer) < 3 || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetID()) < 3)
	{
		iWantPeace -= 10;
	}
	else
	{
		// Lack of progress in war increases desire for peace (doubly so if far away).
		if (GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
		{
			iWantPeace += max(0, (GetPlayerNumTurnsSinceCityCapture(ePlayer) * 2) - 12);
		}
		else
		{
			iWantPeace += max(0, GetPlayerNumTurnsSinceCityCapture(ePlayer) - 12);
		}
	}

	if (GetWarProjection(ePlayer) >= WAR_PROJECTION_GOOD)
	{
		iWantPeace -= 2;
	}
	else if (GetWarProjection(ePlayer) <= WAR_PROJECTION_UNKNOWN)
	{
		iWantPeace += 2;
	}

	if (GetWarState(ePlayer) <= WAR_STATE_STALEMATE)
	{
		iWantPeace += 2;
	}
	else if (GetWarState(ePlayer) >= WAR_STATE_CALM)
	{
		iWantPeace -= 2;
	}

	iWantPeace += GetWantPeaceCounter(ePlayer);

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = m_pPlayer->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Peace_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += playerName + " VS. " + otherPlayerName;

		strOutBuf.Format(" Value Needed: %03d. Value Have: %03d.", iRequestPeaceTurnThreshold, iWantPeace);

		strBaseString += strOutBuf;
		pLog->Msg(strBaseString);
	}

	return (iWantPeace >= iRequestPeaceTurnThreshold);
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// AGGRESSIVE POSTURES
// ////////////////////////////////////

/// Updates how aggressively all players' military Units are positioned in relation to us
void CvDiplomacyAI::DoUpdateMilitaryAggressivePostures()
{
	TeamTypes eOurTeam = GetTeam();
	PlayerTypes eOurPlayerID = GetID();

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
			CvTeam& kTeam = GET_TEAM(kPlayer.getTeam());
			TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

			// Keep a record of last turn
			SetLastTurnMilitaryAggressivePosture(ePlayer, GetMilitaryAggressivePosture(ePlayer));

			if (!IsVassal(ePlayer))
			{
				// We're allowing them Open Borders? We shouldn't care.
				if (GET_TEAM(GetTeam()).IsAllowsOpenBordersToTeam(eTeam))
				{
					SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
					return;
				}

				// We're working together, so don't worry about it
				if (IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer))
				{
					SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
					return;
				}

				// They resurrected us, so don't worry about it
				if (WasResurrectedBy(ePlayer) && !IsAtWar(ePlayer))
				{
					SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
					return;
				}
			}

			// Don't be frightened of vassals.
			if (GET_PLAYER(ePlayer).IsVassalOfSomeone() && !IsAtWar(ePlayer))
			{
				SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
				return;
			}

			int iUnitValueOnMyHomeFront = 0;
			bool bIsAtWarWithSomeone = (kTeam.getAtWarCount(false) > 0);

			// For humans (Move Troops request) or if at war with them, ignore other wars the player may be waging
			bool bIgnoreOtherWars = (GetPlayer()->isHuman() || IsAtWar(ePlayer));

			// Loop through the other guy's units
			int iUnitLoop;
			for (CvUnit* pLoopUnit = kPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iUnitLoop))
			{
				// Don't be scared of noncombat Units!
				if (!pLoopUnit->IsCanAttack() || pLoopUnit->getUnitInfo().GetDefaultUnitAIType() == UNITAI_EXPLORE)
				{
					continue;
				}

				CvPlot* pUnitPlot = pLoopUnit->plot();
				// Can we actually see this Unit? No cheating!
				if (!pUnitPlot->isVisible(eOurTeam) || pLoopUnit->isInvisible(eOurTeam, false))
				{
					continue;
				}

				// Must be close to us
				if (!pUnitPlot->IsCloseToBorder(eOurPlayerID))
				{
					continue;
				}

				// At war with someone? Because if this Unit is in the vicinity of another player he's already at war with, don't count this Unit as aggressive
				if (bIsAtWarWithSomeone && !bIgnoreOtherWars)
				{
					// Loop through all players...
					for (int iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_CIV_PLAYERS; iOtherPlayerLoop++)
					{
						PlayerTypes eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;
						TeamTypes eLoopOtherTeam = (TeamTypes) GET_PLAYER(eLoopOtherPlayer).getTeam();

						// At war with this player?
						if (IsPlayerValid(eLoopOtherPlayer) && eLoopOtherTeam != eTeam && kTeam.isAtWar(eLoopOtherTeam))
						{
							// Is the unit close to the other player?
							if (pUnitPlot->IsCloseToBorder(eLoopOtherPlayer))
							{
								continue;
							}
						}
					}
				}

				int iValueToAdd = 10;

				// If the Unit is in the other player's territory, halve its "aggression value", since he may just be defending himself
				if (pUnitPlot->getOwner() == ePlayer)
				{
					iValueToAdd /= 2;
				}

				// Maybe look at Unit Power here instead?
				iUnitValueOnMyHomeFront += iValueToAdd;
			}

			AggressivePostureTypes eAggressivePosture = AGGRESSIVE_POSTURE_NONE;

			// So how threatening is he being?
			if (iUnitValueOnMyHomeFront >= /*80*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_INCREDIBLE())
				eAggressivePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
			else if (iUnitValueOnMyHomeFront >= /*50*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_HIGH())
				eAggressivePosture = AGGRESSIVE_POSTURE_HIGH;
			else if (iUnitValueOnMyHomeFront >= /*30*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_MEDIUM())
				eAggressivePosture = AGGRESSIVE_POSTURE_MEDIUM;
			else if (iUnitValueOnMyHomeFront >= /*10*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_LOW())
				eAggressivePosture = AGGRESSIVE_POSTURE_LOW;

			SetMilitaryAggressivePosture(ePlayer, eAggressivePosture);
		}
		else
		{
			SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
			SetLastTurnMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		}
	}
}

/// Updates how aggressively all players have settled in relation to us
void CvDiplomacyAI::DoUpdateExpansionAggressivePostures()
{
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer) && GET_PLAYER(ePlayer).isMajorCiv())
		{
			CvCity* pOurOldClosestCity = NULL;
			CvCity* pTheirOldClosestCity = NULL;
			bool bFromPromise = false;

			//They promised not to expand?
			if (IsPlayerMadeExpansionPromise(ePlayer))
			{
				pair<int, int> promisedPair = GetNoExpansionPromiseClosestCities(ePlayer);
				if (promisedPair.first >= 0) //valid?
				{
					pOurOldClosestCity = GetPlotCityAndVerifyOwnership(promisedPair.first, m_pPlayer->GetID());
					pTheirOldClosestCity = GetPlotCityAndVerifyOwnership(promisedPair.second, ePlayer);
					bFromPromise = true;
				}
			}

			//if no promise, use the previous closest pair
			if (!pOurOldClosestCity || !pTheirOldClosestCity)
			{
				pair<int, int> lastTurnPair = GetLastTurnClosestCityPair(ePlayer);
				if (lastTurnPair.first >= 0) //valid?
				{
					pOurOldClosestCity = GetPlotCityAndVerifyOwnership(lastTurnPair.first, m_pPlayer->GetID());
					pTheirOldClosestCity = GetPlotCityAndVerifyOwnership(lastTurnPair.second, ePlayer);
					bFromPromise = false;
				}
			}

			//the current pair for comparison
			pair<int, int> thisTurnPair = GetClosestCityPair(ePlayer);
			CvCity* pOurNewClosestCity = GetPlotCityAndVerifyOwnership(thisTurnPair.first, m_pPlayer->GetID());
			CvCity* pTheirNewClosestCity = GetPlotCityAndVerifyOwnership(thisTurnPair.second, ePlayer);

			//In any case save off our new value for next turn, it'll be our new test point ...
			SetLastTurnClosestCityPair(ePlayer, thisTurnPair);

			//Null? Must be first turn or something. Ignore.
			if (!pOurOldClosestCity || !pTheirOldClosestCity || !pOurNewClosestCity || !pTheirNewClosestCity)
				return;

			// First calculate distance
			int iOldDistance = plotDistance(*pOurOldClosestCity->plot(), *pTheirOldClosestCity->plot());
			int iNewDistance = plotDistance(*pOurNewClosestCity->plot(), *pTheirNewClosestCity->plot());

			// Assume no change
			AggressivePostureTypes eLastAggressivePosture = GetExpansionAggressivePosture(ePlayer);
			AggressivePostureTypes eNewAggressivePosture = eLastAggressivePosture;

			if (
				//if we got closer to each other and their city is newer, they are being aggressive (else we are being aggressive)
				(iNewDistance < iOldDistance && pTheirNewClosestCity->getGameTurnAcquired() > pOurNewClosestCity->getGameTurnAcquired())
				||
				//if one of us lost a city relax the posture, no matter what
				(iNewDistance > iOldDistance)
				)
			{
				if (iNewDistance <= /*2*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_HIGH() + (GetBoldness() / 4)))
					eNewAggressivePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
				else if (iNewDistance <= /*5*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_MEDIUM() + (GetBoldness() / 4)))
					eNewAggressivePosture = AGGRESSIVE_POSTURE_HIGH;
				else if (iNewDistance <= /*9*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW() + (GetBoldness() / 4)))
					eNewAggressivePosture = AGGRESSIVE_POSTURE_MEDIUM;
				else if (iNewDistance <= /*18*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW()*2 + (GetBoldness() / 4)))
					eNewAggressivePosture = AGGRESSIVE_POSTURE_LOW;
				else //default
					eNewAggressivePosture = AGGRESSIVE_POSTURE_NONE;
			}

			if (eNewAggressivePosture != eLastAggressivePosture)
			{
				SetExpansionAggressivePosture(ePlayer, eNewAggressivePosture);

				if (GC.getLogging() && GC.getAILogging())
				{
					// Find the name of this civ and city
					CvString playerName = GetPlayer()->getCivilizationShortDescription();
					CvString otherplayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

					// Open the log file
					CvString strLogName = GC.getPlayerAndCityAILogSplit() ? "DiplomacyAI_ExpansionLogic_Log_" + playerName + ".csv" : "DiplomacyAI_ExpansionLogic_Log.csv";
					FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

					// Get the leading info for this line
					CvString strBaseString;
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strBaseString += otherplayerName + ", ";

					char *names[] = {
						"AGGRESSIVE_POSTURE_UNDEFINED",
						"AGGRESSIVE_POSTURE_NONE",
						"AGGRESSIVE_POSTURE_LOW",
						"AGGRESSIVE_POSTURE_MEDIUM",
						"AGGRESSIVE_POSTURE_HIGH",
						"AGGRESSIVE_POSTURE_INCREDIBLE" };

					// Actual info
					CvString strOutBuf(strBaseString);
					CvString strTmp;
					strOutBuf += (bFromPromise ? "promised: " : "previous: ");
					strOutBuf += pOurOldClosestCity->getName() + ", ";
					strOutBuf += pTheirOldClosestCity->getName() + ", ";
					strTmp.Format("%s, distance %d", names[eLastAggressivePosture+1], iOldDistance);
					strOutBuf += strTmp + ", ";
					strOutBuf += "now: ";
					strOutBuf += pOurNewClosestCity->getName() + ", ";
					strOutBuf += pTheirNewClosestCity->getName() + ", ";
					strTmp.Format("%s, distance %d", names[eNewAggressivePosture+1], iNewDistance);
					strOutBuf += strTmp;

					pLog->Msg(strOutBuf);
				}
			}
		}
		else
		{
			SetExpansionAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		}
	}
}

/// Returns plot indices!
pair<int,int> CvDiplomacyAI::GetClosestCityPair(PlayerTypes eOtherPlayer)
{
	int iCityLoop = 0;
	int iMinDistance = INT_MAX;
	pair<int, int> result(-1,-1);
	for (CvCity* pOtherCity = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop); pOtherCity != NULL; pOtherCity = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop))
	{
		CvCity* pOurClosestCity = m_pPlayer->GetClosestCityByPlots(pOtherCity->plot()); //use estimated turns here?
		if (!pOurClosestCity)
			continue;

		int iDistance = plotDistance(*pOtherCity->plot(), *pOurClosestCity->plot());
		if (iDistance < iMinDistance)
		{
			iMinDistance = iDistance;
			result = make_pair( pOurClosestCity->plot()->GetPlotIndex(),pOtherCity->plot()->GetPlotIndex() );
		}
	}

	return result;
}

CvCity* CvDiplomacyAI::GetPlotCityAndVerifyOwnership(int iPlotIndex, PlayerTypes eSupposedOwner)
{
	if (iPlotIndex < 0)
		return NULL;

	CvCity* pResult = GC.getMap().plotByIndex(iPlotIndex)->getPlotCity();
	if (pResult && pResult->getOwner() == eSupposedOwner)
		return pResult;

	return NULL;
}

/// Updates how aggressively all players have bought land near us
void CvDiplomacyAI::DoUpdatePlotBuyingAggressivePostures()
{
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			AggressivePostureTypes ePosture = AGGRESSIVE_POSTURE_NONE;
			int iAggressionScore = 0;
			int iCityLoop;

			// Loop through all of our Cities to see if this player has bought land near them
			for (CvCity* pLoopCity = GetPlayer()->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iCityLoop))
			{
				iAggressionScore += pLoopCity->AI_GetNumPlotsAcquiredByOtherPlayer(ePlayer);
			}

			// Now See what our new Dispute Level should be
			if (iAggressionScore >= /*10*/ GC.getPLOT_BUYING_POSTURE_INCREDIBLE_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
			else if (iAggressionScore >= /*7*/ GC.getPLOT_BUYING_POSTURE_HIGH_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_HIGH;
			else if (iAggressionScore >= /*4*/ GC.getPLOT_BUYING_POSTURE_MEDIUM_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_MEDIUM;
			else if (iAggressionScore >= /*2*/ GC.getPLOT_BUYING_POSTURE_LOW_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_LOW;

			SetPlotBuyingAggressivePosture(ePlayer, ePosture);
		}
		else
		{
			SetPlotBuyingAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		}
	}
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// DISPUTE LEVELS
// ////////////////////////////////////

/// Updates what our level of Dispute is with a player over Land
void CvDiplomacyAI::DoUpdateLandDisputeLevels()
{
	int iEra = GetPlayer()->GetCurrentEra();
	bool bCramped = GetPlayer()->IsCramped();
	PlayerTypes eSettleSpotThief = GetPlayer()->GetPlayerWhoStoleMyFavoriteCitySite();
	bool bBold = GetBoldness() > 7 || GetPlayer()->GetPlayerTraits()->IsWarmonger() || GetPlayer()->GetPlayerTraits()->IsExpansionist() || (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION);
	bBold |= GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION")) > 7;

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		// Update last turn's values
		SetLastTurnLandDisputeLevel(ePlayer, GetLandDisputeLevel(ePlayer));

		if (IsPlayerValid(ePlayer))
		{
			// Look at our Proximity to the other Player
			PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
			if (eProximity < PLAYER_PROXIMITY_CLOSE)
			{
				SetLandDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
				continue;
			}
			
			int iContestedScore = 0;

			// Loop through all of this player's Cities
			int iCityLoop;
			for (const CvCity* pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))
			{
				iContestedScore += pLoopCity->GetContestedPlotScore(ePlayer);
			}

			// Is the player already cramped in on other sides? If so, bump up the score
			int iMultiplier = bCramped ? /*50*/ GC.getLAND_DISPUTE_CRAMPED_MULTIPLIER() : 0;
			
			// Land disputes matter more if a warmonger, or in the early game.
			if (bBold)
			{
				if (iEra == 0)
				{
					iMultiplier += 150;
				}
				else if (iEra == 1)
				{
					iMultiplier += 100;
				}
				else
				{
					iMultiplier += 50;
				}
			}
			else
			{
				if (iEra == 0)
				{
					iMultiplier += 100;
				}
				else if (iEra == 1)
				{
					iMultiplier += 50;
				}
				else if (iEra == 2)
				{
					iMultiplier += 25;
				}
			}

			iContestedScore *= (100 + iMultiplier);
			iContestedScore /= 100;

			// Now see what our new Dispute Level should be
			DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
			if (iContestedScore >= /*8*/ GC.getLAND_DISPUTE_FIERCE_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_FIERCE;
			else if (iContestedScore >= /*4*/ GC.getLAND_DISPUTE_STRONG_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_STRONG;
			else if (iContestedScore >= /*1*/ GC.getLAND_DISPUTE_WEAK_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_WEAK;

			// Did this player steal "our" favorite city settling spot? We should get mad!
			if (ePlayer == eSettleSpotThief)
			{
				if (bBold)
				{
					if (eDisputeLevel >= DISPUTE_LEVEL_WEAK)
						eDisputeLevel = DISPUTE_LEVEL_FIERCE;
					else
						eDisputeLevel = DISPUTE_LEVEL_STRONG;
				}
				else
				{
					if (eDisputeLevel >= DISPUTE_LEVEL_STRONG)
						eDisputeLevel = DISPUTE_LEVEL_FIERCE;
					else if (eDisputeLevel == DISPUTE_LEVEL_WEAK)
						eDisputeLevel = DISPUTE_LEVEL_STRONG;
					else
						eDisputeLevel = DISPUTE_LEVEL_WEAK;
				}
			}

			// Actually set the Level
			if (GetLandDisputeLevel(ePlayer) != eDisputeLevel)
			{
				SetLandDisputeLevel(ePlayer, eDisputeLevel);

				if (GC.getLogging() && GC.getAILogging())
				{
					// Find the name of this civ and city
					CvString playerName = GetPlayer()->getCivilizationShortDescription();
					CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

					// Open the log file
					CvString strLogName = GC.getPlayerAndCityAILogSplit() ? "DiplomacyAI_ExpansionLogic_Log_" + playerName + ".csv" : "DiplomacyAI_ExpansionLogic_Log.csv";
					FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

					// Get the leading info for this line
					CvString strBaseString;
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", " + otherPlayerName + ", ";

					char *names[] = {
						"DISPUTE_LEVEL_NONE",
						"DISPUTE_LEVEL_WEAK",
						"DISPUTE_LEVEL_STRONG",
						"DISPUTE_LEVEL_FIERCE" };

					// Actual info
					CvString strOutBuf(strBaseString);
					CvString strTmp;
					strTmp.Format("%s, score %d", names[eDisputeLevel], iContestedScore);
					strOutBuf += strTmp;

					pLog->Msg(strOutBuf);
				}
			}
		}
		else
		{
			SetLandDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
		}
	}
}

/// Updates what our level of Dispute is with all players over World Wonders
void CvDiplomacyAI::DoUpdateWonderDisputeLevels()
{
	int iCompetitiveness = GetWonderCompetitiveness();

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
			int iWonderDisputeWeight = GetNumWondersBeatenTo(ePlayer);

			// Add weight for player's competitiveness (1 - 10)
			iWonderDisputeWeight *= iCompetitiveness;

			if (iWonderDisputeWeight >= /*10*/ GC.getWONDER_DISPUTE_FIERCE_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_FIERCE;
			else if (iWonderDisputeWeight >= /*7*/ GC.getWONDER_DISPUTE_STRONG_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_STRONG;
			else if (iWonderDisputeWeight >= /*5*/ GC.getWONDER_DISPUTE_WEAK_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_WEAK;

			SetWonderDisputeLevel(ePlayer, eDisputeLevel);
		}
		else
		{
			SetWonderDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
		}
	}
}

/// Updates what our level of Dispute is with all players over Minor Civ Friendship
void CvDiplomacyAI::DoUpdateMinorCivDisputeLevels()
{
	// Personality factors in quite a bit here, which is why we square the value
	int iPersonalityMod = GetMinorCivCompetitiveness() * GetMinorCivCompetitiveness();	// Ranges from 1 to 100

	int iThreshold = ((10 - GetMinorCivCompetitiveness()) + GC.getGame().getCurrentEra());
	PlayerTypes eMyPlayer = GetID();

	vector<PlayerTypes> vMinorsToCheck;
	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iPlayerLoop;

		// Don't evaluate City-States that are unmet/dead
		if (!IsPlayerValid(eMinor))
			continue;

		if (!GET_PLAYER(eMinor).isMinorCiv())
			continue;

		// Ignore if League resolutions make it irrelevant
		if (GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly())
			continue;

		if (GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == eMyPlayer)
			continue;

		// Ignore if we're aggressive towards this minor
		if (GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_BULLY || GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_CONQUEST)
			continue;

		vMinorsToCheck.push_back(eMinor);
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(ePlayer))
		{
			SetMinorCivDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
			continue;
		}

		DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
		int iDisputeWeight = 0;
		bool bThreatening = ((GetNumTimesTheyLoweredOurInfluence(ePlayer) > 0) && (GetNumTimesTheyLoweredOurInfluence(ePlayer) >= iThreshold));

		for (std::vector<PlayerTypes>::iterator it = vMinorsToCheck.begin(); it != vMinorsToCheck.end(); it++)
		{
			if (bThreatening || GET_PLAYER(*it).GetMinorCivAI()->IsFriends(eMyPlayer))
			{
				bool bOneIsAllied = false;

				// Other Player is Allies with this minor
				if (GET_PLAYER(*it).GetMinorCivAI()->IsAllies(ePlayer))
				{
					if (GetMinorCivApproach(*it) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(*it) == MINOR_CIV_APPROACH_PROTECTIVE)
					{
						iDisputeWeight += (iPersonalityMod / 2);
					}

					bOneIsAllied = true;
				}
				// Other Player is Friends with this minor
				else if (GET_PLAYER(*it).GetMinorCivAI()->IsFriends(ePlayer))
				{
					//We're allies? Grr...
					if (GET_PLAYER(*it).GetMinorCivAI()->IsAllies(eMyPlayer))
					{
						iDisputeWeight += iPersonalityMod;
						bOneIsAllied = true;
					}
					else
					{
						iDisputeWeight -= iPersonalityMod;
					}
				}

				//Let's look at influence.
				int iOurInfluence = GET_PLAYER(*it).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eMyPlayer);
				int iTheirInfluence = GET_PLAYER(*it).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(ePlayer);

				if (bOneIsAllied)
				{
					iDisputeWeight += (iOurInfluence / 5);
					iDisputeWeight += (GetNumTimesTheyLoweredOurInfluence(ePlayer) * 10);
					int iInfluenceStart = iPersonalityMod;

					if (iTheirInfluence > iOurInfluence)
					{
						int iDifference = iTheirInfluence - iOurInfluence;

						//Are our influences within 20 of each other?
						if (iDifference <= 20)
						{
							iInfluenceStart *= 40;
							iInfluenceStart /= 10;
						}
						//Are our influences within 40 of each other?
						else if (iDifference <= 40)
						{
							iInfluenceStart *= 35;
							iInfluenceStart /= 10;
						}
						//Are our influences within 60 of each other?
						else if (iDifference <= 60)
						{
							iInfluenceStart *= 30;
							iInfluenceStart /= 10;
						}
						//Are our influences within 80 of each other?
						else if (iDifference <= 80)
						{
							iInfluenceStart *= 20;
							iInfluenceStart /= 10;
						}
						//Are our influences within 100 of each other?
						else if (iDifference <= 100)
						{
							iInfluenceStart *= 10;
							iInfluenceStart /= 10;
						}
						//Are our influences within 120 of each other?
						else if (iDifference <= 120)
						{
							iInfluenceStart *= 5;
							iInfluenceStart /= 10;
						}
						//Are our influences within 150 of each other?
						else if (iDifference <= 150)
						{
							iInfluenceStart *= 3;
							iInfluenceStart /= 10;
						}
						//Are our influences within 200 of each other?
						else if (iDifference <= 200)
						{
							iInfluenceStart *= 2;
							iInfluenceStart /= 10;
						}
					}
					else if (iOurInfluence > iTheirInfluence)
					{
						int iDifference = iOurInfluence - iTheirInfluence;

						//Are our influences within 20 of each other?
						if (iDifference <= 20)
						{
							iInfluenceStart *= 40;
							iInfluenceStart /= 10;
						}
						//Are our influences within 40 of each other?
						else if (iDifference <= 40)
						{
							iInfluenceStart *= 30;
							iInfluenceStart /= 10;
						}
						//Are our influences within 60 of each other?
						else if (iDifference <= 60)
						{
							iInfluenceStart *= 20;
							iInfluenceStart /= 10;
						}
						//Are our influences within 80 of each other?
						else if (iDifference <= 80)
						{
							iInfluenceStart *= 15;
							iInfluenceStart /= 10;
						}
						//Are our influences within 100 of each other?
						else if (iDifference <= 100)
						{
							iInfluenceStart *= 10;
							iInfluenceStart /= 10;
						}
						//Are our influences within 120 of each other?
						else if (iDifference <= 120)
						{
							iInfluenceStart *= 8;
							iInfluenceStart /= 10;
						}
						//Are our influences within 150 of each other?
						else if (iDifference <= 150)
						{
							iInfluenceStart *= 6;
							iInfluenceStart /= 10;
						}
						//Are our influences within 200 of each other?
						else if (iDifference <= 200)
						{
							iInfluenceStart *= 4;
							iInfluenceStart /= 10;
						}
					}

					// Tied? Ramp it up!
					if (iOurInfluence == iTheirInfluence)
					{
						iDisputeWeight += iOurInfluence;
					}
					else
					{
						// We have a PtP with this minor - bump it up a little bit.
						if (GET_PLAYER(*it).GetMinorCivAI()->IsProtectedByMajor(eMyPlayer))
						{
							iInfluenceStart *= 15;
							iInfluenceStart /= 10;
						}

						iDisputeWeight += iInfluenceStart;
					}
				}
				// Neither of us is allied - but have they been lowering our influence?
				else
				{
					iDisputeWeight += (GetNumTimesTheyLoweredOurInfluence(ePlayer) * 20);
				}
			}
		}

		// Now see what our new Dispute Level should be
		if (iDisputeWeight >= /*700*/ GC.getMINOR_CIV_DISPUTE_FIERCE_THRESHOLD())
			eDisputeLevel = DISPUTE_LEVEL_FIERCE;
		else if (iDisputeWeight >= /*400*/ GC.getMINOR_CIV_DISPUTE_STRONG_THRESHOLD())
			eDisputeLevel = DISPUTE_LEVEL_STRONG;
		else if (iDisputeWeight >= /*200*/ GC.getMINOR_CIV_DISPUTE_WEAK_THRESHOLD())
			eDisputeLevel = DISPUTE_LEVEL_WEAK;

		SetMinorCivDisputeLevel(ePlayer, eDisputeLevel);
	}
}


//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// PLAYER TRUSTWORTHINESS
// ////////////////////////////////////

/// Tests if any promises were broken or expired since last turn
void CvDiplomacyAI::DoTestPromises()
{
	int iTurn = GC.getGame().getGameTurn();

	// Loop through all (known) Majors
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && IsHasMet(eLoopPlayer))
		{
			// Military Promise
			// This promise does not scale with gamespeed!
			if (IsPlayerMadeMilitaryPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerMilitaryPromiseTurn(eLoopPlayer);

				// Expired?
				if (iTurnDifference >= /*20*/ GC.getMOVE_TROOPS_MEMORY_TURN_EXPIRATION())
				{
					SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerIgnoredMilitaryPromise(eLoopPlayer))
			{
				if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
				{
					SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
				{
					SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else
				{
					int iTurnDifference = iTurn - GetPlayerMilitaryPromiseTurn(eLoopPlayer);

					// Expired?
					if (iTurnDifference >= /*40*/ GC.getMILITARY_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN())
					{
						SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
					}
				}
			}
			else if (IsPlayerBrokenMilitaryPromise(eLoopPlayer))
			{
				if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
				{
					SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
				{
					SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else
				{
					int iTurnDifference = iTurn - GetPlayerMilitaryPromiseTurn(eLoopPlayer);

					// Expired?
					if (iTurnDifference >= /*80*/ GC.getMILITARY_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN())
					{
						SetPlayerMilitaryPromiseState(eLoopPlayer, NO_PROMISE_STATE);
					}
				}
			}

			if (GetPlayerMoveTroopsRequestAcceptedTurn(eLoopPlayer) > -1)
			{
				int iTurnDifference = iTurn - GetPlayerMoveTroopsRequestAcceptedTurn(eLoopPlayer);
				if (iTurnDifference >= /*20*/ GC.getMOVE_TROOPS_MEMORY_TURN_EXPIRATION())
				{
					SetPlayerMoveTroopsRequestAccepted(eLoopPlayer, false);
				}
			}

			// Expansion Promise
			if (IsPlayerMadeExpansionPromise(eLoopPlayer))
			{
				AggressivePostureTypes eOldPosture = GetPlayerExpansionPromisePosture(eLoopPlayer);

				// Player has been up to no good since we last warned him
				if ((eOldPosture != NO_AGGRESSIVE_POSTURE_TYPE) && (GetExpansionAggressivePosture(eLoopPlayer) > eOldPosture))
				{
					SetPlayerExpansionPromiseState(eLoopPlayer, PROMISE_STATE_BROKEN);
				}
				// If the expansion promise has expired, announce it
				else if (GetPlayerMadeExpansionPromise(eLoopPlayer) <= 0)
				{
					SetPlayerExpansionPromiseState(eLoopPlayer, NO_PROMISE_STATE);

					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_EXPANSION_PROMISE_EXPIRED", GET_PLAYER(GetID()).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_EXPANSION_PROMISE_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_EXPANSION_PROMISE_EXPIRED, strBuffer, strSummary, -1, -1, GetID(), eLoopPlayer);
					}
				}
			}
			else if (IsPlayerIgnoredExpansionPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerExpansionPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*30*/ GC.getEXPANSION_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerExpansionPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenExpansionPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerExpansionPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*50*/ GC.getEXPANSION_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerExpansionPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// Border Promise
			if (IsPlayerMadeBorderPromise(eLoopPlayer))
			{
				AggressivePostureTypes eOldPosture = GetPlayerBorderPromisePosture(eLoopPlayer);

				// Player has been up to no good since we last warned him
				if ((eOldPosture != NO_AGGRESSIVE_POSTURE_TYPE) && (GetPlotBuyingAggressivePosture(eLoopPlayer) > eOldPosture))
				{
					SetPlayerBorderPromiseState(eLoopPlayer, PROMISE_STATE_BROKEN);
				}
				// If the border promise has expired, announce it
				else if (GetPlayerMadeBorderPromise(eLoopPlayer) <= 0)
				{
					SetPlayerBorderPromiseState(eLoopPlayer, NO_PROMISE_STATE);

					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BORDER_PROMISE_EXPIRED", GET_PLAYER(GetID()).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_BORDER_PROMISE_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_BORDER_PROMISE_EXPIRED, strBuffer, strSummary, -1, -1, GetID(), eLoopPlayer);
					}
				}
			}
			else if (IsPlayerIgnoredBorderPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerBorderPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*30*/ GC.getBORDER_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerBorderPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenBorderPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerBorderPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*50*/ GC.getBORDER_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerBorderPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// Bully City-State Promise
			if (IsPlayerIgnoredBullyCityStatePromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerBullyCityStatePromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*30*/ GC.getBULLY_CS_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerBullyCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenBullyCityStatePromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerBullyCityStatePromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*50*/ GC.getBULLY_CS_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerBullyCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// Attack City-State Promise
			if (IsPlayerIgnoredAttackCityStatePromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerAttackCityStatePromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*40*/ GC.getATTACK_CS_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerAttackCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenAttackCityStatePromise(eLoopPlayer))
			{
				if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
				{
					SetPlayerAttackCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
				{
					SetPlayerAttackCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
				else
				{
					int iTurnDifference = iTurn - GetPlayerAttackCityStatePromiseTurn(eLoopPlayer);
					int iTimeOutTurns = (/*60*/ GC.getATTACK_CS_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

					// Expired?
					if (iTurnDifference >= iTimeOutTurns)
					{
						SetPlayerAttackCityStatePromiseState(eLoopPlayer, NO_PROMISE_STATE);
					}
				}
			}

			// Spy Promise
			if (IsPlayerIgnoredSpyPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerSpyPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*30*/ GC.getSPY_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerSpyPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenSpyPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerSpyPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*50*/ GC.getSPY_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerSpyPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// No Convert Promise
			if (IsPlayerIgnoredNoConvertPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerNoConvertPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*40*/ GC.getCONVERT_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerNoConvertPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenNoConvertPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerNoConvertPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*60*/ GC.getCONVERT_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerNoConvertPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// No Digging Promise
			if (IsPlayerIgnoredNoDiggingPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerNoDiggingPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*40*/ GC.getDIGGING_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerNoConvertPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}
			else if (IsPlayerBrokenNoDiggingPromise(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerNoDiggingPromiseTurn(eLoopPlayer);
				int iTimeOutTurns = (/*60*/ GC.getDIGGING_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerNoConvertPromiseState(eLoopPlayer, NO_PROMISE_STATE);
				}
			}

			// Coop War Promise
			// This promise does not scale with gamespeed!
			if (IsPlayerBrokenCoopWarPromise(eLoopPlayer))
			{
				if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
				{
					SetPlayerBrokenCoopWarPromise(eLoopPlayer, false);
				}
				else if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
				{
					SetPlayerBrokenCoopWarPromise(eLoopPlayer, false);
				}
				else
				{
					int iTurnDifference = iTurn - GetPlayerBrokenCoopWarPromiseTurn(eLoopPlayer);

					// Expired?
					if (iTurnDifference >= /*60*/ GC.getCOOP_WAR_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN())
					{
						SetPlayerBrokenCoopWarPromise(eLoopPlayer, false);
					}
				}
			}
		}
	}
}

/// Forces an update of expired backstabbing penalties
/// This will be called for dead players as well, when other players are examining whether backstabbing took place.
void CvDiplomacyAI::DoTestBackstabbingPenalties()
{
	int iTurn = GC.getGame().getGameTurn();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && IsHasMet(eLoopPlayer))
		{
			// Broken DoF?
			if (IsDoFBroken(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetDoFBrokenTurn(eLoopPlayer);
				int iTimeOutTurns = (/*50*/ GC.getDOF_BROKEN_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100; //todo: globals

				// If we've made amends, take away the DoF malus.
				if (GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
				{
					iTimeOutTurns = /*10*/ GC.getDOF_BROKEN_TURNS_UNTIL_FORGIVEN_FRIENDS();
				}

				int iBackstabTimer = max(0, /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER());
				if (iTimeOutTurns < iBackstabTimer)
				{
					iTimeOutTurns = iBackstabTimer;
				}

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetDoFBroken(eLoopPlayer, false, true);
				}
			}

			// Denounced us while we were friends?
			if (IsFriendDenouncedUs(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetFriendDenouncedUsTurn(eLoopPlayer);
				int iTimeOutTurns = (/*75*/ GC.getFRIEND_DENOUNCED_US_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100; //todo: globals

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetFriendDenouncedUs(eLoopPlayer, false);
				}
			}

			// Declared war on us while we were friends?
			if (IsFriendDeclaredWarOnUs(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetFriendDeclaredWarOnUsTurn(eLoopPlayer);
				int iTimeOutTurns = (/*100*/ GC.getFRIEND_DECLARED_WAR_ON_US_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100; //todo: globals

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetFriendDeclaredWarOnUs(eLoopPlayer, false);
				}
			}

			// Declared war on us while we were their vassal?
			if (MOD_DIPLOMACY_CIV4_FEATURES && IsPlayerBrokenVassalAgreement(eLoopPlayer))
			{
				int iTurnDifference = iTurn - GetPlayerBrokenVassalAgreementTurn(eLoopPlayer);
				int iTimeOutTurns = (/*100*/ GC.getMASTER_DECLARED_WAR_ON_US_TURNS_UNTIL_FORGIVEN() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100; //todo: globals

				// Expired?
				if (iTurnDifference >= iTimeOutTurns)
				{
					SetPlayerBrokenVassalAgreement(eLoopPlayer, false);
				}
			}
		}
	}
}

/// Loop through all players and decide if we view any of them as backstabbers
void CvDiplomacyAI::DoTestUntrustworthyFriends()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
	
		if (GET_PLAYER(ePlayer).isMajorCiv() && GET_PLAYER(ePlayer).isAlive() && IsHasMet(ePlayer))
		{
			SetUntrustworthyFriend(ePlayer, DoTestOnePlayerUntrustworthyFriend(ePlayer));
		}
		else
		{
			SetUntrustworthyFriend(ePlayer, false);
		}
	}
}

/// Do we view this player as a backstabber?
bool CvDiplomacyAI::DoTestOnePlayerUntrustworthyFriend(PlayerTypes ePlayer)
{
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		return true;
	}

	// Vassals can't be untrustworthy, they have no rights.
	if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
	{
		return false;
	}

	// Betrayed us as a friend?
	if (IsDoFBroken(ePlayer) || IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer))
	{
		return true;
	}

	// Betrayed us in their word?
	if (IsPlayerBrokenMilitaryPromise(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer) || IsPlayerBrokenVassalAgreement(ePlayer))
	{
		return true;
	}

	// Done massive damage to us?
	if (IsNukedBy(ePlayer))
	{
		return true;
	}
	// Stole our capital/Holy City? Unless we're your capitulated vassal, we don't care about anything you have to say...
	if (!IsVassal(ePlayer) || IsVoluntaryVassalage(ePlayer))
	{
		// If they resurrected us from the dead, check if they've ever CAPTURED our capital, don't also test to see if they currently own it
		// We should still be grateful for being resurrected, even if they didn't give us back our capital
		if (WasResurrectedBy(ePlayer))
		{
			vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
			for (size_t i=0; i<vTheirTeam.size(); i++)
			{
				if (IsPlayerCapturedCapital(vTheirTeam[i]) || IsPlayerCapturedHolyCity(vTheirTeam[i]))
				{
					return true;
				}
			}
		}
		else
		{
			if (IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer))
			{
				return true;
			}
		}
	}

	int iNumBrokenAgreements = 0;
	int iNumFriendsDenounced = 0;
	int iNumFriendsAttacked = 0;
	int iNumCivsEver = GC.getGame().countMajorCivsEverAlive();

	// Don't tolerate backstabbing if it could get us killed!
	bool bDangerous = (GC.getGame().countMajorCivsAlive() <= (iNumCivsEver / 2));
	bDangerous |= (GetPlayerNumMajorsConquered(ePlayer) >= (iNumCivsEver / 3));

	// If true, ignore backstabbing against anyone who isn't too important.
	bool bBackstabber = IsBackstabber() && !bDangerous;

	// Loop through all other civs
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer == GetID())
			continue;

		if (!GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (!IsHasMet(eLoopPlayer, true))
			continue;

		if (!WasEverBackstabbedBy(eLoopPlayer))
			continue;

		if (!GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()))
			continue;

		if (!GET_PLAYER(eLoopPlayer).isAlive())
		{
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoTestPromises();
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoTestBackstabbingPenalties();
		}

		// Do we particularly care about this player's opinion?
		bool bPriority = IsFriendOrAlly(eLoopPlayer);

		if (!bPriority && !bDangerous)
		{
			if (bBackstabber)
				continue;

			if (IsAtWar(eLoopPlayer))
				continue;

			if (IsDenouncedPlayer(eLoopPlayer))
				continue;

			if (GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
				continue;

			if (GetWarmongerThreat(eLoopPlayer) == THREAT_CRITICAL)
				continue;

			bool bLoopPlayerDangerous = (GetPlayerNumMajorsConquered(eLoopPlayer) >= (iNumCivsEver / 3));

			if (bLoopPlayerDangerous)
				continue;

			if (GetBiggestCompetitor() == eLoopPlayer)
				continue;
		}

		// This player is important to us - backstabbing is unacceptable!
		if (bPriority)
		{
			CvDiplomacyAI* pDiploAI = GET_PLAYER(eLoopPlayer).GetDiplomacyAI();

			if (pDiploAI->IsDoFBroken(ePlayer) && IsTeammate(eLoopPlayer))
			{
				return true;
			}

			if (pDiploAI->IsFriendDenouncedUs(ePlayer) || pDiploAI->IsFriendDeclaredWarOnUs(ePlayer))
			{
				return true;
			}

			if (pDiploAI->IsPlayerBrokenMilitaryPromise(ePlayer) || pDiploAI->IsPlayerBrokenAttackCityStatePromise(ePlayer) || pDiploAI->IsPlayerBrokenVassalAgreement(ePlayer))
			{
				return true;
			}

			// Now loop through all of ePlayer's teammates
			for (int iTeammateLoop = 0; iTeammateLoop < MAX_MAJOR_CIVS; iTeammateLoop++)
			{
				PlayerTypes eTeammate = (PlayerTypes) iTeammateLoop;

				if (eTeammate == GetID() || eTeammate == ePlayer || eTeammate == eLoopPlayer)
					continue;

				if (GET_PLAYER(eTeammate).getTeam() != GET_PLAYER(ePlayer).getTeam())
					continue;

				if (!GET_PLAYER(eTeammate).isAlive())
					continue;

				if (!GET_PLAYER(eTeammate).isMajorCiv())
					continue;

				if (pDiploAI->IsFriendDenouncedUs(eTeammate) || pDiploAI->IsFriendDeclaredWarOnUs(eTeammate))
				{
					return true;
				}

				if (pDiploAI->IsPlayerBrokenMilitaryPromise(eTeammate) || pDiploAI->IsPlayerBrokenAttackCityStatePromise(eTeammate) || pDiploAI->IsPlayerBrokenVassalAgreement(eTeammate))
				{
					return true;
				}
			}
		}
		// Normal check
		else if (!WasResurrectedBy(ePlayer))
		{
			CvDiplomacyAI* pDiploAI = GET_PLAYER(eLoopPlayer).GetDiplomacyAI();

			if (pDiploAI->IsFriendDenouncedUs(ePlayer))
			{
				iNumFriendsDenounced++;
			}

			if (pDiploAI->IsFriendDeclaredWarOnUs(ePlayer))
			{
				iNumFriendsAttacked++;
			}

			if (pDiploAI->IsPlayerBrokenMilitaryPromise(ePlayer))
			{
				iNumBrokenAgreements++;
			}

			if (pDiploAI->IsPlayerBrokenAttackCityStatePromise(ePlayer))
			{
				iNumBrokenAgreements++;
			}

			if (pDiploAI->IsPlayerBrokenVassalAgreement(ePlayer))
			{
				iNumBrokenAgreements++;

				if (IsVassal(ePlayer))
				{
					return true;
				}
			}

			// Now loop through all of ePlayer's teammates
			for (int iTeammateLoop = 0; iTeammateLoop < MAX_MAJOR_CIVS; iTeammateLoop++)
			{
				PlayerTypes eTeammate = (PlayerTypes) iTeammateLoop;

				if (eTeammate == GetID() || eTeammate == ePlayer || eTeammate == eLoopPlayer)
					continue;

				if (GET_PLAYER(eTeammate).getTeam() != GET_PLAYER(ePlayer).getTeam())
					continue;

				if (!GET_PLAYER(eTeammate).isAlive())
					continue;

				if (!GET_PLAYER(eTeammate).isMajorCiv())
					continue;

				if (pDiploAI->IsFriendDenouncedUs(eLoopPlayer))
				{
					iNumFriendsDenounced++;
				}

				if (pDiploAI->IsFriendDeclaredWarOnUs(eLoopPlayer))
				{
					iNumFriendsAttacked++;
				}

				if (pDiploAI->IsPlayerBrokenMilitaryPromise(eLoopPlayer))
				{
					iNumBrokenAgreements++;
				}

				if (pDiploAI->IsPlayerBrokenAttackCityStatePromise(eLoopPlayer))
				{
					iNumBrokenAgreements++;
				}
			}
		}
	}

	// If we're a backstabber, we don't care who ePlayer has backstabbed if they aren't important to us
	if (bBackstabber)
		return false;

	int iBrokenAgreementTolerance = (GetLoyalty() < 6) ? 3 : 2;
	int iFriendDenounceTolerance = (GetLoyalty() < 5) ? 2 : 1;
	int iFriendAttackedTolerance = (GetLoyalty() < 4) ? 1 : 0;

	if (GetForgiveness() > 8)
	{
		iBrokenAgreementTolerance += 2;
		iFriendDenounceTolerance++;
	}

	// Hard override in dangerous situations
	if (bDangerous)
	{
		iBrokenAgreementTolerance = 2;
		iFriendDenounceTolerance = 1;
		iFriendAttackedTolerance = 0;
	}

	// Be more tolerant if they've liberated one of our key cities.
	if (IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
	{
		iBrokenAgreementTolerance *= 2;
		iFriendDenounceTolerance++;
		iFriendAttackedTolerance++;
	}

	if (iNumBrokenAgreements > iBrokenAgreementTolerance)
	{
		return true;
	}

	if (iNumFriendsDenounced > iFriendDenounceTolerance)
	{
		return true;
	}

	if (iNumFriendsAttacked > iFriendAttackedTolerance)
	{
		return true;
	}

	return false;
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// WAR SANITY CHECKS
// ////////////////////////////////////

/// Prevent the AI from being stupid and wrecking its empire/diplomatic relationships by declaring war on the wrong person
void CvDiplomacyAI::DoUpdateSaneDiplomaticTargets()
{
	// Never check for sanity if war scenario flags are active!
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
		return;

	// Are we in bad shape? If so, we should avoid entering additional wars.
	bool bNoNewWars = GetPlayer()->IsNoNewWars();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (ePlayer == NO_PLAYER || ePlayer == BARBARIAN_PLAYER)
			continue;

		if (!GET_PLAYER(ePlayer).isAlive())
			continue;

		if (!IsHasMet(ePlayer))
			continue;

		// If we're already at war, they're a sane target.
		if (IsAtWar(ePlayer))
		{
			SetSaneDiplomaticTarget(ePlayer, true);
			continue;
		}

		// No new wars! Exception for endgame aggression and players who captured our key cities.
		if (bNoNewWars && !IsEndgameAggressiveTo(ePlayer) && !IsCapitalCapturedBy(ePlayer, true, false) && !IsHolyCityCapturedBy(ePlayer, true, false))
		{
			SetSaneDiplomaticTarget(ePlayer, false);
			continue;
		}

		// Check if this is a sane financial decision.
		if (IsWarWouldBankruptUs(ePlayer, /*bIgnoreDPs*/ false))
		{
			SetSaneDiplomaticTarget(ePlayer, false);
			continue;
		}

		// Check if this is a sane diplomatic decision for us.
		if (!DoUpdateOnePlayerSaneDiplomaticTarget(ePlayer, /*bImpulse*/ false))
		{
			SetSaneDiplomaticTarget(ePlayer, false);
			continue;
		}

		// All seems in order...full steam ahead!
		SetSaneDiplomaticTarget(ePlayer, true);
	}
}

/// Would we go bankrupt soon if we went to war with ePlayer?
bool CvDiplomacyAI::IsWarWouldBankruptUs(PlayerTypes ePlayer, bool bIgnoreDPs, int iMinimumIncome)
{
	if (IsAtWar(ePlayer))
		return false;

	int iTreasuryGold = GetPlayer()->GetTreasury()->GetGold();
	int iIncome = GetPlayer()->GetCachedGoldRate();
	int iGoldPerTurnLostFromWar = CalculateGoldPerTurnLostFromWar(ePlayer, bIgnoreDPs);

	// Would we actually lose gold from this war declaration?
	if (iGoldPerTurnLostFromWar <= 0)
		return false;

	// No? Then if we're already bankrupt, don't bother with further checks.
	if (iTreasuryGold <= 0 && iIncome <= 0)
		return true;

	int iAdjustedGPT = iIncome - iGoldPerTurnLostFromWar;

	// If we set a minimum income threshold and we're below that, abort!
	if (iMinimumIncome != 0)
	{
		if (iAdjustedGPT < iMinimumIncome)
		{
			return true;
		}
	}

	// Play it safe if we're exactly at 0
	if (iAdjustedGPT == 0)
	{
		return true;
	}
	// If we're above 0, it's cool
	else if (iAdjustedGPT > 0)
	{
		return false;
	}

	iAdjustedGPT *= -1; // flip the sign!
	int iTurnsUntilBankruptcy = iTreasuryGold / iAdjustedGPT;

	if (iTurnsUntilBankruptcy <= 30)
		return true;

	return false;
}

/// How much Gold Per Turn would we lose if we went to war with this player?
int CvDiplomacyAI::CalculateGoldPerTurnLostFromWar(PlayerTypes ePlayer, bool bIgnoreDPs)
{
	if (IsAtWar(ePlayer))
		return 0;

	int iGPT = 0;
	PlayerTypes eMyPlayer = GetID();

	// City-State - easy calculation
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		iGPT += (GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(ePlayer) / 100);
		iGPT += GET_PLAYER(ePlayer).GetMinorCivAI()->GetCurrentGoldBonus(eMyPlayer);
		return iGPT;
	}

	iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(ePlayer);
	iGPT += (GC.getGame().GetGameDeals().GetDealGPTLostFromWar(GetID(), ePlayer) * 100);

	// Vassal taxes?
	if (IsMaster(ePlayer))
	{
		iGPT += GetPlayer()->GetTreasury()->GetVassalTaxContributionTimes100(ePlayer);
	}

	vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(ePlayer, bIgnoreDPs, true, false);

	for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
	{
		iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(*it);

		if (GET_PLAYER(*it).isMajorCiv())
		{
			iGPT += (GC.getGame().GetGameDeals().GetDealGPTLostFromWar(eMyPlayer, *it) * 100);
		}
		else
		{
			iGPT += (GET_PLAYER(*it).GetMinorCivAI()->GetCurrentGoldBonus(eMyPlayer) * 100);
		}
	}

	// Bring it out of hundreds
	iGPT /= 100;

	return iGPT;
}

/// Is it diplomatically sane to declare war on this player?
bool CvDiplomacyAI::DoUpdateOnePlayerSaneDiplomaticTarget(PlayerTypes ePlayer, bool bImpulse)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return false;

	// Already at war?
	if (IsAtWar(ePlayer))
		return true;

	// City-States have a much easier check
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		// Don't declare war if we've pledged protection!
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
			return false;

		PlayerTypes eAlly = GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly();

		if (eAlly != NO_PLAYER)
		{
			// Don't declare war on our own ally!
			if (eAlly == GetID())
				return false;

			// Don't declare war on our friends' allies, either.
			if (IsFriendOrAlly(eAlly))
				return false;
		}

		// Check to see who's protecting this City-State...
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
			{
				// Don't declare war on our friends' protectorates...
				if (IsFriendOrAlly(eLoopPlayer))
				{
					return false;
				}
			}
		}

		return true;
	}

	// For major civs we have a lot more to consider...
	vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(ePlayer, false, false, false);
	vLinkedWarPlayers.push_back(ePlayer);

	// Something's wrong here...
	if (vLinkedWarPlayers.empty())
		return false;

	// Loop through each major and decide if A) declaring war would be backstabbing them and B) we're okay with doing so.
	for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
	{
		bool bDirect = (GET_PLAYER(*it).getTeam() == GET_PLAYER(ePlayer).getTeam());
		bDirect |= GET_PLAYER(*it).GetDiplomacyAI()->IsVassal(ePlayer);

		if (CanBackstab(*it) && !IsWillingToAttackFriend(*it, bDirect, bImpulse))
			return false;
	}

	// If this is an impulsive decision, run this by our teammates too.
	if (bImpulse)
	{
		vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
		for (size_t i=0; i<vOurTeam.size(); i++)
		{
			if (GET_PLAYER(vOurTeam[i]).GetID() == GetID())
				continue;

			if (!GET_PLAYER(vOurTeam[i]).isAlive())
				continue;

			if (!GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->IsSaneDiplomaticTarget(ePlayer))
				return false;
		}
	}

	// Seems everything is okay - let's go!
	return true;
}

/// Would declaring war on this person be considered backstabbing or otherwise disadvantageous in some way?
bool CvDiplomacyAI::CanBackstab(PlayerTypes ePlayer) const
{
	if (IsDoFAccepted(ePlayer))
		return true;

	if (IsHasDefensivePact(ePlayer))
		return true;

	if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
		return true;

	if (WasResurrectedBy(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetID()))
		return true;

	if (GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		return true;

	if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetID()))
		return true;

	if (IsPlayerLiberatedCapital(ePlayer))
		return true;

	if (IsCityRecentlyLiberatedBy(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFBroken(GetID()) && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetTurnsSinceDoFBroken(GetID()) < /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER())
		return true;

	if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
		return true;

	// Only check this for humans...AI handles this in SelectApproachTowardsVassal()
	if (GetPlayer()->isHuman() && IsMaster(ePlayer))
		return true;

	return false;
}

/// Are we devious enough to declare war on our friend?
bool CvDiplomacyAI::IsWillingToAttackFriend(PlayerTypes ePlayer, bool bDirect, bool bImpulse)
{
	// If this is called for a human, always return no
	if (GetPlayer()->isHuman())
		return false;

	// No backstabbing if we're not competitive.
	if (!IsCompetingForVictory())
		return false;

	// Never backstab if they resurrected us or vice versa
	if (WasResurrectedBy(ePlayer))
		return false;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetID()))
		return false;

	// Too scared of them?
	if (GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_AFRAID)
		return false;

	// Like them too much?
	if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
		return false;

	if (GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		return false;

	bool bEndgameAggressive = IsEndgameAggressiveTo(ePlayer);
	bool bUntrustworthy = IsUntrustworthy(ePlayer);

	if (!bImpulse && !bEndgameAggressive && !bUntrustworthy)
	{
		// Liberating our cities?
		if (IsPlayerLiberatedCapital(ePlayer) && bDirect)
			return false;

		if (IsCityRecentlyLiberatedBy(ePlayer) && GetPlayer()->getCitiesLost() > 0)
			return false;

		// Don't declare war if we agreed to start a coop war with them, that's dumb.
		if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
			return false;

		// Don't declare war if we promised not to attack!
		if (bDirect)
		{
			if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
				return false;

			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetID()))
				return false;
		}
	}

	// What kind of backstabbing is this?
	// Backstab timer?
	bool bBackstabTimer = (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFBroken(GetID()) && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetTurnsSinceDoFBroken(GetID()) < /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER());

	if (bBackstabTimer && bDirect)
	{
		// Only do this if there are no consequences
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer))
			{
				if (WouldBeUpsetIfAttackedFriend(eLoopPlayer, ePlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(GetID()))
				{
					if (IsFriendOrAlly(eLoopPlayer))
					{
						return false;
					}
					else if (IsStrategicTradePartner(eLoopPlayer))
					{
						return false;
					}
					else if (!IsEasyTarget(eLoopPlayer))
					{
						return false;
					}
					else if (!IsBackstabber() && GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
					{
						return false;
					}
				}
			}
		}
	}
	// Declaration of Friendship or Defensive Pact?
	else if (IsDoFAccepted(ePlayer) || (IsHasDefensivePact(ePlayer) && !IsWantsToEndDefensivePactWithPlayer(ePlayer)))
	{
		// Don't directly backstab if approach is FRIENDLY (unless they provoked us)
		if (bDirect && !bImpulse && GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_FRIENDLY)
			return false;

		// We must be stronger than them
		bool bEasyTarget = IsEasyTarget(ePlayer);

		if (bEasyTarget)
		{
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) > STRENGTH_POWERFUL)
				return false;

			if (GetPlayerEconomicStrengthComparedToUs(ePlayer) > STRENGTH_POWERFUL)
				return false;
		}
		else
		{
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE)
				return false;

			if (GetPlayerEconomicStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE)
				return false;
		}

		// Don't backstab if we're loyal
		if (!IsBackstabber() && !bEndgameAggressive && GetLoyalty() > 6)
			return false;

		// We need a good reason to even consider backstabbing a friend...
		bool bGoodReason = IsBackstabber(); // if we've already backstabbed one friend, more willing to backstab others
		bGoodReason |= bEndgameAggressive;
		bGoodReason |= bUntrustworthy;
		bGoodReason |= IsCloseToDominationVictory() && GET_PLAYER(ePlayer).GetCapitalConqueror() == NO_PLAYER;
		bGoodReason |= GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWeDeclaredWarOnFriendCount() > 0; // they also backstabbed people
		bGoodReason |= GetBiggestCompetitor() == ePlayer;
		bGoodReason |= GetWarmongerThreat(ePlayer) >= THREAT_SEVERE;

		if (!bDirect)
		{
			bGoodReason |= IsGoingForWorldConquest() && GET_PLAYER(ePlayer).GetCapitalConqueror() == NO_PLAYER;
			bGoodReason |= IsMajorCompetitor(ePlayer);
		}

		if (!bGoodReason)
			return false;

		// Further checks are only necessary for Declarations of Friendship...breaking a DP doesn't earn a global backstabbing penalty
		if (IsDoFAccepted(ePlayer))
		{
			// Okay, so we have a good reason. Are there any consequences from doing this that we're unwilling to face?
			if (bDirect)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if (IsPlayerValid(eLoopPlayer))
					{
						if (WouldBeUpsetIfAttackedFriend(eLoopPlayer, ePlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(GetID()))
						{
							if (IsFriendOrAlly(eLoopPlayer))
							{
								return false;
							}
							else if (IsStrategicTradePartner(eLoopPlayer))
							{
								return false;
							}
							else if (!(IsEasyTarget(eLoopPlayer) || GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(eLoopPlayer)) && GetPlayer()->GetProximityToPlayer(eLoopPlayer) >= PLAYER_PROXIMITY_CLOSE)
							{
								return false;
							}
							else if (!IsBackstabber() && GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
							{
								return false;
							}
						}
					}
				}
			}
			// Indirect backstab via Defensive Pact - much lower bar. Aim here is to prevent AIs from getting caught up in DP gridlock.
			else
			{
				// Ignore vassals!
				if (!GET_PLAYER(ePlayer).IsVassalOfSomeone())
				{
					// Don't do it if we're very loyal
					if (!IsBackstabber() && !bEndgameAggressive && GetLoyalty() > 8)
						return false;

					// Don't do it if we'd lose a valuable trade partner
					if (IsStrategicTradePartner(ePlayer))
						return false;

					// Impulse wars against people we like are a bad idea.
					if (bImpulse && GetMajorCivOpinion(ePlayer) >= MAJOR_CIV_OPINION_FRIEND)
						return false;

					// Impulse wars against neighbors that aren't easy targets are a bad idea.
					if (bImpulse && GET_PLAYER(ePlayer).GetProximityToPlayer(GetID()) >= PLAYER_PROXIMITY_CLOSE && !IsEasyTarget(ePlayer))
						return false;
				}
			}
		}
	}

	// If we've gone through all the hoops then we're okay with it.
	return true;
}

/// This will do for now...may write more sophisticated logic later
bool CvDiplomacyAI::WouldBeUpsetIfAttackedFriend(PlayerTypes ePlayer, PlayerTypes eBackstabPlayer) const
{
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasEverBackstabbedBy(eBackstabPlayer))
		return false;

	if (GET_PLAYER(eBackstabPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(ePlayer))
		return false;

	return true;
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// OPINION
// ////////////////////////////////////

/// Determines our Diplomatic Opinions of all players we've met
void CvDiplomacyAI::DoUpdateOpinions()
{
	DoTestOpinionModifiers();

	// Loop through all (known) Majors
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && IsHasMet(eLoopPlayer))
		{
			DoUpdateOnePlayerOpinion(eLoopPlayer);
		}
		else
		{
			SetMajorCivOpinion(eLoopPlayer, NO_MAJOR_CIV_OPINION);
		}
	}
}

/// What is our basic opinion of the role a player has in our game?
void CvDiplomacyAI::DoUpdateOnePlayerOpinion(PlayerTypes ePlayer)
{
	MajorCivOpinionTypes eOpinion;

	// Teammates?
	if (IsTeammate(ePlayer))
	{
		eOpinion = MAJOR_CIV_OPINION_ALLY;
		SetCachedOpinionWeight(ePlayer, SHRT_MIN);

#if defined(MOD_ACTIVE_DIPLOMACY)
		if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY && !GetPlayer()->isHuman())
		{
			// JdH => calculate ai to human trade priority for multiplayer
			DoUpdateHumanTradePriority(ePlayer, GC.getOPINION_THRESHOLD_ALLY());
		}
#endif
	}
	// Always at war?
	else if (IsAlwaysAtWar(ePlayer))
	{
		eOpinion = MAJOR_CIV_OPINION_UNFORGIVABLE;
		SetCachedOpinionWeight(ePlayer, SHRT_MAX);
	}
	// Different teams
	else
	{
		// Human shadow AI skips the normal code
		if (GetPlayer()->isHuman())
		{
			if (IsAtWar(ePlayer) || IsDenouncedPlayer(ePlayer))
				SetMajorCivOpinion(ePlayer, MAJOR_CIV_OPINION_ENEMY);
			else
				SetMajorCivOpinion(ePlayer, MAJOR_CIV_OPINION_NEUTRAL);
			return;
		}

		int iOpinionWeight = GetMajorCivOpinionWeight(ePlayer);
		SetCachedOpinionWeight(ePlayer, iOpinionWeight);

		if (iOpinionWeight >= /*160*/ GC.getOPINION_THRESHOLD_UNFORGIVABLE())
			eOpinion = MAJOR_CIV_OPINION_UNFORGIVABLE;
		else if (iOpinionWeight >= /*80*/ GC.getOPINION_THRESHOLD_ENEMY())
			eOpinion = MAJOR_CIV_OPINION_ENEMY;
		else if (iOpinionWeight >= /*30*/ GC.getOPINION_THRESHOLD_COMPETITOR())
			eOpinion = MAJOR_CIV_OPINION_COMPETITOR;
		else if (iOpinionWeight > /*-30*/ GC.getOPINION_THRESHOLD_FAVORABLE())
			eOpinion = MAJOR_CIV_OPINION_NEUTRAL;
		else if (iOpinionWeight > /*-80*/ GC.getOPINION_THRESHOLD_FRIEND())
			eOpinion = MAJOR_CIV_OPINION_FAVORABLE;
		else if (iOpinionWeight > /*-160*/ GC.getOPINION_THRESHOLD_ALLY())
			eOpinion = MAJOR_CIV_OPINION_FRIEND;
		else
			eOpinion = MAJOR_CIV_OPINION_ALLY;

#if defined(MOD_ACTIVE_DIPLOMACY)
		if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH => calculate ai to human trade priority for multiplayer
			DoUpdateHumanTradePriority(ePlayer, iOpinionWeight);
		}
#endif
	}

	// Finally, set the Opinion
	SetMajorCivOpinion(ePlayer, eOpinion);
}

/// What is the number value of our opinion towards ePlayer?
int CvDiplomacyAI::GetMajorCivOpinionWeight(PlayerTypes ePlayer)
{
	int iOpinionWeight = GetBaseOpinionScore(ePlayer);

	//////////////////////////////////////
	// DISPUTE MODIFIERS
	//////////////////////////////////////

	iOpinionWeight += GetLandDisputeLevelScore(ePlayer);
	iOpinionWeight += GetWonderDisputeLevelScore(ePlayer);
	iOpinionWeight += GetMinorCivDisputeLevelScore(ePlayer);
	iOpinionWeight += GetTechBlockLevelScore(ePlayer);
	iOpinionWeight += GetPolicyBlockLevelScore(ePlayer);
	iOpinionWeight += GetVictoryDisputeLevelScore(ePlayer);
	iOpinionWeight += GetVictoryBlockLevelScore(ePlayer);
	iOpinionWeight += GetAngryAboutSidedWithProtectedMinorScore(ePlayer);

	//////////////////////////////////////
	// WAR STUFF
	//////////////////////////////////////

	iOpinionWeight += GetWarmongerThreatScore(ePlayer);
	iOpinionWeight += GetTradeRoutesPlunderedScore(ePlayer);
	iOpinionWeight += max(GetCitiesRazedScore(ePlayer), GetCitiesRazedGlobalScore(ePlayer));
	iOpinionWeight += GetNukedByScore(ePlayer);
	iOpinionWeight += GetHolyCityCapturedByScore(ePlayer);
	iOpinionWeight += GetCapitalCapturedByScore(ePlayer);

	if (!IsVassal(ePlayer))
		iOpinionWeight += (int)GetMilitaryAggressivePosture(ePlayer) * 5;

	//////////////////////////////////////
	// Player has done nice stuff
	//////////////////////////////////////

	iOpinionWeight += GetRecentTradeScore(ePlayer);
	iOpinionWeight += GetRecentAssistScore(ePlayer);
	iOpinionWeight += GetCommonFoeScore(ePlayer);
	iOpinionWeight += GetCiviliansReturnedToMeScore(ePlayer);
	iOpinionWeight += GetLandmarksBuiltForMeScore(ePlayer);
	iOpinionWeight += GetResurrectedScore(ePlayer);
	iOpinionWeight += GetLiberatedCapitalScore(ePlayer);
	iOpinionWeight += GetLiberatedHolyCityScore(ePlayer);
	iOpinionWeight += GetLiberatedCitiesScore(ePlayer);
	iOpinionWeight += GetReturnedCapitalScore(ePlayer);
	iOpinionWeight += GetReturnedHolyCityScore(ePlayer);
	iOpinionWeight += GetEmbassyScore(ePlayer);
	iOpinionWeight += GetDiplomatScore(ePlayer);
	iOpinionWeight += GetForgaveForSpyingScore(ePlayer);
	iOpinionWeight += GetTimesIntrigueSharedScore(ePlayer);

	//////////////////////////////////////
	// Player has done mean stuff
	//////////////////////////////////////

	iOpinionWeight += GetTimesCultureBombedScore(ePlayer);
	iOpinionWeight += GetTimesRobbedScore(ePlayer);
	iOpinionWeight += GetTimesPlottedAgainstUsScore(ePlayer);
	iOpinionWeight += GetTimesPerformedCoupScore(ePlayer);
	iOpinionWeight += GetDugUpMyYardScore(ePlayer);

	//////////////////////////////////////
	// Player has asked us to do things we don't like
	//////////////////////////////////////

	iOpinionWeight += GetNoSettleRequestScore(ePlayer);
	iOpinionWeight += GetStopSpyingRequestScore(ePlayer);
	iOpinionWeight += GetDemandEverMadeScore(ePlayer);

	//////////////////////////////////////
	// DENOUNCING
	//////////////////////////////////////

	iOpinionWeight += GetMutualDenouncementScore(ePlayer);
	iOpinionWeight += GetDenouncedUsScore(ePlayer);
	iOpinionWeight += GetDenouncedThemScore(ePlayer);
	iOpinionWeight += GetDenouncedFriendScore(ePlayer);
	iOpinionWeight += GetDenouncedEnemyScore(ePlayer);

	//////////////////////////////////////
	// PROMISES
	//////////////////////////////////////

	iOpinionWeight += GetBrokenMilitaryPromiseScore(ePlayer);
	iOpinionWeight += GetBrokenMilitaryPromiseWithAnybodyScore(ePlayer);
	iOpinionWeight += GetIgnoredMilitaryPromiseScore(ePlayer);
	
	iOpinionWeight += GetBrokenExpansionPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredExpansionPromiseScore(ePlayer);
	
	iOpinionWeight += GetBrokenBorderPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredBorderPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenAttackCityStatePromiseScore(ePlayer);
	iOpinionWeight += GetBrokenAttackCityStatePromiseWithAnybodyScore(ePlayer);
	iOpinionWeight += GetIgnoredAttackCityStatePromiseScore(ePlayer);

	iOpinionWeight += GetBrokenBullyCityStatePromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredBullyCityStatePromiseScore(ePlayer);

	iOpinionWeight += GetBrokenNoConvertPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredNoConvertPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenNoDiggingPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredNoDiggingPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenSpyPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredSpyPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenCoopWarPromiseScore(ePlayer);

	//////////////////////////////////////
	// RELIGION/IDEOLOGY
	//////////////////////////////////////

	iOpinionWeight += GetPolicyScore(ePlayer);
	iOpinionWeight += GetReligionScore(ePlayer);
	iOpinionWeight += GetReligiousConversionPointsScore(ePlayer);
	iOpinionWeight += GetIdeologyScore(ePlayer);

	//////////////////////////////////////
	// PROTECTED MINORS
	//////////////////////////////////////

	iOpinionWeight += GetPtPSameCSScore(ePlayer);
	iOpinionWeight += GetAngryAboutProtectedMinorKilledScore(ePlayer);
	iOpinionWeight += GetAngryAboutProtectedMinorAttackedScore(ePlayer);
	iOpinionWeight += GetAngryAboutProtectedMinorBulliedScore(ePlayer);

	//////////////////////////////////////
	// DECLARATION OF FRIENDSHIP
	//////////////////////////////////////

	iOpinionWeight += GetDOFAcceptedScore(ePlayer);
	iOpinionWeight += GetDOFWithAnyFriendScore(ePlayer);
	iOpinionWeight += GetDOFWithAnyEnemyScore(ePlayer);

	//////////////////////////////////////
	// TRADE AGREEMENTS
	//////////////////////////////////////

	iOpinionWeight += GetDPAcceptedScore(ePlayer);
	iOpinionWeight += GetDPWithAnyFriendScore(ePlayer);
	iOpinionWeight += GetDPWithAnyEnemyScore(ePlayer);
	iOpinionWeight += GetOpenBordersScore(ePlayer);
	iOpinionWeight += GetResearchAgreementScore(ePlayer);

	//////////////////////////////////////
	// TRAITOR OPINION
	//////////////////////////////////////

	int iTraitorOpinion = GetFriendDenouncementScore(ePlayer);
	iTraitorOpinion = max(iTraitorOpinion, GetWeDenouncedFriendScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetFriendDenouncedUsScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetWeDeclaredWarOnFriendScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetFriendDeclaredWarOnUsScore(ePlayer));
	iOpinionWeight += iTraitorOpinion;

	//////////////////////////////////////
	// RECKLESS EXPANDER / WONDER SPAMMER
	//////////////////////////////////////

	iOpinionWeight += GetRecklessExpanderScore(ePlayer);
	iOpinionWeight += GetWonderSpammerScore(ePlayer);

	//////////////////////////////////////
	// WORLD CONGRESS
	//////////////////////////////////////

	iOpinionWeight += GetLeagueAlignmentScore(ePlayer);
	iOpinionWeight += GetLikedTheirProposalScore(ePlayer);
	iOpinionWeight += GetDislikedTheirProposalScore(ePlayer);
	iOpinionWeight += GetSupportedOurProposalScore(ePlayer);
	iOpinionWeight += GetSupportedMyHostingScore(ePlayer);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	//////////////////////////////////////
	// VASSALAGE
	//////////////////////////////////////
	if (MOD_DIPLOMACY_CIV4_FEATURES) 
	{
		iOpinionWeight += GetVassalScore(ePlayer);
		iOpinionWeight += GetVassalTreatedScore(ePlayer);
		iOpinionWeight += GetMasterScore(ePlayer);
		iOpinionWeight += GetTooManyVassalsScore(ePlayer);
		iOpinionWeight += GetSameMasterScore(ePlayer);
		iOpinionWeight += GetHappyAboutVassalagePeacefullyRevokedScore(ePlayer);
		iOpinionWeight += GetAngryAboutVassalageForcefullyRevokedScore(ePlayer);
		iOpinionWeight += GetBrokenVassalAgreementScore(ePlayer);
	}
#endif

	//////////////////////////////////////
	// SCENARIO-SPECIFIC
	//////////////////////////////////////
#if defined(MOD_EVENTS_DIPLO_MODIFIERS)
	if (MOD_EVENTS_DIPLO_MODIFIERS && !GC.getGame().isReallyNetworkMultiPlayer() && !GC.getGame().isNetworkMultiPlayer())
	{
		std::vector<Opinion> aOpinions;
		iOpinionWeight += GetDiploModifiers(ePlayer, aOpinions);
	}
#else
	iOpinionWeight += GetScenarioModifier1(ePlayer);
	iOpinionWeight += GetScenarioModifier2(ePlayer);
	iOpinionWeight += GetScenarioModifier3(ePlayer);
#endif

	return iOpinionWeight;
}

#if defined(MOD_ACTIVE_DIPLOMACY)
// JdH => calculate ai to human trade priority for multiplayer
void CvDiplomacyAI::DoUpdateHumanTradePriority(PlayerTypes ePlayer, int iOpinionWeight)
{
	if (ePlayer >= 0 && ePlayer < MAX_MAJOR_CIVS)
	{
		iOpinionWeight = max(iOpinionWeight, GC.getOPINION_THRESHOLD_ALLY());
		iOpinionWeight = min(iOpinionWeight, GC.getOPINION_THRESHOLD_UNFORGIVABLE());
		iOpinionWeight -= GC.getOPINION_THRESHOLD_UNFORGIVABLE(); // make it >= 0
		if (iOpinionWeight < 0)
		{
			iOpinionWeight = 0;
		}

		float opinion = iOpinionWeight / (float)(GC.getOPINION_THRESHOLD_ALLY() - GC.getOPINION_THRESHOLD_UNFORGIVABLE());

		int turnsPassed = GC.getGame().getGameTurn() - GetNumTurnsSinceSomethingSent(ePlayer);

		m_aTradePriority[ePlayer] = 10.0f * opinion + turnsPassed; // factor in turns since last contact and opinion of player
	}
}
#endif

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// GLOBAL POLITICS
// ////////////////////////////////////

/// Decide how we're going to handle other players in the world this turn
void CvDiplomacyAI::DoUpdateGlobalPolitics()
{
	vector<PlayerTypes> v;
	DoUpdateMajorCivApproaches(v, /*bStrategic*/ true);
	DoUpdateMajorCompetitors();
	DoRelationshipPairing();
	DoUpdateMajorCivApproaches(v, /*bStrategic*/ false);
	DoUpdateWarTargets();
	DoUpdatePlanningExchanges();
	DoUpdateMinorCivApproaches();
}

/// Reevaluate our general Diplomatic Approach towards specified players
void CvDiplomacyAI::DoReevaluatePlayers(vector<PlayerTypes>& vTargetPlayers, bool bFromWar, bool bCancelExchanges)
{
	if (vTargetPlayers.empty())
		return;

	DoTestPromises();
	DoTestBackstabbingPenalties();

	// If human or dead, halt here!
	if (GetPlayer()->isHuman() || !GetPlayer()->isAlive())
		return;

	DoTestUntrustworthyFriends();

	// War declaration/major event? We have a lot more reevaluating to do.
	if (bFromWar)
	{
		DoResetPotentialWarTargets();
		DoUpdateWarDamage();
		DoUpdateWarStates();
		DoUpdatePlayerMilitaryStrengths();
		DoUpdatePlayerEconomicStrengths();
		DoUpdateMilitaryThreats();
		DoUpdateWarmongerThreats();
		DoUpdatePlayerTargetValues();
		DoUpdateWarProjections();
		GetPlayer()->cacheGoldRate();
		GetPlayer()->DoTestEmpireInBadShapeForWar();
		DoUpdateEasyTargets();
		DoUpdateWarGoals();
		DoUpdatePeaceTreatyWillingness();
		DoUpdateSaneDiplomaticTargets();
	}

	vector<PlayerTypes> vPlayersToReevaluate;

	for (std::vector<PlayerTypes>::iterator it = vTargetPlayers.begin(); it != vTargetPlayers.end(); it++)
	{
		if (GET_PLAYER(*it).isAlive() && IsHasMet(*it))
		{
			DoUpdateOnePlayerOpinion(*it);
			vPlayersToReevaluate.push_back(*it);

			// Reevaluate our exchange desires with this player next turn!
			if (bCancelExchanges)
			{
				SetWantsDoFWithPlayer(*it, false);
				SetWantsDefensivePactWithPlayer(*it, false);
				SetWantsResearchAgreementWithPlayer(*it, false);
			}
		}
	}

	DoUpdateMajorCivApproaches(vPlayersToReevaluate, /*bStrategic*/ false);
}

/// Updates our general Diplomatic Approach towards each major civilization we've met
void CvDiplomacyAI::DoUpdateMajorCivApproaches(vector<PlayerTypes>& vPlayersToReevaluate, bool bStrategic)
{
	std::vector<PlayerTypes> vPlayersToUpdate;
	std::vector<PlayerTypes> vPostUpdatePlayers;
	std::map<PlayerTypes, MajorCivApproachTypes> oldApproaches;
	bool bReevaluation = !vPlayersToReevaluate.empty();
	bool bHuman = GetPlayer()->isHuman();
	bool bNoCities = GetPlayer()->getCapitalCity() == NULL;
	bool bFirstPass = (bStrategic || bReevaluation);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).isAlive() && IsHasMet(eLoopPlayer, false))
		{
			MajorCivApproachTypes eOldApproach = GetMajorCivApproach(eLoopPlayer);
			bool bPriorityUpdate = false;

			// Under certain circumstances, set the approach immediately
			// Prioritized approach updates are done first and don't depend on each other, therefore we can fairly use the new approach in the map ...
			// Only do this on the first pass, because we'll get the exact same result next time.
			if (IsAlwaysAtWar(eLoopPlayer))
			{
				bPriorityUpdate = true;
				if (bFirstPass)
					SelectAlwaysWarApproach(eLoopPlayer);
			}
			else if (bHuman)
			{
				bPriorityUpdate = true;
				if (bFirstPass)
					SelectHumanApproach(eLoopPlayer);
			}
			else if (bNoCities)
			{
				bPriorityUpdate = true;
				if (bFirstPass)
					SelectApproachIfWeHaveNoCities(eLoopPlayer);
			}
			else if (GET_PLAYER(eLoopPlayer).getCapitalCity() == NULL)
			{
				bPriorityUpdate = true;
				if (bFirstPass)
					SelectApproachIfTheyHaveNoCities(eLoopPlayer);
			}
			
			if (bPriorityUpdate)
			{
				MajorCivApproachTypes eUpdatedApproach = GetMajorCivApproach(eLoopPlayer);
				oldApproaches.insert(std::make_pair(eLoopPlayer, eUpdatedApproach));
				continue;
			}

			// Otherwise, add the old approach to the map ...
			oldApproaches.insert(std::make_pair(eLoopPlayer, eOldApproach));

			// If this is a between turns (reevaluation) update, we only reevaluate the players on the list (for performance reasons).
			if (bReevaluation)
			{
				if (std::find(vPlayersToReevaluate.begin(), vPlayersToReevaluate.end(), eLoopPlayer) == vPlayersToReevaluate.end())
					continue;
			}

			// If this player is our master or someone's vassal (and aren't a priority update), we'll deal with them after we're done with the regular approaches
			if (IsVassal(eLoopPlayer) || GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
			{
				vPostUpdatePlayers.push_back(eLoopPlayer);
			}
			else // ... now we add this player to the list of civs to update approaches for this turn	
			{
				vPlayersToUpdate.push_back(eLoopPlayer);
			}
		}
	}

	// Now loop through each player and update their approach!
	for (std::vector<PlayerTypes>::iterator it = vPlayersToUpdate.begin(); it != vPlayersToUpdate.end(); it++)
	{
		SelectBestApproachTowardsMajorCiv(*it, bStrategic, vPlayersToUpdate, vPlayersToReevaluate, oldApproaches);
	}

	// Lastly we handle any post update cases
	if (!bStrategic || bReevaluation)
	{
		for (std::vector<PlayerTypes>::iterator it = vPostUpdatePlayers.begin(); it != vPostUpdatePlayers.end(); it++)
		{
			if (IsVassal(*it))
			{
				SelectApproachTowardsMaster(*it);
			}
			else if (GET_PLAYER(*it).IsVassalOfSomeone())
			{
				SelectApproachTowardsVassal(*it);
			}
		}
	}
}

/// Updates our Diplomatic Approach towards a Civ that we're at permanent war with
void CvDiplomacyAI::SelectAlwaysWarApproach(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		// Permanent war means ONLY WAR!
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_WAR;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 9999;

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_CONQUEST);
	}
}

/// Updates the human shadow AI's Diplomatic Approach towards a Civ
void CvDiplomacyAI::SelectHumanApproach(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

		if (IsAtWar(ePlayer))
		{
			eApproach = MAJOR_CIV_APPROACH_WAR;
		}
		else
		{
			if (IsDenouncedPlayer(ePlayer) || IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
			}
			else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
			{
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
			else if (IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer) || GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
			{
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
			}
			else
			{
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			}
		}

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;

		// Add some base weight to the approach we've selected
		vApproachScores[(int)eApproach] = /*5*/ GC.getGame().GetDefaultFlavorValue();

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		if (IsAtWar(ePlayer))
		{
			if (IsPeaceBlocked(ePlayer))
			{
				SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
			}
			else
			{
				SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_CONQUEST);
			}
		}
		else if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsAllies(GetID()) || GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
		{
			SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_PROTECTIVE);
		}
		else if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsFriends(GetID()))
		{
			SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_FRIENDLY);
		}
		else
		{
			SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
		}
	}
}

/// Updates our Diplomatic Approach towards a Civ if we have no cities
void CvDiplomacyAI::SelectApproachIfWeHaveNoCities(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

		if (IsAtWar(ePlayer))
		{
			eApproach = MAJOR_CIV_APPROACH_WAR;
		}
		else
		{
			if (IsDenouncedPlayer(ePlayer) || IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer) || IsUntrustworthy(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
			}
			else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
			{
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
			else if (WasResurrectedBy(ePlayer) || IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
			}
			else if (GetNumCitiesCapturedBy(ePlayer) > 0)
			{
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
			else
			{
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			}
		}

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
		{
			// If this is the first time ever updating approach towards this player, let's not be hostile right off the bat - neutral is fine, though.
			if (eApproach != MAJOR_CIV_APPROACH_NEUTRAL && eApproach != MAJOR_CIV_APPROACH_FRIENDLY)
			{
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			}

			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		}

		// Add some base weight to the approach we've selected
		vApproachScores[(int)eApproach] = GetPersonalityMajorCivApproachBias(eApproach);

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
	}
}

/// Updates our Diplomatic Approach towards a Civ that has no cities
void CvDiplomacyAI::SelectApproachIfTheyHaveNoCities(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

		if (IsAtWar(ePlayer))
		{
			eApproach = MAJOR_CIV_APPROACH_WAR;
		}
		else
		{
			if (IsDenouncedPlayer(ePlayer) || IsUntrustworthy(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
			}
			else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
			{
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
			else if (WasResurrectedBy(ePlayer) || IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
			}
			else
			{
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			}
		}

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
		{
			// If this is the first time ever updating approach towards this player, let's not be hostile right off the bat - neutral is fine, though.
			if (eApproach != MAJOR_CIV_APPROACH_NEUTRAL && eApproach != MAJOR_CIV_APPROACH_FRIENDLY)
			{
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			}

			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		}

		// Add some base weight to the approach we've selected
		vApproachScores[(int)eApproach] = GetPersonalityMajorCivApproachBias(eApproach);

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		if (IsAtWar(ePlayer))
		{
			SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_CONQUEST);
		}
		else
		{
			SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
		}
	}
}

/// Updates our Diplomatic Approach towards a Master of ours
void CvDiplomacyAI::SelectApproachTowardsMaster(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (!IsVassal(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

		VassalTreatmentTypes eTreatmentLevel = GetVassalTreatmentLevel(ePlayer);

		if (IsVoluntaryVassalage(ePlayer))
		{
			switch (eTreatmentLevel)
			{
			case VASSAL_TREATMENT_CONTENT:
			case VASSAL_TREATMENT_DISAGREE:
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				break;
			case VASSAL_TREATMENT_MISTREATED:
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
				break;
			case VASSAL_TREATMENT_UNHAPPY:
				eApproach = WasResurrectedBy(ePlayer) ? MAJOR_CIV_APPROACH_GUARDED : MAJOR_CIV_APPROACH_HOSTILE;
				break;
			case VASSAL_TREATMENT_ENSLAVED:
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
				break;
			}
		}
		else
		{
			switch (eTreatmentLevel)
			{
			case VASSAL_TREATMENT_CONTENT:
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				break;
			case VASSAL_TREATMENT_DISAGREE:
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
				break;
			case VASSAL_TREATMENT_MISTREATED:
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
				break;
			case VASSAL_TREATMENT_UNHAPPY:
			case VASSAL_TREATMENT_ENSLAVED:
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
				break;
			}
		}

		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

		if (IsUntrustworthy(ePlayer) || eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		{
			eApproach = MAJOR_CIV_APPROACH_HOSTILE;
		}
		else if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer) || eOpinion == MAJOR_CIV_OPINION_ENEMY)
		{
			if (eApproach != MAJOR_CIV_APPROACH_HOSTILE)
			{
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
			}
		}

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;

		// Add some base weight to the approach we've selected
		vApproachScores[(int)eApproach] = GetPersonalityMajorCivApproachBias(eApproach);

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
}

/// Updates our Diplomatic Approach towards a Vassal
void CvDiplomacyAI::SelectApproachTowardsVassal(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || ePlayer == GetID())
		return;

	if (!GET_PLAYER(ePlayer).IsVassalOfSomeone())
		return;

	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		MajorCivApproachTypes eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

		if (IsAtWar(ePlayer))
		{
			eApproach = MAJOR_CIV_APPROACH_WAR;
		}
		else
		{
			// Towards our own vassals, we are friendly by default
			if (IsMaster(ePlayer))
			{
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
			}
			else
			{
				MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

				// Are we vassals of the same master?
				if (GET_TEAM(GetTeam()).GetMaster() == GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster())
				{
					eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				}
				// Friends?
				else if (IsDoFAccepted(ePlayer) && eOpinion > MAJOR_CIV_OPINION_ENEMY)
				{
					eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				}
				// Favorable opinion?
				else if (eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
				{
					eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				}

				// Don't like them?
				if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer) || eOpinion <= MAJOR_CIV_OPINION_ENEMY)
				{
					eApproach = MAJOR_CIV_APPROACH_HOSTILE;
				}

				// Planning war towards this vassal's master?
				bool bWarPlans = false;
				if (!GetPlayer()->IsVassalOfSomeone())
				{
					TeamTypes eMaster = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster();
					vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
					vector<PlayerTypes> vMasterTeam = GET_TEAM(eMaster).getPlayers();

					for (size_t i=0; i<vOurTeam.size(); i++)
					{
						if (!GET_PLAYER(vOurTeam[i]).isAlive())
							continue;

						if (GET_PLAYER(vOurTeam[i]).getNumCities() <= 0)
							continue;

						CvDiplomacyAI* pDiploAI = GET_PLAYER(vOurTeam[i]).GetDiplomacyAI();

						for (size_t j=0; j<vMasterTeam.size(); j++)
						{
							if (pDiploAI->GetGlobalCoopWarAgainstState(vMasterTeam[j]) >= COOP_WAR_STATE_PREPARING)
							{
								bWarPlans = true;
								break;
							}

							if (!GET_PLAYER(vOurTeam[i]).isHuman())
							{
								if (pDiploAI->IsWantsSneakAttack(vMasterTeam[j]) || pDiploAI->IsArmyInPlaceForAttack(vMasterTeam[j]))
								{
									bWarPlans = true;
									break;
								}
								if (pDiploAI->GetMajorCivApproach(vMasterTeam[j]) == MAJOR_CIV_APPROACH_WAR)
								{
									bWarPlans = true;
									break;
								}
							}
						}

						if (bWarPlans)
							break;
					}

					if (bWarPlans)
					{
						eApproach = MAJOR_CIV_APPROACH_WAR;
					}
				}
			}
		}

		if (eApproach != MAJOR_CIV_APPROACH_WAR && GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
		{
			bool bConsiderWar = false;

			int iCityLoop;
			for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				// They have one of our cities!
				if (GET_PLAYER(pLoopCity->getOriginalOwner()).getTeam() == GetTeam())
				{
					bConsiderWar = true;
					break;
				}
			}

			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition())
			{
				bConsiderWar = true;
			}

			if (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION)
			{
				if (GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
				{
					bConsiderWar = true;
				}
				else if (GET_PLAYER(ePlayer).GetNumCapitalCities() > 0)
				{
					bConsiderWar = true;
				}
			}

			if (bConsiderWar)
			{
				if (!GetPlayer()->IsNoNewWars() && GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE && GetPlayerTargetValue(ePlayer) > TARGET_VALUE_AVERAGE)
				{
					if (IsWarSane(ePlayer))
					{
						if (!IsMaster(ePlayer))
						{
							TeamTypes eMaster = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster();
							vector<PlayerTypes> vMasterTeam = GET_TEAM(eMaster).getPlayers();

							bool bAbort = false;
							StrengthTypes eHighestStrength = STRENGTH_PATHETIC;

							for (size_t i=0; i<vMasterTeam.size(); i++)
							{
								if (!IsPlayerValid(vMasterTeam[i]))
									continue;

								if (GET_PLAYER(vMasterTeam[i]).GetProximityToPlayer(GetID()) < PLAYER_PROXIMITY_CLOSE)
									continue;

								StrengthTypes eStrength = GetPlayerMilitaryStrengthComparedToUs(vMasterTeam[i]);
								if (eStrength > eHighestStrength)
								{
									eHighestStrength = eStrength;
								}
							}

							if (GetBoldness() > 6)
							{
								if (eHighestStrength >= STRENGTH_POWERFUL)
								{
									bAbort = true;
								}
							}
							else
							{
								if (eHighestStrength >= STRENGTH_STRONG)
								{
									bAbort = true;
								}
							}

							if (!GET_TEAM(GetTeam()).canDeclareWar(eMaster, GetID()))
							{
								bAbort = true;
							}

							if (!bAbort)
							{
								eApproach = MAJOR_CIV_APPROACH_WAR;

								for (size_t i=0; i<vMasterTeam.size(); i++)
								{
									SetTargetingVassal(vMasterTeam[i], true);

									if (!IsPlayerValid(vMasterTeam[i]))
										continue;

									SetMajorCivApproach(vMasterTeam[i], MAJOR_CIV_APPROACH_WAR);
								}
							}
							else
							{
								eApproach = MAJOR_CIV_APPROACH_HOSTILE;
							}
						}
						else
						{
							eApproach = MAJOR_CIV_APPROACH_WAR;
						}
					}
					else
					{
						eApproach = MAJOR_CIV_APPROACH_HOSTILE;
					}
				}
			}
		}

		// Grab the old approach and scratch values for logging
		MajorCivApproachTypes eOldApproach = GetMajorCivApproach(ePlayer);
		if (eOldApproach == NO_MAJOR_CIV_APPROACH)
			eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;

		// Add some base weight to the approach we've selected
		vApproachScores[(int)eApproach] = GetPersonalityMajorCivApproachBias(eApproach);

		vector<int> vApproachScoresScratch;

		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			SetPlayerApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		// Update approach and log.
		SetMajorCivApproach(ePlayer, eApproach);
		SetMajorCivStrategicApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}
}

/// What is the best Diplomatic Approach to take towards this major civilization?
/// This is the most important calculation in determining AI diplomatic behavior!
void CvDiplomacyAI::SelectBestApproachTowardsMajorCiv(PlayerTypes ePlayer, bool bStrategic, vector<PlayerTypes>& vPlayersToUpdate, vector<PlayerTypes>& vPlayersToReevaluate, std::map<PlayerTypes, MajorCivApproachTypes>& oldApproaches)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS || GET_PLAYER(ePlayer).getTeam() == GetTeam()) return;

	// Are we reevaluating our approach towards this player?
	bool bReevaluation = std::find(vPlayersToReevaluate.begin(), vPlayersToReevaluate.end(), ePlayer) != vPlayersToReevaluate.end();

	// Initialize some variables that are called repeatedly here, just for convenience
	PlayerTypes eMyPlayer = GetID();
	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
	TeamTypes eMyTeam = GetTeam();
	PlayerProximityTypes eProximity = (PlayerProximityTypes) max((int)GET_PLAYER(ePlayer).GetProximityToPlayer(GetID()), (int)GetPlayer()->GetProximityToPlayer(ePlayer));
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	bool bMetValidMinor = GetPlayer()->HasMetValidMinorCiv();

	// Turn/Era
	int iMyEra = GetPlayer()->GetCurrentEra();
	int iTheirEra = GET_PLAYER(ePlayer).GetCurrentEra();
	int iGameEra = GC.getGame().getCurrentEra();
	bool bWeHaveUUTech = GetPlayer()->HasUUPeriod() && GetPlayer()->GetPlayerTechs()->HasUUTech();
	bool bWeHaveUUActive = GetPlayer()->HasUUPeriod() && bWeHaveUUTech && GetPlayer()->HasUUActive();

	// Player traits
	bool bConquerorTraits = GetPlayer()->GetPlayerTraits()->IsWarmonger();
	bool bDiplomatTraits = GetPlayer()->GetPlayerTraits()->IsDiplomat();
	bool bCulturalTraits = GetPlayer()->GetPlayerTraits()->IsTourism();
	bool bScientistTraits = GetPlayer()->GetPlayerTraits()->IsNerd();

	// Victory stuff
	bool bCloseToWorldConquest = IsCloseToDominationVictory();
	bool bCloseToDiploVictory = IsCloseToDiploVictory();
	bool bCloseToScienceVictory = IsCloseToSSVictory();
	bool bCloseToCultureVictory = IsCloseToCultureVictory();
	bool bCloseToAnyVictory = bCloseToWorldConquest || bCloseToDiploVictory || bCloseToScienceVictory || bCloseToCultureVictory;
	bool bTheyAreCloseToWorldConquest = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDominationVictory();
	bool bTheyAreCloseToDiploVictory = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDiploVictory();
	bool bTheyAreCloseToScienceVictory = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToSSVictory();
	bool bTheyAreCloseToCultureVictory = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToCultureVictory();

	// Possessions
	int iNumOurTechs = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iNumTheirTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
	bool bWeLostCapital = GetPlayer()->IsHasLostCapital();
	bool bTheyLostCapital = GET_PLAYER(ePlayer).IsHasLostCapital();

	bool bCapturedOurCapital = IsCapitalCapturedBy(ePlayer, true, false);
	bool bCapturedOurHolyCity = IsHolyCityCapturedBy(ePlayer, true, false);
	bool bCapturedTheirCapital = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCapitalCapturedBy(eMyPlayer, true, false);
	bool bCapturedTheirHolyCity = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHolyCityCapturedBy(eMyPlayer, true, false);
	bool bEverCapturedKeyCity = IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer); // this also checks teammates

	// Evaluations - Todo: Consolidate
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	StrengthTypes eEconomicStrength = GetPlayerEconomicStrengthComparedToUs(ePlayer);
	bool bUntrustworthy = IsUntrustworthy(ePlayer);
	bool bEarlyGameCompetitor = IsEarlyGameCompetitor(ePlayer);
	bool bEasyTarget = IsEasyTarget(ePlayer);
	bool bGoodAttackTarget = GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer);
	// They're only an easy target if we're not already at war with somebody else.
	// ...however, if we're already at war with them, let's keep this weight.
	if (bEasyTarget && !IsAtWar(ePlayer))
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			
			if (IsPlayerValid(eLoopPlayer) && eLoopPlayer != ePlayer && GET_PLAYER(eLoopPlayer).isMajorCiv() && IsAtWar(eLoopPlayer))
			{
				if (!GetPlayer()->IsNoNewWars() && GetWarState(eLoopPlayer) > WAR_STATE_DEFENSIVE)
				{
					// Ignore players who aren't a serious threat.
					if (IsEasyTarget(eLoopPlayer) || GET_PLAYER(eLoopPlayer).IsNoNewWars())
						continue;

					// Disregard phony wars
					if (IsPhonyWar(eLoopPlayer, true))
						continue;
				}

				bEasyTarget = false;
				break;
			}
		}
	}

	// Cold war - increases emphasis for ideologies
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	bool bColdWar = false;
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && pLeague != NULL)
	{
		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if (IsPlayerValid(eLoopPlayer))
			{
				if (GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(eMyPlayer, eLoopPlayer))
				{
					bColdWar = true;
					break;
				}
			}
		}
	}
#endif

	// Previous approach
	bool bFirstUpdate = false;
	MajorCivApproachTypes eOldApproach;
	std::map<PlayerTypes, MajorCivApproachTypes>::iterator oldApproachPointer = oldApproaches.find(ePlayer);
	if (oldApproachPointer != oldApproaches.end())
	{
		eOldApproach = oldApproachPointer->second;
	}
	else
	{
		eOldApproach = GetMajorCivApproach(ePlayer);
	}

	if (eOldApproach == NO_MAJOR_CIV_APPROACH)
	{
		bFirstUpdate = true;
		eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;
	}

	//--------------------------------//
	// [PART 1: INITIAL WEIGHTS]	  //
	//--------------------------------//

	// This vector is what we'll stuff the values into first, and pass it into our logging function (which can't take a CvWeightedVector, which we need to sort...)
	vector<int> vApproachScores(NUM_MAJOR_CIV_APPROACHES, 0);

	////////////////////////////////////
	// PERSONALITY WEIGHTS
	////////////////////////////////////

	vector<int> vApproachBias;

	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;
		int iBias = GetPersonalityMajorCivApproachBias(eLoopApproach);
		vApproachBias.push_back(iBias);

		// Add 1x bias for each approach to reflect personality weight
		vApproachScores[(int)eLoopApproach] += iBias;
	}

	////////////////////////////////////
	// NEUTRAL DEFAULT WEIGHT
	////////////////////////////////////

	vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;

	////////////////////////////////////
	// LAST TURN APPROACH BIASES
	////////////////////////////////////

	// Add a bias for our current approach, to make it less likely to flip from turn to turn
	if (!bFirstUpdate && !bReevaluation)
	{
		vApproachScores[(int)eOldApproach] += vApproachBias[(int)eOldApproach] * 2;

		// If we're planning a war (or want to wipe them off the planet) then add WAR bias so that we don't get away from it too easily
		if (eOldApproach == MAJOR_CIV_APPROACH_WAR || IsWantsSneakAttack(ePlayer) || IsArmyInPlaceForAttack(ePlayer))
		{
			if (GetWarGoal(ePlayer) == WAR_GOAL_PREPARE || GetWarGoal(ePlayer) == WAR_GOAL_CONQUEST || IsWantsSneakAttack(ePlayer))
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4;
			}

			// Ready to attack?
			if (IsArmyInPlaceForAttack(ePlayer))
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += 100;
			}
		}
		// Same for demand
		else if (GetWarGoal(ePlayer) == WAR_GOAL_DEMAND)
		{
			vApproachScores[(int)eOldApproach] += vApproachBias[(int)eOldApproach] * 4;
		}
	}

	////////////////////////////////////
	// WORLD CONQUEST
	////////////////////////////////////

	// Conquest bias: must be a stalemate or better to apply (or not at war yet)
	if (IsGoingForWorldConquest() || bCloseToWorldConquest)
	{
		if (GetWarState(ePlayer) == NO_WAR_STATE_TYPE || GetWarState(ePlayer) > WAR_STATE_DEFENSIVE)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += bCloseToWorldConquest ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 : vApproachBias[MAJOR_CIV_APPROACH_WAR];

			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += bCloseToWorldConquest ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			}
		}
	}

	if (bMetValidMinor)
	{
		// If we were given a quest to attack/denounce this player, it probably means he's a total jerk...
		int iNumWarQuests = 0;
		int iNumHostileQuests = 0;
		int iNumFriendlyQuests = 0;

		// Are there any quests that should influence our decision?
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
			if (IsPlayerValid(eMinor) && GET_PLAYER(eMinor).isMinorCiv() && !IsAtWar(eMinor) && GetMinorCivApproach(eMinor) != MINOR_CIV_APPROACH_BULLY && GetMinorCivApproach(eMinor) != MINOR_CIV_APPROACH_CONQUEST)
			{
				CvPlayer* pMinor = &GET_PLAYER(eMinor);
				CvMinorCivAI* pMinorCivAI = pMinor->GetMinorCivAI();
				if (pMinor && pMinorCivAI)
				{
					// Quests increasing war likelihood
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_WAR) && pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_WAR) == ePlayer)
					{
						iNumWarQuests++;
					}
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY))
					{
						int iX = pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY);
						int iY = pMinorCivAI->GetQuestData2(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY);

						CvPlot* pPlot = GC.getMap().plot(iX, iY);
						if (pPlot != NULL && pPlot->isCity() && pPlot->getOwner() == ePlayer)
						{
							iNumWarQuests++;
						}
					}
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_LIBERATION))
					{
						PlayerTypes eMinorToLiberate = (PlayerTypes) pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_LIBERATION);
						int iX = GET_PLAYER(eMinorToLiberate).GetOriginalCapitalX();
						int iY = GET_PLAYER(eMinorToLiberate).GetOriginalCapitalY();

						CvPlot* pPlot = GC.getMap().plot(iX, iY);
						if (pPlot != NULL && pPlot->isCity() && pPlot->getOwner() == ePlayer)
						{
							iNumWarQuests++;
						}
					}
					// Quests increasing hostile likelihood
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_DENOUNCE_MAJOR) && pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_DENOUNCE_MAJOR) == ePlayer)
					{
						iNumHostileQuests++;
					}
					// Quests increasing friendly likelihood
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_FIND_PLAYER) && pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_FIND_PLAYER) == ePlayer)
					{
						iNumFriendlyQuests++;
					}
					if (pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_CONNECT_RESOURCE))
					{
						ResourceTypes eResource = (ResourceTypes) pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_CONNECT_RESOURCE);
						
						if (GET_PLAYER(eMyPlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ true) <= 0 && GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ false) > 0)
						{
							iNumFriendlyQuests++;
						}
					}
				}
			}
		}

		// Multipliers?
		if (!bCloseToDiploVictory && !bCloseToScienceVictory && !bCloseToCultureVictory)
		{
			if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
			{
				iNumWarQuests *= 2;
				iNumHostileQuests *= 2;
				iNumFriendlyQuests *= 2;
			}
			if (bDiplomatTraits)
			{
				iNumWarQuests *= 2;
				iNumHostileQuests *= 2;
				iNumFriendlyQuests *= 2;
			}
		}

		if (iNumWarQuests > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iNumWarQuests;
		}
		if (iNumHostileQuests > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iNumHostileQuests;
		}
		if (iNumFriendlyQuests > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iNumFriendlyQuests;
		}
	}

	//--------------------------------//
	// [PART 2: FRIENDSHIP MODS]	  //
	//--------------------------------//

	////////////////////////////////////
	// DECLARATION OF FRIENDSHIP
	////////////////////////////////////

	if (IsDoFAccepted(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
	}

	////////////////////////////////////
	// DEFENSIVE PACT
	////////////////////////////////////

	if (IsHasDefensivePact(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
	}

	////////////////////////////////////
	// RESEARCH AGREEMENT
	////////////////////////////////////

	if (IsHasResearchAgreement(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
	}

	////////////////////////////////////
	// EXCHANGE DESIRES
	////////////////////////////////////

	bool bFirstPass = bStrategic && !bReevaluation;

	if (!bFirstPass)
	{
		if (IsWantsDoFWithPlayer(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += GetMostValuableFriend() == ePlayer ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
		}

		if (IsWantsDefensivePactWithPlayer(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += GetMostValuableAlly() == ePlayer ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
		}
	}

	////////////////////////////////////
	// COOP WARS
	////////////////////////////////////

	// Coop War Accepted?
	if (GetCoopWarScore(ePlayer) > 0)
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetCoopWarScore(ePlayer);
	}
	// Coop War Denied?
	else if (GetCoopWarScore(ePlayer) < 0)
	{
		if (IsPlayerBrokenCoopWarPromise(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * -GetCoopWarScore(ePlayer);
		}
		else if (IsDoFAccepted(ePlayer) || (GetMeanness() < 6))
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * -GetCoopWarScore(ePlayer);
		}
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * -GetCoopWarScore(ePlayer);
		}
	}

	// Loop through all (known) Players - did we agree to go to war with this player against someone else?
	bool bCoopWarSoon = false;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			CoopWarStates eCoopWarState = GetCoopWarState(ePlayer, eLoopPlayer);

			if (eCoopWarState >= COOP_WAR_STATE_PREPARING)
			{
				bCoopWarSoon = true;
				int iStrengthMod = (int)GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) - 2;

				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iStrengthMod > 0 ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iStrengthMod : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
			}
		}
	}
	if (bCoopWarSoon)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
	}

	////////////////////////////////////
	// RESURRECTION
	////////////////////////////////////

	bool bResurrectedUs = WasResurrectedBy(ePlayer);
	bool bResurrectedThem = GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(eMyPlayer);

	if (bResurrectedUs || bResurrectedThem) // set all non-friendly approaches to -2x their bias value
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = -vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = -vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = -vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = -vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = -vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] = -vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;

		// Double resurrection? Highly unlikely, but may as well account for it.
		if (bResurrectedUs && bResurrectedThem)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		}
	}

	////////////////////////////////////
	// LIBERATED CITIES
	////////////////////////////////////

	bool bLiberatedCapital = false;

	if (GetNumCitiesLiberatedBy(ePlayer) > 0 && !bEverCapturedKeyCity && !bUntrustworthy)
	{
		int iLiberationMod = GetNumCitiesLiberatedBy(ePlayer) - GetNumCitiesCapturedBy(ePlayer);
		if (iLiberationMod > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iLiberationMod;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
		}

		// Liberated the capital?
		if (IsPlayerLiberatedCapital(ePlayer))
		{
			bLiberatedCapital = true;
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;

			// If there's a resurrection bonus above, subtract instead of setting
			if (bResurrectedUs || bResurrectedThem)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR];
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE];
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
				vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID];
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] = -vApproachBias[MAJOR_CIV_APPROACH_WAR];
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = -vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = -vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE];
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = -vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
				vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = -vApproachBias[MAJOR_CIV_APPROACH_AFRAID];
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] = -vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
			}
		}
	}

	//--------------------------------//
	// [PART 3: PROVOCATIONS]   	  //
	//--------------------------------//

	bool bProvokedUs = false;

	////////////////////////////////////
	// DEMANDS
	////////////////////////////////////

	if (GetNumDemandEverMade(ePlayer) > 0)
	{
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetNumDemandEverMade(ePlayer);
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetNumDemandEverMade(ePlayer) / 2;

		if (GetNumDemandEverMade(ePlayer) > 1)
		{
			bProvokedUs = true;
		}

		if (bEasyTarget || (eMilitaryStrength < STRENGTH_AVERAGE && GetMilitaryThreat(ePlayer) < THREAT_SEVERE))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetNumDemandEverMade(ePlayer);
		}
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * GetNumDemandEverMade(ePlayer);
		}
	}

	////////////////////////////////////
	// DENOUNCEMENTS
	////////////////////////////////////

	// We denounced them
	if (IsDenouncedPlayer(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		if (bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		}
	}

	// They denounced us
	if (IsDenouncedByPlayer(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;
	}

	////////////////////////////////////
	// TRAITOR OPINION
	////////////////////////////////////

	// Do we think they're a good-for-nothing backstabber?!
	if (bUntrustworthy)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		// Extra penalties if they betrayed us personally!
		if (IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer) || IsPlayerBrokenMilitaryPromise(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer) || IsPlayerBrokenVassalAgreement(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3;

			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
			}
		}
	}

	////////////////////////////////////
	// VENGEANCE! Grrrr....
	////////////////////////////////////

	int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));

	// Note: This is in addition to the weight from being an untrustworthy friend!
	if (bCapturedOurCapital)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 10;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 10;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 10;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		// Easy target? Get our capital back!
		if (bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += 200;
		}
	}
	if (bCapturedOurHolyCity)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iFlavorReligion;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iFlavorReligion;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iFlavorReligion;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		// Easy target? Get our Holy City back!
		if (bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iFlavorReligion;
		}
	}

	// Stole our territory?
	if (GetNumTimesCultureBombed(ePlayer) > 0)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetNumTimesCultureBombed(ePlayer) / 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetNumTimesCultureBombed(ePlayer) / 2;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * GetNumTimesCultureBombed(ePlayer) / 4;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		if (bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetNumTimesCultureBombed(ePlayer) / 2;
		}
	}

	// Are we angry about what they've done to our protected City-States?
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		bProvokedUs = true;

		if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
		{
			int iPenalty = max((GetOtherPlayerNumProtectedMinorsKilled(ePlayer) * 2), GetOtherPlayerNumProtectedMinorsAttacked(ePlayer));
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iPenalty;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPenalty;
		}
		else
		{
			int iPenalty = max(GetOtherPlayerNumProtectedMinorsKilled(ePlayer), (GetOtherPlayerNumProtectedMinorsAttacked(ePlayer)/2));
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iPenalty;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPenalty;
		}
	}
	else if (IsAngryAboutProtectedMinorAttacked(ePlayer))
	{
		int iPenalty = (GetOtherPlayerNumProtectedMinorsKilled(ePlayer) + GetOtherPlayerNumProtectedMinorsAttacked(ePlayer));
		bProvokedUs = !IsPlayerMadeAttackCityStatePromise(ePlayer);

		if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iPenalty;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPenalty;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iPenalty / 2;
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		}
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iPenalty;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPenalty / 2;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iPenalty / 2;
		}
	}
	else if (IsAngryAboutProtectedMinorBullied(ePlayer))
	{
		if (IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer) || IsHasResearchAgreement(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetOtherPlayerNumProtectedMinorsBullied(ePlayer) / 2;
		}
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetOtherPlayerNumProtectedMinorsBullied(ePlayer) / 2;
		}
	}

	// Are they standing in the way of our bullying? How nasty am I...?
	if (IsAngryAboutSidedWithProtectedMinor(ePlayer) && !IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer) && !IsHasResearchAgreement(ePlayer))
	{
		if (GetBoldness() > 7 || GetMeanness() > 7)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
		}
		else if (MOD_BALANCE_CORE)
		{
			if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 ||
				GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0 ||
				GetPlayer()->GetPlayerTraits()->GetCityStateCombatModifier() != 0 ||
				GetPlayer()->GetPlayerTraits()->IsBullyAnnex() || GetPlayer()->GetPlayerTraits()->IgnoreBullyPenalties() ||
				GetPlayer()->IsCanBullyFriendlyCS())
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
			}
		}
	}

	////////////////////////////////////
	// CAPTURED CITIES
	////////////////////////////////////

	int iCityDifference = (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumCitiesCapturedBy(eMyPlayer) - GetNumCitiesCapturedBy(ePlayer)) * 2;

	// Only apply weight for this if they're nearby (if we conquered a city far away from the rest of their empire, adding weight here is not helpful).
	if (eProximity >= PLAYER_PROXIMITY_CLOSE)
	{
		// If we've captured cities from them before, we're more likely to finish the job.
		if (iCityDifference > 0)
		{
			// As strong as them or stronger? Let's continue our conquest, especially if they're an easy target.
			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iCityDifference * 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iCityDifference * 2;
			}
			else if (eMilitaryStrength <= STRENGTH_AVERAGE && GetMilitaryThreat(ePlayer) < THREAT_CRITICAL && !GetPlayer()->IsNoNewWars())
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iCityDifference;
			}
			// If they're stronger than us, they're going to want revenge...
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iCityDifference * 2;
			}
		}
		// If they've captured cities from us before, they're more likely to finish the job.
		else if (iCityDifference < 0)
		{
			// Flip it!
			iCityDifference *= -1;
			bProvokedUs = true;

			// Easy target? Get our cities back!
			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iCityDifference * 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iCityDifference * 2;
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
			}
			// Weaker than us? Let's get revenge!
			else if (eMilitaryStrength < STRENGTH_AVERAGE && GetMilitaryThreat(ePlayer) < THREAT_SEVERE && !GetPlayer()->IsNoNewWars())
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
			}
			// As strong as us or stronger? Decrease desire for war, they've proven their might.
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iCityDifference;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iCityDifference;
			}
		}
	}

	//--------------------------------//
	// [PART 4: KEY PLAYERS]     	  //
	//--------------------------------//

	bool bVictoryConcern = GetPlayerNumMajorsConquered(ePlayer) >= 3;

	if (IsCompetingForVictory())
	{
		bVictoryConcern = GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG;
		bVictoryConcern |= GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG;
		bVictoryConcern |= GetTechBlockLevel(ePlayer) == BLOCK_LEVEL_FIERCE;
		bVictoryConcern |= GetPolicyBlockLevel(ePlayer) == BLOCK_LEVEL_FIERCE;
		bVictoryConcern |= IsEndgameAggressiveTo(ePlayer);
		bVictoryConcern |= GetVictoryFocus() == VICTORY_FOCUS_SCIENCE && GetTechBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG;
		bVictoryConcern |= GetVictoryFocus() == VICTORY_FOCUS_DOMINATION && GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG;
		bVictoryConcern |= GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC && GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG;
		bVictoryConcern |= GetVictoryFocus() == VICTORY_FOCUS_CULTURE && (GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetPolicyBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG);
	}

	////////////////////////////////////
	// OPPORTUNITY ATTACK DESIRE
	////////////////////////////////////

	// This value determines whether the AI wants to exploit any weaknesses in the other player's defenses
	bool bWantsOpportunityAttack = false;
	int iAttackMultiplier = bEasyTarget ? 2 : 1;
	int iTheirAttackMultiplier = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsEasyTarget(eMyPlayer) ? 2 : 1;

	// Also take good city attack targets into consideration...
	if (bGoodAttackTarget)
	{
		iAttackMultiplier++;
	}
	if (GetPlayer()->GetMilitaryAI()->HaveCityExposedToEnemy(ePlayer))
	{
		iTheirAttackMultiplier++;
	}

	// Certain things require a higher threshold for an opportunity attack desire
	// If we don't moderate our aggressive desire, we'll lose friends and be hated by the world.
	bool bModerateAggressiveDesire = false;
	bool bBold = GetBoldness() > 7 || bConquerorTraits || (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION);

	// If they're far away, moderate aggressive desire no matter what.
	if (eProximity <= PLAYER_PROXIMITY_FAR)
	{
		bModerateAggressiveDesire = true;
	}
	else if (!bUntrustworthy && !bEverCapturedKeyCity && !GC.getGame().IsAIAggressiveMode() && !IsBackstabber())
	{
		// Ally to us now?
		if (IsFriendOrAlly(ePlayer))
		{
			if (!bBold || !bEasyTarget || !bGoodAttackTarget)
			{
				bModerateAggressiveDesire = true;
			}
		}
		// Friends previously, and not major competitors?
		else if (GetDoFType(ePlayer) >= DOF_TYPE_FRIENDS)
		{
			if (!IsMajorCompetitor(ePlayer) && !bEarlyGameCompetitor && eOpinion >= MAJOR_CIV_OPINION_COMPETITOR)
			{
				if (!bBold || !(bEasyTarget || bGoodAttackTarget))
				{
					bModerateAggressiveDesire = true;
				}
			}
		}
	}

	if (IsLockedIntoCoopWar(ePlayer))
	{
		bWantsOpportunityAttack = true;
		bModerateAggressiveDesire = false;
	}
	else
	{
		// No opportunity attacks if we're doing terribly already!
		if (GetPlayer()->IsNoNewWars() && !IsEndgameAggressiveTo(ePlayer) && !bEverCapturedKeyCity && !bTheyAreCloseToWorldConquest)
		{
			bModerateAggressiveDesire = true;
		}
		else
		{
			// Don't be aggressive towards our friends or distant players without a good reason.
			if (bModerateAggressiveDesire)
			{
				bWantsOpportunityAttack = bCloseToWorldConquest || bProvokedUs || bEverCapturedKeyCity || GetWarmongerThreat(ePlayer) >= THREAT_SEVERE || bEarlyGameCompetitor || GetBiggestCompetitor() == ePlayer || GetPrimeLeagueCompetitor() == ePlayer || bVictoryConcern || bTheyAreCloseToWorldConquest;
			}
			else
			{
				bWantsOpportunityAttack = (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION && iMyEra >= 2) || bEverCapturedKeyCity || bVictoryConcern || GetWarmongerThreat(ePlayer) >= THREAT_SEVERE || bCloseToWorldConquest || bTheyAreCloseToWorldConquest || IsMajorCompetitor(ePlayer);

				// If they're nearby, more reasons are valid to want to attack them!
				if (eProximity >= PLAYER_PROXIMITY_CLOSE)
				{
					bWantsOpportunityAttack |= IsConqueror() || bConquerorTraits || bProvokedUs || (bEasyTarget && eOpinion <= MAJOR_CIV_OPINION_COMPETITOR) || eOpinion <= MAJOR_CIV_OPINION_ENEMY || bEarlyGameCompetitor || IsPlayerRecklessExpander(ePlayer) || IsPlayerWonderSpammer(ePlayer);
				}

				bWantsOpportunityAttack |= GC.getGame().IsAIAggressiveMode();
			}
		}
	}

	// Loop through other players and look for anything interesting
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		TeamTypes eLoopTeam = (TeamTypes) GET_PLAYER(eLoopPlayer).getTeam();

		if (!IsPlayerValid(eLoopPlayer, true))
			continue;

		if (eLoopPlayer == ePlayer || eLoopPlayer == eMyPlayer)
			continue;

		if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
			continue;

		// Has this guy denounced the other player?
		if (!bFirstPass && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
		{
			// Is this loop player our biggest competitor? We should like this guy!
			if (GetBiggestCompetitor() == eLoopPlayer)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetMeanness() / 4;
			}
			// Is this loop player our most valuable DOF or DP? We hate this other guy!
			else if (GetMostValuableFriend() == eLoopPlayer)
			{
				if (IsDoFAccepted(eLoopPlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetLoyalty() / 4;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetLoyalty() / 4;
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDoFWillingness() / 8;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDoFWillingness() / 8;
				}
			}
			else if (GetMostValuableAlly() == eLoopPlayer)
			{
				if (IsHasDefensivePact(eLoopPlayer) || IsDoFAccepted(eLoopPlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetLoyalty() / 4;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetLoyalty() / 4;
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDoFWillingness() / 8;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDoFWillingness() / 8;
				}
			}
		}
		// Is this guy at war with the other player?
		if (!bFirstPass && GET_TEAM(eLoopTeam).isAtWar(eTeam))
		{
			// Is this loop player our biggest competitor? We should like this guy!
			if (GetBiggestCompetitor() == eLoopPlayer)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetMeanness() / 2;
			}
			// Is this loop player our most valuable DOF or DP? We hate this other guy!
			else if (GetMostValuableFriend() == eLoopPlayer)
			{
				if (IsDoFAccepted(eLoopPlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetLoyalty() / 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetLoyalty() / 2;
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDoFWillingness() / 4;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDoFWillingness() / 2;
				}
			}
			else if (GetMostValuableAlly() == eLoopPlayer)
			{
				if (IsHasDefensivePact(eLoopPlayer) || IsDoFAccepted(eLoopPlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetLoyalty() / 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetLoyalty() / 2;
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDoFWillingness() / 4;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDoFWillingness() / 2;
				}
			}
		}
		// Their teammate or Defensive Pact? If the loop player's at least as strong as we are (and it's relevant to our situation), let's reduce our war interest.
		else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsTeammate(eLoopPlayer) || (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer) && (!IsAtWar(ePlayer) || IsAtWar(eLoopPlayer))))
		{
			if (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) >= STRENGTH_AVERAGE && GetMilitaryThreat(eLoopPlayer) > THREAT_MINOR && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && (!IsAtWar(eLoopPlayer) || GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE))
			{
				int iStrengthFactor = (int)GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) - 2; // --> Average: +1, Strong: +2, Powerful: +3, Immense: +4

				if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsEasyTarget(eMyPlayer))
				{
					iStrengthFactor *= 2;
				}

				// Proximity is very important
				switch (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eMyPlayer))
				{
				case PLAYER_PROXIMITY_NEIGHBORS:
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor * 2;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor * 2;
					break;
				case PLAYER_PROXIMITY_CLOSE:
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor;
					break;
				case PLAYER_PROXIMITY_FAR:
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor;
					break;
				}
			}
		}

		// Will the loop player support us in any wars against them?
		if (IsTeammate(eLoopPlayer) || IsHasDefensivePact(eLoopPlayer) || (GetCoopWarState(eLoopPlayer, ePlayer) >= COOP_WAR_STATE_PREPARING) || (IsDoFAccepted(eLoopPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer)))
		{
			if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMilitaryThreat(eLoopPlayer) > THREAT_MINOR && !GET_PLAYER(eLoopPlayer).IsNoNewWars() && (!GET_TEAM(eTeam).isAtWar(eLoopTeam) || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarState(eLoopPlayer) < WAR_STATE_OFFENSIVE))
			{
				int iStrengthFactor = ((int)GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(ePlayer) - 2) * -1; // --> Average: +1, Poor: +2, Weak: +3, Pathetic: +4

				if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsEasyTarget(eLoopPlayer))
				{
					iStrengthFactor *= 2;
				}

				// This player gives us additional offensive punch
				bool bOffensivePower = IsTeammate(eLoopPlayer) || GetCoopWarState(eLoopPlayer, ePlayer) >= COOP_WAR_STATE_PREPARING || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsAtWar(ePlayer);

				// Proximity to the other player is very important
				switch (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer))
				{
				case PLAYER_PROXIMITY_NEIGHBORS:
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += bOffensivePower && bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor * 2 : 0;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bOffensivePower && bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor * 2 : 0;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= bOffensivePower ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor * 2 : 0;
					vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iStrengthFactor * 2;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iStrengthFactor * 2;
					break;
				case PLAYER_PROXIMITY_CLOSE:
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += bOffensivePower && bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor : 0;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bOffensivePower && bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor : 0;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= bOffensivePower ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor : 0;
					vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iStrengthFactor;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iStrengthFactor;
					break;
				case PLAYER_PROXIMITY_FAR:
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= bOffensivePower ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor : 0;
					vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iStrengthFactor / 2;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iStrengthFactor / 2;
					break;
				}
			}
		}
	}

	if (!bFirstPass) // Don't update this on the first pass - we need the updated values, which are updated after the first pass of DoUpdateMajorCivApproaches()
	{
		if (GetBiggestCompetitor() == ePlayer)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5;

			if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || eProximity == PLAYER_PROXIMITY_NEIGHBORS || bVictoryConcern || bProvokedUs || bWantsOpportunityAttack)
			{
				// Easy target? Let's get 'em.
				if (bEasyTarget)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
				}
			}
		}
		// Focus our attention on major competitors.
		else if (IsMajorCompetitor(ePlayer) || IsEarlyGameCompetitor(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 3;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;

			if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || eProximity == PLAYER_PROXIMITY_NEIGHBORS || bVictoryConcern || bProvokedUs)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;

				// Easy target? Let's get 'em.
				if (bEasyTarget)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
				}
			}
		}
		// Not a major competitor in the Renaissance or later? We have bigger fish to fry.
		else if (iMyEra >= 3 && !bVictoryConcern && IsCompetingForVictory())
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetVictoryCompetitiveness() / 2;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * (10 - GetVictoryCompetitiveness()) / 2;
		}

		// Is this our prime competitor in the World Congress?
		if (IsCompetingForVictory() || bProvokedUs)
		{
			if (GetPrimeLeagueCompetitor() == ePlayer)
			{
				if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5;

					if (bEasyTarget)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					}
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
				}
			}
			// No? Then our diplomacy is glad for it.
			else if (pLeague != NULL && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC && !bUntrustworthy)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}
		}

		if (!bUntrustworthy)
		{
			if (GetMostValuableFriend() == ePlayer)
			{
				if (IsDoFAccepted(ePlayer) && !bVictoryConcern && !bProvokedUs)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
				}
				else if (!bProvokedUs)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					if (IsDoFAccepted(ePlayer) || !bVictoryConcern)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 2;
					}
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
				}
			}

			if (GetMostValuableAlly() == ePlayer)
			{
				if (IsHasDefensivePact(ePlayer) && !bVictoryConcern && !bProvokedUs)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] = 0;
				}
				else if (!bProvokedUs)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					if (IsDoFAccepted(ePlayer) || !bVictoryConcern)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 2;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 2;
					}
				}
				else
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
				}
			}
		}
	}

	//--------------------------------//
	// [PART 5: EVALUATIONS]     	  //
	//--------------------------------//

	////////////////////////////////////
	// MILITARY THREAT
	////////////////////////////////////

	switch (GetMilitaryThreat(ePlayer))
	{
	case THREAT_CRITICAL:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 10 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 7 * iTheirAttackMultiplier;
		break;
	case THREAT_SEVERE:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 8 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 * iTheirAttackMultiplier;
		break;
	case THREAT_MAJOR:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
		break;
	case THREAT_MINOR:
	case THREAT_NONE:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	}

	////////////////////////////////////
	// WARMONGER THREAT
	////////////////////////////////////

	switch (GetWarmongerThreat(ePlayer))
	{
	case THREAT_CRITICAL:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 8;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 8;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 5 * iTheirAttackMultiplier;
		break;
	case THREAT_SEVERE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 3 * iTheirAttackMultiplier;
		break;
	case THREAT_MAJOR:
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 3 * iTheirAttackMultiplier;
		break;
	case THREAT_MINOR:
	case THREAT_NONE:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	}

	////////////////////////////////////
	// STRENGTH COMPARED TO US
	////////////////////////////////////

	switch (eMilitaryStrength)
	{
	case STRENGTH_PATHETIC:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 6 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 6 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 6 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 6 * iAttackMultiplier;
		break;
	case STRENGTH_WEAK:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 4 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 4 * iAttackMultiplier;
		break;
	case STRENGTH_POOR:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR];
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE];
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iAttackMultiplier;
		break;
	case STRENGTH_AVERAGE:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	case STRENGTH_STRONG:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iTheirAttackMultiplier;
		break;
	case STRENGTH_POWERFUL:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 4 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iTheirAttackMultiplier;
		break;
	case STRENGTH_IMMENSE:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 8 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 6 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 6 * iTheirAttackMultiplier;
		break;
	}

	// For high economic strength, do not add AFRAID weight or remove WAR/HOSTILE weight unless military strength is also that high ... military power should remain a larger factor
	if (eEconomicStrength == STRENGTH_PATHETIC)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 6 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 6 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 6 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 6 * iAttackMultiplier;
	}
	else if (eEconomicStrength == STRENGTH_WEAK)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 4 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 4 * iAttackMultiplier;
	}
	else if (eEconomicStrength == STRENGTH_POOR)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR];
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE];
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iAttackMultiplier;
	}
	else if (eEconomicStrength == STRENGTH_AVERAGE)
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
	}
	else if (eEconomicStrength == STRENGTH_STRONG)
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iTheirAttackMultiplier;

		if (eMilitaryStrength >= STRENGTH_STRONG)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iTheirAttackMultiplier;
		}
	}
	else if (eEconomicStrength == STRENGTH_POWERFUL)
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;

		if (eMilitaryStrength > STRENGTH_STRONG)
		{
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 4 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iTheirAttackMultiplier;
		}
		else if (eMilitaryStrength == STRENGTH_STRONG)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iTheirAttackMultiplier;
		}
	}
	else if (eEconomicStrength == STRENGTH_IMMENSE)
	{
		switch (eMilitaryStrength)
		{
		case STRENGTH_STRONG:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iTheirAttackMultiplier;
			break;
		case STRENGTH_POWERFUL:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 4 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iTheirAttackMultiplier;
			break;
		case STRENGTH_IMMENSE:
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 8 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 6 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 6 * iTheirAttackMultiplier;
			break;
		default:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
			break;
		}
	}

	////////////////////////////////////
	// DOF HISTORY
	////////////////////////////////////

	int iDiploMultiplier = IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC ? 2 : 1;

	// Our prime league competitor isn't considered aligned with our interests...
	if (IsCompetingForVictory())
	{
		if (GetPrimeLeagueCompetitor() == ePlayer)
		{
			iDiploMultiplier--;
		}
		if (bTheyAreCloseToDiploVictory)
		{
			iDiploMultiplier--;
		}
	}

	iDiploMultiplier = max(iDiploMultiplier, 0);

	// Encourage long-term friendships and alliances
	// Enemies made later in the game are more likely to remain enemies
	switch (GetDoFType(ePlayer))
	{
	case DOF_TYPE_UNTRUSTWORTHY:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMyEra * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMyEra * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMyEra * iDiploMultiplier;
		break;
	case DOF_TYPE_NEW:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMyEra * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMyEra * iDiploMultiplier;
		break;
	case DOF_TYPE_FRIENDS:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMyEra * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMyEra * iDiploMultiplier;
		break;
	case DOF_TYPE_ALLIES:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMyEra * 2 * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMyEra * 2 * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMyEra;
		break;
	case DOF_TYPE_BATTLE_BROTHERS:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMyEra * 3 * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMyEra * 3 * iDiploMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMyEra * 2 * iDiploMultiplier;
		break;
	}

	////////////////////////////////////
	// WORLD CONGRESS ALIGNMENT
	////////////////////////////////////

	if (pLeague != NULL)
	{
		CvLeagueAI::AlignmentLevels eAlignment = (GetPlayer()->GetLeagueAI()->EvaluateAlignment(ePlayer, /*bIgnoreWar*/ true));
		switch (eAlignment)
		{
		case CvLeagueAI::ALIGNMENT_ENEMY:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDiploBalance() * iDiploMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetDiploBalance() * iDiploMultiplier;
			break;
		case CvLeagueAI::ALIGNMENT_HATRED:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDiploBalance() * iDiploMultiplier / 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetDiploBalance() * iDiploMultiplier / 2;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier / 2;
			break;
		case CvLeagueAI::ALIGNMENT_RIVAL:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetDiploBalance() * iDiploMultiplier / 3;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier / 3;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * GetDiploBalance() * iDiploMultiplier / 3;
			break;
		case CvLeagueAI::ALIGNMENT_NEUTRAL:
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * GetDiploBalance() * iDiploMultiplier;
			break;
		case CvLeagueAI::ALIGNMENT_FRIEND:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetDiploBalance() * iDiploMultiplier / 3;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier / 3;
			break;
		case CvLeagueAI::ALIGNMENT_CONFIDANT:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetDiploBalance() * iDiploMultiplier / 2;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier / 2;
			break;
		case CvLeagueAI::ALIGNMENT_ALLY:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetDiploBalance() * iDiploMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier;
			break;
		case CvLeagueAI::ALIGNMENT_LIBERATOR:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetDiploBalance() * iDiploMultiplier * 2;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * GetDiploBalance() * iDiploMultiplier * 2;
			break;	
		}
	}

	////////////////////////////////////
	// VICTORY ISSUES
	////////////////////////////////////

	if (IsCompetingForVictory() && GC.getGame().getGameTurn() > 150)
	{
		int iMaxVictoryDispute = max((int)GetVictoryDisputeLevel(ePlayer), (int)GetVictoryBlockLevel(ePlayer));
		DisputeLevelTypes eMaxVictoryDispute = (DisputeLevelTypes) iMaxVictoryDispute;

		switch (eMaxVictoryDispute)
		{
		case DISPUTE_LEVEL_NONE:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iTheirEra * GetVictoryCompetitiveness() / 4;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iTheirEra * GetVictoryCompetitiveness() / 4;
			break;
		case DISPUTE_LEVEL_WEAK:
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iTheirEra * GetVictoryCompetitiveness() / 10;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iTheirEra * GetVictoryCompetitiveness() / 10;
			break;
		case DISPUTE_LEVEL_STRONG:
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iTheirEra * GetVictoryCompetitiveness() / 7;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iTheirEra * GetVictoryCompetitiveness() / 7;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTheirEra * GetVictoryCompetitiveness() / 7;
			break;
		case DISPUTE_LEVEL_FIERCE:
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iTheirEra * GetVictoryCompetitiveness() / 4;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTheirEra * GetVictoryCompetitiveness() / 4;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iTheirEra * GetVictoryCompetitiveness() / 4;
			break;
		}
	}

	////////////////////////////////////
	// TERRITORIAL DISPUTES
	////////////////////////////////////

	DisputeLevelTypes eDisputeLevel = GetLandDisputeLevel(ePlayer);
	int iMultiplier = 1;
	bool bBonus = true; // territorial disputes should always play a major role ...
	bool bVictoryCompetitor = false;
	if (IsConqueror())
	{
		iMultiplier++;
	}
	if (bConquerorTraits)
	{
		iMultiplier++;
	}
	if (iMyEra <= 1)
	{
		iMultiplier += 2;
	}
	if (iMyEra >= 2 && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION)
	{
		iMultiplier += 2;
		bVictoryCompetitor = true;
	}
	if (bCloseToWorldConquest)
	{
		iMultiplier += 2;
		bVictoryCompetitor = true;
	}
	if (bTheyAreCloseToWorldConquest || GetPlayerNumMajorsConquered(ePlayer) > 2)
	{
		iMultiplier++;
		bBonus = false;
		bVictoryCompetitor = true;
	}
	if (IsPlayerRecklessExpander(ePlayer))
	{
		iMultiplier++;
		bBonus = false;
	}

	// Additional multiplier increase if dispute level is fierce
	if (eDisputeLevel == DISPUTE_LEVEL_FIERCE)
	{
		if (bVictoryCompetitor)
		{
			iMultiplier *= 2;
		}
		else if (IsConqueror() || bConquerorTraits)
		{
			iMultiplier++;
		}
	}

	// No non-competition bonuses if they've provoked us.
	if (bProvokedUs)
	{
		bBonus = false;
	}

	switch (eDisputeLevel)
	{
	case DISPUTE_LEVEL_NONE:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier : 0;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier : 0;
		break;
	case DISPUTE_LEVEL_WEAK:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += (bVictoryCompetitor || IsConqueror() || bConquerorTraits) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier : 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
		break;
	case DISPUTE_LEVEL_STRONG:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
		break;
	case DISPUTE_LEVEL_FIERCE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
		break;
	}

	////////////////////////////////////
	// CITY-STATE COMPETITION
	////////////////////////////////////

	if (bMetValidMinor)
	{
		eDisputeLevel = GetMinorCivDisputeLevel(ePlayer);
		iMultiplier = 1;
		bBonus = false;
		bVictoryCompetitor = false;

		if (IsDiplomat() || bDiplomatTraits)
		{
			iMultiplier++;
			bBonus = true;
		}
		if (iMyEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
		{
			iMultiplier++;
			bBonus = true;
			bVictoryCompetitor = true;
		}
		if (bCloseToDiploVictory)
		{
			iMultiplier++;
			bBonus = true;
			bVictoryCompetitor = true;
		}
		if (bTheyAreCloseToDiploVictory && IsEndgameAggressiveTo(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
			bVictoryCompetitor = true;
		}
		if (GetNumTimesPerformedCoupAgainstUs(ePlayer) > 0)
		{
			iMultiplier++;
			bBonus = false;
		}
		if (IsAngryAboutProtectedMinorAttacked(ePlayer) || IsAngryAboutProtectedMinorKilled(ePlayer) || IsPlayerIgnoredAttackCityStatePromise(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
		}

		// Additional multiplier increase if dispute level is fierce
		if (eDisputeLevel == DISPUTE_LEVEL_FIERCE)
		{
			if (bVictoryCompetitor)
			{
				iMultiplier *= 2;
			}
			else if (IsDiplomat() || bDiplomatTraits)
			{
				iMultiplier++;
			}
		}

		// No non-competition bonuses if they've provoked us.
		if (bProvokedUs)
		{
			bBonus = false;
		}

		switch (eDisputeLevel)
		{
		case DISPUTE_LEVEL_NONE:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier : 0;
			break;
		case DISPUTE_LEVEL_WEAK:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += (bVictoryCompetitor || IsDiplomat() || bDiplomatTraits) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
			break;
		case DISPUTE_LEVEL_STRONG:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		case DISPUTE_LEVEL_FIERCE:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		}
	}

	////////////////////////////////////
	// WORLD WONDER COMPETITION
	////////////////////////////////////

	eDisputeLevel = GetWonderDisputeLevel(ePlayer);
	iMultiplier = 1;
	bBonus = false;
	bVictoryCompetitor = false;

	if (IsCultural() || bCulturalTraits)
	{
		iMultiplier++;
		bBonus = true;
	}
	if (iMyEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_CULTURE)
	{
		iMultiplier++;
		bBonus = true;
		bVictoryCompetitor = true;
	}
	if (bCloseToCultureVictory)
	{
		iMultiplier++;
		bBonus = true;
		bVictoryCompetitor = true;
	}
	if (bTheyAreCloseToCultureVictory && IsEndgameAggressiveTo(ePlayer))
	{
		iMultiplier++;
		bBonus = false;
		bVictoryCompetitor = true;
	}
	if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_INFLUENTIAL)
	{
		iMultiplier++;
		bBonus = !bVictoryCompetitor && IsCompetingForVictory();
	}
	else if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) == INFLUENCE_LEVEL_POPULAR && GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(eMyPlayer) == INFLUENCE_TREND_RISING)
	{
		iMultiplier++;
		bBonus = !bVictoryCompetitor && IsCompetingForVictory();
	}
	if (IsPlayerWonderSpammer(ePlayer))
	{
		iMultiplier++;
		bBonus = false;
	}

	// Additional multiplier increase if dispute level is fierce
	if (eDisputeLevel == DISPUTE_LEVEL_FIERCE)
	{
		if (bVictoryCompetitor)
		{
			iMultiplier *= 2;
		}
		else if (IsCultural() || bCulturalTraits)
		{
			iMultiplier++;
		}
	}

	// No non-competition bonuses if they've provoked us.
	if (bProvokedUs)
	{
		bBonus = false;
	}

	switch (eDisputeLevel)
	{
	case DISPUTE_LEVEL_NONE:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier : 0;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier : 0;
		break;
	case DISPUTE_LEVEL_WEAK:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += (bVictoryCompetitor || IsCultural() || bCulturalTraits) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier : 0;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
		break;
	case DISPUTE_LEVEL_STRONG:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
		break;
	case DISPUTE_LEVEL_FIERCE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
		break;
	}

	if (IsCompetingForVictory())
	{
		////////////////////////////////////
		// TECH BLOCK
		////////////////////////////////////

		BlockLevelTypes eBlockLevel = GetTechBlockLevel(ePlayer);
		iMultiplier = 1;
		bBonus = false;
		bVictoryCompetitor = false;

		if (IsScientist() || bScientistTraits)
		{
			iMultiplier++;
			bBonus = true;
		}
		if (iMyEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_SCIENCE)
		{
			iMultiplier++;
			bVictoryCompetitor = true;
		}
		if (bCloseToScienceVictory)
		{
			iMultiplier++;
			bVictoryCompetitor = true;
		}
		if (bTheyAreCloseToScienceVictory && IsEndgameAggressiveTo(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
			bVictoryCompetitor = true;
		}
		if (GetNumTimesRobbedBy(ePlayer) > 0 || IsPlayerBrokenSpyPromise(ePlayer) || IsPlayerIgnoredSpyPromise(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
		}

		// Additional multiplier increase if block level is fierce
		if (eBlockLevel == BLOCK_LEVEL_FIERCE)
		{
			if (bVictoryCompetitor)
			{
				iMultiplier *= 2;
			}
			else if (IsScientist() || bScientistTraits)
			{
				iMultiplier++;
			}
		}

		// No non-competition bonuses if they've provoked us.
		if (bProvokedUs)
		{
			bBonus = false;
		}

		switch (eBlockLevel)
		{
		case BLOCK_LEVEL_NONE:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier : 0;
			break;
		case BLOCK_LEVEL_WEAK:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += (bVictoryCompetitor || IsScientist() || bScientistTraits) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
			break;
		case BLOCK_LEVEL_STRONG:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		case BLOCK_LEVEL_FIERCE:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		}

		////////////////////////////////////
		// POLICY BLOCK
		////////////////////////////////////

		eBlockLevel = GetPolicyBlockLevel(ePlayer);
		iMultiplier = 1;
		bBonus = false;
		bVictoryCompetitor = false;

		if (IsCultural() || bCulturalTraits)
		{
			iMultiplier++;
			bBonus = true;
		}
		if (iMyEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_CULTURE)
		{
			iMultiplier++;
			bVictoryCompetitor = true;
		}
		if (bCloseToCultureVictory)
		{
			iMultiplier++;
			bVictoryCompetitor = true;
		}
		if (bTheyAreCloseToCultureVictory && IsEndgameAggressiveTo(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
			bVictoryCompetitor = true;
		}
		if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_INFLUENTIAL)
		{
			iMultiplier++;
			bBonus = !bVictoryCompetitor && IsCompetingForVictory();
		}
		else if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) == INFLUENCE_LEVEL_POPULAR && GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(eMyPlayer) == INFLUENCE_TREND_RISING)
		{
			iMultiplier++;
			bBonus = !bVictoryCompetitor && IsCompetingForVictory();
		}
		if (IsPlayerWonderSpammer(ePlayer))
		{
			iMultiplier++;
			bBonus = false;
		}

		// Additional multiplier increase if block level is fierce
		if (eBlockLevel == BLOCK_LEVEL_FIERCE)
		{
			if (bVictoryCompetitor)
			{
				iMultiplier *= 2;
			}
			else if (IsCultural() || bCulturalTraits)
			{
				iMultiplier++;
			}
		}

		// No non-competition bonuses if they've provoked us.
		if (bProvokedUs)
		{
			bBonus = false;
		}

		switch (eBlockLevel)
		{
		case BLOCK_LEVEL_NONE:
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += bBonus ? vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier : 0;
			break;
		case BLOCK_LEVEL_WEAK:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += (bVictoryCompetitor || IsCultural() || bCulturalTraits) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier : 0;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
			break;
		case BLOCK_LEVEL_STRONG:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		case BLOCK_LEVEL_FIERCE:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
			break;
		}
	}

	////////////////////////////////////
	// WAR PROJECTION - how do we think a war against ePlayer will go?
	////////////////////////////////////

	switch (GetWarProjection(ePlayer))
	{
	case WAR_PROJECTION_DESTRUCTION:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 * iTheirAttackMultiplier;
		break;
	case WAR_PROJECTION_DEFEAT:
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += bProvokedUs ? 0 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
		break;
	case WAR_PROJECTION_STALEMATE:
	case WAR_PROJECTION_UNKNOWN:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		break;
	case WAR_PROJECTION_GOOD:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iAttackMultiplier;
		break;
	case WAR_PROJECTION_VERY_GOOD:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier;
		break;
	}

	////////////////////////////////////
	// MILITARY AGGRESSIVE POSTURE - how aggressively has ePlayer deployed their units near our borders?
	////////////////////////////////////

	switch (GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	case AGGRESSIVE_POSTURE_LOW:
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
		break;
	}

	////////////////////////////////////
	// VASSALAGE
	////////////////////////////////////

	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// They refused to give us our independence when we asked (or they betrayed us)!
		if (IsAngryAboutPlayerVassalageForcefullyRevoked(ePlayer) || IsPlayerBrokenVassalAgreement(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * /*4*/ GC.getAPPROACH_WAR_VASSAL_FORCEFULLY_REVOKED();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * /*-10*/ GC.getAPPROACH_FRIENDLY_VASSAL_FORCEFULLY_REVOKED();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * /*-10*/ GC.getAPPROACH_DECEPTIVE_VASSAL_FORCEFULLY_REVOKED();
		}
		// They gave us our independence!
		else if (IsHappyAboutPlayerVassalagePeacefullyRevoked(ePlayer) || IsMasterLiberatedMeFromVassalage(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * /*-4*/ GC.getAPPROACH_WAR_VASSAL_PEACEFULLY_REVOKED();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * /*5*/ GC.getAPPROACH_FRIENDLY_VASSAL_PEACEFULLY_REVOKED();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += IsMasterLiberatedMeFromVassalage(ePlayer) ? 0 : vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * /*2*/ GC.getAPPROACH_DECEPTIVE_VASSAL_PEACEFULLY_REVOKED();
		}

		// Do we have a master? What does our master think about this player?
		// For human masters, shadow AI approach will be used
		if (GetPlayer()->IsVassalOfSomeone())
		{
			TeamTypes eMaster = GET_TEAM(GetTeam()).GetMaster();
			vector<PlayerTypes> vMasterTeam = GET_TEAM(eMaster).getPlayers();

			for (size_t i=0; i<vMasterTeam.size(); i++)
			{
				if (!GET_PLAYER(vMasterTeam[i]).isAlive())
					continue;

				if (GET_PLAYER(vMasterTeam[i]).getNumCities() <= 0)
					continue;

				// How well are we being treated by this master? That will determine how much we care about their opinion.
				bool bCare = false;
				int iMasterOpinionValue = 0;
				VassalTreatmentTypes eTreatmentLevel = GetVassalTreatmentLevel(ePlayer);

				if (IsVoluntaryVassalage(ePlayer))
				{
					switch (eTreatmentLevel)
					{
					case VASSAL_TREATMENT_CONTENT:
						iMasterOpinionValue = 10;
						bCare = true;
						break;
					case VASSAL_TREATMENT_DISAGREE:
						iMasterOpinionValue = 5;
						bCare = true;
						break;
					case VASSAL_TREATMENT_MISTREATED:
						iMasterOpinionValue = 2;
						bCare = true;
						break;
					case VASSAL_TREATMENT_UNHAPPY:
						iMasterOpinionValue = 2;
						bCare = false;
						break;
					case VASSAL_TREATMENT_ENSLAVED:
						iMasterOpinionValue = 5;
						bCare = false;
						break;
					}
				}
				else
				{
					switch (eTreatmentLevel)
					{
					case VASSAL_TREATMENT_CONTENT:
						iMasterOpinionValue = 5;
						bCare = true;
						break;
					case VASSAL_TREATMENT_DISAGREE:
						iMasterOpinionValue = 2;
						bCare = true;
						break;
					case VASSAL_TREATMENT_MISTREATED:
						iMasterOpinionValue = 2;
						bCare = false;
						break;
					case VASSAL_TREATMENT_UNHAPPY:
						iMasterOpinionValue = 5;
						bCare = false;
						break;
					case VASSAL_TREATMENT_ENSLAVED:
						iMasterOpinionValue = 10;
						bCare = false;
						break;
					}
				}

				// Our master is treating us well, so their opinion matters.
				if (bCare)
				{
					MajorCivApproachTypes eMasterApproach = GET_PLAYER(vMasterTeam[i]).isHuman() ? GET_PLAYER(vMasterTeam[i]).GetDiplomacyAI()->GetMajorCivApproach(ePlayer) : GET_PLAYER(vMasterTeam[i]).GetDiplomacyAI()->GetSurfaceApproach(ePlayer);

					switch (eMasterApproach)
					{
					case MAJOR_CIV_APPROACH_WAR:
					case MAJOR_CIV_APPROACH_HOSTILE:
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMasterOpinionValue;
						break;
					case MAJOR_CIV_APPROACH_GUARDED:
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMasterOpinionValue;
						break;
					case MAJOR_CIV_APPROACH_AFRAID:
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iMasterOpinionValue;
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMasterOpinionValue;
						break;
					default:
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMasterOpinionValue;
						break;
					}
				}
				// Our master is treating us poorly, so we will act against their interests!
				else
				{
					MajorCivApproachTypes ePlayerApproachTowardsMaster = GET_PLAYER(ePlayer).isHuman() ? GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(vMasterTeam[i]) : GET_PLAYER(ePlayer).GetDiplomacyAI()->GetSurfaceApproach(vMasterTeam[i]);

					switch (ePlayerApproachTowardsMaster)
					{
					case MAJOR_CIV_APPROACH_WAR:
					case MAJOR_CIV_APPROACH_HOSTILE:
					case MAJOR_CIV_APPROACH_GUARDED:
					case MAJOR_CIV_APPROACH_AFRAID:
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMasterOpinionValue;
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMasterOpinionValue;
						break;
					default:
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMasterOpinionValue;
						break;
					}
				}
			}
		}
	}

	//--------------------------------//
	// [PART 6: STRATEGIC DIPLOMACY]  //
	//--------------------------------//

	bool bIgnorePolicyDifferences = IsIgnorePolicyDifferences(ePlayer);
	bool bIgnoreReligionDifferences = IsIgnoreReligionDifferences(ePlayer);
	bool bIgnoreIdeologyDifferences = IsIgnoreIdeologyDifferences(ePlayer);

	////////////////////////////////////
	// SOCIAL POLICIES
	////////////////////////////////////	

	// Similar government types get along better 
	int iPolicyScore = GetNumSamePolicies(ePlayer);
	if (iPolicyScore > 0 && !bUntrustworthy)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iPolicyScore;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPolicyScore;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iPolicyScore;
	}
	// Different government types get along worse
	else if (iPolicyScore < 0)
	{
		if (bEarlyGameCompetitor)
		{
			iPolicyScore *= 2;
		}

		if (!bIgnorePolicyDifferences)
		{
			if (eMilitaryStrength < STRENGTH_AVERAGE)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iPolicyScore;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iPolicyScore;
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iPolicyScore;
			}
		}
	}

	////////////////////////////////////
	// RELIGION
	////////////////////////////////////

	int iReligiosityScore = 0;
	bool bSameReligion = false;
	bool bDifferentReligions = false;

	if (!GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		iReligiosityScore = iFlavorReligion + GC.getEraInfo((EraTypes)iGameEra)->getDiploEmphasisReligion();

		if (iFlavorReligion < 5)
		{
			iReligiosityScore = max(0, iReligiosityScore - 2);
		}
		else if (iFlavorReligion > 7)
		{
			iReligiosityScore += 2;
		}

		iReligiosityScore += GetPlayer()->GetPlayerTraits()->IsReligious() ? 2 : 0;
		if (iGameEra != 2 && iGameEra != 3)
			iReligiosityScore /= 2;

		// Have they been converting our cities? Grr...
		if (GetNegativeReligiousConversionPoints(ePlayer) > 0 && !IsPlayerMadeNoConvertPromise(ePlayer))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] + iReligiosityScore + GetNegativeReligiousConversionPoints(ePlayer);
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] + iReligiosityScore + GetNegativeReligiousConversionPoints(ePlayer);
		}

		ReligionTypes eOurStateReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);
		ReligionTypes eOurMajorityReligion = GetPlayer()->GetReligions()->GetReligionInMostCities();
		ReligionTypes eTheirStateReligion = GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false);
		ReligionTypes eTheirMajorityReligion = GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();

		// We didn't found or conquer, but have a majority religion
		if (eOurStateReligion == NO_RELIGION && eOurMajorityReligion != NO_RELIGION)
		{
			if (GetNegativeReligiousConversionPoints(ePlayer) <= 0 && !bEverCapturedKeyCity && !bUntrustworthy)
			{
				// We adopted their state religion
				if (eOurMajorityReligion == eTheirStateReligion)
				{
					bSameReligion = true;

					// They must have at least one of their own cities following their state religion to get a bonus
					if (GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eTheirStateReligion, ePlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iReligiosityScore;

						// If it's the World Religion and they're its controller, support them since we get extra League votes from it
						if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(ePlayer, eTheirStateReligion) > 0)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iReligiosityScore;
						}
					}
				}
				// Same majority religions?
				else if (eOurMajorityReligion == eTheirMajorityReligion)
				{
					bSameReligion = true;
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] + iReligiosityScore;
				}
			}
			// Different majority religions?
			if (eOurMajorityReligion != eTheirStateReligion && eOurMajorityReligion != eTheirMajorityReligion && eTheirMajorityReligion != NO_RELIGION)
			{
				if (!bIgnoreReligionDifferences)
				{
					bDifferentReligions = true;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] + iReligiosityScore;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] + iReligiosityScore;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] + iReligiosityScore;
				}
			}
		}
		// We founded or conquered
		else if (eOurStateReligion != NO_RELIGION)
		{
			// Do they also have a state religion? We don't like that!
			if (eTheirStateReligion != NO_RELIGION && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eTheirStateReligion, ePlayer))
			{
				if (!bIgnoreReligionDifferences)
				{
					bDifferentReligions = true;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iReligiosityScore;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += (vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2) + iReligiosityScore;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iReligiosityScore;

					// If it's the World Religion and they control its Holy City, we should work against them
					if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(ePlayer, eTheirStateReligion) > 0)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iReligiosityScore;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iReligiosityScore;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iReligiosityScore;
					}
				}
			}
			// No? Well, do they have a majority religion?
			else if (eTheirMajorityReligion != NO_RELIGION)
			{
				// Ours?
				if (eTheirMajorityReligion == eOurStateReligion)
				{
					bSameReligion = true;
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3) + iReligiosityScore;

					// If it's the World Religion and we control its Holy City, we should work together
					if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(eMyPlayer, eOurStateReligion) > 0)
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iReligiosityScore;
					}
				}
				// Someone else's?
				else if (!bIgnoreReligionDifferences)
				{
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eTheirMajorityReligion, NO_PLAYER);

					// If the religion's founder is our teammate, don't apply a penalty if that teammate is still alive.
					if (!IsTeammate((PlayerTypes)pReligion->m_eFounder) || GET_PLAYER((PlayerTypes)pReligion->m_eFounder).getNumCities() <= 0)
					{
						bDifferentReligions = true;

						// If the religion's founder is THEIR teammate, treat it like a state religion.
						if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsTeammate((PlayerTypes)pReligion->m_eFounder) && GET_PLAYER((PlayerTypes)pReligion->m_eFounder).getNumCities() > 0)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iReligiosityScore;
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += (vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2) + iReligiosityScore;
							vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iReligiosityScore;

							// If it's the World Religion and their teammate controls its Holy City, we should work against them
							if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier((PlayerTypes)pReligion->m_eFounder, eTheirMajorityReligion) > 0)
							{
								vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iReligiosityScore;
								vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iReligiosityScore;
								vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iReligiosityScore;
							}
						}
						// Otherwise, apply a penalty for different majority religions.
						else
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] + iReligiosityScore;
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] + iReligiosityScore;
							vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] + iReligiosityScore;
						}
					}
				}
			}
		}
	}

	////////////////////////////////////
	// IDEOLOGY
	////////////////////////////////////

	int iFlavorCulture = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));
	int iIdeologueScore = iFlavorCulture + GC.getEraInfo((EraTypes)iGameEra)->getDiploEmphasisLatePolicies();

	if (iFlavorCulture < 5)
	{
		iIdeologueScore = max(0, iIdeologueScore - 2);
	}
	else if (iFlavorCulture > 7)
	{
		iIdeologueScore += 2;
	}

	iIdeologueScore += IsCultural() || bCulturalTraits ? 2 : 0;
	iIdeologueScore += GetVictoryFocus() == VICTORY_FOCUS_CULTURE || bCloseToCultureVictory ? 2 : 0;

	if (iGameEra >= 7)
		iIdeologueScore /= 2;

	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	bool bSameIdeology = false;
	bool bDifferentIdeologies = false;

	if (eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE)
	{
		if (eMyBranch == eTheirBranch && !bEverCapturedKeyCity && !bUntrustworthy)
		{
			bSameIdeology = true;
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3) + iIdeologueScore;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3) + iIdeologueScore;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3) + iIdeologueScore;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3) + iIdeologueScore;

			// World Ideology modifier?
			if (pLeague != NULL && pLeague->GetPressureForIdeology(eMyBranch) > 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iIdeologueScore;
			}
			// Cold War?
			if (bColdWar)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iIdeologueScore;
			}
		}
		else if (eMyBranch != eTheirBranch)
		{
			if (!bIgnoreIdeologyDifferences)
			{
				bDifferentIdeologies = true;
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3) + iIdeologueScore;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3) + iIdeologueScore;

				// World Ideology modifier?
				if (pLeague != NULL && (pLeague->GetPressureForIdeology(eMyBranch) > 0 || pLeague->GetPressureForIdeology(eTheirBranch) > 0))
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iIdeologueScore;
				}
				// Cold War?
				if (bColdWar)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2) + iIdeologueScore;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= (vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2) + iIdeologueScore;
				}
			}
		}
	}

	////////////////////////////////////
	// ALLIANCES
	////////////////////////////////////

	int iReligionMod = iReligiosityScore / 2;
	int iIdeologyMod = iIdeologueScore / 2;

	// Let's play good guys versus bad guys!
	// Good alliances
	if (!bUntrustworthy)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			bool bIgnore = GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GetPlayer()->IsVassalOfSomeone(); // Vassals aren't important unless we're one too.

			if (IsPlayerValid(eLoopPlayer) && eTeam != GET_PLAYER(eLoopPlayer).getTeam())
			{
				if (IsAtWar(eLoopPlayer) || IsDenouncedPlayer(eLoopPlayer) || IsUntrustworthy(eLoopPlayer))
				{
					// At war with an enemy of ours
					if (GET_TEAM(eTeam).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
					{
						if (!bIgnore)
						{
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
						}

						// Is this guy helping us take down a HERETIC?!?!
						if (!bDifferentReligions && IsPlayerOpposingReligion(eLoopPlayer) && !IsIgnoreReligionDifferences(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iReligionMod;
						}
						// Is this guy helping to take down our ideological opponents?
						if (!bDifferentIdeologies && IsPlayerOpposingIdeology(eLoopPlayer) && !IsIgnoreIdeologyDifferences(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iIdeologyMod;
						}
					}
					// Denounced an enemy of ours
					if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
					{
						if (!bIgnore)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
						}

						// Is this a brother of the faith who denounced a HERETIC?!?!
						if (bSameReligion && IsPlayerOpposingReligion(eLoopPlayer) && !IsIgnoreReligionDifferences(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iReligionMod;
						}
						// Is this an ideological partner who denounced an ideological opponent?
						if (bSameIdeology && IsPlayerOpposingIdeology(eLoopPlayer) && !IsIgnoreIdeologyDifferences(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iIdeologyMod;
						}
					}
				}
				else
				{
					// Befriended a friend of ours
					if (IsDoFAccepted(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
					{
						if (!bIgnore)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR];
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
							vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
						}

						// Are we all brothers of the faith?
						if (bSameReligion && IsPlayerSameReligion(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iReligionMod;
						}
						// Are we all of the same ideology?
						if (bSameIdeology && IsPlayerSameIdeology(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iIdeologyMod;
						}
					}
					// Made a DP with a DP of ours
					if (IsHasDefensivePact(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer))
					{
						if (!bIgnore)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
							vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR];
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
							vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
						}

						// Are we all brothers of the faith?
						if (bSameReligion && IsPlayerSameReligion(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iReligionMod;
						}
						// Are we all of the same ideology?
						if (bSameIdeology && IsPlayerSameIdeology(eLoopPlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iIdeologyMod;
						}
					}
				}
			}
		}
	}

	// Reduce global penalties for religion/ideology, if appropriate.
	if (bIgnoreReligionDifferences)
	{
		iReligionMod = 0;
	}
	else if (IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer) || GetDoFType(ePlayer) >= DOF_TYPE_ALLIES)
	{
		iReligionMod /= 2;
	}

	if (bIgnoreIdeologyDifferences || GetPlayer()->IsVassalOfSomeone())
	{
		iIdeologyMod = 0;
	}
	else if (IsDoFAccepted(ePlayer))
	{
		iIdeologyMod /= 2;
	}

	// Bad alliances
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		bool bIgnore = GET_PLAYER(eLoopPlayer).IsVassalOfSomeone() && !GetPlayer()->IsVassalOfSomeone(); // Vassals aren't important unless we're one too.

		if (IsPlayerValid(eLoopPlayer) && eTeam != GET_PLAYER(eLoopPlayer).getTeam())
		{
			if (IsAtWar(eLoopPlayer) || IsDenouncedPlayer(eLoopPlayer) || IsUntrustworthy(eLoopPlayer))
			{
				// Made a DoF with an enemy of ours
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
				{
					if (!bIgnore)
					{
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					}

					// Are they brothers of a hostile faith? Let's try to slow down their religion game.
					if (bDifferentReligions && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerSameReligion(eLoopPlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += iReligionMod;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iReligionMod;
					}
					// Are they allied ideological foes? Let's try to slow down their ideological spread.
					if (bDifferentIdeologies && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerSameIdeology(eLoopPlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += iIdeologyMod;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iIdeologyMod;
					}
				}
				// Made a DP with an enemy of ours
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer))
				{
					if (!bIgnore)
					{
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED];
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					}

					// Are they brothers of a hostile faith? Let's try to slow down their religion game.
					if (bDifferentReligions && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerSameReligion(eLoopPlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += iReligionMod;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += iReligionMod;
					}
					// Are they allied ideological foes? Let's try to slow down their ideological spread.
					if (bDifferentIdeologies && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerSameIdeology(eLoopPlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += iIdeologyMod;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += iIdeologyMod;
					}
				}
			}
			else if (IsDoFAccepted(eLoopPlayer))
			{
				// At war with a friend of ours
				if (GET_TEAM(eTeam).isAtWar(GET_PLAYER(ePlayer).getTeam()))
				{
					if (!bIgnore)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
					}

					if (IsPlayerSameReligion(eLoopPlayer))
					{
						// Is this person attacking our brother of the faith as a HERETIC?!?! How dare they!
						if (bDifferentReligions)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += iReligionMod;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iReligionMod;
						}
					}
					// Same for ideology
					if (IsPlayerSameIdeology(eLoopPlayer))
					{
						if (bDifferentIdeologies)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += iIdeologyMod;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iIdeologyMod;
						}
					}
				}
				// Denounced a friend of ours
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
				{
					if (!bIgnore)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2);
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
					}

					if (IsPlayerSameReligion(eLoopPlayer))
					{
						// Is this person denouncing our brother of the faith as a HERETIC?!?! How dare they!
						if (bDifferentReligions)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += iReligionMod;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iReligionMod;
						}
					}
					// Same for ideology
					if (IsPlayerSameIdeology(eLoopPlayer))
					{
						if (bDifferentIdeologies)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += iIdeologyMod;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iIdeologyMod;
						}
					}
				}
			}
		}
	}

	////////////////////////////////////
	// Are we getting yields from trade with them?
	////////////////////////////////////

	// Compare trade route value for us VS. trade route value for them
	int iCurrentGoldIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer);
	int iCurrentGoldOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, eMyPlayer);
	int iCurrentScienceIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, ePlayer);
	int iCurrentScienceOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, eMyPlayer);
	int iCurrentCultureIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, ePlayer);
	int iCurrentCultureOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, eMyPlayer);

	int iGDPEstimate = GetPlayer()->GetTreasury()->GetGoldFromCitiesTimes100(false);
	int iScienceEstimate = GetPlayer()->GetScienceFromCitiesTimes100(false);
	int iCultureEstimate = GetPlayer()->GetJONSCultureFromCitiesTimes100(false) + (GetPlayer()->GetJONSCulturePerTurnForFree() * 100);

	// Scale factor is hard to guess ...
	int iGoldDelta = (5 * (iCurrentGoldIn - iCurrentGoldOut)) / max(iGDPEstimate,1);
	int iScienceDelta = (5 * (iCurrentScienceIn - iCurrentScienceOut)) / max(iScienceEstimate,1);
	int iCultureDelta = (5 * (iCurrentCultureIn - iCurrentCultureOut)) / max(iCultureEstimate,1);

	// Now add in value from ongoing trade deals
	int iTradeDealValue = GC.getGame().GetGameDeals().GetDealValueWithPlayer(eMyPlayer, ePlayer);

	// Scale based on personality - how much do we care about trade loyalty? 
	// Only use 20% of the value for the diplo modifier (/20 followed by /5 = /100).
	iTradeDealValue *= (GetLoyalty() + GetDiploBalance());
	iTradeDealValue /= 100;

	int iTradeDelta = iGoldDelta + iScienceDelta + iCultureDelta + iTradeDealValue;
	if (iTradeDelta > 0)
	{
		if (bUntrustworthy)
		{
			iTradeDelta /= 2;
		}
		else if (IsStrategicTradePartner(ePlayer))
		{
			iTradeDelta *= 2;
		}

		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += iTradeDelta;
	}

	////////////////////////////////////
	// BANKRUPTCY
	////////////////////////////////////

	bool bBankrupt = GetPlayer()->GetTreasury()->GetGold() <= 0 && GetPlayer()->calculateGoldRate() <= 0;
	int iLostGoldPerTurn = CalculateGoldPerTurnLostFromWar(ePlayer, /*bIgnoreDPs*/ false);

	// We're bankrupt!
	if (bBankrupt)
	{
		if (iLostGoldPerTurn < 0) // We're bankrupt, and we'd gain GPT by going to war with them? Well, there's one way to end that.
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] - iLostGoldPerTurn;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] - iLostGoldPerTurn;
		}
		else // Let's not go to war!
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		}
	}

	if (bWeLostCapital)
	{
		// We captured a major city from them? Keep our guard up!
		if (bCapturedTheirCapital || bCapturedTheirHolyCity)
		{
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 10;
		}
		else if (!bEverCapturedKeyCity && !bUntrustworthy)
		{
			if (GetNumCitiesCapturedBy(ePlayer) <= 0 && GetNumWarsDeclaredOnUs(ePlayer) <= 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
			}
			else if (GetNumCitiesCapturedBy(ePlayer) <= 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}

			// Is this a neighbor?
			if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
			}
			else if (eProximity == PLAYER_PROXIMITY_CLOSE)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}

			// We have someone else's capital? Doubly important we stay on others' good sides!
			if (GetPlayer()->GetNumCapitalCities() > 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetPlayer()->GetNumCapitalCities() * 2;
			}
		}
	}

	////////////////////////////////////
	// AT WAR RIGHT NOW
	////////////////////////////////////

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Don't look at the guy we're already thinking about or anyone on his team
		if (eTeam != GET_PLAYER(eLoopPlayer).getTeam())
		{
			if (IsPlayerValid(eLoopPlayer) && IsAtWar(eLoopPlayer))
			{
				// Fighting together against a common foe?
				if (GET_TEAM(eTeam).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
				}

				// Is this guy a neighbor? We want neighbors on our good side if we're going to war with others
				if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
				}

				// Is the target a neighbor? We want others on our good side if we're going to war with neighbors
				if (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eMyPlayer) == PLAYER_PROXIMITY_NEIGHBORS)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];
				}

				////////////////////////////////////
				// WAR STATE
				////////////////////////////////////

				WarStateTypes eLoopWarState = GetWarState(eLoopPlayer);

				// Not significantly war weary? We should ignore certain players for the war state check.
				if (!GetPlayer()->IsNoNewWars() && GetPlayer()->GetCulture()->GetWarWeariness() < 10 && eLoopWarState != WAR_STATE_DEFENSIVE && eLoopWarState != WAR_STATE_NEARLY_DEFEATED)
				{
					// Ignore players who aren't a serious threat.
					if (IsEasyTarget(eLoopPlayer) || GET_PLAYER(eLoopPlayer).IsNoNewWars())
					{
						continue;
					}
					// Ignore phony wars
					if (IsPhonyWar(eLoopPlayer, true))
					{
						continue;
					}
				}

				// Let's not get into too many wars ...
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;

				// Not winning? Let's be even nicer.
				switch (eLoopWarState)
				{
				case WAR_STATE_NEARLY_WON:
				case WAR_STATE_OFFENSIVE:
					break;
				case WAR_STATE_CALM:
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR];
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
					break;
				case WAR_STATE_STALEMATE:
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2 * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iTheirAttackMultiplier;
					break;
				case WAR_STATE_DEFENSIVE:
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iTheirAttackMultiplier;
					break;
				case WAR_STATE_NEARLY_DEFEATED:
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iTheirAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iTheirAttackMultiplier;
					break;
				}
			}
		}
	}

	////////////////////////////////////
	// DANGEROUS NEIGHBORS - Be careful about being dogpiled!
	////////////////////////////////////

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Only consider potential nearby threats that aren't on this player's team
		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).getTeam() != eTeam && GetPlayer()->GetProximityToPlayer(eLoopPlayer) >= PLAYER_PROXIMITY_CLOSE && IsPotentialMilitaryTargetOrThreat(eLoopPlayer, /*bFromApproachSelection*/ true) && GetMilitaryThreat(eLoopPlayer) > THREAT_NONE)
		{
			// Ignore if game options make it irrelevant
			if (!IsAtWar(eLoopPlayer) && GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
				continue;

			// If we're winning against them or they're losing all their wars, don't count this player as a deterrent.
			if (!GetPlayer()->IsNoNewWars())
			{
				if (IsEasyTarget(eLoopPlayer) || GetWarState(eLoopPlayer) >= WAR_STATE_OFFENSIVE || GET_PLAYER(eLoopPlayer).IsNoNewWars())
					continue;
			}

			bool bNeighbors = GetPlayer()->GetProximityToPlayer(eLoopPlayer) == PLAYER_PROXIMITY_NEIGHBORS;
			int iProximityFactor = bNeighbors ? 2 : 1;
			int iStrengthFactor = (int)GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) - 3; // Ranges from -1 (poor) to 3 (immense)
			int iCitiesCapturedFactor = GetNumCitiesCapturedBy(eLoopPlayer) - GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumCitiesCapturedBy(eMyPlayer);

			int iDeterrence = iProximityFactor + iStrengthFactor + iCitiesCapturedFactor;
			if (!bNeighbors)
			{
				iDeterrence /= 2;
			}
			// If we're already at war but not with the other nearby player, halve the effect of deterrence.
			if (IsAtWar(ePlayer) && !IsAtWar(eLoopPlayer))
			{
				iDeterrence /= 2;
			}

			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iDeterrence;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iDeterrence;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iDeterrence;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iDeterrence;
		}
	}

	////////////////////////////////////
	// Is this player already in a war with someone who isn't us?
	////////////////////////////////////

	int iBonus = 0;
	bool bThinkingAboutDogpiling = false;
	bool bAllowDogpiling = true;
	bool bOtherWarPlayerCloseToTarget;

	if (bWantsOpportunityAttack)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if (eLoopPlayer != eMyPlayer && IsPlayerValid(eLoopPlayer, true) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsAtWar(ePlayer))
				{
					bThinkingAboutDogpiling = false;
					bOtherWarPlayerCloseToTarget = GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE;

					if (IsMajorCompetitor(ePlayer) || bEarlyGameCompetitor)
					{
						bThinkingAboutDogpiling = true;
					}
					else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarDamageValue(eLoopPlayer) > 50)
					{
						bThinkingAboutDogpiling = true;
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5;
					}
					else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarState(eLoopPlayer) >= WAR_STATE_OFFENSIVE)
					{
						bThinkingAboutDogpiling = true;
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 3;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3;
					}
					else if (bOtherWarPlayerCloseToTarget && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarProjection(ePlayer) >= WAR_PROJECTION_GOOD)
					{
						bThinkingAboutDogpiling = true;
						vApproachScores[MAJOR_CIV_APPROACH_AFRAID] -= vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 2;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2;
					}

					// If we can't take them, we don't want them attacking us after finishing with this guy
					if (bThinkingAboutDogpiling && bOtherWarPlayerCloseToTarget && GetWarProjection(eLoopPlayer) <= WAR_PROJECTION_DEFEAT && !IsTeammate(eLoopPlayer) && !IsDoFAccepted(eLoopPlayer) && !IsHasDefensivePact(eLoopPlayer) && GetCoopWarState(eLoopPlayer, ePlayer) < COOP_WAR_STATE_PREPARING)
					{
						bAllowDogpiling = false;
						break;
					}

					if (bThinkingAboutDogpiling)
					{
						int iBonusMod = (int)GetVictoryBlockLevel(ePlayer) + (int)GetVictoryDisputeLevel(ePlayer) + (int)GetWarProjection(ePlayer) + (int)GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarProjection(ePlayer);

						if (!bOtherWarPlayerCloseToTarget)
							iBonusMod /= 2;
						
						iBonus += iBonusMod;
					}
				}
			}
		}

		if (bAllowDogpiling && (iBonus > 0))
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] + iBonus;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] + iBonus;
		}
	}

	////////////////////////////////////
	// THEY'RE CLOSE TO WINNING!
	////////////////////////////////////

	if (bTheyAreCloseToWorldConquest)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 5;
	}

	// Are they conquering the world? We could be next!
	int iDangerScore = GetPlayerNumMajorsConquered(ePlayer);
	if (iDangerScore > 0 && eProximity >= PLAYER_PROXIMITY_CLOSE)
	{
		// Be extremely wary of early game conquerors
		if (iGameEra == 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iDangerScore;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3 * iDangerScore;
			
			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;

				// Easy target and we have war bonuses? Attack!
				if (bCloseToWorldConquest || bConquerorTraits || bWeHaveUUActive)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
				}
			}
		}
		else if (iGameEra == 1)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iDangerScore;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iDangerScore;

			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;

				// Easy target and we have war bonuses? Attack!
				if (bCloseToWorldConquest || bConquerorTraits || bWeHaveUUActive)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;
				}
			}
		}
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iDangerScore;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iDangerScore;

			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;

				// Easy target and we have war bonuses? Attack!
				if (IsConqueror() || GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || bCloseToWorldConquest || bConquerorTraits || bWeHaveUUActive)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				}
			}
		}
	}

	if (IsEndgameAggressiveTo(ePlayer))
	{
		if (bTheyAreCloseToScienceVictory)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		}
		if (bTheyAreCloseToDiploVictory)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		}
		if (bTheyAreCloseToCultureVictory)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
		}
		// Are we both close to a victory condition?
		if (bCloseToAnyVictory)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;

			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
			}
		}
		else if (bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
		}
	}

	////////////////////////////////////
	// EARLY GAME STRATEGY - How should we approach players before the Renaissance?
	////////////////////////////////////

	if (iMyEra <= 2)
	{
		// If we've been on a coop war together, let's keep this relationship going.
		if (GetCoopWarScore(ePlayer) > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2 * GetCoopWarScore(ePlayer);
		}

		// Early game competition is fierce.
		if (bEarlyGameCompetitor)
		{
			// Only favor nearby targets before the Renaissance
			if (eProximity >= PLAYER_PROXIMITY_CLOSE)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				
				// Bold/mean AIs and those with war bonuses don't like early game competitors
				if (GetBoldness() > 6 || GetMeanness() > 6 || IsConqueror() || bConquerorTraits)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				}

				// Denouncements are a catalyst for early game aggression.
				if (IsDenouncedPlayer(ePlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				}
				if (IsDenouncedByPlayer(ePlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				}		
				
				// Easy target?
				if (bEasyTarget)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
				}
			}
		}
		// Are they staying out of our way?
		else
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;

			// Scientific civs are more likely to be neutral; all others are more likely to be friendly
			if (IsScientist())
			{
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}

			// More friendliness if not neighbors
			switch (eProximity)
			{
			case PLAYER_PROXIMITY_CLOSE:
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR];
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
				break;
			case PLAYER_PROXIMITY_FAR:
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				break;
			case PLAYER_PROXIMITY_DISTANT:
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4;
				break;
			}
		}
	}

	////////////////////////////////////
	// GRAND STRATEGY WEIGHT - What victory condition am I aiming for?
	////////////////////////////////////

	if (IsCompetingForVictory())
	{
		// Must be at least in the Medieval Era (or with few players / close to winning / already conquered a capital) to add weight for Domination Victory
		if (iMyEra >= 2 || bCloseToWorldConquest || GC.getGame().countMajorCivsAlive() <= 4 || GetPlayerNumMajorsConquered(eMyPlayer) > 1)
		{
			if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || GetPlayerNumMajorsConquered(eMyPlayer) > 1)
			{
				// Add some weight for leader flavors
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += (GetBoldness() + m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"))) / 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += (GetMeanness() + GetDenounceWillingness()) / 2;

				// More likely to declare war for each original capital we own
				if (GetPlayerNumMajorsConquered(eMyPlayer) > 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetPlayerNumMajorsConquered(eMyPlayer);
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * GetPlayerNumMajorsConquered(eMyPlayer);
				}

				// They have another player's original capital?
				if (GET_PLAYER(ePlayer).GetNumCapitalCities() > 0)
				{
					// We're close to winning? Give us that, my precioussss...
					if (bCloseToWorldConquest)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * GET_PLAYER(ePlayer).GetNumCapitalCities();
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * GET_PLAYER(ePlayer).GetNumCapitalCities();
					}
					// They have their own capital too (making them a competitor)? That makes them a worthwhile ally, but let's also be defensive.
					else if (!bTheyLostCapital)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * GetPlayerNumMajorsConquered(ePlayer);
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * GetPlayerNumMajorsConquered(ePlayer);
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5) - (vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GET_PLAYER(ePlayer).GetNumCapitalCities());
					}
					// Easy target? Score!
					if (bEasyTarget)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					}
				}

				// We must control all capitals to win a Domination Victory, including theirs
				if (bCloseToWorldConquest)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;

					if (bEasyTarget)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					}
				}
				// Not close to victory yet? Let's seek friendship with strong civs.
				else
				{
					if (eMilitaryStrength > STRENGTH_AVERAGE)
					{
						int iStrengthFactor = (int)eMilitaryStrength - 3;
						iStrengthFactor *= 2;
						if (IsHasDefensivePact(ePlayer))
						{
							iStrengthFactor++;
						}
						if (IsBackstabber() && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsBackstabber() && !bUntrustworthy) // Backstabbing conquerors like other backstabbers
						{
							iStrengthFactor += 2;
						}

						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor;
					}
					else
					{
						int iStrengthFactor = (int)eMilitaryStrength - 3;
						iStrengthFactor *= -2;
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iStrengthFactor;
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iStrengthFactor;
					}
					// We really want friendship with wealthy civs who aren't close to us (so we can request help and trade)
					if (IsStrategicTradePartner(ePlayer))
					{
						if (eOpinion >= MAJOR_CIV_OPINION_NEUTRAL)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
						}
						else
						{
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5;
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
						}

						if (IsDoFAccepted(ePlayer))
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
						}
					}
				}

				// They're giving us Open Borders, and no contested borders? Add some friendliness weight.
				if (IsHasOpenBorders(ePlayer) && GetLandDisputeLevel(ePlayer) == DISPUTE_LEVEL_NONE)
				{
					if (eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					}
					else
					{
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					}	
				}

				// Value coop wars
				if (GetCoopWarScore(ePlayer) != 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += GetCoopWarScore(ePlayer) * 8;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= GetCoopWarScore(ePlayer) * 8;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= GetCoopWarScore(ePlayer) * 8;
				}
			}
		}

		// Renaissance Era or later (or close to winning) for other victories
		if (iMyEra >= 3 || bCloseToAnyVictory)
		{
			if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC || bCloseToDiploVictory)
			{
				// Increase friendship willingness with all civs (that aren't close to winning)
				if (!IsEndgameAggressiveTo(ePlayer))
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] + GetDoFWillingness() + m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DIPLOMACY"));

					// Larger increase if we're close to winning
					if (bCloseToDiploVictory)
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					}
				}

				if (bMetValidMinor)
				{
					int iLoweredInfluenceCount = (GetNumTimesTheyLoweredOurInfluence(ePlayer)/2) + GetNumTimesPerformedCoupAgainstUs(ePlayer);

					if (iLoweredInfluenceCount > 0)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iLoweredInfluenceCount;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iLoweredInfluenceCount;
					}

					// Are they protecting our allied/protected City-States?
					if (!IsMinorCivTroublemaker(ePlayer))
					{
						int iSamePtP = 0;
						for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes eMinorLoopPlayer = (PlayerTypes) iPlayerLoop;
							if (eMinorLoopPlayer == NO_PLAYER)
								continue;
			
							if (GET_PLAYER(eMinorLoopPlayer).isMinorCiv())
							{
								if (GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(ePlayer))
								{
									if (GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()) || GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->GetAlly() == GetID())
										iSamePtP++;
								}
							}
						}

						if (iSamePtP > 0)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iSamePtP / 2; 
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iSamePtP / 2;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iSamePtP / 2;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iSamePtP / 2;
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iSamePtP / 2;
						}
					}
				}

				// Is this one of our primary League competitors?
				if (pLeague != NULL)
				{
					// Prime competitor?
					if (GetPrimeLeagueCompetitor() == ePlayer)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5;

						// Easy target?
						if (bEasyTarget)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
						}

						// Especially so if we're close to winning
						if (bCloseToDiploVictory)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
						}
					}
					// More votes than us?
					else if (pLeague->CalculateStartingVotesForMember(ePlayer) > pLeague->CalculateStartingVotesForMember(eMyPlayer))
					{
						// Especially so if we're close to winning
						if (bCloseToDiploVictory)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
						}
						// Easy target?
						else if (bEasyTarget && !IsEasyTarget(GetPrimeLeagueCompetitor()))
						{
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 3 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3 * iAttackMultiplier;
						}
						else if (bTheyAreCloseToDiploVictory || (GetPlayer()->GetLeagueAI()->EvaluateAlignment(ePlayer) <= CvLeagueAI::ALIGNMENT_NEUTRAL))
						{
							vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3;
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 3 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3 * iAttackMultiplier;
						}
						else
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
						}
					}
					// No? Well, we should be much more reluctant to go to war then!
					else
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10 : vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_WAR] -= (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 10 : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= (eOpinion > MAJOR_CIV_OPINION_ENEMY && GetWarmongerThreat(ePlayer) < THREAT_SEVERE) ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 10 : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					}
				}
			}

			if (GetVictoryFocus() == VICTORY_FOCUS_CULTURE || bCloseToCultureVictory)
			{
				// They have influence over us
				if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_POPULAR)
				{
					if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_INFLUENTIAL || GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(eMyPlayer) == INFLUENCE_TREND_RISING)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;

						// Easy target? Tourism begone!
						if (bEasyTarget)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
						}
					}
				}
				else
				{
					// Weight for Open Borders
#if defined(MOD_BALANCE_FLIPPED_TOURISM_MODIFIER_OPEN_BORDERS)
					if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasOpenBorders(eMyPlayer))
#else
					if (IsHasOpenBorders(ePlayer))
#endif
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;

						// Additional weight if we're already influential on half of the civs
						if (GetPlayer()->GetCulture()->GetNumCivsToBeInfluentialOn() <= GetPlayer()->GetCulture()->GetNumCivsInfluentialOn())
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
						}
					}
				}

				// The civ we have the lowest influence on is an easy target? Let's get 'em!
				if (GetPlayer()->GetCulture()->GetCivLowestInfluence(false) == ePlayer && bEasyTarget)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;

					// Especially if we're close to winning
					if (bCloseToCultureVictory)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
					}
				}
				else if (GetPlayer()->GetCulture()->GetCivLowestInfluence(false) == ePlayer)
				{
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 10;

					if (bCloseToCultureVictory)
					{
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 10;
					}
				}
				else
				{
					if (bCloseToCultureVictory)
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					}

					// If we need influence over them, we should be more friendly, but they're also a greater competitor
					switch (GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer))
					{
					case INFLUENCE_LEVEL_UNKNOWN:
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 4;
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
						break;
					case INFLUENCE_LEVEL_EXOTIC:
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
						break;
					case INFLUENCE_LEVEL_FAMILIAR:
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 4;
						break;
					case INFLUENCE_LEVEL_POPULAR:
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 4;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
						break;
					case INFLUENCE_LEVEL_INFLUENTIAL:
						if (GetPlayer()->GetCulture()->GetInfluenceTrend(ePlayer) != INFLUENCE_TREND_RISING) // don't let our influence slip!
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 4;
							vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
						}
						else if (eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
						}
						else if (eOpinion <= MAJOR_CIV_OPINION_COMPETITOR && eProximity >= PLAYER_PROXIMITY_CLOSE) // we've already got our influence, now conquering them will be easier
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier;

							if (bEasyTarget)
							{
								vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iAttackMultiplier;
								vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3 * iAttackMultiplier;
							}
						}
						break;
					case INFLUENCE_LEVEL_DOMINANT:
						if (eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
						}
						else if (eOpinion <= MAJOR_CIV_OPINION_COMPETITOR && eProximity >= PLAYER_PROXIMITY_CLOSE) // we've already got our influence, now conquering them will be easier
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
				
							if (bEasyTarget)
							{
								vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
								vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
							}
						}
						break;
					}
				}
			}

			if (GetVictoryFocus() == VICTORY_FOCUS_SCIENCE || bCloseToScienceVictory)
			{
				// Spaceship competitor?
				if (GET_TEAM(eTeam).GetSSProjectCount() > 0 || (!bCloseToScienceVictory && bTheyAreCloseToScienceVictory))
				{
					if (IsEndgameAggressiveTo(ePlayer))
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 10 * iAttackMultiplier;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 10 * iAttackMultiplier;
					}
				}
				else if (bCloseToScienceVictory)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 10;
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 10;
				}
				else
				{
					int iTechDifference = min(10, max(-10, (iNumTheirTechs - iNumOurTechs)));

					// They have a tech lead of 4 or more - enemy!
					if (iTechDifference >= 4)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTechDifference;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iTechDifference;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iTechDifference;

						// Easy target?
						if (bEasyTarget)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
						}
					}
					// They have a tech lead of 2 to 3 - we want to befriend them for tech trading/trade routes, but they're also an enemy
					else if (iTechDifference >= 2)
					{
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iTechDifference;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTechDifference;

						// Easy target?
						if (bEasyTarget)
						{
							vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2 * iAttackMultiplier;
						}
					}
					// We have a tech lead of 2 or more - below average friend/enemy choice, but good DP choice if they're strong
					else if (iTechDifference <= -2)
					{
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iTechDifference;
						vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iTechDifference;

						// We want other civs to guard our back
						if (eMilitaryStrength >= STRENGTH_AVERAGE && !GET_PLAYER(ePlayer).IsNoNewWars() && !IsAtWar(ePlayer) && eProximity >= PLAYER_PROXIMITY_CLOSE)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iTechDifference / iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTechDifference / iAttackMultiplier;
							vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iTechDifference / iAttackMultiplier;
						}
					}
					// Equal, or within one tech of each other
					else
					{
						vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE];
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL];

						// We want other civs to guard our back
						if (eMilitaryStrength >= STRENGTH_AVERAGE && !GET_PLAYER(ePlayer).IsNoNewWars() && !IsAtWar(ePlayer) && eProximity >= PLAYER_PROXIMITY_CLOSE)
						{
							vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] / iAttackMultiplier;
						}
					}

					// Be friendly to our DPs (if they don't have a large tech lead).
					if (IsHasDefensivePact(ePlayer) && iTechDifference <= 3)
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 3;
					}
					// Be friendly to our RA civs (if they don't have a large tech lead).
					if (IsHasResearchAgreement(ePlayer) && iTechDifference <= 3 && !GET_TEAM(eMyTeam).GetTeamTechs()->HasResearchedAllTechs())
					{
						vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 3;
						vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 3;
					}
				}
			}
		}
	}

	//--------------------------------//
	// [PART 7: ADDITIONAL FACTORS]   //
	//--------------------------------//

	////////////////////////////////////
	// NUKES
	////////////////////////////////////

	int iHowLikelyAreTheyToNukeUs = GET_PLAYER(ePlayer).isHuman() ? 100 : 0; // assume humans will use 'em if they've got 'em
	if (iHowLikelyAreTheyToNukeUs == 0)
	{
		if (IsNukedBy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsNukedBy(eMyPlayer)) // nukes have been used already
		{
			iHowLikelyAreTheyToNukeUs = 100;
		}
		// they are surely going to lose a war with us, so they will nuke us
		else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarProjection(eMyPlayer) == WAR_PROJECTION_DESTRUCTION || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarState(eMyPlayer) == WAR_STATE_NEARLY_DEFEATED)
		{
			iHowLikelyAreTheyToNukeUs = 100;
		}
		else
		{
			int iFlavorNuke = GET_PLAYER(ePlayer).GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_USE_NUKE"));
			iHowLikelyAreTheyToNukeUs = iFlavorNuke * iFlavorNuke; // use nukes has to pass 2 rolls
		}
	}

	// Do we have nukes and they don't?
	if (GET_PLAYER(ePlayer).getNumNukeUnits() == 0 && GetPlayer()->getNumNukeUnits() > 0)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iAttackMultiplier : 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3 * iAttackMultiplier : 0;

		if (bWantsOpportunityAttack && bEasyTarget)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5 * iAttackMultiplier;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5 * iAttackMultiplier;
		}
	}
	// Do they have nukes and we don't?
	else if (GET_PLAYER(ePlayer).getNumNukeUnits() > 0 && GetPlayer()->getNumNukeUnits() == 0 && iHowLikelyAreTheyToNukeUs >= 50)
	{
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * 5 * iTheirAttackMultiplier;
	}
	// Do we both have nukes?
	else if (GET_PLAYER(ePlayer).getNumNukeUnits() > 0 && GetPlayer()->getNumNukeUnits() > 0 && iHowLikelyAreTheyToNukeUs >= 25)
	{
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
	}

	// THEY NUKED US!
	if (IsNukedBy(ePlayer))
	{
		int iTimesNuked = min(GetNumTimesNuked(ePlayer), 10);
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTimesNuked / 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iTimesNuked / 2;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iTimesNuked;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += vApproachBias[MAJOR_CIV_APPROACH_AFRAID] * iTimesNuked * iTheirAttackMultiplier;
	}

	////////////////////////////////////
	// UNIQUE UNITS
	////////////////////////////////////

	// We've got a UU? Let's see if it is time to go.
	if (GetPlayer()->HasUUPeriod())
	{
		// We got it? Let's strike!
		if (bWeHaveUUTech && bWeHaveUUActive)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3;

			// Going for world conquest?
			if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || bCloseToWorldConquest)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
			}
			// Easy target?
			if (bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			}
		}
		// Have tech but not UU? Hurry up!
		else if (bWeHaveUUTech && !bWeHaveUUActive)
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 5;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		}
		// Don't have it but will have it soon? Delay.
		else if (GetPlayer()->GetPlayerTechs()->WillHaveUUTechSoon())
		{
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
		}
	}

	////////////////////////////////////
	// EMPIRE CRAMPED
	////////////////////////////////////

	if (GetPlayer()->IsCramped() && eProximity == PLAYER_PROXIMITY_NEIGHBORS)
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 3;
	}

	////////////////////////////////////
	// WAR WEARINESS
	////////////////////////////////////

	int iWarWeariness = GetPlayer()->GetCulture()->GetWarWeariness();

	if (iWarWeariness > 0)
	{
		if (GetPlayer()->IsEmpireSuperUnhappy())
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iWarWeariness * 2;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iWarWeariness * 2;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iWarWeariness * 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iWarWeariness * 2;
		}
		else if (GetPlayer()->IsEmpireVeryUnhappy())
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iWarWeariness;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iWarWeariness;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iWarWeariness;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iWarWeariness;
		}
		else if (GetPlayer()->IsEmpireUnhappy())
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iWarWeariness / 2;
			vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iWarWeariness / 2;
			vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iWarWeariness / 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iWarWeariness / 2;
		}
	}

	////////////////////////////////////
	// Is this player a reckless expander?
	////////////////////////////////////

	if (IsPlayerRecklessExpander(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;

		if (IsConqueror() || bConquerorTraits)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		}

		if (bEasyTarget || bWeHaveUUActive)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		}
	}

	////////////////////////////////////
	// Is this player spamming World Wonders?
	////////////////////////////////////

	if (IsPlayerWonderSpammer(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;

		if (IsCultural() || IsConqueror() || bCulturalTraits || bConquerorTraits)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		}

		if (bEasyTarget || bWeHaveUUActive)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
		}
	}

	////////////////////////////////////
	// DUEL - There's only 2 players in this game
	////////////////////////////////////

	if (GC.getGame().countMajorCivsAlive() == 2)
	{
		if (IsCompetingForVictory())
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
	
			if (IsEndgameAggressiveTo(ePlayer) && bEasyTarget)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += 1000;
			}
		}
		if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || bCloseToWorldConquest)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += 1000;
		}
	}

	////////////////////////////////////
	// COMMUNITY BALANCE OVERHAUL CHANGES
	////////////////////////////////////

	if (MOD_BALANCE_CORE)
	{
		////////////////////////////////////
		// Difficulty Bonus
		////////////////////////////////////

		int iDifficultyBonusBase = MOD_BALANCE_CORE_DIFFICULTY ? (min(10, max(0, (GC.getGame().getHandicapInfo().getAIDifficultyBonusBase()/2)))) : 0; // normally ranges from 0 to 14

		if (MOD_BALANCE_CORE_DIFFICULTY)
		{
			// If we don't view them favorably, increase hostility based on game difficulty
			if (eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
			{
				int iDifficultyBonus = iDifficultyBonusBase - ((int)eOpinion * 2); // Unforgivable: -0, Enemy: -2, Competitor: -4

				if (iDifficultyBonus > 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iDifficultyBonus / 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iDifficultyBonus / 2;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iDifficultyBonus / 2;

					if (bWantsOpportunityAttack)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iDifficultyBonus;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iDifficultyBonus;
					}

					// Easy target?
					if (bEasyTarget)
					{
						vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iDifficultyBonus / 2;
						vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iDifficultyBonus / 2;
					}
				}
			}
		}

		////////////////////////////////////
		// War Bonus
		////////////////////////////////////

		// Do we have bonuses towards war?
		int iWarBonus = 0;
		int iHostileBonus = 0;

		// War or expansionist UA?
		if (bConquerorTraits || GetPlayer()->GetPlayerTraits()->IsExpansionist())
		{
			iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
			iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;

			// Unique unit active? Slay them all!
			if (GetPlayer()->HasUUPeriod() && bWeHaveUUTech && bWeHaveUUActive)
			{
				iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
				iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
			
				// AND we're going for world conquest?
				if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || bCloseToWorldConquest)
				{
					iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
					iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
				}
			}
		}

		// If we picked offensive policy trees, war is a lot better for us.
		PolicyBranchTypes eAuthority = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_HONOR", true);
		PolicyBranchTypes eImperialism = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_EXPLORATION", true);

		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eAuthority))
		{
			iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
			iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;
			
			if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eAuthority))
			{
				iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
				iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;
			}
		}
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eImperialism))
		{
			iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
			iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;;
			
			if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eImperialism))
			{
				iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 3 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier * 15 / 10;
				iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 3 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier * 15 / 10;
			}
		}
		if (eMyBranch == GC.getPOLICY_BRANCH_AUTOCRACY())
		{
			iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
			iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 4 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier;
		}

		// Temporary attack bonus?
		if (GetPlayer()->GetAttackBonusTurns() > 0)
		{
			iWarBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
			iHostileBonus += bWantsOpportunityAttack ? vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier : vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;
		}

		// Scale based on personality (boldness) and victory issues
		iWarBonus *= GetBoldness() + (int)GetVictoryDisputeLevel(ePlayer) + (int)GetVictoryBlockLevel(ePlayer);
		iWarBonus /= 10;
		iHostileBonus *= GetMeanness() + (int)GetVictoryDisputeLevel(ePlayer) + (int)GetVictoryBlockLevel(ePlayer);
		iHostileBonus /= 10;

		if (iWarBonus > 0 || iHostileBonus > 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += iWarBonus;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iHostileBonus;

			if (bConquerorTraits || bCloseToWorldConquest || GetVictoryFocus() == VICTORY_FOCUS_DOMINATION)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += iWarBonus;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += iHostileBonus;
			}
		}

		////////////////////////////////////
		// Non-War Social Policy Bonuses
		////////////////////////////////////

		PolicyBranchTypes eTradition = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_TRADITION", true);
		PolicyBranchTypes eProgress = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_LIBERTY", true);
		PolicyBranchTypes eFealty = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PIETY", true);
		PolicyBranchTypes eStatecraft = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true);
		PolicyBranchTypes eArtistry = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true);
		PolicyBranchTypes eIndustry = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_COMMERCE", true);
		PolicyBranchTypes eRationalism = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_RATIONALISM", true);

		// Tradition
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eTradition))
		{
			// Early game competitor and stronger than a non-Tradition player? Let's seize our advantage while we can!
			if (bEarlyGameCompetitor && eProximity >= PLAYER_PROXIMITY_CLOSE && !GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(eTradition))
			{
				if (bWantsOpportunityAttack)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2 * iAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2 * iAttackMultiplier;
				}
				else if (eMilitaryStrength < STRENGTH_AVERAGE || (eEconomicStrength < STRENGTH_AVERAGE && eMilitaryStrength == STRENGTH_AVERAGE))
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iAttackMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iAttackMultiplier;
				}
				// Stronger than us? Raise our guard!
				else if (eMilitaryStrength > STRENGTH_AVERAGE)
				{
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * 2 * iTheirAttackMultiplier;
				}
			}
			else
			{
				iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eTradition) ? 2 : 1;
				iMultiplier += GetPlayer()->GetPlayerTraits()->IsSmaller() ? 1 : 0; // Additional bonus if we're geared towards being smaller

				// More likely to be friendly if not competing for Wonders, more aggressive if competing for Wonders
				if (GetWonderDisputeLevel(ePlayer) == DISPUTE_LEVEL_FIERCE)
				{
					iMultiplier += GetWonderCompetitiveness() > 7 ? 1 : 0;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
				}
				else if (!bUntrustworthy)
				{
					iMultiplier += GetWonderCompetitiveness() > 7 ? 1 : 0;
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				}
			}
		}

		// Progress
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eProgress))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eProgress) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsSmaller() ? 1 : 0; // Additional bonus if we're geared towards being smaller
			iMultiplier += bEarlyGameCompetitor ? -1 : 1;

			// Disincentivize early war - we want to work on our infrastructure
			if (iMyEra <= 2)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;

				// Be wary of strong neighbors
				if (eProximity >= PLAYER_PROXIMITY_CLOSE && eMilitaryStrength > STRENGTH_AVERAGE)
				{
					iMultiplier += bEarlyGameCompetitor ? 2 : -2; // 2 to undo the earlier change and add 1
					vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
					vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				}
			}
		}

		// Fealty
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eFealty))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eFealty) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsReligious() ? 2 : 0; // Additional bonus if we're geared towards being religious
			iMultiplier += GetVictoryFocus() == VICTORY_FOCUS_DOMINATION ? 1 : 0;
			iMultiplier += iFlavorReligion < 5 ? -1 : 0;
			iMultiplier += iFlavorReligion > 7 ? 1 : 0;

			// Favor players who we share a religion with
			if (bSameReligion)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
			// Pre-Modern Era, let's be more intense about religious fervor
			else if (bDifferentReligions && iMyEra <= 4)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
		}

		// Statecraft
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eStatecraft))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eStatecraft) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsExpansionist() ? 2 : 0; // Larger civs care more, since they have more enforcement ability, resources and City-State allies
			iMultiplier += bDiplomatTraits ? 2 : 0;
			iMultiplier += IsDiplomat() ? 1 : 0;

			// Extra hatred for those who mess with our City-States (also our prime league competitor!)
			if ((bMetValidMinor && IsMinorCivTroublemaker(ePlayer)) || (GetPrimeLeagueCompetitor() == ePlayer))
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
			// Extra friendliness for others!
			else if (bMetValidMinor && !bUntrustworthy)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
		}

		// Artistry
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eArtistry))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eArtistry) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsSmaller() ? 2 : 0; // Smaller civs really care about cultural competition if they've chosen Artistry
			iMultiplier += bCulturalTraits ? 2 : 0;
			iMultiplier += IsCultural() ? 1 : 0;
			bool bStolenArtifacts = GetNumArtifactsEverDugUp(ePlayer) > 0;

			bool bInfluenceOverUs = false;
			// They have influence over us
			if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_POPULAR)
			{
				if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(eMyPlayer) >= INFLUENCE_LEVEL_INFLUENTIAL || GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(eMyPlayer) == INFLUENCE_TREND_RISING)
				{
					bInfluenceOverUs = true;
				}
			}

			// More aggressive if competing for Influence, dig sites or Wonders, more friendly otherwise
			if (bInfluenceOverUs || bStolenArtifacts || GetWonderDisputeLevel(ePlayer) == DISPUTE_LEVEL_FIERCE)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
			else if (!bUntrustworthy)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;

				// If they've built landmarks for us, be happy!
				if (GetNumLandmarksBuiltForMe(ePlayer) > 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * GetNumLandmarksBuiltForMe(ePlayer);
				}
			}
		}

		// Industry - more friendliness for strategic trade partners
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eIndustry))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eIndustry) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsExpansionist() ? 2 : 0; // Larger civs care more, since they have more trade resources
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsImportsCountTowardsMonopolies() ? 2 : 0; // The Netherlands REALLY likes strategic trade partners if they've chosen Industry
			iMultiplier += bDiplomatTraits ? 2 : 0;
			iMultiplier += IsDiplomat() ? 1 : 0;
			iMultiplier += IsMajorCompetitor(ePlayer) ? -1 : 1;

			// Strategic trade partner that we're getting trade value from?
			if (!bUntrustworthy && IsStrategicTradePartner(ePlayer) && iTradeDelta > 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
		}

		// Rationalism - more friendliness if ahead in science, more aggression if behind
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eRationalism))
		{
			iMultiplier = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eRationalism) ? 2 : 1;
			iMultiplier += GetPlayer()->GetPlayerTraits()->IsSmaller() ? 2 : 0; // Smaller civs really care about tech levels if they've chosen Rationalism
			iMultiplier += bScientistTraits ? 2 : 0;
			iMultiplier += IsScientist() ? 1 : 0;

			if (GetTechBlockLevel(ePlayer) > DISPUTE_LEVEL_NONE)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] -= vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] * iMultiplier;
				vApproachScores[MAJOR_CIV_APPROACH_GUARDED] -= vApproachBias[MAJOR_CIV_APPROACH_GUARDED] * iMultiplier;
			}
		}

		////////////////////////////////////
		// LEADER PERSONALITY - Each leader has their own tendencies
		// (currently experimenting with this)
		////////////////////////////////////

		// Assyria - Attitude depends on tech lead
		if (GetPlayer()->GetPlayerTraits()->IsTechFromCityConquer() && !GET_TEAM(eMyTeam).GetTeamTechs()->HasResearchedAllTechs())
		{
			int iTechDifference = iNumTheirTechs - iNumOurTechs;

			if (iTechDifference > 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * iTechDifference;
			}
			else if (iTechDifference < 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * -iTechDifference;
			}
			else
			{
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
			}
		}

		// Aztecs - More likely to declare war than any other civ, everything else equal, plus an extra bonus for war when not in a Golden Age (or in the early game)
		else if (GetPlayer()->GetPlayerTraits()->GetGoldenAgeFromVictory() != 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
		
			if (bEarlyGameCompetitor || (!GetPlayer()->isGoldenAge() && eProximity >= PLAYER_PROXIMITY_CLOSE))
			{
				if (bEasyTarget)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 2;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 2;
				}
				else if (eMilitaryStrength < STRENGTH_AVERAGE)
				{
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR];
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE];
				}					
			}
		}

		// India - More likely to be friendly than any other civ, everything else equal, plus an extra bonus for players with no warmongering penalty
		else if (GetPlayer()->GetPlayerTraits()->GetCityUnhappinessModifier() != 0)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
		
			if (GetOtherPlayerWarmongerScore(ePlayer) <= 0)
			{
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY];
			}

			// ... unless Gandhi has nukes
			if ((GetPlayer()->getNumNukeUnits() > 0 || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsNukedBy(eMyPlayer)) && GC.getGame().IsNuclearGandhiEnabled())
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += 200;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += 100;
				vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = -1000;
				vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] = -1000;
				vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = -1000;
				vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] = -1000;
			}
		}

		////////////////////////////////////
		// WORLD CONGRESS - Are there any resolutions we should take into consideration?
		////////////////////////////////////

		if (pLeague != NULL)
		{
			// UN active? Be more friendly if we're trying to win by diplomacy.
			if (pLeague->IsUnitedNations())
			{
				if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC || bCloseToDiploVictory)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
				}
			}

			// If either of us is sanctioned, we should be more hostile.
			if (pLeague->IsTradeEmbargoed(eMyPlayer, ePlayer))
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
			}

			if (MOD_DIPLOMACY_CITYSTATES)
			{
				// Casus Belli = more war, less friendly
				if (GC.getGame().GetGameLeagues()->IsWorldWar(eMyPlayer) > 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] -= vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] -= vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] += vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
				}

				// Global Peace Accords = less war, more friendly
				if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(eMyPlayer) > 0)
				{
					vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_WAR] -= vApproachBias[MAJOR_CIV_APPROACH_WAR] * 5;
					vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] -= vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] * 5;
				}
			}
		}
	}

	//--------------------------------//
	// [PART 8: MODDER WEIGHT - FLAT] //
	//--------------------------------//

	////////////////////////////////////
	// CUSTOM DLL MOD BONUS/PENALTY
	////////////////////////////////////

	// Modders can add flat weight to approaches based on custom conditions (if a certain Custom Mod is #defined) here.

	////////////////////////////////////
	// LUA BONUS/PENALTY
	////////////////////////////////////

	// Modders can add flat weight to approaches based on custom conditions here.
	// (to-do: add LUA hook)

	////////////////////////////////////
	// SQL BONUS/PENALTY
	////////////////////////////////////

	// Additional weight to approaches (flat +/-; configurable in DiploApproachWeights.sql)
	if (GET_PLAYER(ePlayer).isHuman())
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += /*0*/ GC.getAPPROACH_NEUTRAL_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += /*0*/ GC.getAPPROACH_FRIENDLY_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += /*0*/ GC.getAPPROACH_AFRAID_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += /*0*/ GC.getAPPROACH_GUARDED_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += /*0*/ GC.getAPPROACH_DECEPTIVE_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += /*0*/ GC.getAPPROACH_HOSTILE_HUMAN();
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += /*0*/ GC.getAPPROACH_WAR_HUMAN();
	}
	else
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] += /*0*/ GC.getAPPROACH_NEUTRAL_AI();
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] += /*0*/ GC.getAPPROACH_FRIENDLY_AI();
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] += /*0*/ GC.getAPPROACH_AFRAID_AI();
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] += /*0*/ GC.getAPPROACH_GUARDED_AI();
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] += /*0*/ GC.getAPPROACH_DECEPTIVE_AI();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] += /*0*/ GC.getAPPROACH_HOSTILE_AI();
		vApproachScores[MAJOR_CIV_APPROACH_WAR] += /*0*/ GC.getAPPROACH_WAR_AI();
	}

	//--------------------------------//
	// [PART 9: PRIORITIZATION]		  //
	//--------------------------------//

	int iWarMod = vApproachBias[MAJOR_CIV_APPROACH_WAR] + GetBoldness();
	int iHostileMod = vApproachBias[MAJOR_CIV_APPROACH_HOSTILE] + GetMeanness();
	int iDeceptiveMod = vApproachBias[MAJOR_CIV_APPROACH_DECEPTIVE] + GetDenounceWillingness();
	int iGuardedMod = vApproachBias[MAJOR_CIV_APPROACH_GUARDED] + (10 - GetForgiveness());
	int iAfraidMod = vApproachBias[MAJOR_CIV_APPROACH_AFRAID] + (10 - GetBoldness());
	int iFriendlyMod = vApproachBias[MAJOR_CIV_APPROACH_FRIENDLY] + GetDoFWillingness();
	int iNeutralMod = vApproachBias[MAJOR_CIV_APPROACH_NEUTRAL] + GetDiploBalance() + GetLoyalty();

	// Prioritize our approaches to avoid adopting the same approach towards too many players and allow more variance/strategy
	// Only do this on the second pass of the function, as we've already recorded the most recent values for this turn
	if (!bFirstPass && vPlayersToUpdate.size() > 1)
	{
		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			// Create a vector to store and rank the approach weights of each player from the first pass
			CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> vePlayerApproachValues;

			for (std::vector<PlayerTypes>::iterator it = vPlayersToUpdate.begin(); it != vPlayersToUpdate.end(); ++it)
			{
				int iApproachValue = GetPlayerStrategicApproachValue(*it, eLoopApproach); // We use the strategic approach here for a better variance/response to circumstances.
				vePlayerApproachValues.push_back(*it, iApproachValue);
			}

			// Sort the weights from highest to lowest
			vePlayerApproachValues.SortItems();

			// Find this player's ranking (how far are they down the list?)
			for (int iPlayerRanking = 0; iPlayerRanking < (int) vePlayerApproachValues.size(); iPlayerRanking++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) vePlayerApproachValues.GetElement(iPlayerRanking);
				
				if (eLoopPlayer == ePlayer)
				{
					// If this is the highest rated player for this approach, we do nothing.
					if (iPlayerRanking == 0)
						break;

					// If this player's ranking is greater than 0 (i.e. the highest approach weight of all players) then subtract weight
					// Ranking of 1 = -1x bias, 2 = -2x bias, etc.
					int iReduction = vApproachBias[(int)eLoopApproach] * iPlayerRanking;

					// Adjust the reduction based on flavors
					// Higher approach flavor = Lower reduction
					// Lower approach flavor = Higher reduction
					int iFlavorMod = 0;
					switch (eLoopApproach)
					{
					case MAJOR_CIV_APPROACH_WAR:
						iFlavorMod = iWarMod - 10;
						break;
					case MAJOR_CIV_APPROACH_HOSTILE:
						iFlavorMod = iHostileMod -= 10;
						break;
					case MAJOR_CIV_APPROACH_DECEPTIVE:
						iFlavorMod = iDeceptiveMod - 10;
						break;
					case MAJOR_CIV_APPROACH_GUARDED:
						iFlavorMod = iGuardedMod - 10;
						break;
					case MAJOR_CIV_APPROACH_AFRAID:
						iFlavorMod = iAfraidMod - 10;
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						iFlavorMod = iFriendlyMod - 10;
						break;
					case MAJOR_CIV_APPROACH_NEUTRAL:
						iFlavorMod = iNeutralMod - 10;
						break;
					}

					iFlavorMod *= 10;

					if (iFlavorMod > 0)
					{
						iReduction *= 100;
						iReduction /= (100 + iFlavorMod);
					}
					else if (iFlavorMod < 0)
					{
						iReduction *= (100 + iFlavorMod);
						iReduction /= 100;
					}

					if (iReduction > 0)
						vApproachScores[(int)eLoopApproach] -= iReduction;

					break;
				}
			}
		}
	}

	// Negative approach weights - cap at zero!
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

		if (vApproachScores[(int)eLoopApproach] <= 0)
		{
			vApproachScores[(int)eLoopApproach] = 0;
		}
	}

	//--------------------------------//
	// [PART 10: MULTIPLIERS]   		  //
	//--------------------------------//

	////////////////////////////////////
	// TOO MANY VASSALS MULTIPLIER
	////////////////////////////////////

	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		if (GET_PLAYER(ePlayer).GetNumVassals() > 1)
		{
			// Increase bad approach scores for each vassal they own, provided they have more than one
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= 100 + (GET_PLAYER(ePlayer).GetNumVassals() * /*20*/ GC.getAPPROACH_WAR_TOO_MANY_VASSALS());	// 2 vassals = 140%, 3 vassals = 160%
			vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= 100 + (GET_PLAYER(ePlayer).GetNumVassals() * /*20*/ GC.getAPPROACH_WAR_TOO_MANY_VASSALS());
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= 100 + (GET_PLAYER(ePlayer).GetNumVassals() * /*20*/ GC.getAPPROACH_GUARDED_TOO_MANY_VASSALS());
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 100;
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= 100 + (GET_PLAYER(ePlayer).GetNumVassals() * /*20*/ GC.getAPPROACH_GUARDED_TOO_MANY_VASSALS());
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 100;
		}
	}

	////////////////////////////////////
	// MILITARY TARGET VALUE - how tough is this guy to kill?
	////////////////////////////////////

	// Target capacity should matter! If we don't have a good attack target, we shouldn't want to attack them as much!
	bool bWantsConquest = bWantsOpportunityAttack && bGoodAttackTarget;

	switch (GetPlayerTargetValue(ePlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*75*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_IMPOSSIBLE() : /*25*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_IMPOSSIBLE();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*75*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_IMPOSSIBLE() : /*25*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_IMPOSSIBLE();
		break;
	case TARGET_VALUE_BAD:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*100*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_BAD() : /*50*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_BAD();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*100*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_BAD() : /*50*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_BAD();
		break;
	case TARGET_VALUE_AVERAGE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*125*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_AVERAGE() : /*75*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_AVERAGE();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*125*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_AVERAGE() : /*75*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_AVERAGE();
		break;
	case TARGET_VALUE_FAVORABLE:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*150*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_FAVORABLE() : /*125*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_FAVORABLE();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*150*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_FAVORABLE() : /*125*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_FAVORABLE();
		break;
	case TARGET_VALUE_SOFT:
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*200*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_SOFT() : /*150*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_SOFT();
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*200*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_SOFT() : /*150*/ GC.getMAJOR_WAR_MULTIPLIER_TARGET_SOFT();
		break;
	}

	vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;

	////////////////////////////////////
	// PROXIMITY MULTIPLIER - the farther away a player is the less likely we are to care about them!
	////////////////////////////////////

	bool bCanCrossOcean = GetPlayer()->CanCrossOcean() && iMyEra >= 3;

	if (bCanCrossOcean)
	{
		switch (eProximity)
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*200*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS() : /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*200*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS() : /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			break;
		case PLAYER_PROXIMITY_CLOSE:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*150*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE() : /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*150*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE() : /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			break;
		case PLAYER_PROXIMITY_FAR:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*100*/ GC.getAPPROACH_WAR_PROXIMITY_FAR() : /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*100*/ GC.getAPPROACH_WAR_PROXIMITY_FAR() : /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			break;
		case PLAYER_PROXIMITY_DISTANT:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*75*/ GC.getAPPROACH_WAR_PROXIMITY_DISTANT() : /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*75*/ GC.getAPPROACH_WAR_PROXIMITY_DISTANT() : /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			break;
		}
	}
	else
	{
		switch (eProximity)
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*300*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS_EARLY_GAME() : /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*300*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS_EARLY_GAME() : /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*150*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_NEIGHBORS();
			break;
		case PLAYER_PROXIMITY_CLOSE:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= bWantsConquest ? /*225*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE_EARLY_GAME() : /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= bWantsConquest ? /*225*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE_EARLY_GAME() : /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*125*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_CLOSE();
			break;
		case PLAYER_PROXIMITY_FAR:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*75*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_FAR();
			break;
		case PLAYER_PROXIMITY_DISTANT:
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= /*50*/ GC.getAPPROACH_MULTIPLIER_PROXIMITY_DISTANT();
			break;
		}
	}

	vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 100;
	vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 100;

	////////////////////////////////////
	// DOMINATION VICTORY DISABLED
	////////////////////////////////////

	bool bDominationVictoryEnabled = GC.getGame().isVictoryValid((VictoryTypes) GC.getInfoTypeForString("VICTORY_DOMINATION", true));

	// NO WAR?
	if (!bDominationVictoryEnabled)
	{
		if (GET_PLAYER(ePlayer).isHuman())
		{
			if (!GC.getGame().IsAIAggressiveTowardsHumans())
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 2;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 2;
			}
		}
		else if (!GC.getGame().IsAIAggressiveMode())
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 2;
		}
	}

	////////////////////////////////////
	// SANCTIONED - Less FRIENDLY
	////////////////////////////////////

	if (pLeague != NULL && pLeague->IsTradeEmbargoed(eMyPlayer, ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= 2;
	}

	////////////////////////////////////
	// OPINION
	////////////////////////////////////

	// We double the opinion weight for additional impact!
	int iOpinionWeight = GetCachedOpinionWeight(ePlayer) * 2;

	// Using weight as +/- %: more fluid than the switch table.
	if (iOpinionWeight > /*30*/ GC.getOPINION_THRESHOLD_COMPETITOR())
	{
		// Increase
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= 100 + iWarMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= 100 + iHostileMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= 100 + iDeceptiveMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= 100 + iGuardedMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= 100 + iAfraidMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 100;

		// Decrease
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= max(100, (100 + iFriendlyMod + iOpinionWeight));	

		// Decrease Neutral
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] /=  max(100, (100 + iNeutralMod + iOpinionWeight));
	}
	else if (iOpinionWeight < /*-30*/ GC.getOPINION_THRESHOLD_FAVORABLE())
	{
		// Flip it!
		iOpinionWeight *= -1;

		// Increase
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= 100 + iFriendlyMod + iOpinionWeight;
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= 100;

		// Decrease
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_WAR] /= max(100,(100 + iWarMod + iOpinionWeight));

		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= max(100,(100 + iHostileMod + iOpinionWeight));

		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= max(100,(100 + iDeceptiveMod + iOpinionWeight));

		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= max(100,(100 + iGuardedMod + iOpinionWeight));

		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= max(100,(100 + iAfraidMod + iOpinionWeight));

		// Decrease Neutral
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] *= 100;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] /= max(100,(100 + iNeutralMod + iOpinionWeight));
	}
	else
	{
		// Increase Neutral
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] *= 100 + iNeutralMod;
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] /= 100;
	}

	////////////////////////////////////
	// AGGRESSIVE MODE MULTIPLIER
	////////////////////////////////////

	// Only war? ONLY WAR!!!!
	// (This mode is automatically enabled if only Domination and/or Time Victories are enabled.)
	if (GET_PLAYER(ePlayer).isHuman())
	{
		if (GC.getGame().IsAIAggressiveTowardsHumans())
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] *= 2;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= 2;
		}
	}
	else if (GC.getGame().IsAIAggressiveMode())
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= 2;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= 2;
	}

	//--------------------------------//
	// [PART 11: MODDER WEIGHT - %]	  //
	//--------------------------------//

	////////////////////////////////////
	// CUSTOM DLL MOD BONUS/PENALTY
	////////////////////////////////////

	// Modders can add % weight to approaches based on custom conditions (if a certain Custom Mod is #defined) here.

	////////////////////////////////////
	// LUA BONUS/PENALTY
	////////////////////////////////////

	// Modders can add % weight to approaches based on custom conditions here.
	// (to-do: add LUA hook)

	////////////////////////////////////
	// SQL BONUS/PENALTY
	////////////////////////////////////

	// Now add the percentage weight.
	if (GET_PLAYER(ePlayer).isHuman())
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] *= max(0, (100 + /*0*/ GC.getAPPROACH_NEUTRAL_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= max(0, (100 + /*0*/ GC.getAPPROACH_FRIENDLY_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= max(0, (100 + /*0*/ GC.getAPPROACH_AFRAID_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= max(0, (100 + /*0*/ GC.getAPPROACH_GUARDED_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= max(0, (100 + /*0*/ GC.getAPPROACH_DECEPTIVE_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= max(0, (100 + /*0*/ GC.getAPPROACH_HOSTILE_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= max(0, (100 + /*0*/ GC.getAPPROACH_WAR_HUMAN_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;
	}
	else
	{
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] *= max(0, (100 + /*0*/ GC.getAPPROACH_NEUTRAL_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_NEUTRAL] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] *= max(0, (100 + /*0*/ GC.getAPPROACH_FRIENDLY_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] *= max(0, (100 + /*0*/ GC.getAPPROACH_AFRAID_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] *= max(0, (100 + /*0*/ GC.getAPPROACH_GUARDED_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_GUARDED] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] *= max(0, (100 + /*0*/ GC.getAPPROACH_DECEPTIVE_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_DECEPTIVE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] *= max(0, (100 + /*0*/ GC.getAPPROACH_HOSTILE_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] /= 100;

		vApproachScores[MAJOR_CIV_APPROACH_WAR] *= max(0, (100 + /*0*/ GC.getAPPROACH_WAR_AI_PERCENT()));
		vApproachScores[MAJOR_CIV_APPROACH_WAR] /= 100;
	}

	//--------------------------------//
	// [PART 12: ZERO-OUT CONDITIONS]  //
	//--------------------------------//

	vector<int> vScratchValueOverrides(NUM_MAJOR_CIV_APPROACHES, -1);

	// No valid attack target?
	if (!GetPlayer()->GetMilitaryAI()->HavePossibleAttackTarget(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_WAR] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_HOSTILE] = 0;
	}

	////////////////////////////////////
	// BANKRUPTCY SANITY
	////////////////////////////////////

	// Don't go to war if we would go bankrupt!
	if (IsWarWouldBankruptUs(ePlayer, false))
	{
		vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_WAR] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_HOSTILE] = 0;
	}

	////////////////////////////////////
	// PEACE TREATY - have we made peace with this player recently?  If so, reduce war weight
	////////////////////////////////////

	bool bRecentPeaceTreaty = false;

	if (GetNumWarsFought(ePlayer) > 0)
	{
		int iPeaceTreatyTurn = GET_TEAM(eMyTeam).GetTurnMadePeaceTreatyWithTeam(eTeam);
		if (iPeaceTreatyTurn > -1)
		{
			int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
			int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

			if (MOD_BALANCE_CORE_DIFFICULTY)
			{
				iPeaceDampenerTurns -= GC.getGame().getHandicapInfo().getAIDifficultyBonusBase() / 2;
				if (iPeaceDampenerTurns < 11)
					iPeaceDampenerTurns = 11;
			}

			if (iTurnsSincePeace < iPeaceDampenerTurns)
				bRecentPeaceTreaty = true;

			if (bRecentPeaceTreaty && !bStrategic) // Don't zero out weight here if this is the strategic update, we don't want to make friends that we would prefer to attack
			{
				vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
				vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
				vScratchValueOverrides[MAJOR_CIV_APPROACH_WAR] = 0;
				vScratchValueOverrides[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			}
		}
	}

	////////////////////////////////////
	// Disfavor war if we can't even attack them!
	////////////////////////////////////

	if (!GET_TEAM(eMyTeam).canDeclareWar(eTeam, eMyPlayer) && !IsAtWar(ePlayer))
	{
		if (!bStrategic || !bRecentPeaceTreaty) // For the same reason, don't zero out weight here during the strategic update if we can't attack them due to a recent peace treaty
		{
			vApproachScores[MAJOR_CIV_APPROACH_WAR] = 0;
			vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
			vScratchValueOverrides[MAJOR_CIV_APPROACH_WAR] = 0;
			vScratchValueOverrides[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		}
	}

	// On the flipside, why be afraid of players who can't attack us?
	if (!GET_TEAM(eTeam).canDeclareWar(eMyTeam, ePlayer) && !IsAtWar(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_AFRAID] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_AFRAID] = 0;
	}

	////////////////////////////////////
	// RESURRECTION - Don't be HOSTILE to a player who resurrected us!
	////////////////////////////////////

	if ((bResurrectedUs && !bUntrustworthy) || bLiberatedCapital || IsCityRecentlyLiberatedBy(ePlayer))
	{
		vApproachScores[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		vScratchValueOverrides[MAJOR_CIV_APPROACH_HOSTILE] = 0;
	}

	////////////////////////////////////
	// NO FRIENDLY - Don't be friendly if we hate them!
	////////////////////////////////////

	bool bNoFriendly = IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer) || bUntrustworthy;
	bNoFriendly |= bProvokedUs && bWantsOpportunityAttack && (bEasyTarget || (GetPlayerMilitaryStrengthComparedToUs(ePlayer) < STRENGTH_STRONG && bGoodAttackTarget));

	if (bStrategic)
	{
		bNoFriendly |= eOpinion <= MAJOR_CIV_OPINION_ENEMY;

		if (bNoFriendly)
		{
			vApproachScores[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		}
	}

	//--------------------------------//
	// [PART 13: THE APPROACH CURVE]  //
	//--------------------------------//

	bool bAllZero = true;

	// Save off the scratch value for logging!
	vector<int> vApproachScoresScratch;

	if (!bStrategic)
	{
		// Let's make this a gradual process - no rapid jumping from value to value!
		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;

			int iLastTurnValue = GetPlayerApproachValue(ePlayer, eLoopApproach);
			vApproachScoresScratch.push_back(iLastTurnValue);

			// Certain circumstances call for using a different value than the actual last turn value (for the averaging)
			// This has to be done after pushing back the actual value for logging to work properly
			if (vScratchValueOverrides[(int)eLoopApproach] >= 0)
			{
				iLastTurnValue = vScratchValueOverrides[(int)eLoopApproach];
			}

			int iApproachValue = vApproachScores[(int)eLoopApproach];

			if (!bReevaluation && !bFirstUpdate)
			{
				float fAlpha = 0.10f;
				int iAverage = int(0.5f + (iApproachValue * fAlpha) + (iLastTurnValue * (1 - fAlpha)));

				// If the value changed, make sure it goes up/down by at least one
				if (iAverage == iLastTurnValue && iApproachValue != iLastTurnValue)
				{
					iAverage += (iApproachValue > iLastTurnValue) ? 1 : -1;
				}

				vApproachScores[(int)eLoopApproach] = iAverage;

				if (iAverage > 0)
					bAllZero = false;

				// Set the new average for next turn (but not if we're doing a reevaluation!).
				SetPlayerApproachValue(ePlayer, eLoopApproach, iAverage);
			}
			else
			{
				if (iApproachValue > 0)
					bAllZero = false;

				// We're re-evaluating this player (or evaluating them for the first time), so use this turn's value as the average
				SetPlayerApproachValue(ePlayer, eLoopApproach, iApproachValue);
			}
		}
	}
	else
	{
		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;
			if (vApproachScores[(int)eLoopApproach] > 0)
			{
				bAllZero = false;
				break;
			}
		}
	}

	//--------------------------------//
	// [PART 14: APPROACH SELECTION]  //
	//--------------------------------//

	MajorCivApproachTypes eApproach;

	// This vector is what we'll use to sort
	CvWeightedVector< MajorCivApproachTypes, 128 > vApproachScoresForSorting;

	// Transfer values from our normal int vector (which we need for logging) to the Weighted Vector we can sort
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;
		vApproachScoresForSorting.push_back(eLoopApproach, vApproachScores[(int)eLoopApproach]);
	}

	vApproachScoresForSorting.SortItems();

	// All at zero? Neutral is the default.
	if (bAllZero)
	{
		eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
	}
	else
	{
		eApproach = vApproachScoresForSorting.GetElement(0);
	}

	////////////////////////////////////
	// APPROACH OVERRIDES
	////////////////////////////////////

	// If this is the first time ever updating approach towards this player, let's not be hostile right off the bat - neutral is fine, though.
	if (bFirstUpdate && eApproach != MAJOR_CIV_APPROACH_NEUTRAL && eApproach != MAJOR_CIV_APPROACH_FRIENDLY)
	{
		eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
	}

	// Don't be hostile to players who are liberating our cities (if we care).
	if (IsCityRecentlyLiberatedBy(ePlayer) && eApproach == MAJOR_CIV_APPROACH_HOSTILE)
	{
		eApproach = MAJOR_CIV_APPROACH_GUARDED;
	}

	if (bNoFriendly && (eApproach == MAJOR_CIV_APPROACH_FRIENDLY || eApproach == MAJOR_CIV_APPROACH_DECEPTIVE))
	{
		eApproach = eOpinion <= MAJOR_CIV_OPINION_ENEMY ? MAJOR_CIV_APPROACH_GUARDED : MAJOR_CIV_APPROACH_NEUTRAL;
	}

	// If this was a strategic update, update the strategic approach values
	if (bFirstPass)
	{
		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{	
			MajorCivApproachTypes eLoopApproach = (MajorCivApproachTypes) iApproachLoop;
			SetPlayerStrategicApproachValue(ePlayer, eLoopApproach, vApproachScores[(int)eLoopApproach]);
		}

		SetMajorCivStrategicApproach(ePlayer, eApproach);
	}

	// Finally, update our approach
	if (!bStrategic || bReevaluation)
	{
		SetMajorCivApproach(ePlayer, eApproach);
		LogMajorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach, GetSurfaceApproach(ePlayer));
		LogApproachValueDeltas(ePlayer, &vApproachScores[0], &vApproachScoresScratch[0]);
	}

	return;
}

/// Who are our major competitors?
void CvDiplomacyAI::DoUpdateMajorCompetitors()
{
	int iNumMajorsAlive = GC.getGame().countMajorCivsAlive();
	int iDangerThreshold = GC.getGame().countMajorCivsEverAlive() * 33 / 100;
	bool bCloseToDominationVictory = IsCloseToDominationVictory();
	bool bCloseToDiploVictory = IsCloseToDiploVictory();
	bool bCloseToCultureVictory = IsCloseToCultureVictory();
	bool bCloseToScienceVictory = IsCloseToSSVictory();
	int iEra = GetPlayer()->GetCurrentEra();
	int iOurTechs = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();

	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	int iMyVotes = (pLeague != NULL) ? pLeague->CalculateStartingVotesForMember(GetID()) : 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(ePlayer) || !GET_PLAYER(ePlayer).isMajorCiv())
		{
			SetMajorCompetitor(ePlayer, false);
			continue;
		}

		if (iNumMajorsAlive == 2 && IsCompetingForVictory())
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (GET_PLAYER(ePlayer).GetFractionOriginalCapitalsUnderControl() >= iDangerThreshold)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (GetPlayerNumMajorsConquered(ePlayer) >= iDangerThreshold)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (IsEndgameAggressiveTo(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (IsNukedBy(ePlayer) || GET_PLAYER(ePlayer).getNumNukeUnits() > 0)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		// Vassals aren't major competitors 99% of the time.
		if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
		{
			SetMajorCompetitor(ePlayer, false);
			continue;
		}

		if (GET_PLAYER(ePlayer).IsHasLostCapital())
		{
			SetMajorCompetitor(ePlayer, false);
			continue;
		}

		if (bCloseToDominationVictory)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (IsUntrustworthy(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (IsPlayerOpposingIdeology(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (IsPlayerRecklessExpander(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}
		
		if (IsPlayerWonderSpammer(ePlayer))
		{
			SetMajorCompetitor(ePlayer, true);
			continue;
		}

		if (pLeague != NULL)
		{
			// Is this our primary League competitor?
			if (GetPrimeLeagueCompetitor() == ePlayer)
			{
				SetMajorCompetitor(ePlayer, true);
				continue;
			}
		}

		if (IsCompetingForVictory())
		{
			if (iEra >= 2 && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION)
			{
				if (GET_PLAYER(ePlayer).GetNumCapitalCities() > 0)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}

				if (GetLandDisputeLevel(ePlayer) > DISPUTE_LEVEL_NONE)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}

				if (GetPlayer()->GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}
			}

			if ((iEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC) || bCloseToDiploVictory)
			{
				if (IsMinorCivTroublemaker(ePlayer, true))
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}
				if (pLeague != NULL)
				{
					// More votes than us and aligned against us?
					if (pLeague->CalculateStartingVotesForMember(ePlayer) > iMyVotes)
					{
						if (GetPlayer()->GetLeagueAI()->EvaluateAlignment(ePlayer) < CvLeagueAI::ALIGNMENT_NEUTRAL)
						{
							SetMajorCompetitor(ePlayer, true);
							continue;
						}
					}
				}
			}
			
			if ((iEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_CULTURE) || bCloseToCultureVictory)
			{
				if (GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}

				if (GetPolicyBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}
				
				if (GetPlayer()->GetCulture()->GetCivLowestInfluence(false) == ePlayer)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}
			
				if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(GetID()) >= INFLUENCE_LEVEL_POPULAR)
				{
					if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(GetID()) >= INFLUENCE_LEVEL_INFLUENTIAL || GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(GetID()) != INFLUENCE_TREND_FALLING)
					{
						SetMajorCompetitor(ePlayer, true);
						continue;
					}
				}
			
				if (iEra >= 5)
				{
					if (GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer) <= INFLUENCE_LEVEL_FAMILIAR || (GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer) == INFLUENCE_LEVEL_POPULAR && GetPlayer()->GetCulture()->GetInfluenceTrend(ePlayer) == INFLUENCE_TREND_FALLING))
					{
						SetMajorCompetitor(ePlayer, true);
						continue;
					}
				}
				else
				{
					if (GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer) <= INFLUENCE_LEVEL_EXOTIC || (GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer) == INFLUENCE_LEVEL_FAMILIAR && GetPlayer()->GetCulture()->GetInfluenceTrend(ePlayer) == INFLUENCE_TREND_FALLING))
					{
						SetMajorCompetitor(ePlayer, true);
						continue;
					}
				}
			}
			
			if ((iEra >= 3 && GetVictoryFocus() == VICTORY_FOCUS_SCIENCE) || bCloseToScienceVictory)
			{
				if (GetTechBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}

				int iTheirTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
				
				if (iEra >= 6 && (iTheirTechs > iOurTechs))
				{
					SetMajorCompetitor(ePlayer, true);
					continue;
				}
			}
		}

		SetMajorCompetitor(ePlayer, false);
		continue;
	}
}

/// Plan our relationships with other major civilizations
void CvDiplomacyAI::DoRelationshipPairing()
{
	if (GetPlayer()->isHuman() || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
		return;

	vector<PlayerTypes> vValidPlayers;

	// STEP 1: Identify our prime league competitor
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	bool bGoingForDiploVictory = IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC;
	bool bCloseToDiploVictory = IsCloseToDiploVictory();
	bool bPrimeIsCloseToWinning = false;
	int iMyVotes = pLeague != NULL ? pLeague->CalculateStartingVotesForMember(GetID()) : 0;
	PlayerTypes ePrimeLeagueCompetitor = NO_PLAYER;
	int iHighestVotes = iMyVotes;
	CvLeagueAI::AlignmentLevels eWorstAlignment = CvLeagueAI::ALIGNMENT_FRIEND;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(eLoopPlayer))
			continue;

		if (!GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		// Add them to the evaluation list for later
		vValidPlayers.push_back(eLoopPlayer);

		if (WasResurrectedBy(eLoopPlayer))
			continue;

		if (IsVassal(eLoopPlayer) && GetVassalTreatmentLevel(eLoopPlayer) <= VASSAL_TREATMENT_DISAGREE)
			continue;

		if (pLeague != NULL)
		{
			bool bTheyAreCloseToWinning = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsCloseToDiploVictory();

			if (IsMaster(eLoopPlayer) && !bTheyAreCloseToWinning)
				continue;

			if (IsCompetingForVictory())
			{
				if (bTheyAreCloseToWinning)
				{
					if (!bPrimeIsCloseToWinning)
					{
						ePrimeLeagueCompetitor = eLoopPlayer;
						bPrimeIsCloseToWinning = true;
						iHighestVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);
					}
					else
					{
						int iVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);
						int iPrimeVotes = pLeague->CalculateStartingVotesForMember(ePrimeLeagueCompetitor);

						if (iVotes > iPrimeVotes)
						{
							ePrimeLeagueCompetitor = eLoopPlayer;
							iHighestVotes = iVotes;
						}
						// Resolve any ties here using opinion, not league alignment...better measure of who would we rather to win
						else if (iVotes == iPrimeVotes)
						{
							if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(ePrimeLeagueCompetitor))
							{
								ePrimeLeagueCompetitor = eLoopPlayer;
								iHighestVotes = iVotes;
							}
						}
					}
					continue;
				}
				// Don't evaluate alignment or vote count if someone else is close to winning, and we're competing with them
				else if (bPrimeIsCloseToWinning)
				{
					continue;
				}
			}

			// If we're aiming for a diplomatic victory, we evaluate by highest vote total first, then by worst alignment
			if (bGoingForDiploVictory || bCloseToDiploVictory)
			{
				int iVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);
				if (iVotes > iHighestVotes)
				{
					iHighestVotes = iVotes;
					ePrimeLeagueCompetitor = eLoopPlayer;
					eWorstAlignment = CvLeagueAI::ALIGNMENT_FRIEND;
				}
				// Equal votes...but do they have a worse alignment?
				else if (iVotes == iHighestVotes)
				{
					CvLeagueAI::AlignmentLevels eAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(eLoopPlayer, true);

					if (ePrimeLeagueCompetitor != NO_PLAYER)
					{
						CvLeagueAI::AlignmentLevels ePrimeAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(ePrimeLeagueCompetitor, true);

						if (eAlignment < eWorstAlignment)
						{
							if (eAlignment < ePrimeAlignment)
							{
								ePrimeLeagueCompetitor = eLoopPlayer;
								eWorstAlignment = eAlignment;
							}
							// Another tie? Resolve it using opinion weight.
							else if (eAlignment == ePrimeAlignment)
							{
								if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(ePrimeLeagueCompetitor))
								{
									ePrimeLeagueCompetitor = eLoopPlayer;
								}
							}
						}
					}
					else if (eAlignment < eWorstAlignment)
					{
						ePrimeLeagueCompetitor = eLoopPlayer;
						eWorstAlignment = eAlignment;
					}
				}
			}
			// Otherwise, we evaluate by worst alignment first, then by highest vote total
			else
			{
				CvLeagueAI::AlignmentLevels eAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(eLoopPlayer, true);
				if (eAlignment < eWorstAlignment)
				{
					eWorstAlignment = eAlignment;
					ePrimeLeagueCompetitor = eLoopPlayer;
					iHighestVotes = iMyVotes;
				}
				// Equal alignment...but do they have more votes?
				else if (eAlignment == eWorstAlignment)
				{
					int iVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);

					if (ePrimeLeagueCompetitor != NO_PLAYER)
					{
						int iPrimeVotes = pLeague->CalculateStartingVotesForMember(ePrimeLeagueCompetitor);

						if (iVotes > iHighestVotes)
						{
							if (iVotes > iPrimeVotes)
							{
								ePrimeLeagueCompetitor = eLoopPlayer;
								iHighestVotes = iVotes;
							}
							// Another tie? Resolve it using opinion weight.
							else if (iVotes == iPrimeVotes)
							{
								if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(ePrimeLeagueCompetitor))
								{
									ePrimeLeagueCompetitor = eLoopPlayer;
								}
							}
						}
					}
					else if (iVotes > iHighestVotes)
					{
						ePrimeLeagueCompetitor = eLoopPlayer;
						iHighestVotes = iVotes;
					}
				}
			}
		}
	}

	SetPrimeLeagueCompetitor(ePrimeLeagueCompetitor);


	// STEP 2: Who is our biggest competitor?
	PlayerTypes eBiggestCompetitor = NO_PLAYER;
	int iCompetitorPriority = 0;
	vector<PlayerTypes> vPotentialCompetitors;

	for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
	{
		if (WasResurrectedBy(*it))
			continue;

		if (IsMajorCompetitor(*it) || IsEarlyGameCompetitor(*it))
		{
			vPotentialCompetitors.push_back(*it);
		}
		else if (GetMajorCivStrategicApproach(*it) < MAJOR_CIV_APPROACH_FRIENDLY)
		{
			vPotentialCompetitors.push_back(*it);
		}
		else if (IsVassal(*it) && GetVassalTreatmentLevel(*it) > VASSAL_TREATMENT_DISAGREE)
		{
			vPotentialCompetitors.push_back(*it);
		}
	}

	// First let's examine any conditions which make some players the greatest competitors.
	for (std::vector<PlayerTypes>::iterator it = vPotentialCompetitors.begin(); it != vPotentialCompetitors.end(); it++)
	{
		PlayerTypes eLoopPlayer = GET_PLAYER(*it).GetID();
		int iPriority = 0;
		bool bIgnoreCityConquests = false;

		if (IsVassal(eLoopPlayer) && !IsVoluntaryVassalage(eLoopPlayer))
		{
			bIgnoreCityConquests = true;
		}

		// They captured our capital, currently? Biggest competitor!
		if (IsCapitalCapturedBy(eLoopPlayer, true, false) && !bIgnoreCityConquests)
		{
			eBiggestCompetitor = eLoopPlayer;
			iCompetitorPriority = 1;
		}
		// They're close to conquering the whole planet?
		else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsCloseToDominationVictory())
		{
			iPriority = 2;

			if ((iCompetitorPriority == 0) || (iPriority < iCompetitorPriority))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 2;
			}
		}
		// We're mad because they're close to winning?
		else if (IsEndgameAggressiveTo(eLoopPlayer) && GetMajorCivStrategicApproach(eLoopPlayer) < MAJOR_CIV_APPROACH_NEUTRAL)
		{
			iPriority = 3;

			if ((iCompetitorPriority == 0) || (iPriority < iCompetitorPriority))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 3;
			}
			else if (iPriority == iCompetitorPriority)
			{
				// Okay, so we're endgame aggressive to two people...
				// We hate the people who are going for the same victory condition as us more.
				if (GetVictoryDisputeLevel(eLoopPlayer) > GetVictoryDisputeLevel(eBiggestCompetitor))
				{
					eBiggestCompetitor = eLoopPlayer;
				}
				// Same victory dispute level? Then we hate whichever one is closer to us.
				else if (GetVictoryDisputeLevel(eLoopPlayer) == GetVictoryDisputeLevel(eBiggestCompetitor))
				{
					if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) > GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						eBiggestCompetitor = eLoopPlayer;
					}
					// Same proximity? Then we hate whichever one has the worst opinion.
					else if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) == GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(eBiggestCompetitor))
						{
							eBiggestCompetitor = eLoopPlayer;
						}
					}
				}
			}
		}
		// We're mad because they captured our Holy City, currently?
		else if (IsHolyCityCapturedBy(eLoopPlayer, true, false) && !bIgnoreCityConquests)
		{
			iPriority = 4;

			if ((iCompetitorPriority == 0) || (iPriority < iCompetitorPriority))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 4;
			}
		}
		// We're mad because they captured our capital, previously?
		else if (IsCapitalCapturedBy(eLoopPlayer) && !bIgnoreCityConquests)
		{
			iPriority = 5;

			if ((iCompetitorPriority == 0) || (iPriority < iCompetitorPriority))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 5;
			}
			// Multiple players on the same team can have this penalty
			else if (iPriority == iCompetitorPriority)
			{
				// Pick whoever actually did the deed
				if (IsPlayerCapturedCapital(eLoopPlayer) && !IsPlayerCapturedCapital(eBiggestCompetitor))
				{
					eBiggestCompetitor = eLoopPlayer;
				}
				// They both did at different times? Go with whoever is the closest; failing that, whoever we hate the most
				else
				{
					if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) > GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						eBiggestCompetitor = eLoopPlayer;
					}
					else if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) == GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(eBiggestCompetitor))
						{
							eBiggestCompetitor = eLoopPlayer;
						}
					}
				}
			}
		}
		// We're mad because they captured our Holy City, previously?
		else if (IsHolyCityCapturedBy(eLoopPlayer) && !bIgnoreCityConquests)
		{
			iPriority = 6;

			if ((iCompetitorPriority == 0) || (iPriority < iCompetitorPriority))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 6;
			}
			// Multiple players on the same team can have this penalty
			else if (iPriority == iCompetitorPriority)
			{
				// Pick whoever actually did the deed
				if (IsPlayerCapturedHolyCity(eLoopPlayer) && !IsPlayerCapturedHolyCity(eBiggestCompetitor))
				{
					eBiggestCompetitor = eLoopPlayer;
				}
				// They both did at different times? Go with whoever is the closest; failing that, whoever we hate the most
				else
				{
					if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) > GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						eBiggestCompetitor = eLoopPlayer;
					}
					else if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) == GetPlayer()->GetProximityToPlayer(eBiggestCompetitor))
					{
						if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(eBiggestCompetitor))
						{
							eBiggestCompetitor = eLoopPlayer;
						}
					}
				}
			}
		}
		// They're our master and they're treating us poorly?
		else if (IsVassal(eLoopPlayer) && GetVassalTreatmentLevel(eLoopPlayer) > VASSAL_TREATMENT_DISAGREE)
		{
			iPriority = 7;

			if ((iCompetitorPriority == 0))
			{
				eBiggestCompetitor = eLoopPlayer;
				iCompetitorPriority = 7;
			}
			// Multiple masters? Which one is treating us worse?
			else if (iPriority == iCompetitorPriority)
			{
				if (GetVassalTreatmentLevel(eLoopPlayer) > GetVassalTreatmentLevel(eBiggestCompetitor))
				{
					eBiggestCompetitor = eLoopPlayer;
				}
				// Tied? Go with whoever we hate the most.
				else if (GetVassalTreatmentLevel(eLoopPlayer) == GetVassalTreatmentLevel(eBiggestCompetitor))
				{
					if (GetCachedOpinionWeight(eLoopPlayer) > GetCachedOpinionWeight(eBiggestCompetitor))
					{
						eBiggestCompetitor = eLoopPlayer;
					}
				}
			}
		}
	}

	// Haven't found a biggest competitor yet? Now we start sorting by approach.
	if (eBiggestCompetitor == NO_PLAYER)
	{
		vector<PlayerTypes> vWarExclusions;
		vector<PlayerTypes> vHostileExclusions;
		vector<PlayerTypes> vAfraidExclusions;
		vector<PlayerTypes> vGuardedExclusions;
		vector<PlayerTypes> vDeceptiveExclusions;

		PlayerTypes eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);
		while (eCandidate != NO_PLAYER && eBiggestCompetitor == NO_PLAYER)
		{
			if (GetMajorCivStrategicApproach(eCandidate) < MAJOR_CIV_APPROACH_FRIENDLY && !WasResurrectedBy(eCandidate))
			{
				eBiggestCompetitor = eCandidate;
			}
			else
			{
				vWarExclusions.push_back(eCandidate);
				eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);
			}
		}

		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_HOSTILE, vHostileExclusions);
		while (eCandidate != NO_PLAYER && eBiggestCompetitor == NO_PLAYER)
		{
			if (GetMajorCivStrategicApproach(eCandidate) < MAJOR_CIV_APPROACH_FRIENDLY && !WasResurrectedBy(eCandidate))
			{
				eBiggestCompetitor = eCandidate;
			}
			else
			{
				vHostileExclusions.push_back(eCandidate);
				eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_HOSTILE, vHostileExclusions);
			}
		}

		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_AFRAID, vAfraidExclusions);
		while (eCandidate != NO_PLAYER && eBiggestCompetitor == NO_PLAYER)
		{
			if (GetMajorCivStrategicApproach(eCandidate) < MAJOR_CIV_APPROACH_FRIENDLY && !WasResurrectedBy(eCandidate))
			{
				eBiggestCompetitor = eCandidate;
			}
			else
			{
				vAfraidExclusions.push_back(eCandidate);
				eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_AFRAID, vAfraidExclusions);
			}
		}

		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_GUARDED, vGuardedExclusions);
		while (eCandidate != NO_PLAYER && eBiggestCompetitor == NO_PLAYER)
		{
			if (GetMajorCivStrategicApproach(eCandidate) < MAJOR_CIV_APPROACH_FRIENDLY && !WasResurrectedBy(eCandidate))
			{
				eBiggestCompetitor = eCandidate;
			}
			else
			{
				vGuardedExclusions.push_back(eCandidate);
				eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_GUARDED, vGuardedExclusions);
			}
		}

		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_DECEPTIVE, vDeceptiveExclusions);
		while (eCandidate != NO_PLAYER && eBiggestCompetitor == NO_PLAYER)
		{
			if (GetMajorCivStrategicApproach(eCandidate) < MAJOR_CIV_APPROACH_FRIENDLY && !WasResurrectedBy(eCandidate))
			{
				eBiggestCompetitor = eCandidate;
			}
			else
			{
				vDeceptiveExclusions.push_back(eCandidate);
				eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_DECEPTIVE, vDeceptiveExclusions);
			}
		}
	}

	SetBiggestCompetitor(eBiggestCompetitor);


	// STEP 3: Select our friends and DPs...this is handled in DoUpdatePlanningExchanges(), so we'll call that now
	DoUpdatePlanningExchanges();


	// STEP 4: Select our strategic trade partners
	bool bCloseToConquest = IsCloseToDominationVictory();
	bool bGoingForConquest = IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION;
	PolicyBranchTypes eIndustry = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_COMMERCE", true);
	bool bTradeBonus = GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eIndustry);
	bTradeBonus |= GetPlayer()->GetPlayerTraits()->IsImportsCountTowardsMonopolies();

	for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
	{
		PlayerTypes eLoopPlayer = GET_PLAYER(*it).GetID();

		if (IsAtWar(eLoopPlayer) || IsWantsSneakAttack(eLoopPlayer) || IsArmyInPlaceForAttack(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		if (GetDemandTargetPlayer() == eLoopPlayer)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		if (GetGlobalCoopWarAgainstState(eLoopPlayer) >= COOP_WAR_STATE_PREPARING)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		if (IsUntrustworthy(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// Sanctioned?
		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
		if (pLeague != NULL && pLeague->IsTradeEmbargoed(GetID(), eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// Resurrector?
		if (WasResurrectedBy(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		// Our master?
		if (IsVassal(eLoopPlayer))
		{
			if (IsVoluntaryVassalage(eLoopPlayer) && GetVassalTreatmentLevel(eLoopPlayer) >= VASSAL_TREATMENT_DISAGREE)
			{
				SetStrategicTradePartner(eLoopPlayer, true);
				continue;
			}
			else if (GetVassalTreatmentLevel(eLoopPlayer) == VASSAL_TREATMENT_CONTENT)
			{
				SetStrategicTradePartner(eLoopPlayer, true);
				continue;
			}
		}

		if (GetVictoryDisputeLevel(eLoopPlayer) == DISPUTE_LEVEL_FIERCE)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}
		
		if (GetVictoryBlockLevel(eLoopPlayer) == BLOCK_LEVEL_FIERCE)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}
		
		if (IsEndgameAggressiveTo(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// Vassals are usually strategic trade partners.
		if (IsMaster(eLoopPlayer))
		{
			if (bGoingForConquest || bCloseToConquest)
			{
				if (GET_PLAYER(eLoopPlayer).GetCapitalConqueror() != NO_PLAYER)
				{
					SetStrategicTradePartner(eLoopPlayer, true);
				}
				else
				{
					SetStrategicTradePartner(eLoopPlayer, false);
				}
			}
			else
			{
				SetStrategicTradePartner(eLoopPlayer, true);
			}
			continue;
		}

		if (GetNumTimesTheyPlottedAgainstUs(eLoopPlayer) > 0)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// Not our biggest competitors!
		if (eBiggestCompetitor == eLoopPlayer || ePrimeLeagueCompetitor == eLoopPlayer)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// Are we going for conquest? Check land dispute.
		if ((bGoingForConquest && !GetPlayer()->IsVassalOfSomeone()) || bCloseToConquest)
		{
			if (GetLandDisputeLevel(eLoopPlayer) > DISPUTE_LEVEL_WEAK)
			{
				SetStrategicTradePartner(eLoopPlayer, false);
				continue;
			}
		}

		// Are we going for diplo victory? Check minor civ dispute.
		if (bGoingForDiploVictory || bCloseToDiploVictory)
		{
			if (bCloseToDiploVictory)
			{
				if (IsMinorCivTroublemaker(eLoopPlayer, true))
				{
					SetStrategicTradePartner(eLoopPlayer, false);
					continue;
				}
			}
			else
			{
				if (IsMinorCivTroublemaker(eLoopPlayer, false))
				{
					SetStrategicTradePartner(eLoopPlayer, false);
					continue;
				}
			}
		}

		// Our most valuable friend and ally make good trade partners!
		if (GetMostValuableFriend() == eLoopPlayer || GetMostValuableAlly() == eLoopPlayer)
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		// Liberator?
		if (IsPlayerLiberatedCapital(eLoopPlayer) || IsPlayerLiberatedHolyCity(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		// If we're a vassal, pretty much everyone is a good trade partner
		if (GetPlayer()->IsVassalOfSomeone())
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		// If we have a bonus to trade and this isn't a major competitor, bump up trade value.
		if (bTradeBonus && !IsMajorCompetitor(eLoopPlayer))
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		// Must have at least equal economic strength
		if (GetPlayerEconomicStrengthComparedToUs(eLoopPlayer) < STRENGTH_AVERAGE)
		{
			SetStrategicTradePartner(eLoopPlayer, false);
			continue;
		}

		// If we're going for conquest or diplo victory, bump up trade value.
		if (bGoingForConquest || bCloseToConquest || bGoingForDiploVictory || bCloseToDiploVictory)
		{
			SetStrategicTradePartner(eLoopPlayer, true);
			continue;
		}

		SetStrategicTradePartner(eLoopPlayer, false);
	}
}

/// Updates our desire to make Declarations of Friendship, Defensive Pacts and Research Agreements with all players
void CvDiplomacyAI::DoUpdatePlanningExchanges()
{
	if (GetPlayer()->isHuman() || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
		return;

	vector<PlayerTypes> vValidPlayers;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		bool bValid = true;

		if (!IsPlayerValid(eLoopPlayer))
		{
			bValid = false;
		}

		if (bValid)
		{
			vValidPlayers.push_back(eLoopPlayer);
		}
		else
		{
			SetWantsDoFWithPlayer(eLoopPlayer, false);
			SetWantsDefensivePactWithPlayer(eLoopPlayer, false);
			SetWantsResearchAgreementWithPlayer(eLoopPlayer, false);

			if (IsDoFAccepted(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isAlive())
			{
				SetWantsToEndDoFWithPlayer(eLoopPlayer, true);
			}
			else
			{
				SetWantsToEndDoFWithPlayer(eLoopPlayer, false);
			}

			if (IsHasDefensivePact(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isAlive())
			{
				SetWantsToEndDefensivePactWithPlayer(eLoopPlayer, true);
			}
			else
			{
				SetWantsToEndDefensivePactWithPlayer(eLoopPlayer, false);
			}
		}
	}

	vector<PlayerTypes> vAcceptableFriends;

	for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
	{
		if (IsAtWar(*it))
			continue;

		// Skip over our master and all vassals
		if (IsVassal(*it) || GET_PLAYER(*it).IsVassalOfSomeone())
			continue;

		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(*it);
		MajorCivApproachTypes eApproach = GetMajorCivApproach(*it);
		DoFLevelTypes eDoFLevel = GetDoFType(*it);
		bool bLiberator = (WasResurrectedBy(*it) || IsPlayerLiberatedCapital(*it) || IsPlayerLiberatedHolyCity(*it)) && !IsUntrustworthy(*it) && eOpinion > MAJOR_CIV_OPINION_ENEMY;

		// Don't befriend our biggest competitor!
		if (GetBiggestCompetitor() == GET_PLAYER(*it).GetID() || GetPrimeLeagueCompetitor() == GET_PLAYER(*it).GetID())
		{
			// Correction: If we've worked together before and we're on fairly good terms, let's at least consider it...
			if ((eDoFLevel < DOF_TYPE_FRIENDS && eOpinion < MAJOR_CIV_OPINION_FRIEND) || (eDoFLevel >= DOF_TYPE_FRIENDS && eOpinion < MAJOR_CIV_OPINION_NEUTRAL))
			{
				if (!bLiberator)
					continue;
			}
			// Don't befriend our prime league competitor unless we really like them.
			if (GetPrimeLeagueCompetitor() == GET_PLAYER(*it).GetID() && !bLiberator)
			{
				if (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC && GetMajorCivOpinion(*it) < MAJOR_CIV_OPINION_ALLY)
				{
					continue;
				}
				else if (GetMajorCivOpinion(*it) < MAJOR_CIV_OPINION_FRIEND)
				{
					continue;
				}
			}
			// Too much aggression in this relationship...
			if ((eApproach <= MAJOR_CIV_APPROACH_GUARDED && eApproach != MAJOR_CIV_APPROACH_DECEPTIVE) || GetVictoryDisputeLevel(*it) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(*it) == BLOCK_LEVEL_FIERCE || GetWarmongerThreat(*it) >= THREAT_SEVERE || IsEndgameAggressiveTo(*it))
			{
				continue;
			}
			// Being nasty to us
			if (GetNumTimesTheyPlottedAgainstUs(*it) > 0 || GetNumTimesPerformedCoupAgainstUs(*it) > 0 || GetCoopWarScore(*it) < -1 || GetRecentAssistValue(*it) > 75 || GetNumTimesCultureBombed(*it) > 0)
			{
				continue;
			}
			// Broken/ignored promises
			if (GetPlayerExpansionPromiseState(*it) >= PROMISE_STATE_IGNORED || GetPlayerBorderPromiseState(*it) >= PROMISE_STATE_IGNORED || GetPlayerSpyPromiseState(*it) >= PROMISE_STATE_IGNORED || GetPlayerBullyCityStatePromiseState(*it) >= PROMISE_STATE_IGNORED)
			{
				continue;
			}
			if (GetPlayerAttackCityStatePromiseState(*it) >= PROMISE_STATE_IGNORED || GetPlayerNoConvertPromiseState(*it) >= PROMISE_STATE_IGNORED || GetPlayerNoDiggingPromiseState(*it) >= PROMISE_STATE_IGNORED)
			{
				continue;
			}
			// Backstabber!
			if (IsUntrustworthy(*it))
			{
				continue;
			}
		}

		// Planning war?
		if (AvoidExchangesWithPlayer(*it))
		{
			continue;
		}

		// This checks if they're otherwise okay to befriend
		if (IsGoodChoiceForDoF(*it) && GetMajorCivStrategicApproach(*it) > MAJOR_CIV_APPROACH_GUARDED)
		{
			vAcceptableFriends.push_back(*it);
		}
	}

	for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
	{
		// They're our master or someone's vassal? Okay to befriend if approach is FRIENDLY or NEUTRAL
		if (IsVassal(*it) || GET_PLAYER(*it).IsVassalOfSomeone())
		{
			if (GetMajorCivStrategicApproach(*it) >= MAJOR_CIV_APPROACH_FRIENDLY)
			{
				SetWantsDoFWithPlayer(*it, true);
			}
			else
			{
				if (IsDoFAccepted(*it) && IsEndDoFAcceptable(*it))
				{
					SetWantsToEndDoFWithPlayer(*it, true);
				}
				else
				{
					SetWantsToEndDoFWithPlayer(*it, false);
				}

				SetWantsDoFWithPlayer(*it, false);
			}
			continue;
		}

		// Currently friends?
		if (IsDoFAccepted(*it))
		{
			// Uh oh! Do we want to end this friendship right away or let it expire?
			if (std::find(vAcceptableFriends.begin(), vAcceptableFriends.end(), *it) == vAcceptableFriends.end())
			{
				if (IsEndDoFAcceptable(*it))
				{
					SetWantsToEndDoFWithPlayer(*it, true);
				}
				else
				{
					SetWantsToEndDoFWithPlayer(*it, false);
				}

				SetWantsDoFWithPlayer(*it, false);
			}
			else
			{
				SetWantsDoFWithPlayer(*it, true);
				SetWantsToEndDoFWithPlayer(*it, false);
			}
		}
		// Reset DoF desire
		else
		{
			SetWantsDoFWithPlayer(*it, false);
			SetWantsToEndDoFWithPlayer(*it, false);
		}
	}

	PlayerTypes eMostValuableFriend = NO_PLAYER;
	int iFriends = GetNumDoF(true);
	int iBaseFriendLimit = 2;

	if (GetPlayer()->GetDoFToVotes() > 0)
	{
		iBaseFriendLimit = MAX_MAJOR_CIVS;
	}
	else if (GetDoFWillingness() > 8)
	{
		iBaseFriendLimit = 4;
	}
	else if (GetDoFWillingness() > 6)
	{
		iBaseFriendLimit = 3;
	}

	// Scale friend limit with map size
	int iFriendLimit = iBaseFriendLimit * vValidPlayers.size() / 8;
	iFriendLimit = max(iBaseFriendLimit, iFriendLimit);

	// Now examine all acceptable friends and decide who we want to befriend.
	vector<PlayerTypes> vFriendlyExclusions;
	vector<PlayerTypes> vNeutralExclusions;
	vector<PlayerTypes> vAfraidExclusions;
	bool bLimitReached = false;
	bool bBestFriendPossible = vAcceptableFriends.size() > 1;

	PlayerTypes eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_FRIENDLY, vFriendlyExclusions);
	while (eCandidate != NO_PLAYER)
	{
		if (std::find(vAcceptableFriends.begin(), vAcceptableFriends.end(), eCandidate) != vAcceptableFriends.end())
		{
			if (eMostValuableFriend == NO_PLAYER && bBestFriendPossible)
			{
				eMostValuableFriend = eCandidate;
			}
			if (!IsDoFAccepted(eCandidate))
			{
				if (iFriends < iFriendLimit)
				{
					SetWantsDoFWithPlayer(eCandidate, true);
					iFriends++;

					if (iFriends >= iFriendLimit && (eMostValuableFriend != NO_PLAYER || !bBestFriendPossible))
					{
						bLimitReached = true;
						break;
					}
				}
			}
		}

		vFriendlyExclusions.push_back(eCandidate);
		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_FRIENDLY, vFriendlyExclusions);
	}

	eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_NEUTRAL, vNeutralExclusions);
	while (eCandidate != NO_PLAYER && !bLimitReached)
	{
		if (std::find(vAcceptableFriends.begin(), vAcceptableFriends.end(), eCandidate) != vAcceptableFriends.end())
		{
			if (eMostValuableFriend == NO_PLAYER && bBestFriendPossible)
			{
				eMostValuableFriend = eCandidate;
			}
			if (!IsDoFAccepted(eCandidate))
			{
				if (iFriends < iFriendLimit)
				{
					SetWantsDoFWithPlayer(eCandidate, true);
					iFriends++;

					if (iFriends >= iFriendLimit && (eMostValuableFriend != NO_PLAYER || !bBestFriendPossible))
					{
						bLimitReached = true;
						break;
					}
				}
			}
		}

		vNeutralExclusions.push_back(eCandidate);
		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_NEUTRAL, vNeutralExclusions);
	}

	eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_AFRAID, vAfraidExclusions);
	while (eCandidate != NO_PLAYER && !bLimitReached)
	{
		if (std::find(vAcceptableFriends.begin(), vAcceptableFriends.end(), eCandidate) != vAcceptableFriends.end())
		{
			if (eMostValuableFriend == NO_PLAYER && bBestFriendPossible)
			{
				eMostValuableFriend = eCandidate;
			}
			if (!IsDoFAccepted(eCandidate))
			{
				if (iFriends < iFriendLimit)
				{
					SetWantsDoFWithPlayer(eCandidate, true);
					iFriends++;

					if (iFriends >= iFriendLimit && (eMostValuableFriend != NO_PLAYER || !bBestFriendPossible))
					{
						bLimitReached = true;
						break;
					}
				}
			}
		}

		vAfraidExclusions.push_back(eCandidate);
		eCandidate = GetPlayerWithHighestStrategicApproachValue(MAJOR_CIV_APPROACH_AFRAID, vAfraidExclusions);
	}

	SetMostValuableFriend(eMostValuableFriend);
	PlayerTypes eMostValuableAlly = NO_PLAYER;

	// Now let's examine who we want to form Defensive Pacts with!
	if (GET_TEAM(GetTeam()).isDefensivePactTradingAllowed())
	{
		vector<PlayerTypes> vAcceptableDefensePacts;

		// If we're trying to win World Congress votes, use a less stringent evaluation
		if (GetPlayer()->GetDefensePactsToVotes() > 0)
		{
			for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
			{
				if (IsGoodChoiceForDefensivePact(*it))
				{
					vAcceptableDefensePacts.push_back(*it);
				}
			}
		}
		// Normally, only consider acceptable friend choices for Defensive Pacts
		// And we must also have a Declaration of Friendship already, that we aren't planning on ending
		else
		{
			for (std::vector<PlayerTypes>::iterator it = vAcceptableFriends.begin(); it != vAcceptableFriends.end(); it++)
			{
				if (!IsDoFAccepted(*it))
					continue;

				if (!IsWantsDoFWithPlayer(*it))
					continue;

				if (IsWantsToEndDoFWithPlayer(*it))
					continue;

				if (IsGoodChoiceForDefensivePact(*it))
				{
					vAcceptableDefensePacts.push_back(*it);
				}
			}
		}

		// First we see if there's any Defensive Pacts we want to end!
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			// Do we currently have a DP?
			if (IsHasDefensivePact(*it))
			{
				// Uh oh!
				if (std::find(vAcceptableDefensePacts.begin(), vAcceptableDefensePacts.end(), *it) == vAcceptableDefensePacts.end())
				{
					SetWantsDefensivePactWithPlayer(*it, false);
					SetWantsToEndDefensivePactWithPlayer(*it, true);
				}
				else
				{
					SetWantsDefensivePactWithPlayer(*it, true);
					SetWantsToEndDefensivePactWithPlayer(*it, false);
				}
			}
			// Reset DP desire
			else
			{
				SetWantsDefensivePactWithPlayer(*it, false);
				SetWantsToEndDefensivePactWithPlayer(*it, false);
			}
		}

		int iNumDefensePacts = GetNumDefensePacts();
		int iDefensePactLimit = 2;

		if (GetPlayer()->GetDefensePactsToVotes() > 0)
		{
			iDefensePactLimit = MAX_MAJOR_CIVS;
		}

		// Scale limit with map size, but sparingly
		iDefensePactLimit += (int)(vValidPlayers.size() / 10);

		// If we can make a Defensive Pact with our most valuable friend and they're a good choice, always do so.
		if (eMostValuableFriend != NO_PLAYER && IsDoFAccepted(eMostValuableFriend))
		{
			if (std::find(vAcceptableDefensePacts.begin(), vAcceptableDefensePacts.end(), eMostValuableFriend) != vAcceptableDefensePacts.end())
			{
				if (!IsHasDefensivePact(eMostValuableFriend))
				{
					if (iNumDefensePacts < iDefensePactLimit)
					{
						vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(eCandidate).getTeam()).getPlayers();

						for (size_t i=0; i<vTheirTeam.size(); i++)
						{
							if (!IsPlayerValid(vTheirTeam[i]))
								continue;

							SetWantsDefensivePactWithPlayer(vTheirTeam[i], true);
							iNumDefensePacts++;
						}
					}
				}
				else
				{
					vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(eCandidate).getTeam()).getPlayers();

					for (size_t i=0; i<vTheirTeam.size(); i++)
					{
						if (!IsPlayerValid(vTheirTeam[i]))
							continue;

						SetWantsDefensivePactWithPlayer(vTheirTeam[i], true);
					}
				}
			}
		}

		// Okay, now let's choose the most valuable DPs
		PlayerTypes eMostValuableAlly = NO_PLAYER;
		vector<PlayerTypes> vDPExclusions;

		eCandidate = GetHighestScoringDefensivePact(vAcceptableDefensePacts, vDPExclusions);
		while (eCandidate != NO_PLAYER)
		{
			if (eMostValuableAlly == NO_PLAYER && bBestFriendPossible)
			{
				eMostValuableAlly = eCandidate;
			}
			if (!IsHasDefensivePact(eCandidate))
			{
				if (iNumDefensePacts < iDefensePactLimit)
				{
					vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(eCandidate).getTeam()).getPlayers();

					for (size_t i=0; i<vTheirTeam.size(); i++)
					{
						if (!IsPlayerValid(vTheirTeam[i]))
							continue;

						SetWantsDefensivePactWithPlayer(vTheirTeam[i], true);
						iNumDefensePacts++;
					}

					if (iNumDefensePacts >= iDefensePactLimit && (eMostValuableAlly != NO_PLAYER || !bBestFriendPossible))
					{
						break;
					}
				}
			}

			vDPExclusions.push_back(eCandidate);
			eCandidate = GetHighestScoringDefensivePact(vAcceptableDefensePacts, vDPExclusions);
		}
	}

	SetMostValuableAlly(eMostValuableAlly);

	if (GET_TEAM(GetTeam()).IsResearchAgreementTradingAllowed() && !GetPlayer()->IsAITeammateOfHuman())
	{
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			if (IsGoodChoiceForResearchAgreement(*it))
			{
				SetWantsResearchAgreementWithPlayer(*it, true);
			}
			else
			{
				SetWantsResearchAgreementWithPlayer(*it, false);
			}
		}
	}
}

/// Should we avoid making certain agreements with this player?
bool CvDiplomacyAI::AvoidExchangesWithPlayer(PlayerTypes ePlayer, bool bWarOnly) const
{
	if (IsAtWar(ePlayer))
		return true;

	vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
	vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
	for (size_t i=0; i<vOurTeam.size(); i++)
	{
		if (!GET_PLAYER(vOurTeam[i]).isAlive())
			continue;

		if (GET_PLAYER(vOurTeam[i]).getNumCities() <= 0)
			continue;

		CvDiplomacyAI* pDiploAI = GET_PLAYER(vOurTeam[i]).GetDiplomacyAI();

		for (size_t j=0; j<vTheirTeam.size(); j++)
		{
			if (!GET_PLAYER(vTheirTeam[j]).isAlive())
				continue;

			if (GET_PLAYER(vTheirTeam[j]).getNumCities() <= 0)
				continue;

			if (GET_PLAYER(vTheirTeam[j]).isMajorCiv())
			{
				// Hostile visible approach from them
				if (!bWarOnly)
				{
					if (!GET_PLAYER(vTheirTeam[j]).isHuman() && pDiploAI->GetVisibleApproachTowardsUs(vTheirTeam[j]) == MAJOR_CIV_APPROACH_HOSTILE)
						return true;

					// Has there been a denouncement in either direction?
					if (pDiploAI->IsDenouncedPlayer(vTheirTeam[j]) || pDiploAI->IsDenouncedByPlayer(vTheirTeam[j]))
						return true;
				}

				// Are we planning war?
				if (pDiploAI->GetGlobalCoopWarAgainstState(vTheirTeam[j]) >= COOP_WAR_STATE_PREPARING)
					return true;

				if (!GET_PLAYER(vOurTeam[i]).isHuman())
				{
					if (bWarOnly)
					{
						if (pDiploAI->GetMajorCivApproach(vTheirTeam[j]) == MAJOR_CIV_APPROACH_WAR)
							return true;

						if (pDiploAI->IsWantsSneakAttack(vTheirTeam[j]) || pDiploAI->IsArmyInPlaceForAttack(vTheirTeam[j]))
							return true;
					}
					else
					{
						if (pDiploAI->GetMajorCivApproach(vTheirTeam[j]) <= MAJOR_CIV_APPROACH_HOSTILE)
							return true;

						if (pDiploAI->GetSurfaceApproach(vTheirTeam[j]) != MAJOR_CIV_APPROACH_FRIENDLY && pDiploAI->GetMajorCivOpinion(vTheirTeam[j]) <= MAJOR_CIV_OPINION_ENEMY)
							return true;

						if (pDiploAI->IsWantsSneakAttack(vTheirTeam[j]) || pDiploAI->IsArmyInPlaceForAttack(vTheirTeam[j]))
							return true;
					}
				}
			}
			else if (GET_PLAYER(vTheirTeam[j]).isMinorCiv())
			{
				// Planning to conquer this City-State?
				if (!GET_PLAYER(vOurTeam[i]).isHuman())
				{
					if (pDiploAI->GetCSWarTargetPlayer() == vTheirTeam[j])
						return true;

					if (pDiploAI->GetMinorCivApproach(vTheirTeam[j]) == MINOR_CIV_APPROACH_CONQUEST)
						return true;
				}
			}
		}
	}

	return false;
}

/// Is this player a good choice for a Declaration of Friendship?
bool CvDiplomacyAI::IsGoodChoiceForDoF(PlayerTypes ePlayer)
{
	if (IsAtWar(ePlayer))
		return false;

	// Haven't known this guy for long enough
	if (IsTooEarlyForDoF(ePlayer))
		return false;

	// Untrustworthy?
	if (IsUntrustworthy(ePlayer))
		return false;

	// Denouncement?
	if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer))
		return false;
	
	// If we're willing to end our friendship with them, don't make friends with them!
	if (IsDenounceAcceptable(ePlayer) || IsEndDoFAcceptable(ePlayer, true) || IsDenounceFriendAcceptable(ePlayer))
		return false;

	// Recent peace treaty?
	if (GetNumWarsFought(ePlayer) > 0)
	{
		int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(GET_PLAYER(ePlayer).getTeam());
		if (iPeaceTreatyTurn > -1)
		{
			int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
			int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

			if (iTurnsSincePeace < iPeaceDampenerTurns)
				return false;
		}
	}

	return true;
}

bool CvDiplomacyAI::IsGoodChoiceForDefensivePact(PlayerTypes ePlayer)
{
	if (IsAtWar(ePlayer))
		return false;

	// We need tech & embassy to make a DP
	if (!GET_TEAM(GetTeam()).isDefensivePactTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam()))
		return false;

	if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isDefensivePactTradingAllowedWithTeam(GetTeam()))
		return false;

	// Humans on our team?
	if (GetPlayer()->IsAITeammateOfHuman())
		return false;

	// Sanctioned?
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (pLeague != NULL && pLeague->IsTradeEmbargoed(GetID(), ePlayer))
		return false;

	// Did we just meet them? Let's not make a DP quite yet.
	if (IsTooEarlyForDoF(ePlayer) && !IsDoFAccepted(ePlayer))
		return false;

	//No DPs if last two!
	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();
	if (iNumMajorsLeft <= 2)
		return false;

	// Untrustworthy?
	if (IsUntrustworthy(ePlayer))
		return false;

	// Denouncement?
	if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer))
		return false;

	// If we're willing to end our friendship with them, don't make a DP with them!
	if (IsWantsToEndDoFWithPlayer(ePlayer) || IsDenounceAcceptable(ePlayer) || IsEndDoFAcceptable(ePlayer, true) || IsDenounceFriendAcceptable(ePlayer))
		return false;

	// Recent peace treaty?
	if (GetNumWarsFought(ePlayer) > 0)
	{
		int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(GET_PLAYER(ePlayer).getTeam());
		if (iPeaceTreatyTurn > -1)
		{
			int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
			int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

			if (iTurnsSincePeace < iPeaceDampenerTurns)
				return false;
		}
	}

	// Planning war? Have to check this here as well because of the GetDefensePactsToVotes edge case...
	if (AvoidExchangesWithPlayer(ePlayer))
		return false;

	return true;
}

bool CvDiplomacyAI::IsGoodChoiceForResearchAgreement(PlayerTypes ePlayer)
{
	if (IsAtWar(ePlayer))
		return false;

	// Need a Declaration of Friendship to make a RA
	if (!IsDoFAccepted(ePlayer))
		return false;

	// Already have a RA
	if (IsHasResearchAgreement(ePlayer))
		return false;

	// We need tech & embassy to make a RA
	if (!GET_TEAM(GetTeam()).IsResearchAgreementTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam()))
		return false;

	if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsResearchAgreementTradingAllowedWithTeam(GetTeam()))
		return false;

	// Sanctioned?
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (pLeague != NULL && pLeague->IsTradeEmbargoed(GetID(), ePlayer))
		return false;

	// Humans on our team?
	if (GetPlayer()->IsAITeammateOfHuman())
		return false;

	// Untrustworthy?
	if (IsUntrustworthy(ePlayer))
		return false;

	// Denouncement?
	if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer))
		return false;

	// If we're willing to end our friendship with them, don't make a RA with them!
	if (IsWantsToEndDoFWithPlayer(ePlayer) || IsEndDoFAcceptable(ePlayer) || IsDenounceFriendAcceptable(ePlayer))
		return false;

	// One of us has already researched all techs
	if (GET_TEAM(GetTeam()).GetTeamTechs()->HasResearchedAllTechs() || GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->HasResearchedAllTechs())
		return false;

	return true;
}

/// Are we able to make a Research Agreement with ePlayer right now?
bool CvDiplomacyAI::IsCanMakeResearchAgreementRightNow(PlayerTypes ePlayer)
{
	// We don't want a RA with this guy
	if (!IsWantsResearchAgreementWithPlayer(ePlayer))
		return false;

	// Already have a RA?
	if (IsHasResearchAgreement(ePlayer))
		return false;

	// Either side already has all techs?
	if (GET_TEAM(GetTeam()).GetTeamTechs()->HasResearchedAllTechs() || GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->HasResearchedAllTechs())
		return false;

	// We need tech & embassy to make a RA
	if (!GET_TEAM(GetTeam()).IsResearchAgreementTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam()))
		return false;

	if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsResearchAgreementTradingAllowedWithTeam(GetTeam()))
		return false;

	int iGoldAmount = GC.getGame().GetGameDeals().GetTradeItemGoldCost(TRADE_ITEM_RESEARCH_AGREEMENT, GetID(), ePlayer);

	// We don't have enough Gold
	if (GetPlayer()->GetTreasury()->GetGold() < iGoldAmount)
		return false;

	// They don't have enough Gold
	if (GET_PLAYER(ePlayer).GetTreasury()->GetGold() < iGoldAmount)
		return false;

	return true;
}

PlayerTypes CvDiplomacyAI::GetHighestScoringDefensivePact(vector<PlayerTypes>& vAcceptableChoices, vector<PlayerTypes>& vPlayersToExclude)
{
	if (vAcceptableChoices.empty())
		return NO_PLAYER;

	PlayerTypes eBestDP = NO_PLAYER;
	int iBestDPValue = 0;

	for (std::vector<PlayerTypes>::iterator it = vAcceptableChoices.begin(); it != vAcceptableChoices.end(); it++)
	{
		if (std::find(vPlayersToExclude.begin(), vPlayersToExclude.end(), *it) != vPlayersToExclude.end())
			continue;

		PlayerTypes eChoice = GET_PLAYER(*it).GetID();
		int iDPValue = (GetLoyalty()/2);

		switch (GetPlayerMilitaryStrengthComparedToUs(eChoice))
		{
		case STRENGTH_PATHETIC:
			iDPValue += -20;
			break;
		case STRENGTH_WEAK:
			iDPValue += -10;
			break;
		case STRENGTH_POOR:
			iDPValue += 0;
			break;
		case STRENGTH_AVERAGE:
			iDPValue += 5;
			break;
		case STRENGTH_STRONG:
			iDPValue += 10;
			break;
		case STRENGTH_POWERFUL:
			iDPValue += 15;
			break;
		case STRENGTH_IMMENSE:
			iDPValue += 20;
			break;
		}

		switch (GetPlayer()->GetProximityToPlayer(eChoice))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iDPValue += 5;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iDPValue += 0;
			break;
		case PLAYER_PROXIMITY_FAR:
			iDPValue -= 20;
			break;
		case PLAYER_PROXIMITY_DISTANT:
			iDPValue -= 50;
			break;
		}

		switch (GetMajorCivOpinion(eChoice))
		{
		case MAJOR_CIV_OPINION_UNFORGIVABLE:
		case MAJOR_CIV_OPINION_ENEMY:
			continue;
			break;
		case MAJOR_CIV_OPINION_COMPETITOR:
			iDPValue -= 10;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			iDPValue += 0;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iDPValue += 5;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			iDPValue += 10;
			break;
		case MAJOR_CIV_OPINION_ALLY:
			iDPValue += 20;
			break;
		}

		// Same or different continents?
		if (GET_PLAYER(eChoice).getCapitalCity() && GetPlayer()->getCapitalCity())
		{
			if (GET_PLAYER(eChoice).getCapitalCity()->getArea() == GetPlayer()->getCapitalCity()->getArea())
			{
				iDPValue += 5;
			}
			else
			{
				iDPValue -= 20;
			}
		}

		if (WasResurrectedBy(eChoice))
		{
			iDPValue += 50;
		}

		if (IsPlayerLiberatedCapital(eChoice))
		{
			iDPValue += 15;
		}

		if (GetNumCitiesLiberatedBy(eChoice) > 0 && GetNumCitiesCapturedBy(eChoice) <= 0)
		{
			iDPValue += (GetNumCitiesLiberatedBy(eChoice) * 5);
		}

		if (iDPValue > iBestDPValue)
		{
			eBestDP = eChoice;
			iBestDPValue = iDPValue;
		}
	}

	return eBestDP;
}

/// Update whether which major civs we're targeting for war. NOTE: City-State targets are handled in DoUpdateMinorCivApproaches().
void CvDiplomacyAI::DoUpdateWarTargets()
{
	if (GetPlayer()->isHuman() || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
		return;

	vector<PlayerTypes> vAtWarPlayers;
	vector<PlayerTypes> vNotAtWarPlayers;
	vector<PlayerTypes> vValidPlayers;
	vector<PlayerTypes> vDirectTargets;

	// Which majors are we currently at war with?
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(eLoopPlayer))
			continue;

		if (IsAlwaysAtWar(eLoopPlayer))
			continue;

		if (!GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		vValidPlayers.push_back(eLoopPlayer);

		if (IsAtWar(eLoopPlayer))
		{
			vAtWarPlayers.push_back(eLoopPlayer);
			vDirectTargets.push_back(eLoopPlayer);
		}
		else
		{
			vNotAtWarPlayers.push_back(eLoopPlayer);
		}
	}

	// Who are we PLANNING war against?
	vector<PlayerTypes> vPlanningWarPlayers;
	vector<PlayerTypes> vMyTeam = GET_TEAM(GetTeam()).getPlayers();

	for (std::vector<PlayerTypes>::iterator it = vNotAtWarPlayers.begin(); it != vNotAtWarPlayers.end(); it++)
	{
		vector<PlayerTypes> vTeam = GET_TEAM(GET_PLAYER(*it).getTeam()).getPlayers();
		bool bWarPlans = false;

		for (size_t i=0; i<vMyTeam.size(); i++)
		{
			if (!GET_PLAYER(vMyTeam[i]).isAlive())
				continue;

			for (size_t j=0; j<vTeam.size(); j++)
			{
				if (!IsPlayerValid(vTeam[j]))
					continue;

				// Count any coop wars we've agreed to
				if (GET_PLAYER(vMyTeam[i]).GetDiplomacyAI()->GetGlobalCoopWarAgainstState(vTeam[j]) >= COOP_WAR_STATE_PREPARING)
				{
					bWarPlans = true;
					break;
				}

				// Also count any wars our AI teammates are planning
				if (GET_PLAYER(vMyTeam[i]).GetID() == GetID())
					continue;

				if (!GET_PLAYER(vMyTeam[i]).isHuman())
				{
					if (GET_PLAYER(vMyTeam[i]).GetDiplomacyAI()->IsWantsSneakAttack(vTeam[j]) || GET_PLAYER(vMyTeam[i]).GetDiplomacyAI()->IsArmyInPlaceForAttack(vTeam[j]))
					{
						bWarPlans = true;
						break;
					}
				}
			}

			if (bWarPlans)
				break;
		}

		if (bWarPlans)
		{
			vPlanningWarPlayers.push_back(*it);

			if (GetMajorCivApproach(*it) != MAJOR_CIV_APPROACH_WAR)
			{
				SetMajorCivApproach(*it, MAJOR_CIV_APPROACH_WAR);
			}
		}

		// Check to make sure we're still targeting any vassals of theirs if they're flagged as such
		if (IsTargetingVassal(*it))
		{
			bool bFoundOne = false;

			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsVassal(*it))
				{
					if (GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_WAR)
					{
						bFoundOne = true;
						break;
					}
				}
			}

			if (bFoundOne)
			{
				if (std::find(vPlanningWarPlayers.begin(), vPlanningWarPlayers.end(), *it) == vPlanningWarPlayers.end())
				{
					vPlanningWarPlayers.push_back(*it);
				}
			}
			else
			{
				SetTargetingVassal(*it, false);
			}
		}
	}

	// Combine all players into one array! Need to do it in this circuitous way to check linked war players, which only go to war if not already at war with the target...
	for (std::vector<PlayerTypes>::iterator it = vPlanningWarPlayers.begin(); it != vPlanningWarPlayers.end(); it++)
	{
		if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vAtWarPlayers.end())
		{
			vAtWarPlayers.push_back(*it);
		}

		vDirectTargets.push_back(*it);
		vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(*it, false, false, false);

		for (std::vector<PlayerTypes>::iterator it2 = vLinkedWarPlayers.begin(); it2 != vLinkedWarPlayers.end(); it2++)
		{
			if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it2) == vAtWarPlayers.end())
			{
				vAtWarPlayers.push_back(*it2);
			}
		}
	}

	vNotAtWarPlayers.clear();
	vPlanningWarPlayers.clear();

	// Repopulate vNotAtWarPlayers...
	for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
	{
		if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vAtWarPlayers.end())
		{
			vNotAtWarPlayers.push_back(*it);
		}
	}

	// Finally let's add up our total "conflict score" to see what our situation is at.
	int iConflictScore = 0;

	for (std::vector<PlayerTypes>::iterator it = vAtWarPlayers.begin(); it != vAtWarPlayers.end(); it++)
	{
		if (IsAtWar(*it) && IsPhonyWar(*it))
		{
			iConflictScore += 5;
		}
		else if (IsEasyTarget(*it))
		{
			iConflictScore += 5;
		}
		else
		{
			iConflictScore += 10;
		}
	}

	bool bBold = GetBoldness() > 6 || GetPlayer()->GetPlayerTraits()->IsWarmonger() || (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION);
	bool bCloseToWorldConquest = IsCloseToDominationVictory();
	bool bGoingForWorldConquest = IsGoingForWorldConquest();

	int iConflictLimit = bBold ? 15 : 10;
	int iPotentialWarLimit = iConflictLimit * 2;

	// At our conflict limit? Cancel all new war plans!
	if (iConflictScore >= iConflictLimit)
	{
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			// Must not be in the list of existing wars or war commitments
			if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vValidPlayers.end())
			{
				if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_WAR)
				{
					SetMajorCivApproach(*it, GetHighestValueApproach(*it, true, true));
				}
			}
		}
	}
	else
	{
		// Not at our conflict limit? Let's decide who we want to go to war against (if anyone)!
		// Loop through all players to find valid options
		bool bCanCrossOcean = GetPlayer()->CanCrossOcean();

		for (std::vector<PlayerTypes>::iterator it = vNotAtWarPlayers.begin(); it != vNotAtWarPlayers.end(); it++)
		{
			int iConflictValue = IsEasyTarget(*it) ? 5 : 10;
			int iTestValue = iConflictScore + iConflictValue;

			// If this war would take us over the limit, let's not!
			if (iTestValue > iConflictLimit)
				continue;

			// War weight must be > 0
			if (GetPlayerApproachValue(*it, MAJOR_CIV_APPROACH_WAR) <= 0)
				continue;

			// Must be a sane choice
			if (!IsWarSane(*it))
				continue;

			// Avoid war if we have no chance whatsoever of winning
			if (GetPlayerMilitaryStrengthComparedToUs(*it) == STRENGTH_IMMENSE && !(IsEasyTarget(*it) && GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(*it)))
				continue;

			// Are we not allowing new wars?
			if (GetPlayer()->IsNoNewWars() && !IsEndgameAggressiveTo(*it) && !IsCapitalCapturedBy(*it, true, false))
				continue;

			// Can we declare war?
			if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(*it).getTeam(), GetID()))
				continue;

			// Recent demand?
			if (GetNumTurnsSinceStatementSent(*it, DIPLO_STATEMENT_DEMAND) <= GC.getGame().getGameSpeedInfo().GetDealDuration())
				continue;

			// Recent peace treaty?
			if (GetNumWarsFought(*it) > 0)
			{
				int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(GET_PLAYER(*it).getTeam());
				if (iPeaceTreatyTurn > -1)
				{
					int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
					int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

					if (iTurnsSincePeace < iPeaceDampenerTurns)
						continue;
				}
			}

			// Need a valid (bad) approach towards this player
			bool bValidApproach = false;
			MajorCivApproachTypes eApproach = GetMajorCivApproach(*it);
			PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(*it);

			if (eApproach == MAJOR_CIV_APPROACH_WAR)
			{
				bValidApproach = true;
			}
			else if (eApproach == MAJOR_CIV_APPROACH_HOSTILE)
			{
				if (bCanCrossOcean && eProximity >= PLAYER_PROXIMITY_CLOSE)
				{
					bValidApproach = true;
				}
				else if (!bCanCrossOcean && eProximity == PLAYER_PROXIMITY_NEIGHBORS)
				{
					bValidApproach = true;
				}
				else if (IsCompetingForVictory() && bGoingForWorldConquest)
				{
					bValidApproach = true;
				}
				else if (bCloseToWorldConquest || IsEndgameAggressiveTo(*it))
				{
					bValidApproach = true;
				}
			}
			else if (eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
			{
				if (IsBackstabber())
				{
					bValidApproach = true;
				}
				else if (bCloseToWorldConquest || IsEndgameAggressiveTo(*it))
				{
					bValidApproach = true;
				}
				else if (eProximity == PLAYER_PROXIMITY_NEIGHBORS || (bCanCrossOcean && eProximity >= PLAYER_PROXIMITY_CLOSE))
				{
					if (GetBoldness() > 6 || GetPlayer()->GetPlayerTraits()->IsWarmonger() || bGoingForWorldConquest)
					{
						bValidApproach = true;
					}
				}
			}

			if (!bValidApproach)
				continue;

			vPlanningWarPlayers.push_back(*it);
		}

		// Loop through all players and see if there are any who aren't a valid target anymore
		CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> viExistingSneakAttacks;
		vector<PlayerTypes> vContinuingSneakAttacks;

		for (std::vector<PlayerTypes>::iterator it = vNotAtWarPlayers.begin(); it != vNotAtWarPlayers.end(); it++)
		{
			// Not a valid target anymore?
			if (std::find(vPlanningWarPlayers.begin(), vPlanningWarPlayers.end(), *it) == vPlanningWarPlayers.end())
			{
				if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_WAR)
				{
					SetMajorCivApproach(*it, GetHighestValueApproach(*it, true, true));
				}
			}
			// How much do we value this existing sneak attack?
			else if (IsWantsSneakAttack(*it) || IsArmyInPlaceForAttack(*it))
			{
				int iSneakAttackValue = GetPlayerApproachValue(*it, MAJOR_CIV_APPROACH_WAR);
				viExistingSneakAttacks.push_back(*it, iSneakAttackValue);
			}
		}

		viExistingSneakAttacks.SortItems();

		// If we have an existing (valid) war planned, let's stick with it.
		for (int iSneakAttackLoop = 0; iSneakAttackLoop < (int) viExistingSneakAttacks.size(); iSneakAttackLoop++)
		{
			PlayerTypes eSneakAttackTarget = (PlayerTypes) viExistingSneakAttacks.GetElement(iSneakAttackLoop);

			if (GetMajorCivApproach(eSneakAttackTarget) != MAJOR_CIV_APPROACH_WAR)
			{
				SetMajorCivApproach(eSneakAttackTarget, MAJOR_CIV_APPROACH_WAR);
			}

			int iConflictValue = IsEasyTarget(eSneakAttackTarget) ? 5 : 10;
			iConflictScore += iConflictValue;
			vAtWarPlayers.push_back(eSneakAttackTarget);
			vDirectTargets.push_back(eSneakAttackTarget);
			vContinuingSneakAttacks.push_back(eSneakAttackTarget);

			vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eSneakAttackTarget, false, false, false);

			for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
			{
				// Don't double count them if already in the list of war commitments!
				if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vAtWarPlayers.end())
				{
					iConflictValue = IsEasyTarget(*it) ? 5 : 10;
					iConflictScore += iConflictValue;
					vAtWarPlayers.push_back(*it);
				}
			}

			// Reached our limit? We're done here.
			if (iConflictScore >= iConflictLimit)
				break;
		}

		if (iConflictScore < iConflictLimit)
		{
			// If we don't have enough existing targets, we select new ones here, sorting by highest WAR weight
			vector<PlayerTypes> vWarExclusions;
			PlayerTypes eCandidate = GetPlayerWithHighestApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);

			while (eCandidate != NO_PLAYER)
			{
				// Must be among our valid options
				if (std::find(vPlanningWarPlayers.begin(), vPlanningWarPlayers.end(), eCandidate) == vPlanningWarPlayers.end())
				{
					vWarExclusions.push_back(eCandidate);
					eCandidate = GetPlayerWithHighestApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);
					continue;
				}

				// Can't be in our existing list of sneak attacks
				if (std::find(vContinuingSneakAttacks.begin(), vContinuingSneakAttacks.end(), eCandidate) != vContinuingSneakAttacks.end())
				{
					vWarExclusions.push_back(eCandidate);
					eCandidate = GetPlayerWithHighestApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);
					continue;
				}

				if (GetMajorCivApproach(eCandidate) != MAJOR_CIV_APPROACH_WAR)
				{
					SetMajorCivApproach(eCandidate, MAJOR_CIV_APPROACH_WAR);
				}

				int iConflictValue = IsEasyTarget(eCandidate) ? 5 : 10;
				iConflictScore += iConflictValue;
				vAtWarPlayers.push_back(eCandidate);
				vDirectTargets.push_back(eCandidate);
				vWarExclusions.push_back(eCandidate);

				vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eCandidate, false, false, false);

				for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
				{
					// Don't double count them if already in the list of war commitments!
					if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vAtWarPlayers.end())
					{
						iConflictValue = IsEasyTarget(*it) ? 5 : 10;
						iConflictScore += iConflictValue;
						vAtWarPlayers.push_back(*it);
					}
				}

				// Reached our limit? We're done here.
				if (iConflictScore >= iConflictLimit)
					break;

				// No? Pick another one!
				eCandidate = GetPlayerWithHighestApproachValue(MAJOR_CIV_APPROACH_WAR, vWarExclusions);
			}
		}

		// We've selected all of our war targets! Now go through all players and make sure we don't have the WAR approach if we're not planning war.
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			if (std::find(vAtWarPlayers.begin(), vAtWarPlayers.end(), *it) == vAtWarPlayers.end())
			{
				if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_WAR)
				{
					SetMajorCivApproach(*it, GetHighestValueApproach(*it, true, true));
				}
			}
		}
	}

	// Now update our potential war targets.
	// If we're at or above the limit, no more wars for us!
	if (GetPlayer()->IsNoNewWars() || (iConflictScore >= iPotentialWarLimit))
	{
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			// Already at war?
			if (IsAtWar(*it))
			{
				SetPotentialWarTarget(*it, false);
				continue;
			}

			// In our list of direct targets already, so we're willing to attack them.
			if (std::find(vDirectTargets.begin(), vDirectTargets.end(), *it) != vDirectTargets.end())
			{
				SetPotentialWarTarget(*it, true);
				continue;
			}

			SetPotentialWarTarget(*it, false);
		}
	}
	// Otherwise, mark all valid players as potential war targets
	else
	{
		for (std::vector<PlayerTypes>::iterator it = vValidPlayers.begin(); it != vValidPlayers.end(); it++)
		{
			PlayerTypes ePlayer = GET_PLAYER(*it).GetID();

			// Already at war?
			if (IsAtWar(ePlayer))
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			// If they're in our list of direct targets already, we're willing to attack them.
			if (std::find(vDirectTargets.begin(), vDirectTargets.end(), ePlayer) != vDirectTargets.end())
			{
				SetPotentialWarTarget(ePlayer, true);
				continue;
			}

			int iConflictValue = IsEasyTarget(ePlayer) ? 5 : 10;
			int iTestValue = iConflictScore + iConflictValue;

			// Not if it would take us over the limit!
			if (iTestValue > iPotentialWarLimit)
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			// Scared of them?
			if (GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_AFRAID)
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			// Avoid war if we have no chance whatsoever of winning
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) == STRENGTH_IMMENSE && !(IsEasyTarget(ePlayer) && GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer)))
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			// No target?
			if (!GetPlayer()->GetMilitaryAI()->HavePossibleAttackTarget(ePlayer))
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			// Recent peace treaty?
			if (GetNumWarsFought(ePlayer) > 0)
			{
				int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(GET_PLAYER(ePlayer).getTeam());
				if (iPeaceTreatyTurn > -1)
				{
					int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
					int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

					if (MOD_BALANCE_CORE_DIFFICULTY)
					{
						iPeaceDampenerTurns -= GC.getGame().getHandicapInfo().getAIDifficultyBonusBase() / 2;
						if (iPeaceDampenerTurns < 11)
							iPeaceDampenerTurns = 11;
					}

					if (iTurnsSincePeace < iPeaceDampenerTurns)
					{
						SetPotentialWarTarget(ePlayer, false);
						continue;
					}
				}
			}

			// Recent demand?
			if (GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DEMAND) <= GC.getGame().getGameSpeedInfo().GetDealDuration())
			{
				SetPotentialWarTarget(ePlayer, false);
				continue;
			}

			if (!IsUntrustworthy(ePlayer))
			{
				// Most valuable friend or ally?
				if (GetMostValuableFriend() == ePlayer || GetMostValuableAlly() == ePlayer)
				{
					SetPotentialWarTarget(ePlayer, false);
					continue;
				}

				// Strategic trade partner?
				if (IsStrategicTradePartner(ePlayer))
				{
					SetPotentialWarTarget(ePlayer, false);
					continue;
				}

				// Friendly to them?
				if (GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_FRIENDLY)
				{
					SetPotentialWarTarget(ePlayer, false);
					continue;
				}

				// Like them too much?
				if (GetMajorCivOpinion(ePlayer) >= MAJOR_CIV_OPINION_FRIEND)
				{
					SetPotentialWarTarget(ePlayer, false);
					continue;
				}

				// Liberator?
				if (IsPlayerLiberatedCapital(ePlayer) || IsCityRecentlyLiberatedBy(ePlayer))
				{
					SetPotentialWarTarget(ePlayer, false);
					continue;
				}
			}

			// All clear...the potential is there!
			SetPotentialWarTarget(ePlayer, true);
		}
	}
}

/// Updates our general Diplomatic Approach towards each minor civilization (City-State) we've met
void CvDiplomacyAI::DoUpdateMinorCivApproaches()
{
	bool bHuman = GetPlayer()->isHuman();
	bool bNoCities = GetPlayer()->getCapitalCity() == NULL;
	std::vector<PlayerTypes> vPlayersToUpdate;

	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eMinor).isMinorCiv() && GET_PLAYER(eMinor).isAlive() && IsHasMet(eMinor, false))
		{
			if (IsAlwaysAtWar(eMinor))
			{
				SelectAlwaysWarApproach(eMinor);
				continue;
			}
			else if (bHuman)
			{
				SelectHumanApproach(eMinor);
				continue;
			}
			else if (GET_PLAYER(eMinor).getCapitalCity() == NULL)
			{
				SelectApproachIfTheyHaveNoCities(eMinor);
				continue;
			}
			else if (bNoCities)
			{
				SelectApproachIfWeHaveNoCities(eMinor);
				continue;
			}

			vPlayersToUpdate.push_back(eMinor);
		}
	}

	if (bHuman || bNoCities)
		return;
	
	// Transfer Approaches from last turn to a separate array so we still have access to the info, then clear out the real one
	std::map<PlayerTypes, MinorCivApproachTypes> oldApproaches;
	
	for (std::vector<PlayerTypes>::iterator it = vPlayersToUpdate.begin(); it != vPlayersToUpdate.end(); it++)
	{
		MinorCivApproachTypes eOldApproach = GetMinorCivApproach(*it);
		if (eOldApproach == NO_MINOR_CIV_APPROACH)
			eOldApproach = MINOR_CIV_APPROACH_IGNORE;

		oldApproaches.insert(std::make_pair(*it, eOldApproach));
	}

	CvWeightedVector<PlayerTypes, MAX_MINOR_CIVS, true> vePlayerApproachWeights;
	int iHighestWeight = 1000;

	// Loop through all (known) Minors and determine the order of who we pick our Approach for first based on PROXIMITY - this is different from Majors
	for (std::vector<PlayerTypes>::iterator it = vPlayersToUpdate.begin(); it != vPlayersToUpdate.end(); it++)
	{
		CvCity* pCapitalCity = GET_PLAYER(*it).getCapitalCity();

		CvCity* pOurClosestCity = GetPlayer()->GetClosestCityByPathLength(pCapitalCity->plot());
		if (!pOurClosestCity)
			continue;

		int iDistance = plotDistance(*pCapitalCity->plot(), *pOurClosestCity->plot());

		iHighestWeight = 1000 - iDistance;
		vePlayerApproachWeights.push_back(*it, iHighestWeight);
	}

	// Now sort the list if there's anything in it
	if (vePlayerApproachWeights.size() > 0)
	{
		vePlayerApproachWeights.SortItems();

		// Now that Minors are sorted, ACTUALLY figure out what our Approach will be, taking everything into account
		for (int iPlayerVectorIndex = 0; iPlayerVectorIndex < (int) vePlayerApproachWeights.size(); iPlayerVectorIndex++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) vePlayerApproachWeights.GetElement(iPlayerVectorIndex);

			// See which Approach is best
			SelectBestApproachTowardsMinorCiv(eLoopPlayer, oldApproaches);
		}

		// Now that we've set approaches, let's generate our Bully/War sets.
		bool bBullySet = false;
		bool bWarSet = false;
		for (int iPlayerVectorIndex = 0; iPlayerVectorIndex < (int)vePlayerApproachWeights.size(); iPlayerVectorIndex++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) vePlayerApproachWeights.GetElement(iPlayerVectorIndex);

			// See which Approach is best
			MinorCivApproachTypes eApproach = GetMinorCivApproach(eLoopPlayer);

			//Our first bully?
			if (eApproach == MINOR_CIV_APPROACH_BULLY)
			{
				if (!bBullySet)
				{
					SetCSBullyTargetPlayer(eLoopPlayer);
					bBullySet = true;
				}
				else
				{
					//second bully? Set as ignore.
					SetMinorCivApproach(eLoopPlayer, MINOR_CIV_APPROACH_IGNORE);
				}
			}

			//Our first war?
			if (eApproach == MINOR_CIV_APPROACH_CONQUEST)
			{
				if (!bWarSet)
				{
					SetCSWarTargetPlayer(eLoopPlayer);
					bWarSet = true;
				}
				else
				{
					//second war? Set as ignore.
					SetMinorCivApproach(eLoopPlayer, MINOR_CIV_APPROACH_IGNORE);
				}
			}
		}
	}
}

/// What is the best Diplomatic Approach to take towards a minor civilization (City-State)?
void CvDiplomacyAI::SelectBestApproachTowardsMinorCiv(PlayerTypes ePlayer, std::map<PlayerTypes, MinorCivApproachTypes>& oldApproaches)
{
	if (ePlayer < MAX_MAJOR_CIVS || ePlayer >= MAX_CIV_PLAYERS) return;

	PlayerTypes eMyPlayer = GetID();
	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
	bool bEasyTarget = IsEasyTarget(ePlayer);
	CvPlayerTraits* pTraits = GetPlayer()->GetPlayerTraits();

	MinorCivApproachTypes eOldApproach;
	std::map<PlayerTypes, MinorCivApproachTypes>::iterator oldApproachPointer = oldApproaches.find(ePlayer);
	if (oldApproachPointer != oldApproaches.end())
		eOldApproach = oldApproachPointer->second;
	else
	{
		eOldApproach = GetMinorCivApproach(ePlayer);
		if (eOldApproach == NO_MINOR_CIV_APPROACH)
			eOldApproach = MINOR_CIV_APPROACH_IGNORE;
	}

	// This vector is what we'll stuff the values into first, and pass it into our logging function (which can't take a CvWeightedVector, which we need to sort...)
	vector<int> vApproachScores(NUM_MINOR_CIV_APPROACHES, 0);

	vector<int> vApproachBias;
	for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		MinorCivApproachTypes eLoopApproach = (MinorCivApproachTypes) iApproachLoop;
		int iBias = GetPersonalityMinorCivApproachBias(eLoopApproach);
		vApproachBias.push_back(iBias);

		// Add 1x bias for each approach to reflect personality weight
		vApproachScores[(int)eLoopApproach] += iBias;
	}

	////////////////////////////////////
	// NEUTRAL DEFAULT WEIGHT
	////////////////////////////////////

	vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE];

	////////////////////////////////////
	// PREVIOUS APPROACH BIAS
	////////////////////////////////////

	// If we're planning a war then give it a bias so that we don't get away from it too easily
	if (IsAtWar(ePlayer) || eOldApproach == MINOR_CIV_APPROACH_CONQUEST)
	{
		// Don't give this bias if the war is going poorly
		if (GetWarState(ePlayer) != NO_WAR_STATE_TYPE || GetWarState(ePlayer) > WAR_STATE_CALM)
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		}
	}

	if (eOldApproach == MINOR_CIV_APPROACH_BULLY)
	{
		// Don't give this bias if they're a bad target
		if (bEasyTarget || GetPlayerTargetValue(ePlayer) >= TARGET_VALUE_AVERAGE)
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		}
	}

	////////////////////////////////////
	// RESOURCES
	////////////////////////////////////

	int iNumWeLack = GET_PLAYER(ePlayer).GetMinorCivAI()->GetNumResourcesMajorLacks(eMyPlayer);
	if (iNumWeLack > 0)
	{
		if (GetPlayer()->IsCSResourcesCountMonopolies())
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * iNumWeLack;
			vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * iNumWeLack;
		}
		else
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * iNumWeLack;
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * iNumWeLack;
		}
	}

	////////////////////////////////////
	// FRIENDS WITH MINOR
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsFriends(eMyPlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
	}

	////////////////////////////////////
	// PLEDGE TO PROTECT - have we pledged to protect this minor?
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
	}

	bool bIsGoodWarTarget = false;
	bool bCheckIfGoodWarTarget = true;
	
	////////////////////////////////////
	// EASY TARGET
	////////////////////////////////////
	
	if (bEasyTarget)
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
	}

	////////////////////////////////////
	// TRAITS THAT AFFECT MINORS - These are heavy handed, but that is intentional
	////////////////////////////////////

	bool bAnyFriendshipBonus = false;
	bool bAnyAggressionBonus = false;

	// UA that increases the benefits of City-State friendship
	if (pTraits->GetCityStateFriendshipModifier() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (pTraits->GetCityStateBonusModifier() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (pTraits->GetAllianceCSStrength() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (pTraits->GetAllianceCSDefense() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (pTraits->IsDiplomaticMarriage())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 4;
	}
	if (pTraits->IsAbleToAnnexCityStates())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 4;
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes) iI;
		if (eYield != NO_YIELD)
		{
			if (pTraits->GetYieldFromCSAlly(eYield) > 0)
			{
				vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
				vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
				bAnyFriendshipBonus = true;
			}
		}
	}

	// Other Friendship Bonuses
	if (GetPlayer()->GetMinorFriendshipAnchorMod() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->GetMinorFriendshipDecayMod() < 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->getMinorGoldFriendshipMod() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->IsMinorScienceAllies())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->IsMinorResourceBonus())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->GetIncreasedQuestInfluence() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}
	if (GetPlayer()->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER) > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bAnyFriendshipBonus = true;
	}

	// UA that increases the benefits of aggression towards City-States
	if (pTraits->GetCityStateCombatModifier() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		bAnyAggressionBonus = true;
	}
	if (GetPlayer()->GetCityStateCombatModifier() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		bAnyAggressionBonus = true;
	}
	if (MOD_BALANCE_CORE_AFRAID_ANNEX)
	{
		if (pTraits->IsBullyAnnex())
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
			bAnyAggressionBonus = true;
		}
		if (pTraits->IgnoreBullyPenalties())
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
			bAnyAggressionBonus = true;
		}
		if (pTraits->GetBullyMilitaryStrengthModifier() != 0)
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
			bAnyAggressionBonus = true;
		}
		if (pTraits->GetBullyValueModifier() != 0)
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
			bAnyAggressionBonus = true;
		}
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if (GetPlayer()->GetYieldFromMinorDemand(eYield) > 0)
			{
				vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
				bAnyAggressionBonus = true;
			}
		}
	}

	// Other Bullying Bonuses
	if (GetPlayer()->IsCanBullyFriendlyCS())
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
	}
	if (GetPlayer()->GetBullyGlobalCSReduction() > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 5;
	}

	////////////////////////////////////
	// CONQUEST GRAND STRATEGY
	////////////////////////////////////

	if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION || IsCloseToDominationVictory() || pTraits->IsWarmonger() || pTraits->IsExpansionist())
	{
		// Minor is militaristic or mercantile
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC || GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
			bCheckIfGoodWarTarget = false;
		}
		else
		{
			bAnyAggressionBonus = true;
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 3;
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;

			if (bEasyTarget)
			{
				vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY];
				vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
			}
		}
	}

	////////////////////////////////////
	// DIPLO GRAND STRATEGY
	////////////////////////////////////

	bool bCloseToDiploVictory = IsCloseToDiploVictory();

	if (GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC || bCloseToDiploVictory || pTraits->IsDiplomat())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;

		if (IsGoingForDiploVictory() || bCloseToDiploVictory || pTraits->IsDiplomat())
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
			vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
			bCheckIfGoodWarTarget = false;
			bAnyFriendshipBonus = true;
		}
	}

	////////////////////////////////////
	// CULTURE GRAND STRATEGY
	////////////////////////////////////

	if (GetVictoryFocus() == VICTORY_FOCUS_CULTURE || IsCloseToCultureVictory() || pTraits->IsTourism() || pTraits->IsSmaller())
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];

		// Minor is cultural
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED) 
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
			bCheckIfGoodWarTarget = false;
		}
	}

	////////////////////////////////////
	// SCIENCE GRAND STRATEGY
	////////////////////////////////////

	if (GetVictoryFocus() == VICTORY_FOCUS_SCIENCE || IsCloseToSSVictory() || pTraits->IsNerd())
	{
		// Minor is maritime or militaristic
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME || GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
		{
			vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
			vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
			bCheckIfGoodWarTarget = false;
		}
		else
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		}
	}
	// Smaller civs like science & military support
	else if (pTraits->IsSmaller() && GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		bCheckIfGoodWarTarget = false;
	}

	////////////////////////////////////
	// RELIGIOUS MINORS
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
	{
		if (!GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
		{
			ReligionTypes eReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);

			// Do we already have a religion?
			if (eReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

				// But not yet enhanced?
				if (!pReligion->m_bEnhanced)
				{
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
					vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
					bCheckIfGoodWarTarget = false;
				}
				// Enhanced? Be a bit more friendly (to benefit from faith quests etc), but it's no longer a huge issue.
				else
				{
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
					vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
				}				
			}
			// Can we found a religion?
			else if (GC.getGame().GetGameReligions()->GetNumReligionsStillToFound() <= 0 || GetPlayer()->GetPlayerTraits()->IsAlwaysReligion())
			{
				// We created a pantheon? We're on track, so keep these City-States close...
				if (GetPlayer()->GetReligions()->HasCreatedPantheon())
				{
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 4;
					vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 4;
					bCheckIfGoodWarTarget = false;
				}
				// No one has founded a religion yet, so let's be more friendly...
				else if (GC.getGame().GetGameReligions()->GetNumReligionsFounded() <= 0)
				{
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
					vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
					bCheckIfGoodWarTarget = false;
				}
				else if (!pTraits->IsReligious())
				{
					vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
					vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST];

					if (bEasyTarget)
					{
						vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY];
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
					}
					if (bAnyAggressionBonus)
					{
						vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY];
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
					}
				}
			}

			// Religious civ - apply weight if ANY religion criteria is met
			if (pTraits->IsReligious())
			{
				ReligionTypes eMajorityReligion = GetPlayer()->GetReligions()->GetReligionInMostCities();

				if (eReligion != NO_RELIGION || eMajorityReligion != NO_RELIGION || GetPlayer()->GetReligions()->HasCreatedPantheon())
				{
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
					vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
					bCheckIfGoodWarTarget = false;
				}
			}
		}
	}

	int iNonPuppetCities = GetPlayer()->getNumCities() - GetPlayer()->GetNumPuppetCities();

	if (bAnyFriendshipBonus && iNonPuppetCities < 4)
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
		bCheckIfGoodWarTarget = false;
		bAnyAggressionBonus = false;
	}

	////////////////////////////////////
	// AT WAR RIGHT NOW
	////////////////////////////////////

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Don't look at the guy we're already thinking about or anyone on his team
		if (GET_PLAYER(ePlayer).getTeam() != GET_PLAYER(eLoopPlayer).getTeam())
		{
			if (IsPlayerValid(eLoopPlayer))
			{
				if (IsAtWar(eLoopPlayer))
				{
					vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE];
					vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];

					//either way, let's not worry about CSs as much if at war.
					if (GET_PLAYER(eLoopPlayer).isMajorCiv())
					{
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] -= vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
						vApproachScores[MINOR_CIV_APPROACH_BULLY] -= vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
					}
				}
				//for every nearby major civ, let's reduce our interest in CS conquest. We've got bigger fish to fry.
				if (GET_PLAYER(eLoopPlayer).isMajorCiv())
				{
					if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) == PLAYER_PROXIMITY_NEIGHBORS)
					{
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] -= vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
					}
					else if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) == PLAYER_PROXIMITY_CLOSE)
					{
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] -= vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
					}
				}
			}
		}
	}

	////////////////////////////////////
	// PROXIMITY
	////////////////////////////////////

	switch (GetPlayer()->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_NEIGHBORS:
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2 : vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2 : vApproachBias[MINOR_CIV_APPROACH_BULLY];
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] : vApproachBias[MINOR_CIV_APPROACH_CONQUEST] / 2;
		break;
	case PLAYER_PROXIMITY_CLOSE:
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2 : vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_BULLY] : vApproachBias[MINOR_CIV_APPROACH_BULLY] / 2;
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2 : vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
		break;
	case PLAYER_PROXIMITY_FAR:
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 2;
	case PLAYER_PROXIMITY_DISTANT:
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 4;
		break;
	}

	////////////////////////////////////
	// MINOR PERSONALITY
	////////////////////////////////////

	switch (GET_PLAYER(ePlayer).GetMinorCivAI()->GetPersonality())
	{
	case MINOR_CIV_PERSONALITY_FRIENDLY:
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
		break;
	case MINOR_CIV_PERSONALITY_NEUTRAL:
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
		break;
	case MINOR_CIV_PERSONALITY_HOSTILE:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		break;
	case MINOR_CIV_PERSONALITY_IRRATIONAL:
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		break;
	}

	////////////////////////////////////
	// TRIBUTE HISTORY - have we bullied this player before?  If so, we are more likely to keep bullying
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsEverBulliedByMajor(eMyPlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_BULLY] * 4 : vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2 : vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
	}

	////////////////////////////////////
	// QUESTS - are there any active quests that might sway our decision?
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_PLEDGE_TO_PROTECT))
	{
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2 : vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
	}

	//If this civ has a kill CS quest, then it means another CS has one too...let's compare.
	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_KILL_CITY_STATE))
	{
		for (int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			PlayerTypes eOtherMinor = (PlayerTypes) iMinorCivLoop;

			if (IsPlayerValid(eOtherMinor) && GET_PLAYER(eOtherMinor).isMinorCiv() && GET_PLAYER(eOtherMinor).getTeam() != GET_PLAYER(ePlayer).getTeam())
			{
				if (GET_PLAYER(eOtherMinor).GetMinorCivAI()->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_KILL_CITY_STATE))
				{
					PlayerTypes eTarget = (PlayerTypes) GET_PLAYER(eOtherMinor).GetMinorCivAI()->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_KILL_CITY_STATE);
					if (eTarget == ePlayer)
					{
						bool bBadTarget = false;
						int iPTV = GetPlayerTargetValue(ePlayer);
						switch (iPTV)
						{
							//Is this guy a bad target? Let's diplo him instead.
						case TARGET_VALUE_IMPOSSIBLE:
						case TARGET_VALUE_BAD:
						case TARGET_VALUE_AVERAGE:
							bBadTarget = true;
							break;
							//Good target? Let's kill him and get the prize!
						case TARGET_VALUE_FAVORABLE:
						case TARGET_VALUE_SOFT:
							vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 4 : vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
							bAnyAggressionBonus = true;
							break;
						default:
							break;
						}
						int iPTV2 = GetPlayerTargetValue(eOtherMinor);
						switch (iPTV2)
						{
							//Is the other guy also a bad target? Let's diplo them both instead.
						case TARGET_VALUE_IMPOSSIBLE:
						case TARGET_VALUE_BAD:
						case TARGET_VALUE_AVERAGE:
							if (bBadTarget)
							{
								vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2 : vApproachBias[MINOR_CIV_APPROACH_FRIENDLY];
								vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2 : vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE];
							}
							break;
						default:
							break;
						}
						break;
					}
				}
			}
		}
	}

	// Are we getting yields from trade with them?
	int iCurrentTradeValue = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer) +
							GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, ePlayer) + 
							GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, ePlayer);
	iCurrentTradeValue /= 300;
	iCurrentTradeValue += GET_PLAYER(ePlayer).GetMinorCivAI()->GetCurrentGoldBonus(eMyPlayer);

	if (iCurrentTradeValue > 0)
	{
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * iCurrentTradeValue / 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * iCurrentTradeValue;
	}
	else //not a trade partner
	{
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE];
	}

	////////////////////////////////////
	// WORLD CONGRESS
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsNoAlly())
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2 : vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2 : vApproachBias[MINOR_CIV_APPROACH_BULLY];
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] = 0;
		bCheckIfGoodWarTarget = true;
		bAnyFriendshipBonus = false;
		bAnyAggressionBonus = true;
	}

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetPermanentAlly() != NO_PLAYER && GET_PLAYER(GET_PLAYER(ePlayer).GetMinorCivAI()->GetPermanentAlly()).getTeam() != GetTeam())
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2 : vApproachBias[MINOR_CIV_APPROACH_CONQUEST];
		vApproachScores[MINOR_CIV_APPROACH_BULLY] += (bEasyTarget || bAnyAggressionBonus) ? vApproachBias[MINOR_CIV_APPROACH_BULLY] * 2 : vApproachBias[MINOR_CIV_APPROACH_BULLY];
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 2;
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] = 0;
		bCheckIfGoodWarTarget = true;
		bAnyFriendshipBonus = false;
		bAnyAggressionBonus = true;
	}

	// See if this minor is on the same continent as a major power we want to attack
	if (bCheckIfGoodWarTarget)
	{
		CvCity *pkMinorCapital = GET_PLAYER(ePlayer).getCapitalCity(); // Validity was already checked in DoUpdateMinorCivApproaches()
		int iMinorAreaID = pkMinorCapital->getArea();
		int iMyAreaID = GetPlayer()->getCapitalCity()->getArea();

		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Make sure it is another valid player and not already at war with them
			if (IsPlayerValid(eLoopPlayer))
			{
				// Do we want to attack them?
				if (IsAtWar(eLoopPlayer) || GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_WAR)
				{
					CvCity* pkLoopPlayerCity = GET_PLAYER(eLoopPlayer).getCapitalCity();
					if (pkLoopPlayerCity) // It's possible this is not valid
					{
						int iLoopPlayerAreaID = pkLoopPlayerCity->getArea();
						// All of us neighbors on same landmass?
						if (iLoopPlayerAreaID == iMinorAreaID && iMyAreaID == iLoopPlayerAreaID)
						{
							if (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_NEIGHBORS && GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_NEIGHBORS)
							{
								bIsGoodWarTarget = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	if (bIsGoodWarTarget)
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		
		if (bEasyTarget)
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		}
		if (bAnyAggressionBonus)
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		}
		if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] += vApproachBias[MINOR_CIV_APPROACH_CONQUEST] * 2;
		}
	}
	else if (GetPlayer()->GetProximityToPlayer(ePlayer) <= PLAYER_PROXIMITY_FAR)
	{
		if (IsGoingForWorldConquest())
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] /= 2;
			vApproachScores[MINOR_CIV_APPROACH_BULLY] /= 2;
		}
		else
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
			vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
		}
	}

	////////////////////////////////////
	// APPROACHES TOWARDS OTHER PLAYERS
	////////////////////////////////////

	// Look at Approaches we've already adopted for higher priority major civs
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			if (GET_PLAYER(eLoopPlayer).isMajorCiv() && !bIsGoodWarTarget)
			{
				if (IsAtWar(eLoopPlayer) || GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE || IsWantsSneakAttack(eLoopPlayer) || IsArmyInPlaceForAttack(eLoopPlayer) || GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_WAR)
				{
					if (!IsPhonyWar(eLoopPlayer))
					{
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
						vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 2;
					}
				}
			}
		}
	}

	////////////////////////////////////
	// ALLIES WITH MINOR?
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == eMyPlayer)
	{
		// Disfavor conquest and bullying if they are our ally
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;

		if (!GetPlayer()->IsCanBullyFriendlyCS())
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
		}

		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 6 : vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 3;
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += bAnyFriendshipBonus ? vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 4 : vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] = 0;
	}

	////////////////////////////////////
	// BULLY VIABILITY
	////////////////////////////////////

	if (vApproachScores[MINOR_CIV_APPROACH_BULLY] > 0)
	{
		int iBullyScore = 0;
		{
			iBullyScore = GET_PLAYER(ePlayer).GetMinorCivAI()->CalculateBullyScore(eMyPlayer, false);
			if (iBullyScore > 0)
			{
				if (MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
					vApproachScores[MINOR_CIV_APPROACH_BULLY] += (iBullyScore / 5);
				else
					vApproachScores[MINOR_CIV_APPROACH_BULLY] += (iBullyScore / 10);
			}
			else
				vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
		}
	}

	////////////////////////////////////
	// MILITARY TARGET VALUE - how tough is this guy to kill?
	////////////////////////////////////

	bool bGoodAttackTarget = GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer);
	bool bWantsConquest = bAnyAggressionBonus && bGoodAttackTarget;

	switch (GetPlayerTargetValue(ePlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= bWantsConquest ? /*75*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_IMPOSSIBLE() : /*25*/ GC.getMINOR_APPROACH_WAR_TARGET_IMPOSSIBLE();
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= bWantsConquest ? /*75*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_IMPOSSIBLE() : /*25*/ GC.getMINOR_APPROACH_WAR_TARGET_IMPOSSIBLE();
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 3;
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 3;
		break;
	case TARGET_VALUE_BAD:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= bWantsConquest ? /*100*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_BAD() : /*50*/ GC.getMINOR_APPROACH_WAR_TARGET_BAD();
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= bWantsConquest ? /*100*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_BAD() : /*50*/ GC.getMINOR_APPROACH_WAR_TARGET_BAD();
		vApproachScores[MINOR_CIV_APPROACH_IGNORE] += vApproachBias[MINOR_CIV_APPROACH_IGNORE] * 3;
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 3;
		break;
	case TARGET_VALUE_AVERAGE:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= bWantsConquest ? /*125*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_AVERAGE() : /*75*/ GC.getMINOR_APPROACH_WAR_TARGET_AVERAGE();
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= bWantsConquest ? /*125*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_AVERAGE() : /*75*/ GC.getMINOR_APPROACH_WAR_TARGET_AVERAGE();
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] += vApproachBias[MINOR_CIV_APPROACH_PROTECTIVE] * 2;
		break;
	case TARGET_VALUE_FAVORABLE:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= bWantsConquest ? /*150*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_FAVORABLE() : /*100*/ GC.getMINOR_APPROACH_WAR_TARGET_FAVORABLE();
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= bWantsConquest ? /*150*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_FAVORABLE() : /*100*/ GC.getMINOR_APPROACH_WAR_TARGET_FAVORABLE();
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	case TARGET_VALUE_SOFT:
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= bWantsConquest ? /*200*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_SOFT() : /*150*/ GC.getMINOR_APPROACH_WAR_TARGET_SOFT();
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= bWantsConquest ? /*200*/ GC.getCONQUEST_WAR_MULTIPLIER_TARGET_SOFT() : /*150*/ GC.getMINOR_APPROACH_WAR_TARGET_SOFT();
		vApproachScores[MINOR_CIV_APPROACH_FRIENDLY] += vApproachBias[MINOR_CIV_APPROACH_FRIENDLY] * 2;
		break;
	default:
		break;
	}

	vApproachScores[MINOR_CIV_APPROACH_CONQUEST] /= 100;
	vApproachScores[MINOR_CIV_APPROACH_BULLY] /= 100;
	
	////////////////////////////////////
	// CAN WE PLEDGE TO PROTECT?
	// Disfavor protective if we can't actually pledge protection!
	////////////////////////////////////

	if (!GET_PLAYER(ePlayer).GetMinorCivAI()->CanMajorProtect(eMyPlayer) && !GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(eMyPlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_PROTECTIVE] = 0;
	}

	////////////////////////////////////
	// RECENTLY BULLIED
	// Avoid bullying/conquest if we recently bullied them
	////////////////////////////////////

	if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsRecentlyBulliedByMajor(eMyPlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;

		if (!bIsGoodWarTarget)
		{
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
		}
	}
	
	////////////////////////////////////
	// CAN WE DECLARE WAR?
	// Disfavor conquest if we can't even do war with them!
	////////////////////////////////////

	if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), eMyPlayer) && !IsAtWar(ePlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
		vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
	}

	// No target?
	if (!GetPlayer()->GetMilitaryAI()->HavePossibleAttackTarget(ePlayer))
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
		vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
	}
	// Don't waste our time trying to conquer City-States if they aren't even good targets...
	else if (!bIsGoodWarTarget && !bGoodAttackTarget)
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
	}

	////////////////////////////////////
	// PEACE TREATY - have we made peace with this player recently?  If so, reduce war weight
	////////////////////////////////////

	int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(eTeam);
	if (iPeaceTreatyTurn > -1)
	{
		int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;
		if (iTurnsSincePeace < /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER())
		{
			vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
			vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
		}
	}
	
	////////////////////////////////////
	// Teammates & Friends
	////////////////////////////////////

	if (vApproachScores[MINOR_CIV_APPROACH_CONQUEST] > 0 || vApproachScores[MINOR_CIV_APPROACH_BULLY] > 0)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer, true))
			{
				if (eLoopPlayer == GetID())
					continue;

				// Don't attack a minor that a teammate has allied/protected!
				// Let's not attack our friends' allied/protected City-States either.
				if (IsFriendOrAlly(eLoopPlayer))
				{
					if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == eLoopPlayer)
					{
						vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
						break;
					}
					else if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
					{
						vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
						vApproachScores[MINOR_CIV_APPROACH_CONQUEST] = 0;
						break;
					}
				}
			}
		}
	}

	////////////////////////////////////
	// TOO FAR TO BULLY
	// Don't bully if they're too far away
	////////////////////////////////////

	if (vApproachScores[MINOR_CIV_APPROACH_BULLY] > 0)
	{
		int iDistanceTurns = GetPlayer()->GetCityDistancePathLength(GET_PLAYER(ePlayer).getCapitalCity()->plot());
		if (iDistanceTurns > 23)
			vApproachScores[MINOR_CIV_APPROACH_BULLY] = 0;
	}

	////////////////////////////////////
	// AGGRESSIVE MODE
	////////////////////////////////////

	if (GC.getGame().IsAIAggressiveMode())
	{
		vApproachScores[MINOR_CIV_APPROACH_CONQUEST] *= 2;
		vApproachScores[MINOR_CIV_APPROACH_BULLY] *= 2;
	}

	// Negative approach weights - cap at zero!
	bool bAllZero = true;
	for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		MinorCivApproachTypes eLoopApproach = (MinorCivApproachTypes) iApproachLoop;

		if (vApproachScores[(int)eLoopApproach] <= 0)
		{
			vApproachScores[(int)eLoopApproach] = 0;
		}
		else
		{
			bAllZero = false;
		}
	}

	// This vector is what we'll use to sort
	CvWeightedVector< MinorCivApproachTypes, 128 > vApproachScoresForSorting;

	// Transfer values from our normal int vector (which we need for logging) to the Weighted Vector we can sort
	for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		MinorCivApproachTypes eLoopApproach = (MinorCivApproachTypes) iApproachLoop;
		vApproachScoresForSorting.push_back(eLoopApproach, vApproachScores[(int)eLoopApproach]);
	}

	MinorCivApproachTypes eApproach;
	vApproachScoresForSorting.SortItems();

	// All at zero? Ignore is the default.
	if (bAllZero)
	{
		eApproach = MINOR_CIV_APPROACH_IGNORE;
	}
	else
	{
		eApproach = vApproachScoresForSorting.GetElement(0);
	}

	SetMinorCivApproach(ePlayer, eApproach);
	LogMinorCivApproachUpdate(ePlayer, &vApproachScores[0], eApproach, eOldApproach);

	return;
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// WAR!
// ////////////////////////////////////

/// Handles declarations of War for this AI
void CvDiplomacyAI::MakeWar()
{
	CvWeightedVector<PlayerTypes> playerList;

	if(m_eDiploMode == DIPLO_SPECIFIC_PLAYER)
	{
		DoMakeWarOnPlayer(m_eTargetPlayer);
	}
	else
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eTarget = (PlayerTypes)iPlayerLoop;
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (IsPlayerValid(eTarget))
				{
					int iWeight = GET_PLAYER(eTarget).isMajorCiv() ? GetPlayerStrategicApproachValue(eTarget, MAJOR_CIV_APPROACH_WAR) : (int)GetPlayerTargetValue(eTarget) + 1;

					// Square the distance enum to make it crucial
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));

					playerList.push_back(eTarget, iWeight);
				}
			}
			else
			{
				if(IsValidUIDiplomacyTarget(eTarget) && IsPlayerValid(eTarget))
#else
				if(IsValidUIDiplomacyTarget(eTarget) && IsPlayerValid(eTarget))
#endif
				{
					int iWeight = GET_PLAYER(eTarget).isMajorCiv() ? GetPlayerStrategicApproachValue(eTarget, MAJOR_CIV_APPROACH_WAR) : (int)GetPlayerTargetValue(eTarget) + 1;

					// Square the distance enum to make it crucial
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));

					playerList.push_back(eTarget, iWeight);
				}
#if defined(MOD_ACTIVE_DIPLOMACY)
			}
#endif
		}

		playerList.SortItems();

		for (int iI = 0; iI < playerList.size(); iI++)
		{
			DoMakeWarOnPlayer(playerList.GetElement(iI));
		}
	}
}

/// Handles declarations of War for this AI
void CvDiplomacyAI::DoMakeWarOnPlayer(PlayerTypes eTargetPlayer)
{
	//if we are already at war, there is not much to do
	if (IsAtWar(eTargetPlayer))
	{
		SetWantsSneakAttack(eTargetPlayer, false);
		SetArmyInPlaceForAttack(eTargetPlayer, false);
		return;
	}

	//sometimes we cannot declare war
	if (!IsPlayerValid(eTargetPlayer) || !GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), GetID()))
	{
		SetWarGoal(eTargetPlayer, NO_WAR_GOAL_TYPE);
		SetWantsSneakAttack(eTargetPlayer, false);
		SetArmyInPlaceForAttack(eTargetPlayer, false);

		if (GetPlayer()->getFirstOffensiveAIOperation(eTargetPlayer) != NULL)
		{
			GetPlayer()->StopAllLandOffensiveOperationsAgainstPlayer(eTargetPlayer,AI_ABORT_TARGET_NOT_VALID);
			GetPlayer()->StopAllSeaOffensiveOperationsAgainstPlayer(eTargetPlayer,AI_ABORT_TARGET_NOT_VALID);
		}
		return;
	}

	bool bWantToAttack = false;
	bool bWantShowOfForce = false;

	// Minor Civ
	if (GET_PLAYER(eTargetPlayer).isMinorCiv())
	{
		if (!GetPlayer()->IsNoNewWars())
		{
			bWantToAttack = GetCSWarTargetPlayer() == eTargetPlayer;
			bWantShowOfForce = GetCSBullyTargetPlayer() == eTargetPlayer;
		}
	}
	// Major Civ
	else
	{
		bWantToAttack = (GetMajorCivApproach(eTargetPlayer) == MAJOR_CIV_APPROACH_WAR) && IsWarSane(eTargetPlayer);
		bWantShowOfForce = GetDemandTargetPlayer() == eTargetPlayer;

		// Don't attack someone else's vassal unless we want to attack the master too
		if (GET_PLAYER(eTargetPlayer).IsVassalOfSomeone())
		{
			TeamTypes eMasterTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).GetMaster();
			if (eMasterTeam != GetTeam() && GetMajorCivApproach(GET_TEAM(eMasterTeam).getLeaderID()) != MAJOR_CIV_APPROACH_WAR)
				bWantToAttack = false;
		}
	}

	if (IsArmyInPlaceForAttack(eTargetPlayer))
	{
		// Our Approach with this player calls for war
		if (bWantToAttack)
		{
			DeclareWar(eTargetPlayer);
		}
		else if (bWantShowOfForce)
		{
			//minors will be bullied automatically!
			if (GET_PLAYER(eTargetPlayer).isMajorCiv())
				DoMakeDemand(eTargetPlayer);
		}
		else
		{
			//hmm, seems we changed our mind. abort the operation if it's still ongoing
			CvAIOperation* pCurrentSneakAttackOperation = GetPlayer()->getFirstOffensiveAIOperation(eTargetPlayer);
			if (pCurrentSneakAttackOperation)
			{
				pCurrentSneakAttackOperation->LogOperationSpecialMessage("War goal changed, probably another war is more important");
				pCurrentSneakAttackOperation->SetToAbort(AI_ABORT_DIPLO_OPINION_CHANGE);
			}

			SetWarGoal(eTargetPlayer, NO_WAR_GOAL_TYPE);

			if (GET_PLAYER(eTargetPlayer).isMajorCiv() && GetMajorCivApproach(eTargetPlayer) == MAJOR_CIV_APPROACH_WAR)
				SetMajorCivApproach(eTargetPlayer, GetHighestValueApproach(eTargetPlayer, true, true));
		}

		SetArmyInPlaceForAttack(eTargetPlayer, false);
		SetWantsSneakAttack(eTargetPlayer, false);
	}
	else
	{
		//see if we can start a sneak attack
		if (bWantToAttack)
		{
			SetWarGoal(eTargetPlayer, WAR_GOAL_PREPARE);

			// Attack on minor
			if (GET_PLAYER(eTargetPlayer).isMinorCiv())
			{
				bool bCareful = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, false) > 0;

				if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(eTargetPlayer))
				{
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eTargetPlayer, 1, bCareful);
				}
			}
			// Attack on major
			else
			{
				SetWantsSneakAttack(eTargetPlayer, true);
				bool bCareful = (GetPlayer()->IsNoNewWars() || GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true) > 0) && GetGlobalCoopWarAgainstState(eTargetPlayer) < COOP_WAR_STATE_PREPARING;

				if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(eTargetPlayer))
				{
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eTargetPlayer, 3, bCareful);
				}
			}
		}
		//we just want to scare them
		else if (bWantShowOfForce)
		{
			SetWarGoal(eTargetPlayer, WAR_GOAL_DEMAND);
			GetPlayer()->GetMilitaryAI()->RequestBullyingOperation(eTargetPlayer);
		}
		//we have no operation under way and we don't want to attack anyway
		else
		{
			SetWarGoal(eTargetPlayer, NO_WAR_GOAL_TYPE);
			SetWantsSneakAttack(eTargetPlayer, false);
			SetArmyInPlaceForAttack(eTargetPlayer, false);

			if (GET_PLAYER(eTargetPlayer).isMajorCiv() && GetMajorCivApproach(eTargetPlayer) == MAJOR_CIV_APPROACH_WAR)
				SetMajorCivApproach(eTargetPlayer, GetHighestValueApproach(eTargetPlayer, true, true));
		}
	}
}

/// We've decided to declare war on someone
bool CvDiplomacyAI::DeclareWar(PlayerTypes ePlayer)
{
	CvAssertMsg(!GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() != GetID(), "Major is declaring war on a city-state it is allied with! Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvTeam& kMyTeam = GET_TEAM(GetTeam());
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();

	if (!GET_TEAM(GetTeam()).canDeclareWar(eTheirTeam, GetID()))
		return false;

	// Only do it if we are not already at war.
	if(!kMyTeam.isAtWar(eTheirTeam))
	{
		kMyTeam.declareWar(eTheirTeam, false, GetID());

		m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NOW_AT_WAR);

		// Show scene to human
		if (!GC.getGame().IsAllDiploStatementsDisabled())
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				// JdH: deciding whether to send a notification or pop up directy is done in SendRequest
				if (CvPreGame::isHuman(ePlayer))
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
					CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
			}
			else
			{
				if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
					gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
			}
#else
			if (!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
				gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
			}
#endif
		}

		LogWarDeclaration(ePlayer);
		return true;
	}
	return false;
}

/// We've decided to declare war on someone
bool CvDiplomacyAI::DeclareWar(TeamTypes eTeam)
{
	for (int i = 0; i < MAX_CIV_PLAYERS; i++)
	{
		PlayerTypes ePlayer = (PlayerTypes)i;

		if (ePlayer == NO_PLAYER)
			continue;

		if (!GET_PLAYER(ePlayer).isAlive())
			continue;

		if (GET_PLAYER(ePlayer).getTeam() != eTeam)
			continue;

		CvAssertMsg(!GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() != GetID(), "Major is declaring war on a city-state it is allied with! Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		CvTeam& kMyTeam = GET_TEAM(GetTeam());
		TeamTypes eTheirTeam = eTeam;

		if (!kMyTeam.canDeclareWar(eTheirTeam, GetID()))
			return false;

		// Only do it if we are not already at war.
		if (!kMyTeam.isAtWar(eTheirTeam))
		{
			kMyTeam.declareWar(eTheirTeam, false, GetID());

			m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NOW_AT_WAR);

			// Show scene to human
			if (!GC.getGame().IsAllDiploStatementsDisabled())
			{
#if defined(MOD_ACTIVE_DIPLOMACY)
				if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					// JdH: deciding whether to send a notification or pop up directly is done in SendRequest
					if (CvPreGame::isHuman(ePlayer))
					{
						const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
						CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
					}
				}
				else
				{
					if (!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
					{
						const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
						gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
					}
				}
#else
				if (!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
					gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
#endif
			}

			LogWarDeclaration(ePlayer);
			return true;
		}
	}
	return false;
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// COUNTERS
// ////////////////////////////////////

/// Increment our turn counters
void CvDiplomacyAI::DoCounters()
{
	int iItem;
	DiploStatementTypes eStatement;
	PublicDeclarationTypes eDeclaration;

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			bool bAtWar = IsAtWar(eLoopPlayer);
			
			// War Counter
			if (bAtWar)
			{
				ChangePlayerNumTurnsAtWar(eLoopPlayer, 1);
				ChangePlayerNumTurnsSinceCityCapture(eLoopPlayer, 1);
				SetPlayerNumTurnsAtPeace(eLoopPlayer, 0);
			}
			else
			{
				SetPlayerNumTurnsAtWar(eLoopPlayer, 0);
				SetPlayerNumTurnsSinceCityCapture(eLoopPlayer, 0);
				ChangePlayerNumTurnsAtPeace(eLoopPlayer, 1);
			}

			///////////////////////////////
			// Major Civs only!
			///////////////////////////////
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Trade value counter
				ChangeRecentTradeValue(eLoopPlayer, /*-2*/ -GC.getDEAL_VALUE_PER_TURN_DECAY());
				ChangeCommonFoeValue(eLoopPlayer, /*-25*/ -GC.getCOMMON_FOE_VALUE_PER_TURN_DECAY());
				if (GetRecentAssistValue(eLoopPlayer) > 0)
				{
					int iMin = MIN(GetRecentAssistValue(eLoopPlayer), /*3*/ GC.getASSIST_VALUE_PER_TURN_DECAY());
					ChangeRecentAssistValue(eLoopPlayer, -iMin);
				}
				else if (GetRecentAssistValue(eLoopPlayer) < 0)
				{
					int iMin = MIN(-GetRecentAssistValue(eLoopPlayer), /*3*/ GC.getASSIST_VALUE_PER_TURN_DECAY());
					ChangeRecentAssistValue(eLoopPlayer, iMin);
				}
				if (MOD_DIPLOMACY_CIV4_FEATURES)
				{
					ChangeVassalProtectValue(eLoopPlayer, /*-25*/ -GC.getVASSALAGE_PROTECTED_PER_TURN_DECAY());
					ChangeVassalFailedProtectValue(eLoopPlayer, /*-25*/ -GC.getVASSALAGE_FAILED_PROTECT_PER_TURN_DECAY());
				}
	
				if (GetNegativeArchaeologyPoints(eLoopPlayer) > 0)
				{
					ChangeNegativeArchaeologyPoints(eLoopPlayer, -1);
				}

				// Diplo Statement Log Counter
				for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
				{
					eStatement = GetDiploLogStatementTypeForIndex(eLoopPlayer, iItem);

					if(eStatement != NO_DIPLO_STATEMENT_TYPE)
						ChangeDiploLogStatementTurnForIndex(eLoopPlayer, iItem, 1);
					else
						SetDiploLogStatementTurnForIndex(eLoopPlayer, iItem, 0);
				}

#if defined(MOD_BALANCE_CORE)
				if(!IsAtWar(eLoopPlayer))
				{
					if(GetNumTimesRazed(eLoopPlayer) > 0)
					{
						if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
						{
							ChangeNumTimesRazed(eLoopPlayer, -10);
						}
						else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_NEUTRAL)
						{
							ChangeNumTimesRazed(eLoopPlayer, -5);
						}
						else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_COMPETITOR)
						{
							ChangeNumTimesRazed(eLoopPlayer, -3);
						}
						else
						{
							ChangeNumTimesRazed(eLoopPlayer, -1);
						}
					}
				}
#endif
				// Are we ready to forget our denunciation?
				if (IsDenouncedPlayer(eLoopPlayer) && GetTurnsSinceDenouncedPlayer(eLoopPlayer) >= GC.getGame().getGameSpeedInfo().getRelationshipDuration())
				{
					SetDenouncedPlayer(eLoopPlayer, false);

					// Notify the target of the denouncement that it has expired.
					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotifications)
					{
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_THEIR_DENUNCIATION_EXPIRED_S");
						Localization::String	strInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_THEIR_DENUNCIATION_EXPIRED");
						Localization::String strTemp = strInfo;
						strTemp << GET_PLAYER(GetID()).getCivilizationShortDescriptionKey();
						pNotifications->Add(NOTIFICATION_DENUNCIATION_EXPIRED, strTemp.toUTF8(), strSummary, -1, -1, GetID(), eLoopPlayer);
					}
				}

				// Has our Friendship expired?
				if (IsDoFAccepted(eLoopPlayer) && GetTurnsSinceBefriendedPlayer(eLoopPlayer) >= GC.getGame().getGameSpeedInfo().getRelationshipDuration())
				{
					SetDoFAccepted(eLoopPlayer, false);
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), false);

					// Notify both parties that our friendship has expired.
					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED", GET_PLAYER(GetID()).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_FRIENDSHIP_EXPIRED, strBuffer, strSummary, -1, -1, GetID(), eLoopPlayer);				
					}

					pNotifications = GET_PLAYER(GetID()).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_FRIENDSHIP_EXPIRED, strBuffer, strSummary, -1, -1, eLoopPlayer, GetID());				
					}
				}
			}
		}
	}

	///////////////////////////////
	// Declaration Log Counter
	///////////////////////////////

	for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
	{
		eDeclaration = GetDeclarationLogTypeForIndex(iItem);

		if(eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
		{
			ChangeDeclarationLogTurnForIndex(iItem, 1);
		}
		else
		{
			SetDeclarationLogTurnForIndex(iItem, 0);
		}
	}

}



// ************************************
// Player Opinion & Approach
// ************************************



/// Does this AI have a gold quest active with any minor civ?
bool CvDiplomacyAI::IsHasActiveGoldQuest()
{
	//antonjs: consider: optimize
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if (GET_PLAYER(eMinor).GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_GIVE_GOLD))
			return true;
		if (GET_PLAYER(eMinor).GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_INVEST))
			return true;
	}
	return false;
}

/// Returns ePlayer's visible Diplomatic Approach towards us
MajorCivApproachTypes CvDiplomacyAI::GetVisibleApproachTowardsUs(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS || GET_PLAYER(ePlayer).isObserver()) return NO_MAJOR_CIV_APPROACH;

	if (IsAtWar(ePlayer))
	{
		return MAJOR_CIV_APPROACH_WAR;
	}

	if (!GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
	{
		return MAJOR_CIV_APPROACH_NEUTRAL;
	}

	return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetSurfaceApproach(GetID());
}

/// See if there's anything we need to change with our guesses as to other players' true Diplomatic Approaches towards us
void CvDiplomacyAI::DoUpdateApproachTowardsUsGuesses()
{
	return;
}


// ************************************
// Demands
// ************************************

/// Updates our desire to make a demand from a player
void CvDiplomacyAI::DoUpdateDemands()
{
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE) || GetPlayer()->IsVassalOfSomeone())
		return;

	CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> vePotentialDemandTargets;
	bool bExistingValidTarget = false;
	int iWarCount = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, false);
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		// Must be a valid player
		if (!IsPlayerValid(ePlayer))
			continue;

		if (!GET_PLAYER(ePlayer).isMajorCiv())
			continue;

		// Can't be at war
		if (IsAtWar(ePlayer))
			continue;

		// Have to be able to declare war against this player
		if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
			continue;

		// If we're planning a war, don't make a demand of them...doesn't mesh well
		if (GetWarGoal(ePlayer) != NO_WAR_GOAL_TYPE && GetWarGoal(ePlayer) != WAR_GOAL_DEMAND)
			continue;

		// Have to be able to contact this player
		if (GET_PLAYER(ePlayer).isHuman() && (GC.getGame().IsAllDiploStatementsDisabled() || GC.getGame().isReallyNetworkMultiPlayer()))
			continue;

		// Are we doing badly?
		if (GetPlayer()->IsNoNewWars())
			continue;

		// Is this a potential war target?
		if (!IsPotentialWarTarget(ePlayer))
			continue;

		// Don't make demands of them too often
		if (GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DEMAND) < 40)
			continue;

		// Can't make/accept demands if sanctioned
		if (pLeague != NULL && pLeague->IsTradeEmbargoed(GetID(), ePlayer))
			continue;

		// Is it sane to attack this player?
		if (!IsWarSane(ePlayer))
			continue;

		// If one of us doesn't have a capital, then stop...
		if (GetPlayer()->getCapitalCity() == NULL)
			continue;

		if (GET_PLAYER(ePlayer).getCapitalCity() == NULL)
			continue;

		// Good city attack target?
		if (!GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer))
			continue;

		int iWeight = (GetBoldness()/2);

		switch (GetPlayer()->GetProximityToPlayer(ePlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWeight += 10;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWeight -= 10;
			break;
		default:
			continue;
			break;
		}

		// Bad approach?
		switch (GetMajorCivApproach(ePlayer))
		{
		case MAJOR_CIV_APPROACH_HOSTILE:
			iWeight += 20;
			break;
		case MAJOR_CIV_APPROACH_GUARDED:
			iWeight += 10;
			break;
		case MAJOR_CIV_APPROACH_DECEPTIVE:
			iWeight += 10;
			break;
		case MAJOR_CIV_APPROACH_NEUTRAL:
			iWeight += (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY) ? -10 : -1000;
		default:
			continue;
			break;
		}

		switch (GetMajorCivOpinion(ePlayer))
		{
		case MAJOR_CIV_OPINION_UNFORGIVABLE:
			iWeight += 20;
			break;
		case MAJOR_CIV_OPINION_ENEMY:
			iWeight += 15;
			break;
		case MAJOR_CIV_OPINION_COMPETITOR:
			iWeight += 10;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			iWeight -= 5;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iWeight -= 15;
			break;
		default:
			continue;
			break;
		}

		// Good target?
		switch (GetPlayerTargetValue(ePlayer))
		{
		case TARGET_VALUE_SOFT:
			iWeight += 20;
			break;
		case TARGET_VALUE_FAVORABLE:
			iWeight += 10;
			break;
		case TARGET_VALUE_AVERAGE:
			iWeight -= 5;
			break;
		default:
			continue;
			break;
		}

		// We must be stronger than them militarily.
		switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
		{
		case STRENGTH_PATHETIC:
			iWeight += 30;
			break;
		case STRENGTH_WEAK:
			iWeight += 20;
			break;
		case STRENGTH_POOR:
			iWeight += 10;
			break;
		case STRENGTH_AVERAGE:
			iWeight -= 10;
			break;
		default:
			continue;
			break;
		}

		// Better for us if we're stronger than them economically.
		switch (GetPlayerEconomicStrengthComparedToUs(ePlayer))
		{
		case STRENGTH_PATHETIC:
			iWeight += 20;
			break;
		case STRENGTH_WEAK:
			iWeight += 10;
			break;
		case STRENGTH_POOR:
			iWeight += 5;
			break;
		case STRENGTH_AVERAGE:
			iWeight -= 5;
			break;
		case STRENGTH_STRONG:
			iWeight -= 15;
			break;
		case STRENGTH_POWERFUL:
			iWeight -= 25;
			break;
		default:
			continue;
			break;
		}

		// Easy target?
		if (IsEasyTarget(ePlayer))
		{
			iWeight += 20;
		}

		// Already at war?
		if (iWarCount > 0)
		{
			iWeight -= (iWarCount * 10);
		}

		if (iWeight <= 0)
		{
			continue;
		}

		int iDemandValueScore = GetPlayerDemandValueScore(ePlayer);
		if (iDemandValueScore <= 0)
		{
			continue;
		}

		// Don't make demands if they're too far away...
		// Do this check last, for performance
		CvCity* pTheirClosestCity = GetPlayer()->GetClosestCityToUsByPlots(ePlayer);
		if (pTheirClosestCity == NULL)
			continue;

		int iDistanceTurns = GetPlayer()->GetCityDistancePathLength(pTheirClosestCity->plot());
		if (iDistanceTurns > 23)
			continue;

		iWeight += iDemandValueScore;

		// Is this our existing target?
		if (GetDemandTargetPlayer() == ePlayer)
		{
			bExistingValidTarget = true;
		}

		vePotentialDemandTargets.push_back(ePlayer, iWeight);
	}

	// Any valid possibilities?
	if (vePotentialDemandTargets.size() > 0)
	{
		// If we already have a valid demand target, don't assign a new one
		// Otherwise, start the demand process against the player with the highest weight
		if (!bExistingValidTarget)
		{
			SetDemandTargetPlayer(vePotentialDemandTargets.GetElement(0));
		}
	}
	else
	{
		SetDemandTargetPlayer(NO_PLAYER);
	}
}

/// How much value can we get from ePlayer if we made a demand of them?
int CvDiplomacyAI::GetPlayerDemandValueScore(PlayerTypes ePlayer)
{
	int iIdealValue = 25 * (GetPlayer()->GetDiplomacyAI()->GetMeanness() + GetPlayer()->GetCurrentEra());
	int Value = NUM_STRENGTH_VALUES - (int)GetPlayer()->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if (Value > 0)
	{
		iIdealValue *= Value;
	}
	else
	{
		return 0;
	}

	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		//End the gift exchange at the start of each round.
		GetPlayer()->GetDiplomacyAI()->SetOfferingGift(ePlayer, false);
		GetPlayer()->GetDiplomacyAI()->SetOfferedGift(ePlayer, false);
	}

	// We can use this deal pointer to form a trade offer
	CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

	pDeal->SetRequestingPlayer(NO_PLAYER);
	pDeal->SetFromPlayer(GetID());
	pDeal->SetToPlayer(ePlayer);
	pDeal->SetDuration(GC.getGame().getGameSpeedInfo().GetDealDuration());

	int iDemandValue = GetPlayer()->GetDealAI()->GetPotentialDemandValue(ePlayer, pDeal, iIdealValue);

	pDeal->ClearItems();

	if (iDemandValue < (iIdealValue/2))
		return 0;

	return iDemandValue;
}

/////////////////////////////////////////////////////////
// Requests
/////////////////////////////////////////////////////////




/// Is this AI willing to make a request of ePlayer?
bool CvDiplomacyAI::IsMakeRequest(PlayerTypes ePlayer, CvDeal* pDeal, bool& bRandPassed)
{
	bool bFriendly = GetSurfaceApproach(ePlayer) == MAJOR_CIV_APPROACH_FRIENDLY;

	if(bFriendly && IsDoFAccepted(ePlayer))
	{
		// Is there something we want?
		bool bWantsSomething = false;
		// Is there a strong reason why we want something? (added to rand roll)
		int iWeightBias = 0;

		// Luxury Request
		if(!bWantsSomething)
			bWantsSomething = IsLuxuryRequest(ePlayer, pDeal, iWeightBias);
		// Gold Request
		if(!bWantsSomething)
			bWantsSomething = IsGoldRequest(ePlayer, pDeal, iWeightBias);

		if(bWantsSomething)
		{
			// Random element
			int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			iRand += iWeightBias;

			if(iRand >= 7)
			{
				bRandPassed = true;
				return true;
			}
			else
			{
				bRandPassed = false;
				return false;
			}
		}
	}

	return false;
}

/// Does this AI want a luxury resource gift from ePlayer?
bool CvDiplomacyAI::IsLuxuryRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	iWeightBias = 0;

	ResourceTypes eLuxuryToAskFor = NO_RESOURCE;

	int iResourceLoop;

	// See if the other player has a Resource to trade
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if(pkResourceInfo)
		{
			// Only look at Luxuries
			if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(ePlayer, GetID(), TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			eLuxuryToAskFor = eResource;
			break;
		}
	}

	// Didn't find something they could give us?
	if(eLuxuryToAskFor == NO_RESOURCE)
		return false;

	// See if there's any Luxuries WE can trade (because if there are then we shouldn't be asking for hand outs)
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			// Only look at Luxuries
			if(pkResource->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GetPlayer()->getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(GetID(), ePlayer, TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			// Found something we can trade to them, so abort
			return false;
		}
	}

	// Add a little something extra since we're in dire straits
	if(GetPlayer()->IsEmpireUnhappy())
		iWeightBias += 5;

	// Now seed the deal
	pDeal->AddResourceTrade(ePlayer, eLuxuryToAskFor, 1, GC.getGame().GetDealDuration());

	return true;
}

/// Does this AI want a gold gift from ePlayer?
bool CvDiplomacyAI::IsGoldRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	iWeightBias = 0;

	int iOurGold = GetPlayer()->GetTreasury()->GetGold();
	int iOurGPT = GetPlayer()->calculateGoldRate();
	int iOurExpenses = GetPlayer()->GetTreasury()->CalculateInflatedCosts();
	int iOurGrossIncome = iOurGPT + iOurExpenses;

	// If we have no expenses, don't ask (and also don't crash)
	if(iOurExpenses == 0)
		return false;

	// If we already have some gold saved up then don't bother
	if(iOurGold > 100)
		return false;

	// If we're making 35% more than we're spending then don't ask, we're doing alright
	if(iOurGrossIncome * 100 / iOurExpenses > 135)
		return false;

	int iTheirGold = GET_PLAYER(ePlayer).GetTreasury()->GetGold();
	int iTheirGPT = GET_PLAYER(ePlayer).calculateGoldRate();
	int iTheirExpenses = GET_PLAYER(ePlayer).GetTreasury()->CalculateInflatedCosts();
	int iTheirGrossIncome = iTheirGPT + iTheirExpenses;

	// Don't divide by zero please
	if(iTheirExpenses != 0)
	{
		// If they're making less than 35% more than they're spending then don't ask, they're not in great shape
		if(iTheirGrossIncome * 100 / iTheirExpenses < 135)
			return false;
	}
	else if(iTheirGPT <= iOurGPT)
	{
		return false;
	}

	// Add a little something extra since we're in dire straits
	if(iOurGPT < 0)
		iWeightBias += 5;

	// If we've made it this far we'd like to ask, so figure out how much we want to ask for
	int iGoldToAskFor = iTheirGPT * GC.getGame().GetDealDuration() / 5;
	int iGPTToAskFor = 0;

	if(iGoldToAskFor > iTheirGold)
	{
		iGoldToAskFor = 0;
		iGPTToAskFor = max(1, iTheirGPT / 6);
	}

	// Now seed the deal
	if(iGoldToAskFor > 0)
		pDeal->AddGoldTrade(ePlayer, iGoldToAskFor);
	else if(iGPTToAskFor > 0)
		pDeal->AddGoldPerTurnTrade(ePlayer, iGPTToAskFor, GC.getGame().GetDealDuration());

	return true;
}

/// Are we willing to swap embassies with ePlayer?
bool CvDiplomacyAI::IsEmbassyExchangeAcceptable(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);

	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
	{
		return false;
	}

	if (IsUntrustworthy(ePlayer))
	{
		return false;
	}

	switch(eApproach)
	{
	case MAJOR_CIV_APPROACH_WAR:
	case MAJOR_CIV_APPROACH_HOSTILE:
	case MAJOR_CIV_APPROACH_GUARDED:
		return false;
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
	case MAJOR_CIV_APPROACH_AFRAID:
	case MAJOR_CIV_APPROACH_FRIENDLY:
	case MAJOR_CIV_APPROACH_NEUTRAL:
		return true;
		break;
	}

	return false;
}

/// What are our opinions of this player's neigbors?
MajorCivOpinionTypes CvDiplomacyAI::GetNeighborOpinion(PlayerTypes ePlayer) const
{
	if (ePlayer == NO_PLAYER)
	{
		return NO_MAJOR_CIV_OPINION;
	}

	int iBad = 0;
	int iNeutral = 0;
	int iGood = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer, true) && GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
		{
			if (GetMajorCivOpinion(eLoopPlayer) <= MAJOR_CIV_OPINION_COMPETITOR)
			{
				iBad++;
			}
			else if (GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_NEUTRAL)
			{
				iNeutral++;
			}
			else if (GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
			{
				iGood++;
			}
		}
	}
	if (iGood > iNeutral && iGood > iBad)
	{
		return MAJOR_CIV_OPINION_FRIEND;
	}
	else if (iNeutral > iGood && iNeutral > iBad)
	{
		return MAJOR_CIV_OPINION_NEUTRAL;
	}
	else if (iBad > iGood && iBad > iNeutral)
	{
		return MAJOR_CIV_OPINION_ENEMY;
	}
	else
	{
		return NO_MAJOR_CIV_OPINION;
	}
}

bool CvDiplomacyAI::MusteringForNeighborAttack(PlayerTypes ePlayer) const
{
	if (ePlayer == NO_PLAYER)
	{
		return false;
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
		{
			if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(m_pPlayer->getTeam()))
			{
				return true;
			}
			if (IsArmyInPlaceForAttack(eLoopPlayer))
			{
				return true;
			}
			if (m_pPlayer->HasAnyOffensiveOperationsAgainstPlayer(eLoopPlayer))
			{
				return true;
			}
			if (GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE)
			{
				return true;
			}
		}
	}

	return false;
}

/// Do we want to have an embassy in the player's capital? - this is only used for when to trigger an AI request, not whether or not the AI will accept a deal period
bool CvDiplomacyAI::WantsEmbassyAtPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
	{
		return false;
	}

	// May want to make this logic more sophisticated eventually. This will do for now.
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
	if(eApproach <= MAJOR_CIV_APPROACH_HOSTILE)
	{
		return false;
	}
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	if(IsArmyInPlaceForAttack(ePlayer))
	{
		return false;
	}
	if(IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
#endif

	return true;
}

/// Are we willing to accept Open Borders from eOtherPlayer?
bool CvDiplomacyAI::IsWantsOpenBordersWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
	{
		return false;
	}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (IsVassal(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetID()))
		return true;
#endif

#if defined (MOD_BALANCE_FLIPPED_TOURISM_MODIFIER_OPEN_BORDERS)
	//If they need influence over us, we don't want their OB, thanks.
	if ((GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) > INFLUENCE_LEVEL_FAMILIAR) && (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(m_pPlayer->GetID()) >= INFLUENCE_TREND_STATIC))
	{
		return false;
	}
#else
	//If we need influence over them, we want their OB, thanks.
	if ((m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) > INFLUENCE_LEVEL_FAMILIAR) && (m_pPlayer->GetCulture()->GetInfluenceTrend(ePlayer) >= INFLUENCE_TREND_STATIC))
	{
		return true;
	}
#endif

#if defined(MOD_BALANCE_CORE)
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
	{
		return false;
	}
	if(IsArmyInPlaceForAttack(ePlayer))
	{
		return false;
	}
	if(IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
	if (IsHasDefensivePact(ePlayer) || IsDoFAccepted(ePlayer))
	{
		return true;
	}
#endif

	if(m_pPlayer->IsCramped() || (GET_PLAYER(ePlayer).getNumCities() * 3) > (m_pPlayer->getNumCities() * 2))
	{
		return true;
	}

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);
	if (eApproach >= MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE)
	EconomicAIStrategyTypes eNeedRecon = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON");
	EconomicAIStrategyTypes eNavalRecon = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON_SEA");
	if(eNeedRecon != NO_ECONOMICAISTRATEGY && m_pPlayer->GetEconomicAI()->IsUsingStrategy(eNeedRecon))
	{
		return true;
	}
	if(eNavalRecon != NO_ECONOMICAISTRATEGY && m_pPlayer->GetEconomicAI()->IsUsingStrategy(eNavalRecon))
	{
		CvCity* pLoopCity = NULL;
		int iCityLoop;
		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
		{
			if(pLoopCity != NULL && pLoopCity->isCoastal())
			{
				return true;
			}
		}
	}
	if(MusteringForNeighborAttack(ePlayer) || IsGoingForWorldConquest() || IsGoingForCultureVictory())
	{
		return true;
	}
	AICityStrategyTypes ePocketCity = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_POCKET_CITY");
	if(ePocketCity != NO_AICITYSTRATEGY && GetPlayer()->GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
	{
		CvCity* pLoopCity = NULL;
		int iCityLoop;
		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
		{
			if(pLoopCity != NULL && pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(ePocketCity))
			{
				return true;
			}
		}
	}
#endif
	return false;
}

/// Are we willing to give Open Borders to eOtherPlayer?
bool CvDiplomacyAI::IsWillingToGiveOpenBordersToPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
	{
		return false;
	}
	
#if defined(MOD_BALANCE_CORE)
	// Are they here to steal our PRICELESS ARCHAEOLOGICAL ARTIFACTS???
	if (GetNumArtifactsEverDugUp(ePlayer) > 0)
	{
		int iHiddenSites = GetPlayer()->GetEconomicAI()->GetVisibleHiddenAntiquitySitesOwnTerritory();
		int iNormalSites = GetPlayer()->GetEconomicAI()->GetVisibleAntiquitySitesOwnTerritory() - iHiddenSites;
		PolicyBranchTypes eArtistry = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true);
		
		if (iNormalSites > 0)
		{
			return false;
		}
		// Have they unlocked Artistry?
		if (iHiddenSites > 0 && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(eArtistry))
		{
			return false;
		}
	}
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDominationVictory())
	{
		return false;
	}
#endif

// If going for culture win we always want open borders against civs we need influence on
#if defined (MOD_BALANCE_FLIPPED_TOURISM_MODIFIER_OPEN_BORDERS)
	//If we need influence over them, we want to give OB, thanks.
	if ((m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) > INFLUENCE_LEVEL_FAMILIAR) && (m_pPlayer->GetCulture()->GetInfluenceTrend(ePlayer) >= INFLUENCE_TREND_STATIC))
	{
		return true;
	}
#else
	//If we need influence over them, we want to give OB, thanks.
	if ((GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) > INFLUENCE_LEVEL_FAMILIAR) && (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(m_pPlayer->GetID()) >= INFLUENCE_TREND_STATIC))
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if (IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
	{
		return false;
	}
	if (IsArmyInPlaceForAttack(ePlayer) || IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
	if (IsHasDefensivePact(ePlayer) || IsDoFAccepted(ePlayer))
	{
		return true;
	}
#endif

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);
	if (eApproach >= MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}
	if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE)
	{
		return true;
	}

#if defined(MOD_BALANCE_CORE)
	if (!GET_PLAYER(ePlayer).isHuman() && GET_PLAYER(ePlayer).GetDiplomacyAI()->MusteringForNeighborAttack(m_pPlayer->GetID()))
	{
		return true;
	}
#endif
	return false;
}

/// Are we willing to swap Open Borders with ePlayer?
bool CvDiplomacyAI::IsOpenBordersExchangeAcceptable(PlayerTypes ePlayer)
{
	if (IsWillingToGiveOpenBordersToPlayer(ePlayer) && IsWantsOpenBordersWithPlayer(ePlayer))
		return true;

	return false;
}

// ************************************
// Peace!
// ************************************


/// Make peace with vassals if we're not at war with the master
void CvDiplomacyAI::DoMakePeaceWithVassals()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer != NO_PLAYER && IsPlayerValid(eLoopPlayer))
		{
			if (IsAtWar(eLoopPlayer) && GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassalOfSomeone())
			{
				TeamTypes eMaster = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetMaster();
				if (eMaster != NO_TEAM && !GET_TEAM(GetTeam()).isAtWar(eMaster))
				{
					GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetID());
				}
			}
		}
	}
}

/// Do we want to make peace with any Minors we're at war with?
void CvDiplomacyAI::DoMakePeaceWithMinors()
{
	//we want to do this only once per turn
	if (m_eDiploMode == DIPLO_SPECIFIC_PLAYER)
		return;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer != NO_PLAYER && GET_PLAYER(eLoopPlayer).isMinorCiv() && IsAtWar(eLoopPlayer))
		{
			if (GetPlayer()->IsVassalOfSomeone())
			{
				TeamTypes eMaster = GET_TEAM(GetTeam()).GetMaster();
				if (!GET_TEAM(eMaster).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetID());
					LogPeaceMade(eLoopPlayer);
				}
			}
			else if (IsWantsPeaceWithPlayer(eLoopPlayer))
			{
				GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetID());
				LogPeaceMade(eLoopPlayer);
			}
		}
	}
}


/////////////////////////////////////////////////////////
// Planning Exchanges
/////////////////////////////////////////////////////////

/// Is this war not worth caring about?
bool CvDiplomacyAI::IsPhonyWar(PlayerTypes ePlayer, bool bFromApproachSelection /* = false */) const
{
	if (!IsAtWar(ePlayer))
		return false;

	// Approach is WAR
	if (!bFromApproachSelection && GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_WAR)
		return false;

	// They captured our cities before, don't dismiss them.
	if (GetNumCitiesCapturedBy(ePlayer) > 0)
		return false;

	// War state too high or too low
	WarStateTypes eWarState = GetWarState(ePlayer);
	if (eWarState == WAR_STATE_NEARLY_WON || eWarState == WAR_STATE_DEFENSIVE || eWarState == WAR_STATE_NEARLY_DEFEATED)
		return false;

	// War score is too high
	int iWarScore = GetPlayer()->GetDiplomacyAI()->GetWarScore(ePlayer);
	if (iWarScore <= -25 || iWarScore >= 25)
		return false;

	// We want to conquer them!
	if (IsWantsToConquer(ePlayer))
		return false;

	// We have offensive operations ongoing.
	if (m_pPlayer->HasAnyOffensiveOperationsAgainstPlayer(ePlayer))
		return false;

	// Our cities are threatened by them
	if (GetPlayer()->GetDiplomacyAI()->GetNumberOfThreatenedCities(ePlayer) > 0)
		return false;

	// They're too close or have a lot of soldiers nearby
	PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
	AggressivePostureTypes ePosture = GetMilitaryAggressivePosture(ePlayer);
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

	if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
	{
		return false;
	}
	else if (eProximity == PLAYER_PROXIMITY_CLOSE)
	{
		if (ePosture >= AGGRESSIVE_POSTURE_MEDIUM || eMilitaryStrength >= STRENGTH_POWERFUL)
			return false;
	}
	else
	{
		if (ePosture >= AGGRESSIVE_POSTURE_HIGH || eMilitaryStrength == STRENGTH_IMMENSE)
			return false;
	}

	return true;
}

/// Does the AI even want to conquer another player if they are at war?
/// Since there is no "defensive war" flag, this seems to be the best way to differentiate
bool CvDiplomacyAI::IsWantsToConquer(PlayerTypes ePlayer) const
{
	if (!IsAtWar(ePlayer))
		return false;

	if (IsAlwaysAtWar(ePlayer))
		return true;
	
	if (GC.getGame().countMajorCivsAlive() == 2)
		return true;
	
	if (GetPlayer()->IsAITeammateOfHuman())
		return true;

	// Doing well already - let's keep it up.
	if (GetWarState(ePlayer) >= WAR_STATE_OFFENSIVE)
		return true;

	// Captured one of our key cities?
	if (IsCapitalCapturedBy(ePlayer, true, false) || IsHolyCityCapturedBy(ePlayer, true, false))
		return true;
	
	// If they're about to win, we have nothing to lose!
	if (IsEndgameAggressiveTo(ePlayer))
		return true;

	// If we're in bad shape for war, retreat!
	if (GetPlayer()->IsNoNewWars())
		return false;
	
	TargetValueTypes eTargetValue = GetPlayerTargetValue(ePlayer);
	bool bWeHaveGoodAttackTarget = GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer);
	bool bBold = GetBoldness() > 6 || GetPlayer()->GetPlayerTraits()->IsWarmonger() || (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION);

	// They're an easy target, so play offensively!
	if (IsEasyTarget(ePlayer) && bWeHaveGoodAttackTarget)
		return true;

	// We started or wanted this war - if they're not a bad target we should attack at full force
	if (IsAggressor(ePlayer))
	{
		// Bad target
		if (eTargetValue == TARGET_VALUE_IMPOSSIBLE || (eTargetValue == TARGET_VALUE_BAD && !bWeHaveGoodAttackTarget))
		{
			// Bold and fiercely competitive players don't give up so easily
			if (IsMajorCompetitor(ePlayer) && bBold)
			{
				return true;
			}

			// We're in a coop war with another player against this guy
			if (GetGlobalCoopWarAgainstState(ePlayer) >= COOP_WAR_STATE_PREPARING)
			{
				return true;
			}

			return false;
		}

		return true;
	}
	// Didn't start or want this war - don't care as much
	else
	{
		// Bold and nearby players
		if (bBold && GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE)
		{
			if (eTargetValue == TARGET_VALUE_IMPOSSIBLE)
			{
				return false;
			}
			else if (eTargetValue == TARGET_VALUE_BAD && !bWeHaveGoodAttackTarget)
			{
				return false;
			}
		}
		// Other players
		else if (eTargetValue <= TARGET_VALUE_BAD || (eTargetValue == TARGET_VALUE_AVERAGE && !bWeHaveGoodAttackTarget))
		{
			return false;
		}
	}

	return true; //by default we conquer everything
}

/// Is this major civ a potential military target or threat?
bool CvDiplomacyAI::IsPotentialMilitaryTargetOrThreat(PlayerTypes ePlayer, bool bFromApproachSelection /* = false */) const
{
	if (!GET_PLAYER(ePlayer).isMajorCiv() || !GET_PLAYER(ePlayer).isAlive() || GET_PLAYER(ePlayer).getNumCities() <= 0)
		return false;

	if (IsTeammate(ePlayer) || IsVassal(ePlayer) || GET_PLAYER(ePlayer).IsVassalOfSomeone())
		return false;

	if (IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer) || GetNumCitiesCapturedBy(ePlayer) > 0)
		return true;

	// If they've lost their capital to someone else, we can ignore them unless they're stronger...
	if (GET_PLAYER(ePlayer).IsHasLostCapital() && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCapitalCapturedBy(GetID()) && GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE)
		return false;

	// We trust our friends.
	if ((IsDoFAccepted(ePlayer) || IsHasDefensivePact(ePlayer)) && !IsUntrustworthy(ePlayer))
		return false;

	if (!bFromApproachSelection)
	{
		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
		if (eApproach != NO_MAJOR_CIV_APPROACH && eApproach <= MAJOR_CIV_APPROACH_AFRAID)
			return true;
	}

	if (GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE)
	{
		if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE || GetPlayerEconomicStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE)
			return true;

		if (GetMilitaryThreat(ePlayer) >= THREAT_MAJOR || GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
			return true;

		// If they're equal or one level below us in strength, let's check diplomacy
		if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) >= STRENGTH_POOR)
		{
			// Backstabber?
			if (IsUntrustworthy(ePlayer))
				return true;

			// Denouncement in either direction?
			if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer))
				return true;

			if (GetNumWarsDeclaredOnUs(ePlayer) > 0)
				return true;

			// Any reason for them to be mad at us?
			PlayerTypes eMyPlayer = GetID();
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCapitalCapturedBy(eMyPlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHolyCityCapturedBy(eMyPlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumCitiesCapturedBy(ePlayer) > 0)
				return true;

			MajorCivApproachTypes eApproachTowardsUs = GetVisibleApproachTowardsUs(ePlayer);
			if (eApproachTowardsUs != NO_MAJOR_CIV_APPROACH && eApproachTowardsUs <= MAJOR_CIV_APPROACH_GUARDED)
				return true;
		}
	}

	return false;
}

/// Returns if this player has been nuked by ePlayer
bool CvDiplomacyAI::IsNukedBy(PlayerTypes ePlayer) const
{
	return (GetNumTimesNuked(ePlayer) > 0);
}

/// Is this player a friend or ally in any way? Quick heuristic check that only checks for good things.
bool CvDiplomacyAI::IsFriendOrAlly(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer))
		return true;

	if (!GET_PLAYER(ePlayer).isAlive())
		return false;

	if (IsDoFAccepted(ePlayer))
		return true;

	if (IsHasDefensivePact(ePlayer))
		return true;

	if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
		return true;

	if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES)
		return true;

	if (WasResurrectedBy(ePlayer))
		return true;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetID()))
		return true;

	return false;
}

/// Is this player causing us problems in the early game?
bool CvDiplomacyAI::IsEarlyGameCompetitor(PlayerTypes ePlayer)
{
	// Not the early game
	if (GetPlayer()->GetCurrentEra() > 2)
		return false;

	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return true;

	if (GetLandDisputeLevel(ePlayer) > DISPUTE_LEVEL_WEAK)
		return true;

	if (GetNumWondersBeatenTo(ePlayer) > 0)
		return true;

	if (GetNumDemandEverMade(ePlayer) > 0)
		return true;

	if (GetNegativeReligiousConversionPoints(ePlayer) > 0)
		return true;

	if (GetNumTimesTheyPlottedAgainstUs(ePlayer) > 0)
		return true;

	if (IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
		return true;

	// Major early lead in techs/policies? Let's slow that down.
	if (GetPolicyBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG || GetTechBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		return true;

	// Special check for England / Statecraft
	if (GetNumTimesRobbedBy(ePlayer) > 0 || GetNumTimesPerformedCoupAgainstUs(ePlayer) > 0)
		return true;

	if (IsPlayerIgnoredBullyCityStatePromise(ePlayer) || IsPlayerBrokenBullyCityStatePromise(ePlayer) || IsAngryAboutProtectedMinorAttacked(ePlayer) || IsAngryAboutProtectedMinorKilled(ePlayer))
		return true;

	if (IsUntrustworthy(ePlayer))
		return true;

	// Are they a juicy target?
	if (IsEasyTarget(ePlayer) || GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(ePlayer))
	{
		PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
		bool bRecklessExpander = IsPlayerRecklessExpander(ePlayer);
		bool bWonderSpammer = IsPlayerWonderSpammer(ePlayer);

		if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
		{
			if (bRecklessExpander || bWonderSpammer)
				return true;
		}
		else if (eProximity == PLAYER_PROXIMITY_CLOSE)
		{
			if (IsConqueror())
			{
				if (bRecklessExpander || bWonderSpammer)
					return true;
			}
			else if (IsCultural())
			{
				if (bWonderSpammer)
					return true;
			}
		}
	}

	return false;
}

/// Should we ignore Social Policy differences with ePlayer?
bool CvDiplomacyAI::IsIgnorePolicyDifferences(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer) || IsVassal(ePlayer) || IsMaster(ePlayer))
		return true;

	if (IsAtWar(ePlayer) || IsUntrustworthy(ePlayer))
		return false;

	// Capital or Holy City captured? Exception if they resurrected us: only test to see if they captured it.
	if (WasResurrectedBy(ePlayer))
	{
		vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
		for (size_t i=0; i<vTheirTeam.size(); i++)
		{
			if (IsPlayerCapturedCapital(vTheirTeam[i]) || IsPlayerCapturedHolyCity(vTheirTeam[i]))
				return false;
		}
	}
	else
	{
		if (IsCapitalCapturedBy(ePlayer))
			return false;
	}

	if (IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer) || IsPlayerReturnedCapital(ePlayer) || IsPlayerReturnedHolyCity(ePlayer) || WasResurrectedBy(ePlayer))
		return true;

	if (IsDoFAccepted(ePlayer) || GetDoFType(ePlayer) >= DOF_TYPE_ALLIES)
		return true;

	// Ideological or religious buddies tolerate policy differences.
	if (IsPlayerSameIdeology(ePlayer) || IsPlayerSameReligion(ePlayer))
		return true;

	if (IsCityRecentlyLiberatedBy(ePlayer))
		return true;

	// If they're helping us go to war, we'll set aside our differences for now.
	if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
		return true;

	return false;
}

/// Should we ignore religious differences with ePlayer?
bool CvDiplomacyAI::IsIgnoreReligionDifferences(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer) || IsMaster(ePlayer))
		return true;

	if (GetNegativeReligiousConversionPoints(ePlayer) > 0)
		return false;

	if (IsHolyCityCapturedBy(ePlayer))
		return false;

	// Capital captured? Exception if they resurrected us: only test to see if they captured it.
	if (WasResurrectedBy(ePlayer))
	{
		vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
		for (size_t i=0; i<vTheirTeam.size(); i++)
		{
			if (IsPlayerCapturedCapital(vTheirTeam[i]))
				return false;
		}
	}
	else
	{
		if (IsCapitalCapturedBy(ePlayer))
			return false;
	}

	// Special diplomatic behavior for Celts - no natural religion spread
	if (!HasEverConvertedCity(ePlayer) && !GET_PLAYER(ePlayer).GetDiplomacyAI()->HasEverConvertedCity(GetID()))
	{
		if (GetPlayer()->GetPlayerTraits()->IsNoNaturalReligionSpread())
			return true;

		if (GET_PLAYER(ePlayer).GetPlayerTraits()->IsNoNaturalReligionSpread())
			return true;
	}

	if (IsAtWar(ePlayer) || IsUntrustworthy(ePlayer))
		return false;

	// Ideological buddies tolerate religious differences.
	if (IsPlayerSameIdeology(ePlayer))
		return true;

	if (IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer) || IsPlayerReturnedCapital(ePlayer) || IsPlayerReturnedHolyCity(ePlayer) || WasResurrectedBy(ePlayer) || GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		return true;

	if (IsCityRecentlyLiberatedBy(ePlayer))
		return true;

	// If they're helping us go to war, we'll set aside our differences for now.
	if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
		return true;

	return false;
}

/// Should we ignore ideological differences with ePlayer?
bool CvDiplomacyAI::IsIgnoreIdeologyDifferences(PlayerTypes ePlayer) const
{
	if (IsTeammate(ePlayer) || IsVassal(ePlayer) || IsMaster(ePlayer))
		return true;

	if (IsAtWar(ePlayer) || IsUntrustworthy(ePlayer))
		return false;

	// Capital or Holy City captured? Exception if they resurrected us: only test to see if they captured it.
	if (WasResurrectedBy(ePlayer))
	{
		vector<PlayerTypes> vTheirTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
		for (size_t i=0; i<vTheirTeam.size(); i++)
		{
			if (IsPlayerCapturedCapital(vTheirTeam[i]) || IsPlayerCapturedHolyCity(vTheirTeam[i]))
				return false;
		}
	}
	else
	{
		if (IsCapitalCapturedBy(ePlayer))
			return false;
	}

	if (IsPlayerLiberatedCapital(ePlayer) || WasResurrectedBy(ePlayer) || GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		return true;

	// If they're helping us go to war, we'll set aside our differences for now.
	if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
		return true;

#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	// Cold War resolution active?
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && pLeague != NULL)
	{
		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer))
			{
				if (GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetID(), eLoopPlayer))
				{
					return false;
				}
			}
		}
	}
#endif

	if (IsPlayerLiberatedHolyCity(ePlayer) || IsCityRecentlyLiberatedBy(ePlayer))
		return true;

	return false;
}

/// Is this player causing trouble around our Minor Civs?
bool CvDiplomacyAI::IsMinorCivTroublemaker(PlayerTypes ePlayer, bool bIgnoreBullying /* = false */) const
{
	if (GetMinorCivDisputeLevel(ePlayer) > DISPUTE_LEVEL_WEAK)
		return true;
	
	if (GetNumTimesPerformedCoupAgainstUs(ePlayer) > 0)
		return true;
	
	if (IsAngryAboutProtectedMinorKilled(ePlayer) || IsAngryAboutProtectedMinorAttacked(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer) || IsPlayerIgnoredAttackCityStatePromise(ePlayer))
		return true;
	
	if (!bIgnoreBullying)
	{
		if (IsAngryAboutProtectedMinorBullied(ePlayer) || IsPlayerBrokenBullyCityStatePromise(ePlayer) || IsPlayerIgnoredBullyCityStatePromise(ePlayer))
			return true;
	}
	
	return false;
}

/// Is this player our prime competitor in the World Congress / United Nations by vote count?
bool CvDiplomacyAI::IsPrimeLeagueCompetitor(PlayerTypes ePlayer) const
{
	// We're not competing for victory, so we don't care.
	if (!IsCompetingForVictory())
		return false;
	
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
		
	if (pLeague == NULL)
		return false;

	int iBestVotes = pLeague->GetCoreVotesForMember(GetID());
	PlayerTypes eDiploLoopPlayer;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eDiploLoopPlayer = (PlayerTypes) iPlayerLoop;
	
		if (IsPlayerValid(eDiploLoopPlayer))
		{
			if (eDiploLoopPlayer == ePlayer)
				continue;
		
			int iVotes = pLeague->CalculateStartingVotesForMember(eDiploLoopPlayer);
		
			if (iVotes > iBestVotes)
				iBestVotes = iVotes;
		}
	}
	
	// Prime competitor?
	if (pLeague->CalculateStartingVotesForMember(ePlayer) > iBestVotes)
	{
		return true;
	}
	
	return false;
}

/// Diplomacy AI Options
/// Should we specifically hide dispute-related modifiers towards ePlayer?
bool CvDiplomacyAI::ShouldHideDisputeMods(PlayerTypes ePlayer) const
{
	// Game options forbid hiding.
	if (GC.getGame().IsShowAllOpinionModifiers())
		return false;

	// If we're at war, don't bother.
	if (IsAtWar(ePlayer))
		return false;

	// If we've declared war on them previously, let's be honest about disputes.
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumWarsDeclaredOnUs(GetID()) > 0)
		return false;

	// If we're their vassal, don't bother.
	if (IsVassal(ePlayer))
		return false;

	// If we've denounced them, don't bother.
	if (IsDenouncedPlayer(ePlayer))
		return false;

	// If they've resurrected us, let's be honest.
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer))
		return false;

	// If they're untrustworthy, don't bother hiding anything.
	if (IsUntrustworthy(ePlayer))
		return false;

	MajorCivApproachTypes eSurfaceApproach = GetSurfaceApproach(ePlayer);

	// Only hide if our surface approach is FRIENDLY or AFRAID
	if (eSurfaceApproach == MAJOR_CIV_APPROACH_FRIENDLY || eSurfaceApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	return false;
}

/// Should we hide certain negative opinion modifiers towards ePlayer? (stuff like competition, warmongering etc)
/// NOTE: If both hiding dispute mods and hiding negative mods, dispute mods will show up as if the DisputeLevel was NONE. Otherwise, dispute mods are treated separately.
bool CvDiplomacyAI::ShouldHideNegativeMods(PlayerTypes ePlayer) const
{
	// Game options forbid hiding.
	if (GC.getGame().IsShowAllOpinionModifiers())
		return false;

	// If we're their vassal, don't bother.
	if (IsVassal(ePlayer))
		return false;

	// If we've denounced them, don't bother.
	if (IsDenouncedPlayer(ePlayer))
		return false;

	// If they've resurrected us, let's be honest.
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer))
		return false;

	// If they're untrustworthy, don't bother hiding anything.
	if (IsUntrustworthy(ePlayer))
		return false;

	// If we're in a war that we wanted to declare, let's show our true colors.
	if (IsAtWar(ePlayer) && IsAggressor(ePlayer))
		return false;

	MajorCivApproachTypes eSurfaceApproach = GetSurfaceApproach(ePlayer);

	// Always hide if our surface approach is FRIENDLY (and not at war) or AFRAID
	if ((eSurfaceApproach == MAJOR_CIV_APPROACH_FRIENDLY && !IsAtWar(ePlayer)) || eSurfaceApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// Never hide if our surface approach is HOSTILE
	if (eSurfaceApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	// If we're acting hostile, don't hide anything.
	if (IsActHostileTowardsHuman(ePlayer, true))
		return false;

	// If they're a favorable target, let's not bother hiding things.
	if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) < STRENGTH_POWERFUL)
	{
		if (IsEasyTarget(ePlayer) || GetPlayerTargetValue(ePlayer) >= TARGET_VALUE_FAVORABLE)
			return false;
	}

	return true; // Let's conceal our negative thoughts!
}


// ************************************
// Evaluation of Other Players' Tendencies
// ************************************


/// ePlayer made peace with someone, so figure out what that means
void CvDiplomacyAI::DoWeMadePeaceWithSomeone(TeamTypes eOtherTeam)
{
	if (eOtherTeam < 0 || eOtherTeam >= MAX_CIV_TEAMS) return;

	for (int iPeacePlayerLoop = 0; iPeacePlayerLoop < MAX_CIV_PLAYERS; iPeacePlayerLoop++)
	{
		PlayerTypes ePeacePlayer = (PlayerTypes) iPeacePlayerLoop;

		if (GET_PLAYER(ePeacePlayer).getTeam() == eOtherTeam)
		{
			// In case we had an ongoing operation, kill it
			SetArmyInPlaceForAttack(ePeacePlayer, false);
			SetWantsSneakAttack(ePeacePlayer, false);

			// Reset aggressor status
			SetAggressor(ePeacePlayer, false);

			if (GET_PLAYER(ePeacePlayer).isMajorCiv())
			{
				CancelCoopWarsAgainstPlayer(ePeacePlayer);
			}
			else if (GET_PLAYER(ePeacePlayer).isMinorCiv())
			{
				// Reset flags for taunt messages we sent to other civs about attacking this minor
				ResetSentAttackProtectedMinorTaunts(ePeacePlayer);
			}

			// Reset number of turns locked into war
			GET_TEAM(GetTeam()).SetNumTurnsLockedIntoWar(GET_PLAYER(ePeacePlayer).getTeam(), 0);
		}
	}
}

/// ePlayer declared war on someone, so figure out what that means
void CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone(PlayerTypes ePlayer, TeamTypes eOtherTeam, bool bDefensivePact)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS || GET_PLAYER(ePlayer).isBarbarian()) return;
	if (eOtherTeam < 0 || eOtherTeam >= MAX_CIV_TEAMS || GET_TEAM(eOtherTeam).isBarbarian()) return;
	
	PlayerTypes eMyPlayer = GetID();
	bool bMajorAttackedMajor = false;

	for (int iAttackedPlayerLoop = 0; iAttackedPlayerLoop < MAX_CIV_PLAYERS; iAttackedPlayerLoop++)
	{
		PlayerTypes eAttackedPlayer = (PlayerTypes) iAttackedPlayerLoop;

		if (GET_PLAYER(eAttackedPlayer).getTeam() == eOtherTeam)
		{
			// We were attacked! Change appropriate diplomacy stuff!
			if (eAttackedPlayer == eMyPlayer)
			{
				ChangeNumWarsFought(ePlayer, 1);

				if (!bDefensivePact)
				{
					ChangeNumWarsDeclaredOnUs(ePlayer, 1);
				}
				
				// Only stuff for major civs
				if (!GET_PLAYER(ePlayer).isMajorCiv())
					continue;

				if (!bDefensivePact)
				{
					bool bBackstabTimer = (IsDoFBroken(ePlayer) && GetTurnsSinceDoFBroken(ePlayer) < /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER());

					// WAS working with this player
					if (IsDoFAccepted(ePlayer) || bBackstabTimer)
					{
						ChangeRecentAssistValue(ePlayer, 300);
						SetDoFBroken(ePlayer, true, true);
						SetFriendDeclaredWarOnUs(ePlayer, true);
					}
				}

				// Reset DoF values
				SetDoFAccepted(ePlayer, false);
				SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(eMyPlayer, DOF_TYPE_UNTRUSTWORTHY);

				SetShareOpinionAccepted(ePlayer, false);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetShareOpinionAccepted(eMyPlayer, false);

				// End all coop war agreements with this player
				CancelCoopWarsWithPlayer(ePlayer, !bDefensivePact);

				// Reset various promises for both of us...all is fair in war!
				if (IsPlayerMadeExpansionPromise(ePlayer))
				{
					SetPlayerExpansionPromiseState(ePlayer, NO_PROMISE_STATE);
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(eMyPlayer))
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerExpansionPromiseState(eMyPlayer, NO_PROMISE_STATE);
				}
				if (IsPlayerMadeBorderPromise(ePlayer))
				{
					SetPlayerBorderPromiseState(ePlayer, NO_PROMISE_STATE);
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeBorderPromise(eMyPlayer))
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBorderPromiseState(eMyPlayer, NO_PROMISE_STATE);
				}
				if (IsPlayerMadeSpyPromise(ePlayer))
				{
					SetPlayerSpyPromiseState(ePlayer, NO_PROMISE_STATE);
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeSpyPromise(eMyPlayer))
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerSpyPromiseState(eMyPlayer, NO_PROMISE_STATE);
				}
				
				// Player broke a promise that he wasn't going to attack us
				if (IsPlayerMadeMilitaryPromise(ePlayer))
				{
					if (!bDefensivePact)
						SetPlayerMilitaryPromiseState(ePlayer, PROMISE_STATE_BROKEN);
					else
						SetPlayerMilitaryPromiseState(ePlayer, NO_PROMISE_STATE);
				}

				// Cancel any military promises
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(eMyPlayer))
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState(eMyPlayer, NO_PROMISE_STATE);
				}
				if (MOD_DIPLOMACY_CIV4_FEATURES)
				{
					SetPlayerMoveTroopsRequestAccepted(ePlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMoveTroopsRequestAccepted(eMyPlayer, false);
				}

				// We're no longer trade partners
				SetRecentTradeValue(ePlayer, 0);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetRecentTradeValue(eMyPlayer, 0);
				
				// Clear penalties for stealing territory during peacetime
				if (!GetPlayer()->isHuman())
				{
					SetNumTimesCultureBombed(ePlayer, 0);
				}
				if (!GET_PLAYER(ePlayer).isHuman())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetNumTimesCultureBombed(eMyPlayer, 0);
				}

				if (!bDefensivePact)
				{
					// Forget any of that liberation crud!
					SetResurrectedBy(ePlayer, false);
					SetPlayerLiberatedCapital(ePlayer, false);
					SetPlayerLiberatedHolyCity(ePlayer, false);
					SetNumCitiesLiberatedBy(ePlayer, 0);
					SetPlayerReturnedCapital(ePlayer, false);
					SetPlayerReturnedHolyCity(ePlayer, false);
					SetMasterLiberatedMeFromVassalage(ePlayer, false);
					SetVassalagePeacefullyRevokedTurn(ePlayer, -1);
					
					// Forget civilians returned, landmarks built, and intrigue shared so they don't affect relations any more
					SetNumCiviliansReturnedToMe(ePlayer, 0);
					SetNumLandmarksBuiltForMe(ePlayer, 0);
					SetNumTimesIntrigueSharedBy(ePlayer, 0);
					
					// Clear positive diplomatic values					
					SetCommonFoeValue(ePlayer, 0);
					if (GetRecentAssistValue(ePlayer) < 0)
						SetRecentAssistValue(ePlayer, 0);
				}
			}

			// If it's us OR we know the attacked player, change appropriate values
			if (IsPlayerValid(eAttackedPlayer, true) && GET_PLAYER(ePlayer).isMajorCiv())
			{
				if (GET_PLAYER(eAttackedPlayer).isMajorCiv())
				{
					bMajorAttackedMajor = true;

					if (!bDefensivePact)
					{
						ChangeOtherPlayerNumMajorsAttacked(ePlayer, 1, eOtherTeam);

						if (GetTeam() != eOtherTeam && !IsAtWar(ePlayer) && !IsUntrustworthy(ePlayer))
						{
							// If we view the target as a backstabber, apply a large diplo bonus.
							if (IsUntrustworthy(eAttackedPlayer))
							{
								ChangeRecentAssistValue(ePlayer, -300);
							}
							// Did they declare war on someone we're at war with?
							else if (IsAtWar(eAttackedPlayer))
							{
								// If we're doing badly in the war, we appreciate the assistance.
								switch (GetWarState(eAttackedPlayer))
								{
								case WAR_STATE_NEARLY_WON:
								case WAR_STATE_OFFENSIVE:
									break;
								case WAR_STATE_CALM:
									ChangeRecentAssistValue(ePlayer, -50);
									break;
								case WAR_STATE_STALEMATE:
									ChangeRecentAssistValue(ePlayer, -100);
									break;
								case WAR_STATE_DEFENSIVE:
									ChangeRecentAssistValue(ePlayer, -200);
									break;
								case WAR_STATE_NEARLY_DEFEATED:
									ChangeRecentAssistValue(ePlayer, -300);
									break;
								}
							}
						}
					}
				}

				else if (GET_PLAYER(eAttackedPlayer).isMinorCiv() && !bDefensivePact)
				{
					// Did they attack a Minor we're protecting?
					bool bProtected = GET_PLAYER(eAttackedPlayer).GetMinorCivAI()->IsProtectedByMajor(eMyPlayer) || GET_PLAYER(eAttackedPlayer).GetMinorCivAI()->IsAllies(eMyPlayer);

					if (bProtected)
					{
						SetOtherPlayerAttackedProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());
						SetOtherPlayerProtectedMinorAttacked(ePlayer, eAttackedPlayer);
					}

					int iTurn = GET_PLAYER(eAttackedPlayer).GetMinorCivAI()->GetTurnLastAttacked(GET_PLAYER(ePlayer).getTeam());

					// Only apply this penalty once!
					if (bProtected && iTurn == -1 && GetOtherPlayerNumProtectedMinorsAttacked(ePlayer) >= 2)
					{
						ChangeOtherPlayerNumProtectedMinorsAttacked(ePlayer, 1);
					}

					// Only apply warmongering if they haven't attacked this minor within the last 50 turns...and any minors within the last 10 turns
					// Prevents infinite warmongering exploits, etc.
					int iTurnDifference = GC.getGame().getGameTurn() - iTurn;
					if (iTurn > -1 && iTurnDifference < 50)
						return;

					iTurn = GET_PLAYER(ePlayer).GetTurnsSinceLastAttackedMinorCiv();
					if (iTurn > -1 && iTurn < 10)
						return;

					ChangeOtherPlayerNumMinorsAttacked(ePlayer, 1, eOtherTeam);
				}
			}
		}
	}
}

/// ePlayer killed eDeadPlayer, so figure out what that means
void CvDiplomacyAI::DoPlayerKilledSomeone(PlayerTypes ePlayer, PlayerTypes eDeadPlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	if (eDeadPlayer < 0 || eDeadPlayer >= MAX_CIV_PLAYERS) return;

	if (IsPlayerValid(ePlayer))
	{
		// Minor Civ
		if (GET_PLAYER(eDeadPlayer).isMinorCiv())
		{
			// Did they kill a Minor we're protecting?
			if (GET_PLAYER(eDeadPlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
			{
				SetOtherPlayerKilledProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());
				SetOtherPlayerProtectedMinorKilled(ePlayer, eDeadPlayer);
				ChangeOtherPlayerNumProtectedMinorsKilled(ePlayer, 1);

				// Player broke a promise that he wasn't going to kill the Minor
				if (IsPlayerMadeAttackCityStatePromise(ePlayer))
				{
					SetPlayerAttackCityStatePromiseState(ePlayer, PROMISE_STATE_BROKEN);
				}
			}
		}
	}
}

/// ePlayer bullied eOtherPlayer (minor civ), so figure out what that means
void CvDiplomacyAI::DoPlayerBulliedSomeone(PlayerTypes ePlayer, PlayerTypes eOtherPlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;
	if (eOtherPlayer < MAX_MAJOR_CIVS || eOtherPlayer >= MAX_CIV_PLAYERS) return;

	// The bully was someone else
	if (IsPlayerValid(ePlayer))
	{
		// Did they bully a Minor we're protecting?
		if (GET_PLAYER(eOtherPlayer).isMinorCiv() && GET_PLAYER(eOtherPlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
		{
			// Only apply this penalty if they haven't bullied them already
			if (GET_PLAYER(eOtherPlayer).GetMinorCivAI()->GetTurnLastBulliedByMajor(ePlayer))
			{
				ChangeOtherPlayerNumProtectedMinorsBullied(ePlayer, 1);
			}

			SetOtherPlayerProtectedMinorBullied(ePlayer, eOtherPlayer);
			SetOtherPlayerBulliedProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());

			// You broke the promise you made!
			if (IsPlayerMadeBullyCityStatePromise(ePlayer))
			{
				SetPlayerBullyCityStatePromiseState(ePlayer, PROMISE_STATE_BROKEN);
			}
		}
	}
}

/// Someone met a new player
void CvDiplomacyAI::DoPlayerMetSomeone(PlayerTypes ePlayer, PlayerTypes eOtherPlayer)
{
	// Have to have met both players (since this function is called upon EVERY contact)
	if (IsPlayerValid(ePlayer) && IsPlayerValid(eOtherPlayer) && GET_PLAYER(ePlayer).isMajorCiv())
	{
		// Catch up on Public Declarations
		PublicDeclarationTypes eDeclaration;
		int iData1;
		int iData2;
		bool bActive;

		for (int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
		{
			// Did ePlayer just meet the person this declaration is about?
			if (GetDeclarationLogMustHaveMetPlayerForIndex(iLoop) == eOtherPlayer)
			{
				eDeclaration = GetDeclarationLogTypeForIndex(iLoop);

				// Does this entry in the log exist?
				if (eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
				{
					bActive = IsDeclarationLogForIndexActive(iLoop);

					// Is this still an active declaration?
					if (bActive)
					{
						iData1 = GetDeclarationLogData1ForIndex(iLoop);
						iData2 = GetDeclarationLogData2ForIndex(iLoop);

						DoMakePublicDeclaration(eDeclaration, iData1, iData2, eOtherPlayer, ePlayer);
					}
				}
			}
		}
	}
}

/// Return the value of the warmonger amount adjusted by how much this player hates warmongers
int CvDiplomacyAI::GetOtherPlayerWarmongerScore(PlayerTypes ePlayer)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	int iReturnValue = GetOtherPlayerWarmongerAmount(ePlayer);

	if (iReturnValue < 10)
		return 0;

	if (GetPlayer()->isHuman())
	{
		return (iReturnValue / 3);
	}

	// Modify warmonger amount based on diplomatic view of this player
	bool bUntrustworthy = false;

	if (IsDenouncedPlayer(ePlayer) || IsDenouncedByPlayer(ePlayer) || IsUntrustworthy(ePlayer))
	{
		bUntrustworthy = true;
	}

	if (!bUntrustworthy)
	{
		if (IsDoFAccepted(ePlayer) || GetDoFType(ePlayer) >= DOF_TYPE_ALLIES || GetCoopWarScore(ePlayer) > 0)
		{
			iReturnValue /= 2;
		}
		else if (GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
		{
			iReturnValue *= 75;
			iReturnValue /= 100;
		}
		else if (GetDoFType(ePlayer) == DOF_TYPE_FRIENDS)
		{
			iReturnValue *= 90;
			iReturnValue /= 100;
		}

		if (IsPlayerDPWithAnyFriend(ePlayer) || IsPlayerDoFWithAnyFriend(ePlayer) || IsPlayerDenouncedEnemy(ePlayer))
		{
			iReturnValue *= 75;
			iReturnValue /= 100;
		}
	}

	if (bUntrustworthy)
	{
		iReturnValue *= 150;
		iReturnValue /= 100;
	}
	if (IsPlayerDPWithAnyEnemy(ePlayer) || IsPlayerDoFWithAnyEnemy(ePlayer) || IsPlayerDenouncedFriend(ePlayer))
	{
		iReturnValue *= 125;
		iReturnValue /= 100;
	}
	// Large reduction if either of us resurrected the other
	if (WasResurrectedBy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetID()))
	{
		iReturnValue /= 2;
	}

	// Religion/ideology should impact this.
	if (IsPlayerSameReligion(ePlayer))
	{
		iReturnValue *= 75;
		iReturnValue /= 100;
	}
	else if (IsPlayerOpposingReligion(ePlayer) && !IsIgnoreReligionDifferences(ePlayer))
	{
		iReturnValue *= 125;
		iReturnValue /= 100;
	}

	if (IsPlayerSameIdeology(ePlayer))
	{
		iReturnValue *= 50;
		iReturnValue /= 100;
	}
	else if (IsPlayerOpposingIdeology(ePlayer) && !IsIgnoreIdeologyDifferences(ePlayer))
	{
		iReturnValue *= 150;
		iReturnValue /= 100;
	}

	iReturnValue *= GetWarmongerHate(); // ranges from 1 to 10
	iReturnValue /= 15;

	return iReturnValue;
}

/////////////////////////////////////////////////////////
// Contact
/////////////////////////////////////////////////////////

/// First contact between this player and another
void CvDiplomacyAI::DoFirstContact(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (ePlayer != GetID())
	{
		DoFirstContactInitRelationship(ePlayer);

		// Humans don't say hi to one another through the shadow diplo AI and, uh, don't show up in MP please
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH: notifications do get send in MP + updated to new 
			if (GC.getGame().isFinalInitialized())
			{
				if (!IsAtWar(ePlayer) && CvPreGame::isHuman(ePlayer))
				{
					const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_INTRO);
					CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DEFAULT_ROOT, szText, LEADERHEAD_ANIM_INTRO);
				}
			}
		}
		else
		{
			if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
			{
				if(!GetPlayer()->isHuman())
				{
					// Should fire off a diplo message when we meet a human
					if(GET_PLAYER(ePlayer).isHuman())
					{
						if(!IsAtWar(ePlayer))
						{
							if(GC.getGame().isFinalInitialized())
							{
								if(std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), ePlayer) == m_aGreetPlayers.end())
								{
									// Put in the list of people to greet when their turn comes up.
									m_aGreetPlayers.push_back(ePlayer);
								}
							}
						}
					}
				}
				else
				{
					// Human to Human will just send a notification
					CvPlayer& kTargetPlayer = GET_PLAYER(ePlayer);
					if(kTargetPlayer.isHuman())
					{
						if(!IsAtWar(ePlayer))
						{
							if(GC.getGame().isFinalInitialized())
							{
								CvNotifications* pNotifications = kTargetPlayer.GetNotifications();
								if(pNotifications)
								{
									CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GetPlayer()->getNameKey());
									pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strBuffer, -1, -1, GetID());
								}
							}
						}
					}
				}
			}
		}

#else
		if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
		{
			if(!GetPlayer()->isHuman())
			{
				// Should fire off a diplo message when we meet a human
				if(GET_PLAYER(ePlayer).isHuman())
				{
					if(!IsAtWar(ePlayer))
					{
						if(GC.getGame().isFinalInitialized())
						{
							if(std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), ePlayer) == m_aGreetPlayers.end())
							{
								// Put in the list of people to greet when their turn comes up.
								m_aGreetPlayers.push_back(ePlayer);
							}
						}
					}
				}
			}
			else
			{
				// Human to Human will just send a notification
				CvPlayer& kTargetPlayer = GET_PLAYER(ePlayer);
				if(kTargetPlayer.isHuman())
				{
					if(!IsAtWar(ePlayer))
					{
						if(GC.getGame().isFinalInitialized())
						{
							CvNotifications* pNotifications = kTargetPlayer.GetNotifications();
							if(pNotifications)
							{
								CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GetPlayer()->getNameKey());
								pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strBuffer, -1, -1, GetID());
							}
						}
					}
				}
			}
		}
#endif
		// Catch up on public declarations this player has made

		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			PublicDeclarationTypes eDeclaration;
			int iData1;
			int iData2;
			PlayerTypes eMustHaveMetPlayer;
			bool bActive;

			for(int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
			{
				eDeclaration = GetDeclarationLogTypeForIndex(iLoop);

				// Does this entry in the log exist?
				if(eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
				{
					bActive = IsDeclarationLogForIndexActive(iLoop);

					iData1 = GetDeclarationLogData1ForIndex(iLoop);
					iData2 = GetDeclarationLogData2ForIndex(iLoop);

					// Validate active status - minors must be alive
					if(eDeclaration == PUBLIC_DECLARATION_PROTECT_MINOR)
					{
						CvAssert(((PlayerTypes) iData1) != NO_PLAYER);
						if(((PlayerTypes) iData1) != NO_PLAYER)
						{
							if(!GET_PLAYER((PlayerTypes) iData1).isAlive())
								bActive = false;
						}
					}
					else if(eDeclaration == PUBLIC_DECLARATION_ABANDON_MINOR)
					{
						CvAssert(((PlayerTypes) iData1) != NO_PLAYER);
						if(((PlayerTypes) iData1) != NO_PLAYER)
						{
							if(!GET_PLAYER((PlayerTypes) iData1).isAlive())
								bActive = false;
						}
					}

					// Is this still an active declaration?
					if(bActive)
					{
						eMustHaveMetPlayer = GetDeclarationLogMustHaveMetPlayerForIndex(iLoop);

						DoMakePublicDeclaration(eDeclaration, iData1, iData2, eMustHaveMetPlayer, ePlayer);
					}
				}
			}
		}
	}
}

/// Initiate relationship values towards a new player on first contact
void CvDiplomacyAI::DoFirstContactInitRelationship(PlayerTypes ePlayer)
{
	DoUpdateConquestStats();
	DoUpdatePlayerMilitaryStrengths();
	DoUpdatePlayerEconomicStrengths();
	DoUpdatePlayerTargetValues();

	DoUpdateMilitaryAggressivePostures();
	DoUpdateExpansionAggressivePostures();

	// Major Civ
	if (GET_PLAYER(ePlayer).isMajorCiv())
	{
		SetDoFType(ePlayer, DOF_TYPE_NEW);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_NEW);
		for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			MajorCivApproachTypes eApproach = (MajorCivApproachTypes) iApproachLoop;
			SetPlayerApproachValue(ePlayer, eApproach, 0);
		}

		vector<PlayerTypes> v;
		v.push_back(ePlayer);
		DoReevaluatePlayers(v);
	}
	// Minor civ
	else if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
	}
}
//	-----------------------------------------------------------------------------------------------
/// Player killed us
void CvDiplomacyAI::DoKilledByPlayer(PlayerTypes ePlayer)
{
#if defined(MOD_ACTIVE_DIPLOMACY)
	if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if(ePlayer != NO_PLAYER && CvPreGame::isHuman(ePlayer))
		{
			const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
		}
	}
	else
	{
		if(ePlayer == GC.getGame().getActivePlayer() && !GC.getGame().isNetworkMultiPlayer())
		{
			const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
			gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
		}
#else
	if(ePlayer == GC.getGame().getActivePlayer() && !GC.getGame().isNetworkMultiPlayer())
	{
		const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
		gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
#endif

#if !defined(NO_ACHIEVEMENTS)
		if(!GC.getGame().isGameMultiPlayer())
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_DESTROY_CIV);

			CvAchievementUnlocker::AlexanderConquest(ePlayer);
		}
#endif
	}
}
//	-------------------------------------------------------------------------------------------------------------------
/// Send a statement to another player
void CvDiplomacyAI::DoSendStatementToPlayer(PlayerTypes ePlayer, DiploStatementTypes eStatement, int iData1, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eStatement >= 0, "DIPLOMACY_AI: Invalid DiploStatementType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eStatement < NUM_DIPLO_LOG_STATEMENT_TYPES, "DIPLOMACY_AI: Invalid DiploStatementType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* szText;
	bool bHuman = GET_PLAYER(ePlayer).isHuman();

	// Aggressive Military warning
	if(eStatement == DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING)
	{
		if(bHuman)
		{
			if(IsActHostileTowardsHuman(ePlayer))
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_AGGRESSIVE_MILITARY_WARNING);
			else
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_AGGRESSIVE_MILITARY_WARNING);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AGGRESSIVE_MILITARY_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		// AI resolution
		else
		{
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam()))
			{
				SetPlayerMilitaryPromiseState(ePlayer, PROMISE_STATE_MADE);
			}
			else
			{
				if (GET_PLAYER(ePlayer).HasAnyOffensiveOperationsAgainstPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->AvoidExchangesWithPlayer(GetID(), /*bWarOnly*/ true))
				{
					if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->DeclareWar(GetTeam()))
					{
						SetPlayerMilitaryPromiseState(ePlayer, PROMISE_STATE_MADE);
					}
					else
					{
						SetPlayerMilitaryPromiseState(ePlayer, PROMISE_STATE_IGNORED);
					}
				}
				else
				{
					SetPlayerMilitaryPromiseState(ePlayer, PROMISE_STATE_MADE);
				}
			}
		}
	}

	// Player killed a City-State we were protecting
	else if(eStatement == DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
	}

	// Player attacked a City-State we're protecting
	else if (eStatement == DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE)
	{
		if (bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_ATTACKED_MINOR_CIV, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(eMinorCiv) == MINOR_CIV_APPROACH_CONQUEST)
				{
					SetPlayerAttackCityStatePromiseState(ePlayer, PROMISE_STATE_IGNORED);
				}
				else
				{
					SetPlayerAttackCityStatePromiseState(ePlayer, PROMISE_STATE_MADE);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMinorCivApproach(eMinorCiv, MINOR_CIV_APPROACH_IGNORE);
				}
			}
		}
	}

	// Player bullied a City-State we're protecting
	else if (eStatement == DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE)
	{
		if (bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_BULLIED_MINOR_CIV, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(eMinorCiv) == MINOR_CIV_APPROACH_BULLY)
				{
					SetPlayerBullyCityStatePromiseState(ePlayer, PROMISE_STATE_IGNORED);
				}
				else
				{
					SetPlayerBullyCityStatePromiseState(ePlayer, PROMISE_STATE_MADE);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMinorCivApproach(eMinorCiv, MINOR_CIV_APPROACH_IGNORE);
				}
			}
		}
	}

	// Serious Expansion warning
	else if(eStatement == DIPLO_STATEMENT_EXPANSION_SERIOUS_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_SERIOUS_WARNING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_EXPANSION_SERIOUS_WARNING, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Expansion warning
	else if (eStatement == DIPLO_STATEMENT_EXPANSION_WARNING)
	{
		if (bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_WARNING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_EXPANSION_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDontSettleAcceptable(GetID()))
				SetPlayerExpansionPromiseState(ePlayer, PROMISE_STATE_MADE);
			else
				SetPlayerExpansionPromiseState(ePlayer, PROMISE_STATE_IGNORED);
		}
	}

	// Broken Expansion Promise
	else if(eStatement == DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_BROKEN_PROMISE);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Serious Plot Buying warning
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_SERIOUS_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_SERIOUS_WARNING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_PLOT_BUYING_SERIOUS_WARNING, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Plot Buying warning
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_WARNING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_PLOT_BUYING_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() > 8)
			{
				SetPlayerBorderPromiseState(ePlayer, PROMISE_STATE_IGNORED);
			}
			else
			{
				SetPlayerBorderPromiseState(ePlayer, PROMISE_STATE_MADE);
			}
		}
	}

	// Broken Plot Buying Promise
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_BROKEN_PROMISE);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// We attacked a Minor someone has a PtP with
	else if(eStatement == DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();
				if(IsActHostileTowardsHuman(ePlayer))
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_WE_ATTACKED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);
				else
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_ATTACKED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);

				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_I_ATTACKED_YOUR_MINOR_CIV, szText, LEADERHEAD_ANIM_POSITIVE, eMinorCiv);

				// Extra flag, since diplo log does not save which minor civ the message was about
				SetSentAttackProtectedMinorTaunt(ePlayer, eMinorCiv, true);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE)
				{
					SetOtherPlayerSidedWithProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());

					// For now the AI will always give in
					bool bValid = false;
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							bool bCareful = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true) > 0 && GetGlobalCoopWarAgainstState(ePlayer) < COOP_WAR_STATE_PREPARING;

							if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(ePlayer))
							{
								GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer, 3, bCareful);
							}
						}
					}
				}
				else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivCompetitiveness() > 6)
				{
					SetOtherPlayerSidedWithProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());

					// For now the AI will always give in
					bool bValid = false;
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							bool bCareful = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true) > 0 && GetGlobalCoopWarAgainstState(ePlayer) < COOP_WAR_STATE_PREPARING;

							if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(ePlayer))
							{
								GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer, 3, bCareful);
							}
						}
					}
				}
				else
				{
					GC.getGame().DoMinorPledgeProtection(ePlayer, eMinorCiv, false, true); // Pledge is broken!	
				}
			}
		}
#endif
	}

	// We bullied a Minor someone has a PtP with
	else if(eStatement == 	DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();
				if(IsActHostileTowardsHuman(ePlayer))
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_WE_BULLIED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);
				else
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_BULLIED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);

				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_I_BULLIED_YOUR_MINOR_CIV, szText, LEADERHEAD_ANIM_POSITIVE, eMinorCiv);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE)
				{
					SetOtherPlayerSidedWithProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());

					// For now the AI will always give in
					bool bValid = false;
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer,3);
						}
					}
				}
				else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivCompetitiveness() > 6)
				{
					SetOtherPlayerSidedWithProtectedMinorTurn(ePlayer, GC.getGame().getGameTurn());

					// For now the AI will always give in
					bool bValid = false;
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer,3);
						}
					}
				}
				else
				{
					GC.getGame().DoMinorPledgeProtection(ePlayer, eMinorCiv, false, true); // Pledge is broken!	
				}
			}
		}
#endif
	}

	// We'd like a defense pact
	else if(eStatement == DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFENSE_PACT_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;
				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a 3rd party war
	else if(eStatement == DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THIRDPARTY_WAR_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a peace trade
	else if(eStatement == DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THIRDPARTY_PEACE_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a vote trade
	else if(eStatement == DIPLO_STATEMENT_VOTE_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VOTE_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	
	// We'd like to trade cities
	else if(eStatement == DIPLO_STATEMENT_TRADE_CITIES_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_CITIES_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like to exchange cities
	else if(eStatement == DIPLO_STATEMENT_EXCHANGE_CITIES)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXCHANGE_CITIES_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_WORK_WITH_US)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), true);
				SetDoFType(ePlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_FRIENDS);	

				// Update diplomacy stuff
				vector<PlayerTypes> v;
				v.push_back(ePlayer);
				DoReevaluatePlayers(v, false, false);

				vector<PlayerTypes> v2;
				v2.push_back(GetID());
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoReevaluatePlayers(v2, false, false);

				LogDoF(ePlayer);
			}
		}
	}

	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_BB)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_BATTLE_BROTHERS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), true);
				
				// Update diplomacy stuff
				vector<PlayerTypes> v;
				v.push_back(ePlayer);
				DoReevaluatePlayers(v, false, false);

				vector<PlayerTypes> v2;
				v2.push_back(GetID());
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoReevaluatePlayers(v2, false, false);

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_ALLIES)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_OLD_FRIENDS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), true);
				SetDoFType(ePlayer, DOF_TYPE_BATTLE_BROTHERS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_BATTLE_BROTHERS);

				// Update diplomacy stuff
				vector<PlayerTypes> v;
				v.push_back(ePlayer);
				DoReevaluatePlayers(v, false, false);

				vector<PlayerTypes> v2;
				v2.push_back(GetID());
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoReevaluatePlayers(v2, false, false);

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_FRIENDS)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_FRIENDS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), true);
				SetDoFType(ePlayer, DOF_TYPE_ALLIES);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_ALLIES);

				// Update diplomacy stuff
				vector<PlayerTypes> v;
				v.push_back(ePlayer);
				DoReevaluatePlayers(v, false, false);

				vector<PlayerTypes> v2;
				v2.push_back(GetID());
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoReevaluatePlayers(v2, false, false);

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_UNTRUSTWORTHY)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_UNTRUSTWORTHY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetID(), true);

				SetDoFType(ePlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_FRIENDS);		

				// Update diplomacy stuff
				vector<PlayerTypes> v;
				v.push_back(ePlayer);
				DoReevaluatePlayers(v, false, false);

				vector<PlayerTypes> v2;
				v2.push_back(GetID());
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoReevaluatePlayers(v2, false, false);

				LogDoF(ePlayer);
			}
		}
	}

	// We no longer want to work with a player
	else if(eStatement == DIPLO_STATEMENT_END_WORK_WITH_US)
	{
		PlayerTypes eMyPlayer = GetID();
		
		SetDoFAccepted(ePlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
		
		// End all coop war agreements with this player
		GET_PLAYER(ePlayer).GetDiplomacyAI()->CancelCoopWarsWithPlayer(eMyPlayer, true);
		
		// End any Defensive Pact
		GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(ePlayer).getTeam(), false);
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);
	
		SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(eMyPlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFBroken(eMyPlayer, true, false);
		LogBrokenDoF(ePlayer);

		if (!GET_PLAYER(ePlayer).isHuman() && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer) > MAJOR_CIV_APPROACH_GUARDED)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMajorCivApproach(eMyPlayer, MAJOR_CIV_APPROACH_GUARDED);
		}
		
		// Other players' reactions
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer, true) && !GET_PLAYER(eLoopPlayer).isHuman() && eLoopPlayer != ePlayer && eLoopPlayer != eMyPlayer)
			{
				// Our teammates
				if (IsTeammate(eLoopPlayer))
				{
					if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(ePlayer))
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -300);
					}
				}
				else if (GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(ePlayer).getTeam())
				{
					// Player might apply a diplo bonus if they don't hate us
					if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && !IsDenouncedPlayer(eLoopPlayer) &&
						!GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eMyPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(eMyPlayer) &&
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(eMyPlayer) != MAJOR_CIV_OPINION_UNFORGIVABLE)
					{
						// Bonus for ending a DoF with a backstabber
						if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(ePlayer))
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -75);
						}
						// Bonus for ending a DoF with a player they're at war with
						else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -50);
							
							// Extra bonus if they're doing badly in the war
							if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarState(ePlayer) <= WAR_STATE_DEFENSIVE)
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -25);
							}
						}
						// Bonus for ending a DoF with a player who denounced them
						else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -50);
						}
						// Penalty for ending a DoF with a friend, DP or ally
						else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(ePlayer) || 
								GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) ||
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 75);
						}						
					}
					// Penalty for ending a DoF with a friend, DP or ally (they hate us)
					else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(ePlayer) || 
							GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) ||
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 150);
					}
				}
				// Their teammates
				else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(ePlayer))
				{
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
				}
			}
		}

		// Send message to human
		if (bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_END_WORK_WITH_US, ePlayer);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Denounce
	else if(eStatement == DIPLO_STATEMENT_DENOUNCE)
	{
		DoDenouncePlayer(ePlayer);
		LogDenounce(ePlayer);

		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, ePlayer);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Denounce Friend (backstab)
	else if(eStatement == DIPLO_STATEMENT_DENOUNCE_FRIEND)
	{
		DoDenouncePlayer(ePlayer);
		LogDenounce(ePlayer, /*bBackstab*/ true);

		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_AI_DOF_BACKSTAB, ePlayer);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Request Friend Denounce Someone
	else if(eStatement == DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE)
	{
		PlayerTypes eTarget = (PlayerTypes) iData1;
		CvAssert(eTarget != NO_PLAYER);
		if(eTarget != NO_PLAYER)
		{
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();

			// Send message to human
		if(bHuman)
			{
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_AI_DENOUNCE_REQUEST, ePlayer, strTargetCivKey);

				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AI_REQUEST_DENOUNCE, szText, LEADERHEAD_ANIM_POSITIVE, eTarget);
			}
			else
			{
				bool bAgree = IsDenounceAcceptable(eTarget, /*bBias*/ true);

				LogFriendRequestDenounce(ePlayer, eTarget, bAgree);

				if(bAgree)
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->DoDenouncePlayer(eTarget);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->LogDenounce(eTarget);

					// Denounced a human?
#if defined(MOD_ACTIVE_DIPLOMACY)
					if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
					{
						if(GET_PLAYER(eTarget).isHuman())
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, eTarget);
							CvDiplomacyRequests::SendRequest(ePlayer, eTarget, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
						}
					}
					else
					{
						if(eTarget == GC.getGame().getActivePlayer())
#else
						if(eTarget == GC.getGame().getActivePlayer())
#endif
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, eTarget);
							CvDiplomacyRequests::SendRequest(ePlayer, eTarget, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
						}
#if defined(MOD_ACTIVE_DIPLOMACY)
					}
#endif
				}
				else
				{
					// Oh, you're gonna say no, are you?
					if(IsFriendDenounceRefusalUnacceptable(ePlayer, eTarget))
					{
						DoDenouncePlayer(ePlayer);
						LogDenounce(ePlayer, /*bBackstab*/ false, /*bRefusal*/ true);
					}
				}
			}
		}
	}

	// We'd like to declare war on someone
	else if (eStatement == DIPLO_STATEMENT_COOP_WAR_REQUEST)
	{
		PlayerTypes eAgainstPlayer = (PlayerTypes) iData1;
		CvAssert(!IsPlayerValid(eAgainstPlayer));
		if (IsPlayerValid(eAgainstPlayer))
		{
			// Send message to human
			if (bHuman)
			{
				const char* strAgainstPlayerKey = GET_PLAYER(eAgainstPlayer).getNameKey();
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_REQUEST, ePlayer, strAgainstPlayerKey);

				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_COOP_WAR, szText, LEADERHEAD_ANIM_POSITIVE, eAgainstPlayer);
			}
			// AI resolution
			else
			{
				CoopWarStates eResponse = GET_PLAYER(ePlayer).GetDiplomacyAI()->RespondToCoopWarRequest(GetID(), eAgainstPlayer);

				if (eResponse == COOP_WAR_STATE_REJECTED)
				{
					int iAssistPenalty = 100 - (GetDifferenceFromAverageFlavorValue(GetForgiveness()) * 10);
					ChangeRecentAssistValue(ePlayer, iAssistPenalty);
					ChangeCoopWarScore(ePlayer, -1);
				}
			}
		}
	}

	/*
	// We'd like to declare war on someone
	else if(eStatement == DIPLO_STATEMENT_COOP_WAR_TIME)
	{
		PlayerTypes eAgainstPlayer = (PlayerTypes) iData1;
		CvAssert(eAgainstPlayer != NO_PLAYER);
		if(eAgainstPlayer != NO_PLAYER)
		{
			// Send message to human
			if(bHuman)
			{
				const char* strAgainstPlayerKey = GET_PLAYER(eAgainstPlayer).getNameKey();
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_TIME, ePlayer, strAgainstPlayerKey);

				CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_COOP_WAR_TIME, szText, LEADERHEAD_ANIM_POSITIVE, eAgainstPlayer);
			}
		}

		// No AI resolution! This is handled automatically in DoCounters() - no need for diplo exchange
	}
	*/

	// We're making a demand of this player
	else if(eStatement == DIPLO_STATEMENT_DEMAND)
	{
		// Active human
		if (bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEMAND);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_DEMAND, szText, LEADERHEAD_ANIM_DEMAND);
		}
		// AI player
		else
		{
			// Apply diplomacy penalties!
			GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumDemandEverMade(GetID(), 1);

			if (IsMaster(ePlayer))
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumTimesDemandedWhileVassal(GetID(), 1);
			}

			// For now the AI will always give in
			bool bValid = false;
			if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetID()))
			{
				if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarmongerHate())
				{
					bValid = true;
				}
			}
			if (bValid && ((GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >  7) || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMeanness() > 7))
			{
				if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
				{
					pDeal->ClearItems();
					bool bCareful = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true) > 0 && GetGlobalCoopWarAgainstState(ePlayer) < COOP_WAR_STATE_PREPARING;

					if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(ePlayer))
					{
						GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer, 3, bCareful);
					}
				}
			}
			else
			{
				if (IsMaster(ePlayer))
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetHasPaidTributeTo(GetID(), true);
				}

#if defined(MOD_ACTIVE_DIPLOMACY)
				if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
				}
				else
				{
					CvDeal kDeal = *pDeal;

					GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
					GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
				}
#else
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >= 8)
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->DoDenouncePlayer(GetID());
				}
			}
		}
	}

	// We're making a request of this player
	else if(eStatement == DIPLO_STATEMENT_REQUEST)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_REQUEST);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_REQUEST, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI player
		else
		{
			// For now the AI will always give in - may eventually write additional logic here

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// Player has a Luxury Resource we'd like to trade for
	else if(eStatement == DIPLO_STATEMENT_LUXURY_TRADE)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_LUXURY_TRADE);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like to exchange embassies with this player
	else if(eStatement == DIPLO_STATEMENT_EMBASSY_EXCHANGE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EMBASSY_EXCHANGE);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// We want an embassy in this player's capital
	else if(eStatement == DIPLO_STATEMENT_EMBASSY_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EMBASSY_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like mutual Open Borders with this player
	else if(eStatement == DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OPEN_BORDERS_EXCHANGE);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like this player to open their borders to us
	else if(eStatement == DIPLO_STATEMENT_OPEN_BORDERS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OPEN_BORDERS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// Offer a Research Agreement
	else if(eStatement == DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_RESEARCH_AGREEMENT_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}

	// Offer to renew an existing trade deal
	else if (eStatement == DIPLO_STATEMENT_RENEW_DEAL)
	{
		if(bHuman)
		{
			int iDealValueToMe;
			DiploMessageTypes eMessageType = NUM_DIPLO_MESSAGE_TYPES;
			bool bCantMatchOffer;
			bool bDealAcceptable = m_pPlayer->GetDealAI()->IsDealWithHumanAcceptable(pDeal, ePlayer, iDealValueToMe, &bCantMatchOffer, false);

			if(bDealAcceptable)
			{
				eMessageType = DIPLO_MESSAGE_RENEW_DEAL;
			}
			// We want more from this deal
			else if(iDealValueToMe < 0)
			{
				eMessageType = DIPLO_MESSAGE_WANT_MORE_RENEW_DEAL;
			}

			if(eMessageType != NUM_DIPLO_MESSAGE_TYPES)
			{
				if (m_pPlayer->GetDiplomacyAI()->GetDealToRenew(ePlayer) != NULL)
				{
					// make the deal not remove resources when processed
					CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(ePlayer), pDeal);
					szText = GetDiploStringForMessage(eMessageType);
					CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
				}
				else
					CancelRenewDeal(ePlayer, REASON_NO_DEAL);
			}
			else
			{
				CancelRenewDeal(ePlayer, REASON_CANNOT_COMPROMISE);
			}
		}
		// Offer to an AI player
		else
		{
			CvDeal kDeal = *pDeal;
			CvDeal* pRenewedDeal = m_pPlayer->GetDiplomacyAI()->GetDealToRenew(ePlayer);
			if(pRenewedDeal)
			{
				CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(ePlayer), &kDeal);

				if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					GC.getGame().GetGameDeals().FinalizeMPDeal(kDeal, true);
				}
				else
				{
					// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
					GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
					GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
				}
			}
			else
				CancelRenewDeal(ePlayer, REASON_NO_DEAL);
		}
	}

	// Our Opinion of them is now Unforgivable
	else if(eStatement == DIPLO_STATEMENT_NOW_UNFORGIVABLE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_UNFORGIVABLE);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Our Opinion of them is now Enemy
	else if(eStatement == DIPLO_STATEMENT_NOW_ENEMY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_ENEMY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// They caught one of our spies
	else if(eStatement == DIPLO_STATEMENT_CAUGHT_YOUR_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_CAUGHT_YOUR_SPY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_CAUGHT_YOUR_SPY, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// They killed one of our spies
	else if(eStatement == DIPLO_STATEMENT_KILLED_YOUR_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_KILLED_YOUR_SPY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_KILLED_YOUR_SPY, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// We killed one of their spies
	else if(eStatement == DIPLO_STATEMENT_KILLED_MY_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_KILLED_MY_SPY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_KILLED_MY_SPY, szText, LEADERHEAD_ANIM_DEFEATED);
		}
	}

	// We (the AI) have intrigue information to share with them
	else if(eStatement == DIPLO_STATEMENT_SHARE_INTRIGUE)
	{
		IntrigueNotificationMessage* pNotificationMessage = GetPlayer()->GetEspionage()->GetRecentIntrigueInfo(ePlayer);
		CvAssertMsg(pNotificationMessage, "pNotificationMessage is null. Whut?");
		if (pNotificationMessage)
		{
			CvAssertMsg(pNotificationMessage->m_eSourcePlayer != NO_PLAYER, "There is no plotter! What's going on");
			PlayerTypes ePlotterPlayer = pNotificationMessage->m_eSourcePlayer;
			CvIntrigueType eIntrigueType = (CvIntrigueType)pNotificationMessage->m_iIntrigueType;
			// don't share intrigue about two parties if they are already at war
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlotterPlayer).getTeam()))
			{
				CvCity* pCity = NULL;
				if(pNotificationMessage->m_iCityX != -1 && pNotificationMessage->m_iCityY != -1)
				{
					CvPlot* pPlot = GC.getMap().plot(pNotificationMessage->m_iCityX, pNotificationMessage->m_iCityY);
					if(pPlot)
					{
						pCity = pPlot->getPlotCity();
					}
				}

				// add the notification to the player
				GET_PLAYER(ePlayer).GetEspionage()->AddIntrigueMessage(m_pPlayer->GetID(), ePlotterPlayer, ePlayer, NO_BUILDING, NO_PROJECT, eIntrigueType, 0, pCity, false);

				if(bHuman)
				{
					const char* szPlayerName;
					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlotterPlayer).isHuman())
					{
						szPlayerName = GET_PLAYER(ePlotterPlayer).getNickName();
					}
					else
					{
						szPlayerName = GET_PLAYER(ePlotterPlayer).getNameKey();
					}

					szText = "";

					switch(eIntrigueType)
					{
					case INTRIGUE_TYPE_ARMY_SNEAK_ATTACK:
						if(pCity)
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY, NO_PLAYER, szPlayerName, pCity->getNameKey());
						}
						else
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY, NO_PLAYER, szPlayerName);
						}
						break;
					case INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK:
						if(pCity)
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY, NO_PLAYER, szPlayerName, pCity->getNameKey());
						}
						else
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY, NO_PLAYER, szPlayerName);
						}
						break;
					case INTRIGUE_TYPE_DECEPTION:
						szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE, NO_PLAYER, szPlayerName);
						break;
					default:
						CvAssertMsg(false, "Unknown intrigue type");
						break;
					}

					CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
				}
#if defined(MOD_BALANCE_CORE)
				else
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(GetID(), 1);
				}
#endif
			}

			// mark the messages as shared so the player isn't told the same thing repeatedly
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)ui;
				GET_PLAYER(eLoopPlayer).GetEspionage()->MarkRecentIntrigueAsShared(ePlayer, ePlotterPlayer, eIntrigueType);
			}
		}
	}

	// Stop converting our cities
	else if(eStatement == DIPLO_STATEMENT_STOP_CONVERSIONS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_STOP_CONVERSIONS, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Stop digging up our yard
	else if(eStatement == DIPLO_STATEMENT_STOP_DIGGING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_STOP_DIGGING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Insult
	else if(eStatement == DIPLO_STATEMENT_INSULT)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetID(), MAJOR_CIV_APPROACH_HOSTILE);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_INSULT_ROOT);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Compliment
	else if(eStatement == DIPLO_STATEMENT_COMPLIMENT)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetID(), MAJOR_CIV_APPROACH_FRIENDLY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_COMPLIMENT);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Boot-kissing of a stronger power
	else if(eStatement == DIPLO_STATEMENT_BOOT_KISSING)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetID(), MAJOR_CIV_APPROACH_AFRAID);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_BOOT_KISSING);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// We're warning a player that his warmongering behavior is attracting attention
	else if(eStatement == DIPLO_STATEMENT_WARMONGER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WARMONGER);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// We're warning a player that his interactions with City-States are not to our liking
	else if(eStatement == DIPLO_STATEMENT_MINOR_CIV_COMPETITION)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

			szText = GetDiploStringForMessage(DIPLO_MESSAGE_MINOR_CIV_COMPETITION, NO_PLAYER, strMinorCivKey);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Human befriended an enemy of this AI!
	else if(eStatement == DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOFED_ENEMY, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Human denounced a friend of this AI!
	else if(eStatement == DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCED_FRIEND, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Human denounced an enemy of this AI!
	else if(eStatement == DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCED_ENEMY, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Human befriended a friend of this AI!
	else if(eStatement == DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOFED_FRIEND, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI befriended an enemy of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DOF, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// AI denounced a friend of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DENOUNCE, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// AI denounced an enemy of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DENOUNCE, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI befriended a friend of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DOF, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI chose same late game policy tree as the human!
	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_ORDER);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_LIKED_THEIR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_DISLIKED_THEIR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_SUPPORTED_OUR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_FOILED_OUR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_SUPPORTED_OUR_HOSTING, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Ideological statements
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_ORDER);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_CULTURE_INFLUENTIAL);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_CULTURE_INFLUENTIAL);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	// Player has a Strategic Resource we'd like
	else if(eStatement == DIPLO_STATEMENT_STRATEGIC_TRADE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STRATEGIC_TRADE);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	
	// Announce to the human that this AI is competing with them for the same victory condition
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	
	// Announce to the human that this AI wants to block them from achieving victory
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// We'd like to purchase this player's World Map
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_MAPS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_MAPS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like to purchase a technology from this player
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_TECH_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_TECH_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// We're making a generous offer to this player
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_GENEROUS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_GENEROUS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_GENEROUS_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				// For now the AI will always accept - may eventually write additional logic here
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			// For now the AI will always accept - may eventually write additional logic here
			CvDeal kDeal = *pDeal;

			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	//We want to declare independence from our master
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_REVOKE_VASSALAGE)
	{
		if(bHuman)
		{
			if(IsActHostileTowardsHuman(ePlayer))
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSALAGE_HOSTILE);
			else
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSALAGE);

			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AI_REVOKE_VASSALAGE, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		// AI resolution
		else
		{
			// Do we accept or make war?
			// How do we think war with ePlayer will go?

			////War will go well? We should get free peacefully!
			//if(GetWarProjection(ePlayer) > WAR_PROJECTION_UNKNOWN)
			//{
			//	bPeaceful = true;
			//}
			//// For stalemates, we do a 50/50 roll
			//else if(GetWarProjection(ePlayer) == WAR_PROJECTION_STALEMATE || GetWarProjection(ePlayer) == WAR_PROJECTION_UNKNOWN)
			//{
			//	int iChance = GC.getGame().getJonRandNum(2, "Diplomacy AI: Is AI request to end vassalage acceptable?");
			//	if(iChance == 1)
			//		bPeaceful = true;
			//	else
			//		bPeaceful = false;
			//}
			//// War Projection was bad, so our master isn't letting go without a fight.
			//else
			//{
			//	bPeaceful = false;
			//}

			CvPlayer& kVassalPlayer = GET_PLAYER(GetID());
			CvPlayer& kMasterPlayer = GET_PLAYER(ePlayer);

			// AIs now use same evaluation as humans (for some reason I didn't do this before???)
			bool bPeaceful = kMasterPlayer.GetDiplomacyAI()->IsEndVassalageRequestAcceptable(kVassalPlayer.GetID());
			GET_TEAM(kVassalPlayer.getTeam()).DoEndVassal(kMasterPlayer.getTeam(), bPeaceful, false);
		}
	}
	//We want this player to liberate their vassals
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSAL_THIRD_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// AI offers to make ePlayer his voluntary vassal
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_BECOME_MY_VASSAL)
	{
		if(bHuman)
		{
			CvAssertMsg(false, "Don't send vassalage statement to human!");
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// AI offers to become voluntary vassal of ePlayer
	else if (MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_ACCEPT_VASSALAGE)
	{
		if (bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_BECOME_VASSAL);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif
		}
	}
	// AI is happy that they were liberated from vassalage
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_LIBERATE_VASSAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATE_VASSAL);
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}

		// Liberate this vassal
		GET_TEAM(GetTeam()).DoLiberateVassal(GET_PLAYER(ePlayer).getTeam());
	}
	// AI is upset that their taxes were raised
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_RAISED_HUMAN_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI is happy that their taxes were lowered
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_HUMAN_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI notifies human that their taxes were RAISED
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_RAISED_AI_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI notifies human that their taxes were LOWERED
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_AI_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}

#endif

	// Do we want peace with ePlayer?
	else if (eStatement == DIPLO_STATEMENT_REQUEST_PEACE)
	{
		if(bHuman)
		{
#if defined(MOD_BALANCE_CORE)
			int iOurWarScore = GetWarScore(ePlayer);
			int iTheirWarScore = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarScore(GetID());
			if(iOurWarScore > (iTheirWarScore + 10))
			{
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_WINNER_PEACE_OFFER);
			}
			else
			{
#endif
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PEACE_OFFER);
#if defined(MOD_BALANCE_CORE)
			}
#endif
			CvDiplomacyRequests::SendDealRequest(GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetID(), ePlayer, true);
#endif

			LogPeaceMade(ePlayer);
		}
	}
}
//	-------------------------------------------------------------------------------------------------------------------
/// Does this AI have something to say to the world this turn?
void CvDiplomacyAI::DoMakePublicDeclaration(PublicDeclarationTypes eDeclaration, int iData1, int iData2, PlayerTypes eMustHaveMetPlayer, PlayerTypes eForSpecificPlayer)
{
	// Don't give Public Declarations if we're a human
	if(GetPlayer()->isHuman())
	{
		// TODO: jdh, check if we do want public declarations from humans
		return;
	}

	CvAssertMsg(eDeclaration >= 0, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeclaration < NUM_PUBLIC_DECLARATION_TYPES, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eForSpecificPlayer >= NO_PLAYER, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// We can be sending to no specific player
	CvAssertMsg(eForSpecificPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "";
	//LeaderheadAnimationTypes eAnimation;
	//DiploUIStateTypes eDiploState = DIPLO_UI_STATE_DEFAULT_ROOT;

	bool bActive = true;

	// We're protecting a Minor Civ, so watch out!
	if(eDeclaration == PUBLIC_DECLARATION_PROTECT_MINOR)
	{
		PlayerTypes eMinorCiv = (PlayerTypes) iData1;
		const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

		strText = GetDiploStringForMessage(DIPLO_MESSAGE_DECLARATION_PROTECT_CITY_STATE, NO_PLAYER, strMinorCivKey);
		//eAnimation = LEADERHEAD_ANIM_POSITIVE;
		//eDiploState = DIPLO_UI_STATE_DISCUSS_PROTECT_MINOR_CIV;

		DoMakeDeclarationInactive(PUBLIC_DECLARATION_PROTECT_MINOR, iData1, iData2);
	}

	// We're no longer protecting a Minor Civ, sorry...
	if(eDeclaration == PUBLIC_DECLARATION_ABANDON_MINOR)
	{
		// Make previous declarations to protect this Minor inactive
		DoMakeDeclarationInactive(PUBLIC_DECLARATION_PROTECT_MINOR, iData1, iData2);

		// No point in telling new people we JUST meet we're not protecting someone any more...
		bActive = false;

		PlayerTypes eMinorCiv = (PlayerTypes) iData1;
		const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

		strText = GetDiploStringForMessage(DIPLO_MESSAGE_DECLARATION_ABANDON_CITY_STATE, NO_PLAYER, strMinorCivKey);
		//eAnimation = LEADERHEAD_ANIM_POSITIVE;
	}



	// Should also send to the other AIs here somehow



	// If our declaration is only for a specific player (e.g. we just met them) take that into account
	if(eForSpecificPlayer != NO_PLAYER)
	{
	}

	// Only add this declaration to the log if it's for everyone, as announcements to specific people are only for catching them up after meeting them later
	if(eForSpecificPlayer == NO_PLAYER)
	{
		DoAddNewDeclarationToLog(eDeclaration, iData1, iData2, eMustHaveMetPlayer, bActive);

		//Send notification to everyone that can get it.
		for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
			PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
			CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
			if(IsPlayerValid(eCurPlayer) 
				&& (eMustHaveMetPlayer == NO_PLAYER || GET_TEAM(kCurPlayer.getTeam()).isHasMet(GET_PLAYER(eMustHaveMetPlayer).getTeam()))){
				CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
				if(pNotifications){
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMACY_DECLARATION");
					strSummary << GetPlayer()->getCivilizationShortDescriptionKey();
					pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText, strSummary.toUTF8(), -1, -1, -1);
				}
			}
		}
	}
	else
	{
		//send notification to the specific player.
		CvPlayerAI& kSpecificPlayer = GET_PLAYER(eForSpecificPlayer);
		if(IsPlayerValid(eForSpecificPlayer) 
			&& (eMustHaveMetPlayer == NO_PLAYER || GET_TEAM(kSpecificPlayer.getTeam()).isHasMet(GET_PLAYER(eMustHaveMetPlayer).getTeam()))){	
			CvNotifications* pNotifications = kSpecificPlayer.GetNotifications();
			if(pNotifications){
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMACY_DECLARATION");
				strSummary << GetPlayer()->getCivilizationShortDescriptionKey();
				pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText, strSummary.toUTF8(), -1, -1, -1);
			}
		}
	}

	LogPublicDeclaration(eDeclaration, iData1, eForSpecificPlayer);
}

/// Any Major Civs we want to chat with?
void CvDiplomacyAI::DoContactMajorCivs()
{
	// NOTE: This function is broken up into two sections: AI contact opportunities, and then human contact opportunities
	// This is to prevent a nasty bug where the AI will continue making decisions as the diplo screen is firing up. Making humans
	// handled at the end prevents the Diplo AI from having this problem

	// Loop through AI Players
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if (m_eDiploMode == DIPLO_SPECIFIC_PLAYER)
		{
			DoContactPlayer(m_eTargetPlayer);
		}
		else if (m_eDiploMode == DIPLO_ALL_PLAYERS || m_eDiploMode == DIPLO_AI_PLAYERS)
		{
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

				if (!IsPlayerValid(eLoopPlayer))
					continue;

				// No humans
				if (GET_PLAYER(eLoopPlayer).isHuman())
					continue;

				DoContactPlayer(eLoopPlayer);
			}
		}
		if (m_eDiploMode == DIPLO_ALL_PLAYERS || m_eDiploMode == DIPLO_HUMAN_PLAYERS)
		{
			// JdH => contact humans by priority, but use a notification system instead of pop up the diplo screen
			// every AI can only talk to one human a time (as a human can only talk to one human a time
			// TODO: the one to one restriction should be removed in favor of a trade resource pool allocation
			if (!CvDiplomacyRequests::HasActiveDiploRequestWithHuman(m_pPlayer->GetID()))
			{
				vector<PlayerTypes> aeHumansByPriority;
				vector<PlayerTypes>::const_iterator priorityIter, humanIter;
				// bring players in priority order
				for (humanIter = CvDiplomacyRequests::s_aDiploHumans.begin(); humanIter != CvDiplomacyRequests::s_aDiploHumans.end(); ++humanIter)
				{
					PlayerTypes eLoopPlayer = *humanIter;

					CvAssert(CvPreGame::isHuman(eLoopPlayer));
					CvAssert(GET_PLAYER(eLoopPlayer).isTurnActive());

					if (!IsPlayerValid(eLoopPlayer))
						continue;

					// No AI
					if (!GET_PLAYER(eLoopPlayer).isHuman())
						continue;

					// Only active Players
					if (!GET_PLAYER(eLoopPlayer).isTurnActive())
						continue;

					for (priorityIter = aeHumansByPriority.begin(); priorityIter != aeHumansByPriority.end(); ++priorityIter)
					{
						if (m_aTradePriority[*priorityIter] < m_aTradePriority[eLoopPlayer])
						{
							aeHumansByPriority.insert(priorityIter, eLoopPlayer);
							break;
						}
					}
					if (priorityIter == aeHumansByPriority.end())
					{
						aeHumansByPriority.push_back(eLoopPlayer);
					}
				}

				for (humanIter = aeHumansByPriority.begin(); humanIter != aeHumansByPriority.end(); ++humanIter)
				{
					DoContactPlayer(*humanIter);
					if (GET_PLAYER(*humanIter).GetDiplomacyRequests()->HasActiveRequestFrom(GetID()))
					{
						// we actually found someone worth talking with, the others must wait...
						break;
					}
				}
			}
		}
	}
	else
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (!IsPlayerValid(eLoopPlayer))
				continue;

			// No humans
			if (GET_PLAYER(eLoopPlayer).isHuman())
				continue;

			DoContactPlayer(eLoopPlayer);
		}

		// Loop through HUMAN Players - if we're not in MP
		if (!CvPreGame::isNetworkMultiplayerGame())
		{
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if (!IsPlayerValid(eLoopPlayer))
					continue;

				// No AI
				if (!GET_PLAYER(eLoopPlayer).isHuman())
					continue;

				DoContactPlayer(eLoopPlayer);
			}
		}
	}
#else
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!IsPlayerValid(eLoopPlayer))
			continue;

		// No humans
		if (GET_PLAYER(eLoopPlayer).isHuman())
			continue;

		DoContactPlayer(eLoopPlayer);
	}

	// Loop through HUMAN Players - if we're not in MP
	if (!CvPreGame::isNetworkMultiplayerGame())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (!IsPlayerValid(eLoopPlayer))
				continue;

			// No AI
			if (!GET_PLAYER(eLoopPlayer).isHuman())
				continue;

			DoContactPlayer(eLoopPlayer);
		}
	}
#endif
}

/// Individual contact opportunity
void CvDiplomacyAI::DoContactPlayer(PlayerTypes ePlayer)
{
	if (!IsValidUIDiplomacyTarget(ePlayer))
		return;		// Can't contact this player at the moment.

	// Can't contact this player because of game options
	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsAllDiploStatementsDisabled())
		return;

	int iDiploLogStatement;
	DiploStatementTypes eStatement;

	// We can use this deal pointer to form a trade offer
	CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

	// These can be used for info about deal items, e.g. what Minor Civ we're telling the guy to stay away from, etc.
	int iData1;
	int iData2;

	// If this is the same turn we've met a player, don't send anything his way quite yet - wait until we've said hello at least
	if (GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) == 0)
		return;

	// Clear out the scratch pad
	for (int iLoop = 0; iLoop < NUM_DIPLO_LOG_STATEMENT_TYPES; iLoop++)
	{
		m_aDiploLogStatementTurnCountScratchPad[iLoop] = MAX_TURNS_SAFE_ESTIMATE;
	}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		//End the gift exchange at the start of each round.
		GetPlayer()->GetDiplomacyAI()->SetOfferingGift(ePlayer, false);
		GetPlayer()->GetDiplomacyAI()->SetOfferedGift(ePlayer, false);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	pDeal->SetRequestingPlayer(NO_PLAYER);
#endif
#if defined(MOD_BALANCE_CORE)
	//Clear this data out before any deals are offered.
	SetCantMatchDeal(ePlayer, false);
#endif
	// Make a scratch pad keeping track of the last time we sent each message.  This way we can know what we've said in the past already - this member array will be used in the function calls below
	for (iDiploLogStatement = 0; iDiploLogStatement < MAX_DIPLO_LOG_STATEMENTS; iDiploLogStatement++)
	{
		eStatement = GetDiploLogStatementTypeForIndex(ePlayer, iDiploLogStatement);

		if (eStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			CvAssert(eStatement < NUM_DIPLO_LOG_STATEMENT_TYPES);

			m_aDiploLogStatementTurnCountScratchPad[eStatement] = GetDiploLogStatementTurnForIndex(ePlayer, iDiploLogStatement);
		}
	}

	eStatement = NO_DIPLO_STATEMENT_TYPE;

	iData1 = -1;
	iData2 = -1;

	pDeal->ClearItems();
	pDeal->SetFromPlayer(GetID());
	pDeal->SetToPlayer(ePlayer);
	pDeal->SetDuration(GC.getGame().getGameSpeedInfo().GetDealDuration());

	// JON: Add in some randomization here?
	// How predictable do we want the AI to be with regards to what state they're in?

	// Note that the order in which the following functions are called is very important to how the AI behaves - first come, first served

	// AT PEACE
	if (!IsAtWar(ePlayer))
	{
		// Avoiding exchanges?
		if (AvoidExchangesWithPlayer(ePlayer))
		{
			SetAvoidDeals(true);
		}

		//DoCoopWarTimeStatement(ePlayer, eStatement, iData1);
		DoCoopWarStatement(ePlayer, eStatement, iData1);
		DoRenewExpiredDeal(ePlayer, eStatement, pDeal);

		// Some things we don't say to teammates
		if (GetTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			// STATEMENTS - all members but ePlayer passed by address

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			// Some things we only say to our masters
			if (MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(ePlayer)) 
			{
				DoEndVassalageStatement(ePlayer, eStatement);
			}
#endif

			DoAggressiveMilitaryStatement(ePlayer, eStatement);
			DoKilledCityStateStatement(ePlayer, eStatement, iData1);
			DoAttackedCityStateStatement(ePlayer, eStatement, iData1);
			DoBulliedCityStateStatement(ePlayer, eStatement, iData1);
			//DoSeriousExpansionWarningStatement(ePlayer, eStatement);
			DoExpansionWarningStatement(ePlayer, eStatement);
			DoExpansionBrokenPromiseStatement(ePlayer, eStatement);
			//DoSeriousPlotBuyingWarningStatement(ePlayer, eStatement);
			DoPlotBuyingWarningStatement(ePlayer, eStatement);
			DoPlotBuyingBrokenPromiseStatement(ePlayer, eStatement);

			DoWeAttackedYourMinorStatement(ePlayer, eStatement, iData1);
			DoWeBulliedYourMinorStatement(ePlayer, eStatement, iData1);

			DoKilledYourSpyStatement(ePlayer, eStatement);
			DoKilledMySpyStatement(ePlayer, eStatement);
			DoCaughtYourSpyStatement(ePlayer, eStatement);

			DoTheySupportedOurHosting(ePlayer, eStatement);
			DoWeLikedTheirProposal(ePlayer, eStatement);
			DoWeDislikedTheirProposal(ePlayer, eStatement);
			DoTheySupportedOurProposal(ePlayer, eStatement);
			DoTheyFoiledOurProposal(ePlayer, eStatement);

			DoConvertedMyCityStatement(ePlayer, eStatement);

			DoDugUpMyYardStatement(ePlayer, eStatement);

			DoDoFStatement(ePlayer, eStatement);
			DoDenounceFriendStatement(ePlayer, eStatement);
			DoDenounceStatement(ePlayer, eStatement);
			DoEndDoFStatement(ePlayer, eStatement);
#if !defined(MOD_BALANCE_CORE)
			DoRequestFriendDenounceStatement(ePlayer, eStatement, iData1);
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) 
			{
				DoMapsOffer(ePlayer,eStatement,pDeal);
				DoTechOffer(ePlayer,eStatement,pDeal);

				DoRevokeVassalageStatement(ePlayer, eStatement, pDeal);
				DoMakeVassalageStatement(ePlayer, eStatement, pDeal);

				DoLiberateMyVassalStatement(ePlayer, eStatement);

				DoVassalTaxesRaisedStatement(ePlayer, eStatement);
				DoVassalTaxesLoweredStatement(ePlayer, eStatement);
			}
#endif
		}

		//	OFFERS - all members but ePlayer passed by address
		DoLuxuryTrade(ePlayer, eStatement, pDeal);
		DoEmbassyExchange(ePlayer, eStatement, pDeal);
		DoEmbassyOffer(ePlayer, eStatement, pDeal);
		DoOpenBordersExchange(ePlayer, eStatement, pDeal);
		DoOpenBordersOffer(ePlayer, eStatement, pDeal);
		DoResearchAgreementOffer(ePlayer, eStatement, pDeal);
		DoStrategicTrade(ePlayer, eStatement, pDeal);
		DoDefensivePactOffer(ePlayer, eStatement, pDeal);
		DoCityExchange(ePlayer, eStatement, pDeal);
		DoThirdPartyWarTrade(ePlayer, eStatement, pDeal);
		DoThirdPartyPeaceTrade(ePlayer, eStatement, pDeal);
		DoVoteTrade(ePlayer, eStatement, pDeal);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			DoBecomeVassalageStatement(ePlayer, eStatement, pDeal);
		}
#endif

		DoShareIntrigueStatement(ePlayer, eStatement);

		DoRequest(ePlayer, eStatement, pDeal);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES) 
		{
			DoGenerousOffer(ePlayer, eStatement, pDeal);
		}
#endif

		// Second set of things we don't say to teammates
		if (GetTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			//DoNowUnforgivableStatement(ePlayer, eStatement);
			//DoNowEnemyStatement(ePlayer, eStatement);
			//DoFriendlyStatement(ePlayer, eStatement);

			DoAfraidStatement(ePlayer, eStatement);
			DoHostileStatement(ePlayer, eStatement);
			DoWarmongerStatement(ePlayer, eStatement);
			DoMinorCivCompetitionStatement(ePlayer, eStatement, iData1);

			// Don't bother with this fluff stuff it's just AI on AI stuff
			if (GET_PLAYER(ePlayer).isHuman())
			{
				DoAngryBefriendedEnemy(ePlayer, eStatement, iData1);
				DoAngryDenouncedFriend(ePlayer, eStatement, iData1);
				
				DoHappyDenouncedEnemy(ePlayer, eStatement, iData1);
				DoHappyBefriendedFriend(ePlayer, eStatement, iData1);
			
				DoFYIBefriendedHumanEnemy(ePlayer, eStatement, iData1);
				DoFYIDenouncedHumanFriend(ePlayer, eStatement, iData1);
				
				DoFYIDenouncedHumanEnemy(ePlayer, eStatement, iData1);
				DoFYIBefriendedHumanFriend(ePlayer, eStatement, iData1);
				DoHappySamePolicyTree(ePlayer, eStatement);
				DoIdeologicalStatement(ePlayer, eStatement);
				DoVictoryCompetitionStatement(ePlayer, eStatement);
			}
		}
	}

	// AT WAR
	else if (!IsAlwaysAtWar(ePlayer))
	{
		//	OFFERS - all members but ePlayer passed by address
		DoPeaceOffer(ePlayer, eStatement, pDeal);

		// If not offering peace, can still denounce while at war!
		DoDenounceStatement(ePlayer, eStatement);
	}

	// Reset avoiding deals value
	SetAvoidDeals(false);

#if !defined(FINAL_RELEASE)
	// Check for an optional message injection from the Tuner
	if(eStatement == NO_DIPLO_STATEMENT_TYPE && m_eTestStatement != NO_DIPLO_STATEMENT_TYPE && ePlayer == m_eTestToPlayer)
	{
		eStatement = m_eTestStatement;
		iData1 = m_iTestStatementArg1;

		m_eTestStatement = NO_DIPLO_STATEMENT_TYPE;
	}
#endif

	// Now see if it's a valid time to send this message (we may have already sent it)
	if(eStatement != NO_DIPLO_STATEMENT_TYPE)
	{
		//if (bSendStatement)
		{
			LogStatementToPlayer(ePlayer, eStatement);

			DoSendStatementToPlayer(ePlayer, eStatement, iData1, pDeal);
			DoAddNewStatementToDiploLog(ePlayer, eStatement);
		}
	}
}

/// Any Minor Civs we want to chat with?
void CvDiplomacyAI::DoContactMinorCivs()
{
	// If the player has deleted the DIPLOMACY Flavor we have to account for that
	int iDefaultFlavorValue = /*5*/ GC.getGame().GetDefaultFlavorValue();
	int iDiplomacyFlavor = iDefaultFlavorValue;
	int iGoldFlavor = iDefaultFlavorValue;
	int iTileImprovementFlavor = iDefaultFlavorValue;
	int iExpansionFlavor = iDefaultFlavorValue;

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_DIPLOMACY")
		{
			iDiplomacyFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_GOLD")
		{
			iGoldFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_TILE_IMPROVEMENT")
		{
			iTileImprovementFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")
		{
			iExpansionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
	}
	EconomicAIStrategyTypes eFoundCity = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EARLY_EXPANSION");
	EconomicAIStrategyTypes eExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	EconomicAIStrategyTypes eNeedHappiness = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS");
	EconomicAIStrategyTypes eNeedHappinessCritical = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL");
	EconomicAIStrategyTypes eLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");
	bool bFoundCity = (eFoundCity != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eFoundCity) : false;
	bool bExpandToOtherContinents = (eExpandToOtherContinents != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eExpandToOtherContinents) : false;
	bool bNeedHappiness = (eNeedHappiness != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eNeedHappiness) : false;
	bool bNeedHappinessCritical = (eNeedHappinessCritical != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eNeedHappinessCritical) : false;
	bool bLosingMoney = (eLosingMoney != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eLosingMoney) : false;

	// **************************
	// Would we like to buyout a minor this turn?  (Venice / Austria UA)
	// **************************
	bool bWantsToBuyout = false;
	if(GetPlayer()->IsAbleToAnnexCityStates())
	{
		if(bFoundCity || bExpandToOtherContinents ||
		        GetStateAllWars() == STATE_ALL_WARS_LOSING ||
		        IsGoingForWorldConquest() ||
		        m_pPlayer->calculateGoldRate() > 100)
		{
			bWantsToBuyout = true;
		}
		else
		{
			int iThreshold = iExpansionFlavor; //antonjs: todo: xml
			int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iExpansionFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			if(iRandRoll < iThreshold)
				bWantsToBuyout = true;
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayer()->IsDiplomaticMarriage())
	{
		//Always yes please
		bWantsToBuyout = true;
	}
#endif

	// **************************
	// Would we like to give a gold gift this turn?
	// **************************
	bool bWantsToMakeGoldGift = false;

	// If we're a highly diplomatic leader, then always look for an opportunity
	if(iDiplomacyFlavor >= /*4*/ GC.getMC_ALWAYS_GIFT_DIPLO_THRESHOLD() ||
	        IsGoingForDiploVictory() ||
	        IsGoingForCultureVictory() ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT) ||
	        IsHasActiveGoldQuest() ||
	        m_pPlayer->calculateGoldRate() > 100) // if we are very wealthy always do this
	{
		bWantsToMakeGoldGift = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iDiplomacyFlavor;
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iDiplomacyFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		// Threshold will be 15 for a player (3 flavor * 5)
		// Threshold will be 5 for non-diplomatic player (2 flavor * 5)

		if(iRandRoll < iThreshold)
			bWantsToMakeGoldGift = true;
	}

	// **************************
	// Would we like to get a unit by bullying this turn?
	// **************************
	bool bWantsToBullyUnit = false;
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	// Would we like to get Heavy Tribute by bullying this turn?
	if(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	{
		int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_GROWTH"));
		int iScienceFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_SCIENCE"));
		int iCultureFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_CULTURE"));
		int iFaithFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_RELIGION"));
		int iProductionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_PRODUCTION"));

		// Loop through all (known) Minors
		PlayerTypes eMinor;
		int iValue = 0;
		for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			eMinor = (PlayerTypes) iMinorLoop;

			if(GET_PLAYER(eMinor).isMinorCiv())
			{
				if((iScienceFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_SCIENCE));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
						}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iScienceFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if (iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
							break;
						}
				else if((iProductionFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_PRODUCTION));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
						{
						iThreshold = 10;
						}
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iProductionFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if (iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
							break;
						}
				else if((iCultureFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_CULTURE));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
						{
						iThreshold = 10;
						}
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iCultureFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if (iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
							break;
						}
				else if((iFaithFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FAITH));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
						}
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iFaithFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if (iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
							break;
						}
				else if((iGrowthFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FOOD));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
						}
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iGrowthFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if (iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
							break;
						}
				else
				{
					if(GetPlayer()->GetEconomicAI()->GetWorkersToCitiesRatio() < 0.25 &&  //antonjs: todo: XML
			        GetPlayer()->GetEconomicAI()->GetImprovedToImprovablePlotsRatio() < 0.50) //antonjs: todo: XML
					{
						bWantsToBullyUnit = true;
					}
					// Otherwise, do a random roll
					else
					{
						int iThreshold = iTileImprovementFlavor; //antonjs: todo: XML
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iTileImprovementFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if(iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
					}
				}
			}
		}
	}
	else
	{
#endif	
	if(GetPlayer()->GetEconomicAI()->GetWorkersToCitiesRatio() < 0.25 &&  //antonjs: todo: XML
	        GetPlayer()->GetEconomicAI()->GetImprovedToImprovablePlotsRatio() < 0.50) //antonjs: todo: XML
	{
		bWantsToBullyUnit = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iTileImprovementFlavor; //antonjs: todo: XML
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iTileImprovementFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		if(iRandRoll < iThreshold)
			bWantsToBullyUnit = true;
	}
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	}
#endif

	//antonjs: todo: if too many workers then set to false (ex. want to disband workers you have)

	// **************************
	// Would we like to get some gold by bullying this turn?
	// **************************
	bool bWantsToBullyGold = false;

	if(iGoldFlavor >= 6 ||  //antonjs: todo: GC.getMC_ALWAYS_BULLY_GOLD_THRESHOLD()
	        IsGoingForWorldConquest() ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_UNIT) ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_BUILDING) ||
	        bLosingMoney ||
	        m_pPlayer->calculateGoldRate() < 0) // if we are losing gold per turn
	{
		bWantsToBullyGold = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iGoldFlavor; //antonjs: todo: XML
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iGoldFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		if(iRandRoll < iThreshold)
			bWantsToBullyGold = true;
	}

	if(BULLY_DEBUGGING)
	{
		//bWantsToMakeGoldGift = false;
		//bWantsToBullyGold = true;
		//bWantsToBullyUnit = true;
	}

	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBuyout; // Austria UA
	CvWeightedVector<MinorGoldGiftInfo, MAX_PLAYERS, true> veMinorsToGiveGold;
	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBullyGold;
	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBullyUnit;

	int iLargeGift = /*1000*/ GC.getMINOR_GOLD_GIFT_LARGE();
	int iMediumGift = /*500*/ GC.getMINOR_GOLD_GIFT_MEDIUM();
	int iSmallGift = /*250*/ GC.getMINOR_GOLD_GIFT_SMALL();
	int iLargeGiftFriendship;
	int iMediumGiftFriendship;
	int iSmallGiftFriendship;
	bool bMediumGiftAllies;
	bool bSmallGiftAllies;

	PlayerTypes eID = GetID();

	CvMinorCivInfo* pMinorInfo;
	CvPlayer* pMinor;
	CvMinorCivAI* pMinorCivAI;

	int iOtherMajorLoop;
	PlayerTypes eOtherMajor;
	int iFriendshipWithMinor;
	int iOtherPlayerFriendshipWithMinor;

	bool bWantsToConnect;

	MinorCivApproachTypes eApproach;

	int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_GROWTH"));

#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
	if(MOD_BALANCE_CORE_AFRAID_ANNEX)
	{
		if (GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
		{
			if(!GetPlayer()->IsEmpireUnhappy())
			{
				bWantsToBullyUnit = true;
				bWantsToBullyGold = false;
				bWantsToMakeGoldGift = false;
			}
		}
		if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
		{
			if (!GetPlayer()->IsEmpireUnhappy())
			{
				bWantsToBullyUnit = true;
				bWantsToBullyGold = true;
				bWantsToMakeGoldGift = false;
			}
		}
	}

	if (GetPlayer()->IsCanBullyFriendlyCS())
	{
		bWantsToBullyUnit = true;
		bWantsToBullyGold = true;
		bWantsToMakeGoldGift = false;
	}
	else if (GetPlayer()->GetBullyGlobalCSReduction())
	{
		bWantsToBullyUnit = true;
		bWantsToBullyGold = true;
		bWantsToMakeGoldGift = false;
	}
#endif
	// Loop through all (known) Minors
	PlayerTypes eMinor;
	TeamTypes eMinorTeam;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;

		pMinor = &GET_PLAYER(eMinor);
		pMinorCivAI = pMinor->GetMinorCivAI();
		eMinorTeam = pMinor->getTeam();

		bWantsToConnect = false;
		bool bWantsToGiveGoldToThisMinor = false;
		bool bWantsToBullyUnitFromThisMinor = false;
		bool bWantsToBullyGoldFromThisMinor = false;
		bool bWantsToBuyoutThisMinor = false;

		if(IsPlayerValid(eMinor))
		{
			// Can't do anything with minors we're at war with, besides make peace (which isn't done here, but in DoMakePeaceWithMinors())
			if(IsAtWar(eMinor))
				continue;

			eApproach = GetMinorCivApproach(eMinor);

			// Do we want to change our protection of this minor?
			DoUpdateMinorCivProtection(eMinor, eApproach);

			// Do we want to connect to this player?
			if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_ROUTE))
			{
				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE ||
				        eApproach == MINOR_CIV_APPROACH_FRIENDLY)
				{
					if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						bWantsToConnect = true;
				}
			}

			// Calculate desirability to buyout this minor
			if(bWantsToBuyout)
			{
				int iValue = 100; //antonjs: todo: xml
				// Only bother if we actually can buyout
				CvCity* pMinorCapital = pMinor->getCapitalCity();
				if(GetPlayer()->IsAbleToAnnexCityStates() && pMinorCivAI->CanMajorBuyout(eID) && pMinorCapital != NULL)
				{
					// Determine presence of player cities on this continent
					int iMinorArea = pMinorCapital->getArea();
					CvArea* pMinorArea = GC.getMap().getArea(iMinorArea);
					bool bPresenceInArea = false;
					int iMajorCapitalsInArea = 0;
					if(pMinorArea)
					{
						// Do we have a city here?
						if(pMinorArea->getCitiesPerPlayer(eID) > 0)
							bPresenceInArea = true;

						// Does another major civ have their capital here? (must be visible)
						for(int iMajorRivalLoop = 0; iMajorRivalLoop < MAX_MAJOR_CIVS; iMajorRivalLoop++)
						{
							PlayerTypes eMajorRivalLoop = (PlayerTypes) iMajorRivalLoop;
							if(eMajorRivalLoop == eID)
								continue;

							if(GET_PLAYER(eMajorRivalLoop).isAlive())
							{
								CvCity* pCapital = GET_PLAYER(eMajorRivalLoop).getCapitalCity();
								if(pCapital && pCapital->plot())
								{
									CvPlot* pPlot = pCapital->plot();
									if(pPlot->isVisible(GetTeam()))
										iMajorCapitalsInArea++;
								}
							}
						}
					}
					else
					{
						CvAssertMsg(false, "Could not lookup minor civ's area! Please send Anton your save file and version.");
					}

					// How many units does the city-state have?
					int iMinorMilitaryUnits = 0;
					int iMinorUnits = 0;
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = pMinor->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pMinor->nextUnit(&iLoop))
					{
						if(pLoopUnit->IsCanAttack() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)
						{
							iMinorMilitaryUnits++;
						}
						iMinorUnits++;
					}

					// Foreign continent
					if(!bPresenceInArea)
					{
						// Military foothold to attack other majors
						if(IsGoingForWorldConquest() && iMajorCapitalsInArea > 0)
						{
							iValue += 100; //antonjs: todo: xml
						}
						// Expansion
						else if(bExpandToOtherContinents)
						{
							iValue += 60; //antonjs: todo: xml
						}
						else
						{
							iValue += -50; //antonjs: todo: xml
						}
					}
					// Continent we have presence on
					else
					{
						// Proximity plays a large factor, since we don't want a remote, isolated city
						if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						{
							iValue += 100; //antonjs: todo: xml
							// Military units could come to our rescue quickly
							if(GetStateAllWars() == STATE_ALL_WARS_LOSING)
							{
								if(iMinorMilitaryUnits > 0)  //antonjs: todo: xml
								{
									iValue += (iMinorMilitaryUnits) * 10; //antonjs: todo: xml
								}
								else
								{
									iValue -= 50; //antonjs: todo: xml
								}
							}
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
						{
							iValue += 10; //antonjs: todo: xml
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
						{
							iValue += -50; //antonjs: todo: xml
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_DISTANT)
						{
							iValue += -100; //antonjs: todo: xml
						}
					}

					// Military units - How many, and can we support them?
					if(GetPlayer()->GetNumUnitsSupplied() >= GetPlayer()->getNumUnits() + iMinorUnits)
					{
						iValue += (iMinorMilitaryUnits) * 5;
					}

					// Happiness
					if(bNeedHappiness)
						iValue += -50; //antonjs: todo: xml
					if(bNeedHappinessCritical)
						iValue += -150; //antonjs: todo: xml

					// Potential bonuses lost
					MinorCivTraitTypes eTrait = pMinorCivAI->GetTrait();
					if(eTrait == MINOR_CIV_TRAIT_CULTURED && IsGoingForCultureVictory())
					{
						iValue += -70; //antonjs: todo: xml
					}
					else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)
					{
						if(bNeedHappiness)
							iValue += -100; //antonjs: todo: xml
						if(bNeedHappinessCritical)
							iValue += -150; //antonjs: todo: xml
					}

					// Time to decide - Do we want it enough?
					if(iValue > 100)  //antonjs: todo: xml
					{
						veMinorsToBuyout.push_back(eMinor, iValue);
						bWantsToBuyoutThisMinor = true;
					}
				}
#if defined(MOD_BALANCE_CORE)
				// Only bother if we actually can buyout
				if(GetPlayer()->IsDiplomaticMarriage() && pMinorCivAI->CanMajorDiploMarriage(eID))
				{
					veMinorsToBuyout.push_back(eMinor, 1000);
						bWantsToBuyoutThisMinor = true;
				}	
#endif
			}

			// Calculate desirability to give this minor gold
			if(bWantsToMakeGoldGift && !bWantsToBuyoutThisMinor)
			{
#if defined(MOD_DIPLOMACY_CITYSTATES)
				if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly())
				{
					continue;
				}
				if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == GetID())
				{
					continue;
				}
#endif
				int iValue = /*100*/ GC.getMC_GIFT_WEIGHT_THRESHOLD();
				// If we're not protective or friendly, then don't bother with minor diplo
				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE || eApproach == MINOR_CIV_APPROACH_FRIENDLY)
				{
					MinorGoldGiftInfo sGiftInfo;
					sGiftInfo.eMinor = eMinor;
					sGiftInfo.eMajorRival = NO_PLAYER;
					sGiftInfo.bQuickBoost = false;
					sGiftInfo.iGoldAmount = 0;

					// if we are rich we are more likely to, conversely if we are poor...
					iValue += min(max(0, m_pPlayer->calculateGoldRate() - 50),100);

					pMinorInfo = GC.getMinorCivInfo(pMinorCivAI->GetMinorCivType());

					// Diplo victory makes us more likely to spend gold
					if(IsGoingForDiploVictory())
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					// double up if this is the home stretch
					if(GC.getGame().IsUnitedNationsActive())
					{
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					}
					// Going for Culture victory, focus on Cultural city states
					else if(IsGoingForCultureVictory())
					{
						if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_CULTURED)
							iValue += /*100*/ GC.getMC_GIFT_WEIGHT_CULTURE_VICTORY();
					}
					// Going for Conquest victory, focus on Militaristic city states
					else if(IsGoingForWorldConquest())
					{
						if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
							iValue += /*100*/ GC.getMC_GIFT_WEIGHT_CONQUEST_VICTORY();
					}

					//antonjs: todo: work extra gold quest INF potential into the friends/allies/passing logic as well
					// Gold gift quest is active, so we would get more bang for our bucks
					if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_GIVE_GOLD))
					{
						iValue += 150; //antonjs: todo: constant/XML
					}

					// Invest quest is active, so we would get more bang for our bucks
					if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_INVEST))
					{
						iValue += 100; //antonjs: todo: constant/XML
					}

					// having traits that give us bonuses also make us want to spend gold
					if(m_pPlayer->GetPlayerTraits()->GetCityStateFriendshipModifier() > 0 || m_pPlayer->GetPlayerTraits()->GetCityStateBonusModifier())
					{
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					}

					// Nearly everyone likes to grow
					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME && !GetPlayer()->IsEmpireUnhappy())
					{
						iValue += /*20*/ GC.getMC_GIFT_WEIGHT_MARITIME_GROWTH() * iGrowthFlavor * max(1, GetPlayer()->getNumCities() / 3);
					}

					// Slight negative weight towards militaristic
					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MILITARISTIC && !IsGoingForWorldConquest())
						iValue += /*-50*/ GC.getMC_GIFT_WEIGHT_MILITARISTIC();

					// If they have a resource we don't have, add extra weight
					int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(eID);
					if(iResourcesWeLack > 0)
						iValue += (iResourcesWeLack* /*80*/ GC.getMC_GIFT_WEIGHT_RESOURCE_WE_NEED());

					// If we're protective this is worth more than if we're friendly
					if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE)
						iValue += /*10*/ GC.getMC_GIFT_WEIGHT_PROTECTIVE();

					// If the minor is hostile, then reduce the weighting
					if(pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)
						iValue += /*-20*/ GC.getMC_GIFT_WEIGHT_HOSTILE();

					// The closer we are the better
					if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						iValue += /*5*/ GC.getMC_GIFT_WEIGHT_NEIGHBORS();
					else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
						iValue += /*4*/ GC.getMC_GIFT_WEIGHT_CLOSE();
					else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
						iValue += /*3*/ GC.getMC_GIFT_WEIGHT_FAR();

					iLargeGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iLargeGift);
					iMediumGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iMediumGift);
					iSmallGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iSmallGift);

					iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eID);

					// Only care if we'll actually be Allies or better
					bMediumGiftAllies = iFriendshipWithMinor + iMediumGiftFriendship >= pMinorCivAI->GetAlliesThreshold(eID);
					bSmallGiftAllies = iFriendshipWithMinor + iSmallGiftFriendship >= pMinorCivAI->GetAlliesThreshold(eID);

					// Loop through other players to see if we can pass them
					for(iOtherMajorLoop = 0; iOtherMajorLoop < MAX_MAJOR_CIVS; iOtherMajorLoop++)
					{
						eOtherMajor = (PlayerTypes) iOtherMajorLoop;

						// Player must be alive
						if(!GET_PLAYER(eOtherMajor).isAlive())
							continue;

						iOtherPlayerFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eOtherMajor);

						// Player must have friendship with this major
						if(iOtherPlayerFriendshipWithMinor <= 0)
							continue;

						// They must have more friendship with this guy than us
						if(iFriendshipWithMinor <= iOtherPlayerFriendshipWithMinor)
							continue;

						// If we can pass them with a small gift, great
						if(bSmallGiftAllies && iOtherPlayerFriendshipWithMinor - iFriendshipWithMinor < iSmallGiftFriendship)
						{
							iValue += /*15*/ GC.getMC_SMALL_GIFT_WEIGHT_PASS_OTHER_PLAYER();
							sGiftInfo.bQuickBoost = true;
							sGiftInfo.eMajorRival = eOtherMajor;
						}
						// If a medium gift passes them up, that's good too
						else if(bMediumGiftAllies && iOtherPlayerFriendshipWithMinor - iFriendshipWithMinor < iMediumGiftFriendship)
						{
							iValue += /*10*/ GC.getMC_GIFT_WEIGHT_PASS_OTHER_PLAYER();
							sGiftInfo.eMajorRival = eOtherMajor;
						}
						// We're behind and we can't catch up right now, so zero-out the value
						else
							iValue = 0;
					}

					// Are we already allies?
					if(pMinorCivAI->IsAllies(eID))
					{
						// Are we close to losing our status?
						if(pMinorCivAI->IsCloseToNotBeingAllies(eID))
						{
							iValue += /*150*/ GC.getMC_GIFT_WEIGHT_ALMOST_NOT_ALLIES();
							sGiftInfo.bQuickBoost = true;
						}
						// Not going to lose status, so not worth going after this guy
						else
							iValue = 0;
					}
					// Are we already Friends?
					else if(pMinorCivAI->IsFriends(eID))
					{
						// Are we close to losing our status?
						if(pMinorCivAI->IsCloseToNotBeingFriends(eID))
						{
							iValue += /*125*/ GC.getMC_GIFT_WEIGHT_ALMOST_NOT_FRIENDS();
							sGiftInfo.bQuickBoost = true;
						}
						// Not going to lose status, so not worth going after this guy
						else if(!IsGoingForDiploVictory() || !GC.getGame().IsUnitedNationsActive())
							iValue = 0;
					}

					// Did we bully you recently?  If so, giving you gold now would be very odd.
					if(pMinorCivAI->IsRecentlyBulliedByMajor(eID))
					{
						iValue -= 100; //antonjs: todo: constant/XML
					}

					//antonjs: consider: different behavior to CS that have been bullied by others, bullied by rival, etc.

					// Do we want it enough?
					if(iValue > GC.getMC_GIFT_WEIGHT_THRESHOLD())
					{
						veMinorsToGiveGold.push_back(sGiftInfo, iValue);
						bWantsToGiveGoldToThisMinor = true;
					}
				}
			}

			// Calculate desirability to bully a unit from this minor
			if (bWantsToBullyUnit && !bWantsToBuyoutThisMinor && !bWantsToGiveGoldToThisMinor)  //antonjs: todo: xml
			{
				int iValue = 100; //antonjs: todo: XML, bully threshold
				if (MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
					iValue = pMinor->GetMinorCivAI()->CalculateBullyScore(eID, true);

				if (iValue <= 0)
					continue;

				if(eApproach == MINOR_CIV_APPROACH_BULLY)
				{
					// Only bother if we can successfully bully
					if (pMinor->GetMinorCivAI()->CanMajorBullyUnit(eID, MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING ? iValue - 25 : 0))
					{
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						if (MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						{
							int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH")) / 2;
							int iScienceFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SCIENCE")) / 2;
							int iCultureFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE")) / 2;
							int iFaithFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION")) / 2;
							int iProductionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_PRODUCTION")) / 2;

							if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_SCIENCE) * iScienceFlavor) / 5;
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_PRODUCTION) * iProductionFlavor) / 5;
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_CULTURE) * iCultureFlavor) / 5;
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FAITH) * iFaithFlavor) / 5;
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FOOD) * iGrowthFlavor) / 5;
							}
							iValue += GC.getGame().getSmallFakeRandNum(GetBoldness(), eID+m_pPlayer->getGlobalAverage(YIELD_CULTURE));
						}
						else
						{
#endif
						// The closer we are the better, because the unit travels less distance to get home
						if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
							iValue += 25;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
							iValue += 15;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
							iValue += -15;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_DISTANT)
							iValue += -25;
						//antonjs: consider: knock it down if is there a chance the worker will get captured by a nearby rival
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						}
#endif
						//antonjs: consider: if military unit, it would be a good thing to get it near a rival or ongoing war

						// If this minor has a PtP from someone, bullying it could have big consequences
						if (!GetPlayer()->GetPlayerTraits()->IgnoreBullyPenalties())
						{
							if (pMinor->GetMinorCivAI()->IsProtectedByAnyMajor())
							{
								iValue += -20;
								//antonjs: consider: scale based on which major is protecting it
							}
							else if (pMinor->GetMinorCivAI()->GetAlly() != NO_PLAYER)
							{
								iValue += -20;
							}
							else
							{
								iValue += 20;
							}
						}
						else
						{
							iValue += 25;
						}
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if(MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
							{
								if(!GetPlayer()->IsEmpireUnhappy())
								{
									iValue += 100;
								}
								else
								{
									iValue -= 50;
								}
							}
						}
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if (MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
							{
								iValue += 25;
							}
						}
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes)iI;
							if (eYield != NO_YIELD)
							{
								if (GetPlayer()->GetYieldFromMinorDemand(eYield) > 0)
								{
									iValue += 10;
								}
							}
						}

						iValue -= GetDiploBalance() * 2;
#endif
						//antonjs: consider: allies or friends with another major
						//antonjs: consider: distance to other majors
						// If we are getting a bonus, don't mess that up!
						if(pMinor->GetMinorCivAI()->IsAllies(eID) || pMinor->GetMinorCivAI()->IsFriends(eID))
						{
							if (!GetPlayer()->IsCanBullyFriendlyCS())
								iValue = 0;
						}
						// Do we want it enough?
						if(iValue > 100)  //antonjs: todo: XML for threshold
						{
							veMinorsToBullyUnit.push_back(eMinor, iValue);
							bWantsToBullyUnitFromThisMinor = true;
						}
					}
				}
			}

			// Calculate desirability to bully gold from this minor
			if(bWantsToBullyGold && !bWantsToBuyoutThisMinor && !bWantsToGiveGoldToThisMinor && !bWantsToBullyUnitFromThisMinor)
			{
				int iValue = 100; //antonjs: todo: XML, bully threshold
				if (MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
					iValue = pMinor->GetMinorCivAI()->CalculateBullyScore(eID, false);

				if (iValue <= 0)
					continue;

				if(eApproach == MINOR_CIV_APPROACH_BULLY)
				{
					// Only bother if we can successfully bully
					if (pMinor->GetMinorCivAI()->CanMajorBullyGold(eID, MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING ? iValue - 25 : 0))
					{
						// The closer we are the better
						// The closer we are the better, because the unit travels less distance to get home
						if (GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
							iValue += 25;
						else if (GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
							iValue += 15;
						else if (GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
							iValue += -15;
						else if (GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_DISTANT)
							iValue += -25;

						// We like to keep bullying the same minor
						if(pMinor->GetMinorCivAI()->IsEverBulliedByMajor(eID))
						{
							iValue += 25;
						}

						// If we have not bullied this minor recently, but someone else has, it might be good to wait for an opportunity to gain a lot of INF
						if(!pMinor->GetMinorCivAI()->IsRecentlyBulliedByMajor(eID) && pMinor->GetMinorCivAI()->IsRecentlyBulliedByAnyMajor())
						{
							iValue += -15;
							//antonjs: consider: but if everyone near the minor has bullied it, then there is nobody to come to its rescue, so we can bully safely
						}

						// If this minor has a PtP from someone, bullying it could have big consequences
						if(pMinor->GetMinorCivAI()->IsProtectedByAnyMajor())
						{
							iValue += -20;
							//antonjs: consider: scale based on which major is protecting it
						}
						else
						{
							iValue += 20;
						}
						//antonjs: consider: allies or friends another major
						//antonjs: consider: distance to other majors

#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if (MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
							{
								iValue += 25;
							}
						}
#endif

						// If we are getting a bonus, don't mess that up!
						if(pMinor->GetMinorCivAI()->IsAllies(eID) || pMinor->GetMinorCivAI()->IsFriends(eID))
						{
							if (!GetPlayer()->IsCanBullyFriendlyCS())
								iValue = 0;
						}

						// Do we want it enough?
						if(iValue > 100)  //antonjs: todo: XML for threshold
						{
							veMinorsToBullyGold.push_back(eMinor, iValue);
							bWantsToBullyGoldFromThisMinor = true;
						}
					}
				}
			}

		}

		SetWantToRouteConnectToMinor(eMinor, bWantsToConnect);
	}

	int iGoldReserve = GetPlayer()->GetTreasury()->GetGold();

	// Do we want to buyout a minor?
	if(veMinorsToBuyout.size() > 0)
	{
		veMinorsToBuyout.SortItems();
		int iGoldLeft = GetPlayer()->GetTreasury()->GetGold();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBuyout.size(); i++)
		{
			eLoopMinor = veMinorsToBuyout.GetElement(i);
			int iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetBuyoutCost(eID);
			if(iGoldLeft >= iBuyoutCost)
			{
				if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBuyout(eID))
				{
					GC.getGame().DoMinorBuyout(eID, eLoopMinor);
					iGoldLeft -= iBuyoutCost;
					break; // Don't buyout more than once in a single turn
				}
				else
				{
					CvAssertMsg(false, "Chose a minor to buyout that cannot actually be bought! Please send Anton your save file and version.");
				}
			}
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					LogMinorCivBuyout(eLoopMinor, iBuyoutCost, /*bSaving*/ true);

					int iPriority = GC.getAI_GOLD_PRIORITY_BUYOUT_CITY_STATE();
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iBuyoutCost, iPriority);
				}
			}
#if defined(MOD_BALANCE_CORE)
			iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetMarriageCost(eID);
			if(iGoldLeft >= iBuyoutCost)
			{
				if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorDiploMarriage(eID))
				{
					GET_PLAYER(eLoopMinor).GetMinorCivAI()->DoMarriage(eID);
					iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetMarriageCost(eID);
					iGoldLeft -= iBuyoutCost;
				}
				else
				{
					CvAssertMsg(false, "Chose a minor to buyout that cannot actually be bought! Please send Anton your save file and version.");
				}
			}
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					LogMinorCivBuyout(eLoopMinor, iBuyoutCost, /*bSaving*/ true);

					int iPriority = GC.getAI_GOLD_PRIORITY_BUYOUT_CITY_STATE();
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iBuyoutCost, iPriority);
				}
			}
#endif
		}
	}

	// Do we want to give someone Gold enough to actually do it?
	if(veMinorsToGiveGold.size() > 0)
	{
		veMinorsToGiveGold.SortItems(); // Sort from highest desirability to lowest
		for(int i = 0; i < veMinorsToGiveGold.size(); i++)
		{
			int iGoldLeft = GetPlayer()->GetTreasury()->GetGold();
			MinorGoldGiftInfo sGift = veMinorsToGiveGold.GetElement(i);
#if defined(MOD_BALANCE_CORE)
			//Interception! Let's do a tile improvement if we can (and we'll benefit from it)
			if (sGift.eMinor != NO_PLAYER && GET_PLAYER(sGift.eMinor).GetMinorCivAI()->IsFriends(GetID()))
			{
				CvPlot* pImprovementPlot = GET_PLAYER(sGift.eMinor).GetMinorCivAI()->GetMajorGiftTileImprovement(GetID());
				if (pImprovementPlot != NULL)
				{
					GET_PLAYER(sGift.eMinor).GetMinorCivAI()->DoTileImprovementGiftFromMajor(GetID(), pImprovementPlot->getX(), pImprovementPlot->getY());
					LogMinorCivGiftTile(sGift.eMinor);
				}
			}
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
			//Default is 1 - this will prevent the AI from trying to spam gold gifts of zero gold.
			if (MOD_DIPLOMACY_CITYSTATES && GC.getCSD_GOLD_GIFT_DISABLED() > 0)
			{
				continue;
			}
#endif			
			sGift.iGoldAmount = 0;

			if(iGoldLeft >= iSmallGift && sGift.bQuickBoost)
				sGift.iGoldAmount = iSmallGift;
			else if(iGoldLeft >= iLargeGift)
				sGift.iGoldAmount = iLargeGift;
			else if(iGoldLeft >= iMediumGift)
				sGift.iGoldAmount = iMediumGift;

			int iOldFriendship = GET_PLAYER(sGift.eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eID);

			// Able to give a gift?  Don't gift more than half of the gold we have in one turn
			if(sGift.iGoldAmount > 0 && iGoldLeft >= (iGoldReserve / 2))
			{
				GET_PLAYER(sGift.eMinor).GetMinorCivAI()->DoGoldGiftFromMajor(GetID(), sGift.iGoldAmount); //antonjs: todo: go through CvGame instead?

				LogMinorCivGiftGold(sGift.eMinor, iOldFriendship, sGift.iGoldAmount, /*bSaving*/ false, sGift.bQuickBoost, sGift.eMajorRival);

				if(GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
					GetPlayer()->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT);
			}
			// Can't afford gift yet, so start saving
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					int iAmountToSaveFor = iMediumGift;

					if(sGift.bQuickBoost)
						iAmountToSaveFor = iSmallGift;

					LogMinorCivGiftGold(sGift.eMinor, iOldFriendship, iAmountToSaveFor, /*bSaving*/ true, sGift.bQuickBoost, sGift.eMajorRival);

					int iPriority = GC.getAI_GOLD_PRIORITY_DIPLOMACY_BASE();
					iPriority += GC.getAI_GOLD_PRIORITY_DIPLOMACY_PER_FLAVOR_POINT() * iDiplomacyFlavor;
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iAmountToSaveFor, iPriority);
				}
			}
		}
	}

	// Do we want a unit enough to bully someone?
	if(veMinorsToBullyUnit.size() > 0)
	{
		veMinorsToBullyUnit.SortItems();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBullyUnit.size(); i++)
		{
			eLoopMinor = veMinorsToBullyUnit.GetElement(i);
			CvAssertMsg(eLoopMinor != NO_PLAYER, "Trying to bully a unit from NO_PLAYER! Please send Anton your save file and version.");
			if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBullyUnit(eID))
			{
				GC.getGame().DoMinorBullyUnit(eID, eLoopMinor);
				break; // Don't bully a unit more than once in a single turn
			}
			else
			{
				CvAssertMsg(false, "Chose a minor to bully unit from that cannot actually be bullied! Please send Anton your save file and version.");
			}
		}
	}

	// Do we want gold enough to bully someone?
	if(veMinorsToBullyGold.size() > 0)
	{
		veMinorsToBullyGold.SortItems();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBullyGold.size(); i++)
		{
			eLoopMinor = veMinorsToBullyGold.GetElement(i);
			CvAssertMsg(eLoopMinor != NO_PLAYER, "Trying to bully gold from NO_PLAYER! Please send Anton your save file and version.");
			if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBullyGold(eID))
			{
				GC.getGame().DoMinorBullyGold(eID, eLoopMinor);
			}
			else
			{
				CvAssertMsg(false, "Chose a minor to bully gold from that cannot actually be bullied! Please send Anton your save file and version.");
			}
		}
	}
}

void CvDiplomacyAI::DoUpdateMinorCivProtection(PlayerTypes eMinor, MinorCivApproachTypes eApproach)
{
	// Only change protection if this player is not human controlled!
	if (!GetPlayer()->isHuman())
	{
		if (eApproach == MINOR_CIV_APPROACH_PROTECTIVE || GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
		{
			// We are protective, so do a PtP if we are able to and haven't already
			if (GET_PLAYER(eMinor).GetMinorCivAI()->CanMajorStartProtection(GetID()))
			{
				GC.getGame().DoMinorPledgeProtection(GetID(), eMinor, true);
				DoMakePublicDeclaration(PUBLIC_DECLARATION_PROTECT_MINOR, eMinor, -1, eMinor);
			}
		}
		else
		{
			// We are not protective, so revoke PtP if we can
			if (GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetID()) && GET_PLAYER(eMinor).GetMinorCivAI()->CanMajorWithdrawProtection(GetID()))
			{
				GC.getGame().DoMinorPledgeProtection(GetID(), eMinor, false);
				DoMakePublicDeclaration(PUBLIC_DECLARATION_ABANDON_MINOR, eMinor, -1, eMinor);
			}
		}
	}
}

/// How many players have other major civilizations conquered?
void CvDiplomacyAI::DoUpdateConquestStats()
{
	// What players do we know exist?
	vector<PlayerTypes> vKnownPlayers;
	int iLoop;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsHasMet(eLoopPlayer, true))
		{
			if (std::find(vKnownPlayers.begin(), vKnownPlayers.end(), eLoopPlayer) == vKnownPlayers.end())
			{
				vKnownPlayers.push_back(eLoopPlayer);
			}
		}

		for (CvCity* pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))
		{
			CvPlot* pCityPlot = pLoopCity->plot();
			if (pCityPlot == NULL)
				continue;

			if (!pCityPlot->isRevealed(GetTeam()))
				continue;

			PlayerTypes eCityOwner = pCityPlot->getOwner();

			if (eCityOwner == NO_PLAYER || eCityOwner == BARBARIAN_PLAYER || eCityOwner == GetID())
				continue;

			if (std::find(vKnownPlayers.begin(), vKnownPlayers.end(), eCityOwner) == vKnownPlayers.end())
			{
				vKnownPlayers.push_back(eCityOwner);
			}

			PlayerTypes eOriginalOwner = pLoopCity->getOriginalOwner();
			if (eOriginalOwner == eCityOwner || eOriginalOwner == NO_PLAYER || eOriginalOwner == BARBARIAN_PLAYER || eOriginalOwner == GetID())
				continue;

			if (std::find(vKnownPlayers.begin(), vKnownPlayers.end(), eOriginalOwner) == vKnownPlayers.end())
			{
				vKnownPlayers.push_back(eOriginalOwner);
			}
		}
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

		if (IsPlayerValid(ePlayer, true))
		{
			int iNumMajorsConquered = 0;
			int iNumMinorsConquered = 0;

			for (std::vector<PlayerTypes>::iterator it = vKnownPlayers.begin(); it != vKnownPlayers.end(); it++)
			{
				TeamTypes eLoopTeam = GET_PLAYER(*it).getTeam();

				if (eLoopTeam == eTeam)
					continue;

				if (!GET_PLAYER(*it).isAlive() && GET_TEAM(eLoopTeam).GetKilledByTeam() == eTeam)
				{
					if (GET_PLAYER(*it).isMajorCiv())
					{
						iNumMajorsConquered++;
					}
					else if (GET_PLAYER(*it).isMinorCiv())
					{
						iNumMinorsConquered++;
					}
				}
				else if (GET_PLAYER(*it).isMajorCiv() && GET_TEAM(eLoopTeam).IsVassal(eTeam))
				{
					iNumMajorsConquered++;
				}
				else if (GET_PLAYER(*it).IsHasLostCapital())
				{
					CvPlot *pOriginalCapitalPlot = GC.getMap().plot(GET_PLAYER(*it).GetOriginalCapitalX(), GET_PLAYER(*it).GetOriginalCapitalY());
					if (pOriginalCapitalPlot != NULL && pOriginalCapitalPlot->isCity())
					{
						if (GET_PLAYER(pOriginalCapitalPlot->getOwner()).getTeam() == eTeam)
						{
							if (GET_PLAYER(*it).isMajorCiv())
							{
								iNumMajorsConquered++;
							}
							else if (GET_PLAYER(*it).isMinorCiv())
							{
								iNumMinorsConquered++;
							}
						}
					}
				}
			}

			SetPlayerNumMajorsConquered(ePlayer, iNumMajorsConquered);
			SetPlayerNumMinorsConquered(ePlayer, iNumMinorsConquered);
		}
		else
		{
			SetPlayerNumMajorsConquered(ePlayer, 0);
			SetPlayerNumMinorsConquered(ePlayer, 0);
		}
	}
}

/*
/// Possible Contact Statement - Notify human it's time for a coop war they agreed to
void CvDiplomacyAI::DoCoopWarTimeStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Don't send this to AI players - coop war timer is automatically handled in DoCounters()
		if(!GET_PLAYER(ePlayer).isHuman())
			return;

		CvTeam* pTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());

		PlayerTypes eTargetPlayer;
		TeamTypes eTargetTeam;

		for(int iTargetLoop = 0; iTargetLoop < MAX_MAJOR_CIVS; iTargetLoop++)
		{
			eTargetPlayer = (PlayerTypes) iTargetLoop;

			bool bInvalid = false;

			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), ePlayer))
			{
				bInvalid = true;
			}

			if (!IsPlayerValid(eTargetPlayer))
			{
				bInvalid = true;
			}

			if (bInvalid)
			{
				if (GetCoopWarAcceptedState(ePlayer, eTargetPlayer) == COOP_WAR_STATE_SOON)
				{
					SetCoopWarAcceptedState(ePlayer, eTargetPlayer, NO_COOP_WAR_STATE);
					SetCoopWarCounter(ePlayer, eTargetPlayer, -666);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(GetID(), eTargetPlayer, NO_COOP_WAR_STATE);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(GetID(), eTargetPlayer, -666);
				}
				continue;
			}

			// Agreed to go to war soon... what's the counter at?
			if(GetCoopWarAcceptedState(ePlayer, eTargetPlayer) == COOP_WAR_STATE_SOON)
			{
				if(GetCoopWarCounter(ePlayer, eTargetPlayer) == GC.getCOOP_WAR_SOON_COUNTER())
				{
					eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();

					// If they're already at war, don't bother
					if(!pTeam->isAtWar(eTargetTeam) && GET_PLAYER(eTargetPlayer).isAlive())
					{
						eStatement = DIPLO_STATEMENT_COOP_WAR_TIME;
						iData1 = eTargetPlayer;

						// Don't evaluate other players
						break;
					}
					// Human is already at war - process what we would have if he'd agreed at this point
					else
					{
						SetCoopWarAcceptedState(ePlayer, eTargetPlayer, COOP_WAR_STATE_ACCEPTED);

						// AI declaration
						if(!IsAtWar(eTargetPlayer) && GET_PLAYER(eTargetPlayer).isAlive())
						{
							if (DeclareWar(eTargetPlayer))
							{
								GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eTargetPlayer, 1);
							}
						}
					}
				}
			}
		}
	}
}
*/

/// Possible Contact Statement - Coop War Request
void CvDiplomacyAI::DoCoopWarStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsCoopWarRequestsDisabled())
		return;

	// Don't start a war if our empire is in bad shape for it
	if (GetPlayer()->IsNoNewWars())
		return;

	if (IsAvoidDeals())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		PlayerTypes eTargetPlayer;
		if (DoTestCoopWarDesire(ePlayer, /*passed by address*/ eTargetPlayer))
		{
			if (eTargetPlayer != NO_PLAYER)
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_COOP_WAR_REQUEST;
				int iTurnsBetweenStatements = 10;

				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					iData1 = eTargetPlayer;
				}
			}
		}
	}
}

/// Possible Contact Statement - Demand
void CvDiplomacyAI::DoMakeDemand(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		//End the gift exchange at the start of each round.
		GetPlayer()->GetDiplomacyAI()->SetOfferingGift(ePlayer, false);
		GetPlayer()->GetDiplomacyAI()->SetOfferedGift(ePlayer, false);
	}

	// We can use this deal pointer to form a trade offer
	CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

	// Clear this data out before any deals are offered.
	pDeal->ClearItems();
	pDeal->SetRequestingPlayer(NO_PLAYER);
	pDeal->SetDuration(GC.getGame().getGameSpeedInfo().GetDealDuration());
	pDeal->SetFromPlayer(GetID());
	pDeal->SetToPlayer(ePlayer);
	SetCantMatchDeal(ePlayer, false);

	//set up the deal
	if (GetPlayer()->GetDealAI()->IsMakeDemand(ePlayer, /*pDeal can be modified in this function*/ pDeal))
	{
		int iTurnsBetweenStatements = 13;
		if (GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DEMAND) >= iTurnsBetweenStatements)
		{
			DiploStatementTypes eStatement = DIPLO_STATEMENT_DEMAND;
			DoSendStatementToPlayer(ePlayer, eStatement, -1, pDeal);
			LogStatementToPlayer(ePlayer, eStatement);
			DoAddNewStatementToDiploLog(ePlayer, eStatement);
		}
	}

	// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
	pDeal->ClearItems();
}

/// Possible Contact Statement - guy has his military positioned aggressively near us
void CvDiplomacyAI::DoAggressiveMilitaryStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;

		// Don't bother if they've already made or broken a military promise to us
		if (GetPlayerMilitaryPromiseState(ePlayer) > NO_PROMISE_STATE)
			return;

		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		// If we're a vassal and the other player is an AI, don't send the statement
		if (!GET_PLAYER(ePlayer).isHuman() && GET_TEAM(GetTeam()).IsVassalOfSomeone())
			return;

		// Don't threaten if this person resurrected us
		if (WasResurrectedBy(ePlayer))
			return;

		// They're HIGH this turn and weren't last turn
		if (GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_HIGH && GetLastTurnMilitaryAggressivePosture(ePlayer) < AGGRESSIVE_POSTURE_HIGH)
			bSendStatement = true;

		// They're MEDIUM this turn and were NONE last turn
		else if (GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM && GetLastTurnMilitaryAggressivePosture(ePlayer) <= AGGRESSIVE_POSTURE_NONE)
			bSendStatement = true;

		// We're working together, so don't worry about it
		if (IsDoFAccepted(ePlayer))
			return;

		//We're allowing them Open Borders? We shouldn't care.
		if (GET_TEAM(GetTeam()).IsAllowsOpenBordersToTeam(GET_PLAYER(ePlayer).getTeam()))
			return;

		// Check other player status
		for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
		{
			PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;

			// Are we at war with the same player?
			if (IsAtWar(eThirdParty) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(eThirdParty).getTeam()))
				return;

			// Are they at war with anyone we're neighbors with?
			if (GetPlayer()->GetProximityToPlayer(eThirdParty) == PLAYER_PROXIMITY_NEIGHBORS && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(eThirdParty).getTeam()))
				return;
		}

		if (bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING;
			int iTurnsBetweenStatements = 20;

			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Killed a City-State we're protective towards
void CvDiplomacyAI::DoKilledCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		if(IsPlayerMadeAttackCityStatePromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorKilled(ePlayer);
				if(eMinorCiv != NO_PLAYER)
				{
					CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
					CvAssert(eMinorCiv < MAX_CIV_PLAYERS);

					eStatement = eTempStatement;

					iData1 = eMinorCiv;
				}
			}
		}
	}
}

/// Possible Contact Statement - Attacked a City-State we're protective towards
void CvDiplomacyAI::DoAttackedCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		if (GetOtherPlayerAttackedProtectedMinorTurn(ePlayer) == GC.getGame().getGameTurn())
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE;
			int iTurnsBetweenStatements = 1;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorAttacked(ePlayer);
				if(eMinorCiv != NO_PLAYER)
				{
					CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
					CvAssert(eMinorCiv < MAX_CIV_PLAYERS);
					// Minor civ must still be alive!
					if(GET_PLAYER(eMinorCiv).isAlive())
					{	
						eStatement = eTempStatement;
						iData1 = eMinorCiv;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Bullied a City-State we're protective towards
void CvDiplomacyAI::DoBulliedCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		// Bullied a City State we're protective towards
		if (GetOtherPlayerBulliedProtectedMinorTurn(ePlayer) == GC.getGame().getGameTurn())
		{
			// Have we asked you to make a promise before?
			if(IsPlayerBrokenBullyCityStatePromise(ePlayer) ||
			        IsPlayerIgnoredBullyCityStatePromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
#if defined(MOD_DIPLOMACY_CITYSTATES)
				if (MOD_DIPLOMACY_CITYSTATES && (GetMajorCivApproach(ePlayer) <= MAJOR_CIV_APPROACH_HOSTILE))
				{
					const char* strText;
					bool bActivePlayer = GC.getGame().getActivePlayer() == ePlayer;
					if (DeclareWar(ePlayer))
					{
						GetPlayer()->GetMilitaryAI()->RequestCityAttack(ePlayer,1);
					}

					if(bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WARMONGER);
						gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
					}
				}
#endif
			}
			// Otherwise, ask you to make a promise
			else if (GetPlayerBullyCityStatePromiseState(ePlayer) == NO_PROMISE_STATE)
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE;
				int iTurnsBetweenStatements = 1;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorBullied(ePlayer);
					if(eMinorCiv != NO_PLAYER)
					{
						CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
						CvAssert(eMinorCiv < MAX_CIV_PLAYERS);
						// Minor civ must still be alive!
						if(GET_PLAYER(eMinorCiv).isAlive())
						{
							eStatement = eTempStatement;
							iData1 = eMinorCiv;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Comment on aggressive expansion by this player
void CvDiplomacyAI::DoExpansionWarningStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;
		if (GET_PLAYER(ePlayer).GetTurnsSinceSettledLastCity() < GC.getEXPANSION_BICKER_TIMEOUT() && !EverMadeExpansionPromise(ePlayer) && GetPlayerExpansionPromiseState(ePlayer) == NO_PROMISE_STATE)
		{
			// We're fiercely opposed to their expansion
			if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_FIERCE)
				bSendStatement = true;

			// Have a strong dispute over land now, and didn't last turn
			else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetLastTurnLandDisputeLevel(ePlayer) < DISPUTE_LEVEL_STRONG)
			{
				if(GetExpansionAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM)
					bSendStatement = true;
			}
		}

		if(bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXPANSION_WARNING;
			int iTurnsBetweenStatements = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Tell the player he broke his expansion promise
void CvDiplomacyAI::DoExpansionBrokenPromiseStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsPlayerBrokenExpansionPromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Comment on aggressive Plot Buying by this player
void CvDiplomacyAI::DoPlotBuyingWarningStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;
		if (!EverMadeBorderPromise(ePlayer) && GetPlayerBorderPromiseState(ePlayer) == NO_PROMISE_STATE)
		{
			if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			{
				// We've spotten them buying up Plots
				if(GetPlotBuyingAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_LOW)
					bSendStatement = true;
			}
		}

		if(bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_PLOT_BUYING_WARNING;
			int iTurnsBetweenStatements = (GC.getBORDER_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}

	}
}

/// Possible Contact Statement - Tell the player he broke his Plot Buying promise
void CvDiplomacyAI::DoPlotBuyingBrokenPromiseStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsPlayerBrokenBorderPromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - We attacked a minor that is protected by someone
void CvDiplomacyAI::DoWeAttackedYourMinorStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		for (int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			PlayerTypes eMinor = (PlayerTypes) iMinorCivLoop;

			if (IsAtWar(eMinor) && GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(ePlayer))
			{
				// Did we declare war on them recently?
				int iTurn = GET_PLAYER(eMinor).GetMinorCivAI()->GetTurnLastAttacked(GetTeam());
				if (iTurn < 0)
					return;

				int iTurnDifference = GC.getGame().getGameTurn() - iTurn;

				if (iTurnDifference < 10)
				{
					// Has this message not yet been sent during this war?
					if (!HasSentAttackProtectedMinorTaunt(ePlayer, eMinor))
					{
						DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR;
						int iTurnsBetweenStatements = 1;
						if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
						{
							CvAssert(eMinor >= MAX_MAJOR_CIVS);
							CvAssert(eMinor < MAX_CIV_PLAYERS);

							eStatement = eTempStatement;
							iData1 = eMinor;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - We bullied a minor that is protected by someone
void CvDiplomacyAI::DoWeBulliedYourMinorStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;
		PlayerTypes eMinor;
		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			eMinor = (PlayerTypes) iMinorCivLoop;

			// Minor must be alive
			if(!GET_PLAYER(eMinor).isAlive())
				continue;

			// Did we bully this minor last turn?
			if(GET_PLAYER(eMinor).GetMinorCivAI()->IsEverBulliedByMajor(GetID()))
			{
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetTurnLastBulliedByMajor(GetID()) == (GC.getGame().getGameTurn() - 1))
				{
					// Is this minor protected by this player?
					if(GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(ePlayer))
					{
						DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR;

						int iTurnsBetweenStatements = 1;

						if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
						{
							CvAssert(eMinor >= MAX_MAJOR_CIVS);
							CvAssert(eMinor < MAX_CIV_PLAYERS);

							eStatement = eTempStatement;
							iData1 = eMinor;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - We caught this player spying on us
void CvDiplomacyAI::DoCaughtYourSpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[ePlayer] == GC.getGame().getGameTurn())
		{
			// Ask you to make a promise if you haven't before
			if (GetPlayerSpyPromiseState(ePlayer) == NO_PROMISE_STATE)
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_CAUGHT_YOUR_SPY;
				int iTurnsBetweenStatements = 40;

				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We killed this player's spy
void CvDiplomacyAI::DoKilledYourSpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(m_pPlayer->GetEspionageAI()->m_aiNumSpiesKilled[ePlayer] > 0)
		{
			if(m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyKilled[ePlayer] == GC.getGame().getGameTurn())
			{
				// Ask you to make a promise if you haven't before
				if (GetPlayerSpyPromiseState(ePlayer) == NO_PROMISE_STATE)
				{
					DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_YOUR_SPY;
					int iTurnsBetweenStatements = 40;

					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - This player killed our spy
void CvDiplomacyAI::DoKilledMySpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyDied[ePlayer] == GC.getGame().getGameTurn() - 1)
		{
			if (!IsPlayerBrokenSpyPromise(ePlayer) && !IsPlayerIgnoredSpyPromise(ePlayer)) // Ignore if they refuse to stop spying on us
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_MY_SPY;
#if defined(MOD_BALANCE_CORE_SPIES)
				int iTurnsBetweenStatements = 40;
#else
				int iTurnsBetweenStatements = 1;
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - Share intrigue with this player
void CvDiplomacyAI::DoShareIntrigueStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		IntrigueNotificationMessage* pNotificationMessage = m_pPlayer->GetEspionage()->GetRecentIntrigueInfo(ePlayer);
		if (pNotificationMessage)
		{
			// if this player has an untold plot against a player
			if(pNotificationMessage->m_eSourcePlayer != NO_PLAYER)
			{
				bool bIsNewIntrigue = true;
				// has any other player told the player about this plot?
				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes eOtherPlayer = (PlayerTypes)ui;
					// don't evaluate the plotting player
					if(eOtherPlayer == pNotificationMessage->m_eSourcePlayer)
					{
						continue;
					}

					if(GET_PLAYER(eOtherPlayer).GetEspionage()->HasSharedIntrigue(ePlayer, pNotificationMessage->m_eSourcePlayer, (CvIntrigueType)(pNotificationMessage->m_iIntrigueType)))
					{
						bIsNewIntrigue = false;
						break;
					}
				}

				if(bIsNewIntrigue)
				{
					MajorCivApproachTypes eApproachTowardsTarget = m_pPlayer->GetDiplomacyAI()->GetMajorCivApproach(ePlayer);
					MajorCivOpinionTypes eOpinionOfTarget = m_pPlayer->GetDiplomacyAI()->GetMajorCivOpinion(ePlayer);
					MajorCivOpinionTypes eOpinionOfPlotter = m_pPlayer->GetDiplomacyAI()->GetMajorCivOpinion(pNotificationMessage->m_eSourcePlayer);
					
					if (eApproachTowardsTarget > MAJOR_CIV_APPROACH_GUARDED || (eApproachTowardsTarget > MAJOR_CIV_APPROACH_HOSTILE && (eOpinionOfTarget > eOpinionOfPlotter)))
					{
						DiploStatementTypes eTempStatement = DIPLO_STATEMENT_SHARE_INTRIGUE;
						int iTurnsBetweenStatements = 1;
						if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) > iTurnsBetweenStatements)
						{
							eStatement = eTempStatement;
						}
					}
				}
				else
				{
					// mark this as shared so it doesn't try to interrupt the player
					m_pPlayer->GetEspionage()->MarkRecentIntrigueAsShared(ePlayer, pNotificationMessage->m_eSourcePlayer, (CvIntrigueType)(pNotificationMessage->m_iIntrigueType));
				}
			}
		}
	}
}

/// Possible Contact Statement - They converted one of our cities, and we want them to stop that
void CvDiplomacyAI::DoConvertedMyCityStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (HasEverConvertedCity(ePlayer) && GetPlayerNoConvertPromiseState(ePlayer) == NO_PROMISE_STATE && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerAskedNotToConvert(GetID()))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STOP_CONVERSIONS;
			int iTurnsBetweenStatements = 50;

			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - They dug up one of our artifacts, and we want them to stop that
void CvDiplomacyAI::DoDugUpMyYardStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (GetNumArtifactsEverDugUp(ePlayer) > 0) // TODO: arch
		{
			// Have we asked you to make a promise before?
			if (GetPlayerNoDiggingPromiseState(ePlayer) == NO_PROMISE_STATE && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerAskedNotToDig(GetID()))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STOP_DIGGING;
				int iTurnsBetweenStatements = 30;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We want to make a Declaration of Friendship with them
void CvDiplomacyAI::DoDoFStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsFriendshipRequestsDisabled())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Have we already made the agreement?
		if (!IsDoFAccepted(ePlayer) && !HasEndedFriendshipThisTurn())
		{
			// Do we actually want a DoF with ePlayer?
			if (IsWantsDoFWithPlayer(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WORK_WITH_US;

				if (GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_BB;
				}
				else if (GetDoFType(ePlayer) == DOF_TYPE_ALLIES)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_ALLIES;
				}
				else if (GetDoFType(ePlayer) == DOF_TYPE_FRIENDS)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_FRIENDS;
				}
				else if (GetDoFType(ePlayer) == DOF_TYPE_UNTRUSTWORTHY)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_UNTRUSTWORTHY;
				}

				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 30)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We're denouncing one of our friends (backstabbing)
void CvDiplomacyAI::DoDenounceFriendStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Must have already made the agreement
		if (IsDoFAccepted(ePlayer))
		{
			// Done working with this guy, and willing to denounce?
			if (IsWantsToEndDoFWithPlayer(ePlayer) && IsDenounceFriendAcceptable(ePlayer))
			{
				eStatement = DIPLO_STATEMENT_DENOUNCE_FRIEND;
			}
		}
	}
}

/// Possible Contact Statement - We're ending our Declaration of Friendship with them
void CvDiplomacyAI::DoEndDoFStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Must have already made the agreement
		if (IsDoFAccepted(ePlayer))
		{
			// Done working with this guy, but not willing to denounce?
			if (IsWantsToEndDoFWithPlayer(ePlayer))
			{
				eStatement = DIPLO_STATEMENT_END_WORK_WITH_US;
			}
		}
	}
}

/// Possible Contact Statement - We're denouncing a player
void CvDiplomacyAI::DoDenounceStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsDenounceAcceptable(ePlayer, /*bBias*/ false))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DENOUNCE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= GC.getGame().GetDealDuration() &&
			        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED) >= 10)
			{
				bool bSendStatement = true;

				// 1 in 2 chance we don't actually send the message (don't want full predictability)
				//if (50 < GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to work with a player"))
				//	bSendStatement = false;

				if(bSendStatement)
				{
					eStatement = eTempStatement;
				}

				// Add this statement to the log so we don't evaluate it again until time has passed
				else
					DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED);
			}
		}
	}
}

/// Possible Contact Statement - We're requesting that a player denounce someone
void CvDiplomacyAI::DoRequestFriendDenounceStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bRandFailed;

		PlayerTypes eTarget = GetRequestFriendToDenounce(ePlayer, bRandFailed);
		if(eTarget != NO_PLAYER)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
			        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE_RANDFAILED) >= 10)
			{
				if(!bRandFailed)
				{
					eStatement = eTempStatement;
					iData1 = eTarget;
				}
				// Add this statement to the log so we don't evaluate it again until time has passed
				else
				{
					DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED);
				}
			}
		}
	}
}

/// Possible Contact Statement - Luxury Trade
void CvDiplomacyAI::DoLuxuryTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForLuxuryResource(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_LUXURY_TRADE;
			int iTurnsBetweenStatements = 20;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possibile Contact Statement - Embassy Exchange
void CvDiplomacyAI::DoEmbassyExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can both sides open an embassy
		if(pDeal->IsPossibleToTradeItem(GetID(), ePlayer, TRADE_ITEM_ALLOW_EMBASSY) &&
		        pDeal->IsPossibleToTradeItem(ePlayer, GetID(), TRADE_ITEM_ALLOW_EMBASSY))
		{
			// Does this guy want to exchange embassies?
			if(IsEmbassyExchangeAcceptable(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EMBASSY_EXCHANGE;
				int iTurnsBetweenStatements = 20;
				if ((GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_OFFER) >= 20)		
				{
					bool bSendStatement = false;

					// AI
					if(!GET_PLAYER(ePlayer).isHuman())
					{
						if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsEmbassyExchangeAcceptable(GetID()))
							bSendStatement = true;
					}
					// Human
					else
						bSendStatement = true;

					if(bSendStatement)
					{
						pDeal->AddAllowEmbassy(GetID());
						pDeal->AddAllowEmbassy(ePlayer);

						eStatement = eTempStatement;
					}
					else
					{
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
						pDeal->ClearItems();
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Embassy
void CvDiplomacyAI::DoEmbassyOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->MakeOfferForEmbassy(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EMBASSY_OFFER;
			int iTurnsBetweenStatements = 15;
			if ((GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_EXCHANGE) >= 10)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Open Borders Exchange
void CvDiplomacyAI::DoOpenBordersExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		int iDuration = GC.getGame().GetDealDuration();

		// Can both sides trade OB?
		if(pDeal->IsPossibleToTradeItem(GetID(), ePlayer, TRADE_ITEM_OPEN_BORDERS, iDuration) &&
		        pDeal->IsPossibleToTradeItem(ePlayer, GetID(), TRADE_ITEM_OPEN_BORDERS, iDuration))
		{
			// Does this guy want to exchange OB?
			if(IsOpenBordersExchangeAcceptable(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE;
				int iTurnsBetweenStatements = 25;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{			
					// OB on each side
					pDeal->AddOpenBorders(GetID(), iDuration);
					pDeal->AddOpenBorders(ePlayer, iDuration);

					bool bDealAcceptable = false;

					// AI evaluation
					if(!GET_PLAYER(ePlayer).isHuman())
					{
						bDealAcceptable = GetPlayer()->GetDealAI()->DoEqualizeDealWithAI(pDeal, ePlayer);	// Change the deal as necessary to make it work
					}
					else
					{
						bool bUselessReferenceVariable;
						bool bCantMatchOffer;
						bDealAcceptable = GetPlayer()->GetDealAI()->DoEqualizeDealWithHuman(pDeal, ePlayer, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work
					}
					if(bDealAcceptable)
					{
						eStatement = eTempStatement;
					}
					// Add this statement to the log so we don't evaluate it again until 20 turns has come back around
					else
					{
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
						pDeal->ClearItems();
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Open Borders
void CvDiplomacyAI::DoOpenBordersOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForOpenBorders(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_OPEN_BORDERS_OFFER;
			int iTurnsBetweenStatements = 25;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Research Agreement Offer
void CvDiplomacyAI::DoResearchAgreementOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (IsCanMakeResearchAgreementRightNow(ePlayer))
		{
			if (GetPlayer()->GetDealAI()->IsMakeOfferForResearchAgreement(ePlayer, /*pDeal can be modified in this function*/ pDeal))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER;
				int iTurnsBetweenStatements = 20;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
				else
				{
					pDeal->ClearItems();
				}
			}
			else
			{
				// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement - Strategic Resource Offer
void CvDiplomacyAI::DoStrategicTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForStrategicResource(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STRATEGIC_TRADE;
			int iTurnsBetweenStatements = 20;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Defensive Pact Offer
void CvDiplomacyAI::DoDefensivePactOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (IsWantsDefensivePactWithPlayer(ePlayer))
		{
			if (GetPlayer()->GetDealAI()->IsMakeOfferForDefensivePact(ePlayer, /*pDeal can be modified in this function*/ pDeal))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST;
				int iTurnsBetweenStatements = 20;					
				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
				else
				{
					pDeal->ClearItems();
				}
			}
			else
			{
				// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement - City Exchange
void CvDiplomacyAI::DoCityExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForCityExchange(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXCHANGE_CITIES;
			int iTurnsBetweenStatements = 30;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Third Party War Trade
void CvDiplomacyAI::DoThirdPartyWarTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForThirdPartyWar(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST;
			int iTurnsBetweenStatements = 40;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Peace Trade
void CvDiplomacyAI::DoThirdPartyPeaceTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForThirdPartyPeace(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST;
			int iTurnsBetweenStatements = 30;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Vote Trade
void CvDiplomacyAI::DoVoteTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForVote(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_VOTE_REQUEST;
			int iTurnsBetweenStatements = 10;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Renew Recently Expired Deal
void CvDiplomacyAI::DoRenewExpiredDeal(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (IsAvoidDeals())
		{
			CancelRenewDeal(ePlayer, REASON_CANNOT_COMPROMISE);
			return;
		}

		CvDeal* pTargetDeal = NULL;
		CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();

		int iNumDeals = kGameDeals.GetRenewableDealsWithPlayer(ePlayer, GetID(), 10);

		//no valid deals?
		if (iNumDeals <= 0)
		{
			return;
		}

		for(int iDeal = 0; iDeal < iNumDeals; iDeal++)
		{
			CvDeal* pCurrentDeal = kGameDeals.GetRenewableDealWithPlayer(ePlayer, GetID(), iDeal);

			//this is not good.
			if (!pCurrentDeal)
				continue;

			// if this deal is a gift or peace deal, move on.
			if (pCurrentDeal->m_bIsGift || pCurrentDeal->IsPeaceTreatyTrade(ePlayer) || pCurrentDeal->IsPeaceTreatyTrade(GetID()))
			{
				//shouldn't happen but it might.
				continue;
			}

			// if the deal can be fully renewed
			TradedItemList::iterator it;
			CvDeal kTempDeal;

			for(it = pCurrentDeal->m_TradedItems.begin(); it != pCurrentDeal->m_TradedItems.end(); ++it)
			{
				PlayerTypes eOtherPlayer;
				if (it->m_eFromPlayer == pCurrentDeal->m_eFromPlayer)
				{
					eOtherPlayer = pCurrentDeal->m_eToPlayer;
				}
				else
				{
					eOtherPlayer = pCurrentDeal->m_eFromPlayer;
				}

				//exclude items that can't be renewed:
				if (it->m_eItemType ==
					TRADE_ITEM_GOLD ||
					TRADE_ITEM_GOLD_PER_TURN ||
					TRADE_ITEM_RESOURCES ||
					TRADE_ITEM_OPEN_BORDERS ||
					TRADE_ITEM_ALLOW_EMBASSY ||
					TRADE_ITEM_DEFENSIVE_PACT)
					continue;
				
				//otherwise remove it.
				pCurrentDeal->RemoveByType(it->m_eItemType, it->m_eFromPlayer);
				
			}

			//we emptied the deal? whoops.
			if (pCurrentDeal->GetNumItems() <= 0)
			{
				continue;
			}

			//We are considering the deal? Cool.
			pTargetDeal = pCurrentDeal;
			break;
		}

		if (pTargetDeal)
		{
			// copy the target deal into the new deal
			*pDeal = *pTargetDeal;

			//Set as considered for renewal.
			pDeal->m_iFinalTurn = -1;
			
			int iValue = m_pPlayer->GetDealAI()->GetDealValue(pTargetDeal);
			if (iValue != INT_MAX)
			{
				bool bAbleToEqualize = false;
				if (!GET_PLAYER(ePlayer).isHuman())
				{
					bAbleToEqualize = m_pPlayer->GetDealAI()->DoEqualizeDealWithAI(pDeal, ePlayer);
				}
				else
					bAbleToEqualize = true;

				if (!bAbleToEqualize)
				{
					CancelRenewDeal(ePlayer, REASON_CANNOT_COMPROMISE);
					pDeal->ClearItems();
					return;
				}
				else
					eStatement = DIPLO_STATEMENT_RENEW_DEAL;
			}
			else
			{
				CancelRenewDeal(ePlayer, REASON_NO_GPT);
				pDeal->ClearItems();
				return;
			}
		}
		else
		{
			CancelRenewDeal(ePlayer, REASON_NO_DEAL);
			pDeal->ClearItems();
		}
	}
	else
		CancelRenewDeal(ePlayer, REASON_NO_DEAL);
}

/// Possible Contact Statement - Request Help
void CvDiplomacyAI::DoRequest(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsHelpRequestsDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST;

		// If a request was accepted or rejected, wait 60 turns. If we rolled for rand and failed, wait 15 turns before we try again
		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED) >= 15 &&
				// If we just sent out a generous offer, don't ask for a request until some time has passed
				(MOD_DIPLOMACY_CIV4_FEATURES && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER) >= 25))
#else
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED) >= 15)
#endif
		{
			bool bRandPassed;	// This is used to see if we WOULD have made a request, but the rand roll failed (so add an entry to the log)
			bool bMakeRequest = IsMakeRequest(ePlayer, pDeal, bRandPassed);

			// Want to make a request of ePlayer? Pass pDeal in to see if there's actually anything we want
			if(bMakeRequest)
			{
				eStatement = eTempStatement;
				pDeal->SetRequestingPlayer(GetID());
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				pDeal->m_bIsGift = true;
#endif
			}

			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			else
				pDeal->ClearItems();

			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
			{
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED);
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement - Gift
void CvDiplomacyAI::DoGift(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsGiftOffersDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_GIFT;

		// If a request was accepted or rejected, wait 60 turns. If we rolled for rand and failed, wait 15 turns before we try again
		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GIFT_RANDFAILED) >= 15)
		{
			bool bRandPassed = false;	// This is used to see if we WOULD have made a gift, but the rand roll failed (so add an entry to the log)
			bool bMakeGift = false;//IsMakeGift(ePlayer, pDeal, bRandPassed);

			// Want to make a request of ePlayer? Pass pDeal in to see if there's actually anything we want
			if(bMakeGift)
			{
				eStatement = eTempStatement;
				pDeal->SetRequestingPlayer(GetID());
			}

			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			else
				pDeal->ClearItems();

			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
			{
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_GIFT_RANDFAILED);
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement
//void CvDiplomacyAI::DoNowUnforgivableStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
//		return;
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		bool bSendStatement = false;
//
//		// Unforgivable!
//		if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
//		{
//			// Our approach (real or fake) can't be Friendly
//			if (GetSurfaceApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY)
//			{
//				bSendStatement = true;
//			}
//		}
//
//		if (bSendStatement)
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_NOW_UNFORGIVABLE;
//			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//			{
//				eStatement = eTempStatement;
//			}
//		}
//	}
//}

/// Possible Contact Statement
//void CvDiplomacyAI::DoNowEnemyStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
//		return;
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		bool bSendStatement = false;
//
//		// Don't show this message if we've already given a more severe one
//		if (m_aDiploLogStatementTurnCountScratchPad[DIPLO_STATEMENT_NOW_UNFORGIVABLE] == MAX_TURNS_SAFE_ESTIMATE)
//		{
//			// An enemy
//			if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ENEMY)
//			{
//				// Our approach (real or fake) can't be Friendly
//				if (GetSurfaceApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY)
//				{
//					bSendStatement = true;
//				}
//			}
//
//			if (bSendStatement)
//			{
//				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_NOW_ENEMY;
//				int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;
//
//				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//				{
//					eStatement = eTempStatement;
//				}
//			}
//		}
//	}
//}

/// Possible Contact Statement - Approach towards player is now HOSTILE
void CvDiplomacyAI::DoHostileStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
#if defined(MOD_BALANCE_CORE)
		if(!IsTooEarlyForDoF(ePlayer) && (eApproach == MAJOR_CIV_APPROACH_HOSTILE) && (GetMeanness() > 6))
#else
		if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
#endif
		{
			TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

			// If we've made peace recently, don't go mouthing off right away
			int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(eTeam);
			if(iPeaceTreatyTurn != -1)
			{
				int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;
				if(iTurnsSincePeace < /*25*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER())
					return;
			}

			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_INSULT;
#if defined(MOD_BALANCE_CORE)
			int iTurnsBetweenStatements = 75;
#else
			int iTurnsBetweenStatements = 35;
#endif

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement
//void CvDiplomacyAI::DoFriendlyStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
//		return;
//
//	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_COMPLIMENT;
//			int iTurnsBetweenStatements = 35;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//			{
//				eStatement = eTempStatement;
//			}
//		}
//	}
//}

/// Possible Contact Statement - Approach towards player is now AFRAID
void CvDiplomacyAI::DoAfraidStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BOOT_KISSING;
			int iTurnsBetweenStatements = 35;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Warning the player about their warmongering
void CvDiplomacyAI::DoWarmongerStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
		{
			bool bSendStatement = true;

			// Don't send statement if we're going for conquest ourselves
			if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
				bSendStatement = false;

			// 2 in 3 chance we don't actually send the message (don't want to bombard the player from all sides)
			if (4 < GC.getGame().getSmallFakeRandNum(10, ePlayer + m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
				bSendStatement = false;

			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WARMONGER;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(bSendStatement)
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					eStatement = eTempStatement;
			}
			// Add this statement to the log so we don't evaluate it again next turn
			else
				DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
		}
	}
}

/// Possible Contact Statement - Warning the player that we don't like their interactions with "our" City-States
void CvDiplomacyAI::DoMinorCivCompetitionStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1, bool bIgnoreTurnsBetweenLimit)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetTeam(), ePlayer))
			return;

		if (GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_MINOR_CIV_COMPETITION;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements || bIgnoreTurnsBetweenLimit)
			{
				// Find a city state we're upset over
				for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
				{
					PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
					
					// Don't evaluate City-States that are unmet/dead
					if (!IsPlayerValid(eMinor))
						continue;

					// Ignore if League resolutions make it irrelevant
					if (GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly() || GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == GetID())
						continue;

					// Must be a minor we aren't attacking/bullying
					if (GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_BULLY || GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_CONQUEST)
						continue;

					// We have a PtP with this minor
					if (GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetID()))
					{
						if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(ePlayer))
						{
							iData1 = eMinor;
							break;
						}
						else if (GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(ePlayer))
						{
							iData1 = eMinor;
							break;
						}
					}
				}

				// Don't change the statement unless we found a minor to complain about
				if (iData1 != NO_PLAYER)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We're angry that they befriended a player we denounced
void CvDiplomacyAI::DoAngryBefriendedEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	// We denounced the leader we're talking to - no use whining at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetSurfaceApproach(ePlayer) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our enemy, that ePlayer befriended
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy and we're not at war with them
				if(!IsDenouncedPlayer(eLoopPlayer) && !IsAtWar(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetTurnsSinceBefriendedPlayer(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're angry that they denounced one of our friends
void CvDiplomacyAI::DoAngryDenouncedFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	// We denounced the leader we're talking to - no use whining at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetSurfaceApproach(ePlayer) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our friend, that ePlayer denounced
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetTurnsSinceDenouncedPlayer(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy that they denounced a player we denounced
void CvDiplomacyAI::DoHappyDenouncedEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	// We denounced the leader we're talking to - no use talking at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetSurfaceApproach(ePlayer) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our enemy, that ePlayer denounced
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if(!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetTurnsSinceDenouncedPlayer(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're chatty enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy they befriended one of our friends
void CvDiplomacyAI::DoHappyBefriendedFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	// We denounced the leader we're talking to - no use talking at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetSurfaceApproach(ePlayer) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our friend, that ePlayer DoFed
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't DoFed this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't DoFed this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetTurnsSinceBefriendedPlayer(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're chatty enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - Peace
void CvDiplomacyAI::DoPeaceOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsPeaceOffersDisabled())
		return;

	if (!IsAtWar(ePlayer))
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Have to have been at war for at least a little while
		GetPlayer()->SetCachedValueOfPeaceWithHuman(0);

		if (IsWantsPeaceWithPlayer(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST_PEACE;
			int iTurnsBetweenStatements = 5;

			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				if (GetPlayer()->GetDealAI()->IsOfferPeace(ePlayer, /*pDeal can be modified in this function*/ pDeal, false /*bEqualizingDeals*/) && pDeal->GetNumItems() > 0)
				{
					eStatement = eTempStatement;
				}
				else
				{
					// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
					pDeal->ClearItems();
				}
			}
		}
	}
}

/// Possible Contact Statement - We befriended one of the human's enemies and we're letting them know
void CvDiplomacyAI::DoFYIBefriendedHumanEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that we just made friends with, that ePlayer denounced
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetTurnsSinceBefriendedPlayer(eLoopPlayer) > 1)
					continue;

				MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
				MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

				// Don't say mean things if we like ePlayer
				if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
					continue;

				int iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
					iWeight += 10;

				iWeight += GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We denounced one of the human's friends and we're letting them know
void CvDiplomacyAI::DoFYIDenouncedHumanFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (WasResurrectedBy(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that we just denoucned, that ePlayer has befriended
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if (!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if (eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if (!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if (!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if (GetTurnsSinceDenouncedPlayer(eLoopPlayer) > 1)
					continue;

				MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
				MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

				// Don't say mean things if we like ePlayer
				if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
					continue;

				int iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
					iWeight += 10;

				iWeight += GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We denounced someone the human has denounced and we're letting them know
void CvDiplomacyAI::DoFYIDenouncedHumanEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that we just denounced, that ePlayer has denounced
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if (!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if (eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if (!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if (!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if (GetTurnsSinceDenouncedPlayer(eLoopPlayer) > 1)
					continue;

				MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
				MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

				// Don't say nice things if we dislike ePlayer
				if (eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
					continue;
				if (eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
					continue;

				int iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
					iWeight += 10;

				if(eOpinion == MAJOR_CIV_APPROACH_FRIENDLY)
					iWeight += 2;

				// Add weight if they're strong
				if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE)
					iWeight += 3;

				iWeight += GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We befriended one of the human's friends, and we're letting them know
void CvDiplomacyAI::DoFYIBefriendedHumanFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND;

			int iMessage = 0;
			int iMessageMax = MAX_INT;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= 40 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that we just befriended, that ePlayer has befriended
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetTurnsSinceBefriendedPlayer(eLoopPlayer) > 1)
					continue;

				MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
				MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

				// Don't say nice things if we dislike ePlayer
				if (eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
					continue;
				if (eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
					continue;

				int iWeight = 0;

				if (eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
					iWeight += 2;
				else if (eOpinion == MAJOR_CIV_OPINION_FRIEND)
					iWeight += 5;
				else if (eOpinion == MAJOR_CIV_OPINION_ALLY)
					iWeight += 10;

				if (eOpinion == MAJOR_CIV_APPROACH_FRIENDLY)
					iWeight += 2;

				iWeight += GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if (iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy we're following the same ideology as the human
void CvDiplomacyAI::DoHappySamePolicyTree(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;

		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch && GET_PLAYER(ePlayer).GetCulture()->GetTurnIdeologySwitch() < 0)
		{
			// Don't say nice things if we dislike ePlayer
			bool bSkip = false;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;
			eOpinion = GetMajorCivOpinion(ePlayer);
			eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;

			// Check chattiness to see if we send the message this turn
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				DiploStatementTypes eOtherStatementToCheck = NO_DIPLO_STATEMENT_TYPE;

				if(eMyBranch == GC.getPOLICY_BRANCH_FREEDOM())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_FREEDOM;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM;
				}
				else if(eMyBranch == GC.getPOLICY_BRANCH_ORDER())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_ORDER;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER;
				}
				else if(eMyBranch == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY;
				}

				if(eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						// Also check the statement for joining the ideology.  Don't want to send messages like this on back-to-back turns
						if(GetNumTurnsSinceStatementSent(ePlayer, eOtherStatementToCheck) >= iTurnsBetweenStatements)
						{
							eStatement = eTempStatement;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Either AI or human has switched ideologies due to the other's pressure
void CvDiplomacyAI::DoIdeologicalStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PolicyBranchTypes eFreedom = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
	PolicyBranchTypes eOrder = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();
	int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

	CvPlayer &kTheirPlayer = GET_PLAYER(ePlayer);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement;

		if (m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) >= INFLUENCE_LEVEL_INFLUENTIAL)
		{
			eTempStatement = DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
				return;
			}
		}

		if (kTheirPlayer.GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) >= INFLUENCE_LEVEL_INFLUENTIAL)
		{
			eTempStatement = DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
				return;
			}
		}

		// Everything below are "insult" type messages
		if (kTheirPlayer.isHuman() && GC.getGame().IsInsultMessagesDisabled())
			return;

		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = kTheirPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
		{
			PublicOpinionTypes eOpinionInMyCiv = m_pPlayer->GetCulture()->GetPublicOpinionType();
			PlayerTypes eMyGreatestInfluence = m_pPlayer->GetCulture()->GetPublicOpinionBiggestInfluence();
			PublicOpinionTypes eOpinionInTheirCiv = kTheirPlayer.GetCulture()->GetPublicOpinionType();
			PlayerTypes eTheirGreatestInfluence = kTheirPlayer.GetCulture()->GetPublicOpinionBiggestInfluence();

			// Did this player recently switch ideology due to our pressure?
			int iIdeologySwitchTurn = kTheirPlayer.GetCulture()->GetTurnIdeologySwitch();
			if (iIdeologySwitchTurn > 0 && iIdeologySwitchTurn + 10 > GC.getGame().getGameTurn())
			{
				kTheirPlayer.GetCulture()->SetTurnIdeologySwitch(-1);  // Reset so they only get 1 popup
				if (eTheirBranch == eFreedom)
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM;
				}
				else if (eTheirBranch == eOrder)
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER;
				}
				else
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY;
				}
				return;
			}

			if (eOpinionInMyCiv >= PUBLIC_OPINION_CIVIL_RESISTANCE && eMyGreatestInfluence == ePlayer)
			{
				if (eTheirBranch == eFreedom)
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM;
				}
				else if (eTheirBranch == eOrder)
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER;
				}
				else
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY;
				}
				if (eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
			if (eOpinionInTheirCiv >= PUBLIC_OPINION_CIVIL_RESISTANCE && eTheirGreatestInfluence == m_pPlayer->GetID())
			{
				if (eMyBranch == eFreedom)
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM;
				}
				else if (eMyBranch == eOrder)
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER;
				}
				else
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY;
				}
				if (eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Message to human if the AI thinks they are getting close to the victory they're also going for.
void CvDiplomacyAI::DoVictoryCompetitionStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (!IsCompetingForVictory())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	int iTurnsBetweenStatements = 50;
	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	if(eMyGrandStrategy == NO_AIGRANDSTRATEGY)
	{
		return;
	}
	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		EraTypes eModern = (EraTypes) GC.getInfoTypeForString("ERA_MODERN", true);
		DisputeLevelTypes eDispute = GetVictoryDisputeLevel(ePlayer);
		if(eDispute < DISPUTE_LEVEL_STRONG)
		{
			return;
		}
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
		{
			return;
		}
		bool bLeagueCompetitor = false;
		bool bSpaceRace = false;
		bool bCulture = false;
		bool bWar = false;
		int iVotes = 0;
		int iNeededVotes = 0;
		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
		if(pLeague != NULL)
		{
			iVotes = pLeague->CalculateStartingVotesForMember(ePlayer);
			iNeededVotes = GC.getGame().GetVotesNeededForDiploVictory();
			if(iNeededVotes > 0)
			{
				// 33% there? Close!
				if(iVotes >= (iNeededVotes / 3))
				{
					bLeagueCompetitor = true;
				}
			}
		}
		int iProjectCount = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetSSProjectCount();
		if (iProjectCount > 1)
		{
			bSpaceRace = true;
		}
		else
		{
			int iTheirTechNum = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

			int iNumOtherPlayers = 0;
			int iNumPlayersAheadInTech = 0;
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes)ui;
				if(!GET_PLAYER(eOtherPlayer).isAlive())
				{
					continue;
				}

				if (eOtherPlayer == ePlayer)
				{
					continue;
				}

				iNumOtherPlayers++;
				int iNumTechs = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
				if (iTheirTechNum > iNumTechs )
				{
					iNumPlayersAheadInTech++;
				}
			}
			if(iNumPlayersAheadInTech >= iNumOtherPlayers)
			{
				bSpaceRace = true;
			}
		}
		if(GetWarmongerThreat(ePlayer) >= THREAT_SEVERE && GET_PLAYER(ePlayer).GetNumCapitalCities() > 1 && GetPlayer()->GetNumCapitalCities() > 1)
		{
			bWar = true;
		}
		//More than double our influence, and we both have some?
		if(GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn() > 1 && GetPlayer()->GetCulture()->GetNumCivsInfluentialOn() > 0 && (GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn() > (GetPlayer()->GetCulture()->GetNumCivsInfluentialOn() * 2)))
		{
			bCulture = true;
		}
		DiploStatementTypes eTempStatement;

		if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer) == eMyGrandStrategy)
		{
			if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(ePlayer) >= GUESS_CONFIDENCE_LIKELY)
			{					
				//Conquered a capital? You are in our way!
				if(IsGoingForWorldConquest() && bWar)
				{			
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForDiploVictory() && bLeagueCompetitor)
				{				
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForCultureVictory() && bCulture)
				{
					//We've both influenced someone? Competitor!
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForSpaceshipVictory() && bSpaceRace)
				{
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				//Don't have it figured out, but we're competitive? Grr!
				else if(GetPlayer()->GetCurrentEra() > eModern)
				{
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Message to human if the AI thinks they are getting close to a victory that they're not going for.
void CvDiplomacyAI::DoVictoryBlockStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (!IsCompetingForVictory())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	int iTurnsBetweenStatements = 50;
	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");
	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");
	AIGrandStrategyTypes eUNGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");
	AIGrandStrategyTypes eSpaceshipGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");
	EraTypes eAtomic = (EraTypes) GC.getInfoTypeForString("ERA_POSTMODERN", true);
	bool bSkip = false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
	{
		bSkip = true;
	}
	//Let's not send this before the Atomic Era, okay?
	if(GetPlayer()->GetCurrentEra() < eAtomic)
	{
		bSkip = true;
	}
	if(eStatement == NO_DIPLO_STATEMENT_TYPE && !bSkip)
	{
		DiploStatementTypes eTempStatement;

		if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		{
			AIGrandStrategyTypes eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer);
			if(eGrandStrategy == eConquestGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eUNGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eCultureGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eSpaceshipGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
		}
	}
}

/// Possible Contact Statement - We liked the human's proposal to the World Congress
void CvDiplomacyAI::DoWeLikedTheirProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetWeLikedTheirProposalTurn(ePlayer) > -1;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if ((GC.getGame().getGameTurn() - GetWeLikedTheirProposalTurn(ePlayer)) > 10)
				bSkip = true;
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				eTempStatement = DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS();
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - We disliked the human's proposal to the World Congress
void CvDiplomacyAI::DoWeDislikedTheirProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetWeDislikedTheirProposalTurn(ePlayer) > -1;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
				bSkip = true;
			if ((GC.getGame().getGameTurn() - GetWeDislikedTheirProposalTurn(ePlayer)) > 10)
				bSkip = true;
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				eTempStatement = DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS();
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped our proposal pass in the World Congress
void CvDiplomacyAI::DoTheySupportedOurProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetTheySupportedOurProposalTurn(ePlayer) > -1;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if ((GC.getGame().getGameTurn() - GetTheySupportedOurProposalTurn(ePlayer)) > 10)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS();
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped our proposal fail in the World Congress
void CvDiplomacyAI::DoTheyFoiledOurProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsInsultMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetTheyFoiledOurProposalTurn(ePlayer) > -1;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
				bSkip = true;
			if ((GC.getGame().getGameTurn() - GetTheyFoiledOurProposalTurn(ePlayer)) > 10)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS();
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped relocate the World Congress to our lands
void CvDiplomacyAI::DoTheySupportedOurHosting(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsComplimentMessagesDisabled())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetTheySupportedOurHostingTurn(ePlayer) > -1;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if ((GC.getGame().getGameTurn() - GetTheySupportedOurHostingTurn(ePlayer)) > 20)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS();

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					eStatement = eTempStatement;
			}
		}
	}
}

/////////////////////////////////////////////////////////
// Diplo stuff relating to UI
/////////////////////////////////////////////////////////


/// Initiate diplo screen with default state
void CvDiplomacyAI::DoBeginDiploWithHuman()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
#if defined(MOD_BALANCE_CORE)
		PlayerTypes ePlayer = GC.getGame().getActivePlayer();
		if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isHuman() && IsAtWar(ePlayer))
		{
			DoUpdateWarDamage();
			DoUpdatePeaceTreatyWillingness();
		}
#endif
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH => go into the deal, if there is anything proposed
			PlayerTypes eTo = GC.getGame().getActivePlayer();
			CvPlayer& kTo = GET_PLAYER(eTo);
			CvDiplomacyRequests* pRequests = kTo.GetDiplomacyRequests();
			pRequests->ActivateAllFrom(GetID());
			if (!pRequests->HasActiveRequest())
			{
				LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
				const char* szText = GetGreetHumanMessage(eAnimation);

				gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
			}
		}
		else
		{
			LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
			const char* szText = GetGreetHumanMessage(eAnimation);

			gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
		}
#else
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetGreetHumanMessage(eAnimation);

		gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
#endif
	}
}

/// Initiate diplo screen after the player has clicked on the notification to threaten the thief.
void CvDiplomacyAI::DoBeginDiploWithHumanEspionageResult()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) && !IsAtWar(GC.getGame().getActivePlayer()))
	{
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_CONFRONT_YOU_KILLED_MY_SPY, GC.getGame().getActivePlayer());
		gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_CONFRONT_YOU_KILLED_MY_SPY, szText, eAnimation);
	}
}

/// Initiate diplo screen after the player has clicked on the notification that involves intrigue
void CvDiplomacyAI::DoBeginDiploWithHumanInDiscuss()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetGreetHumanMessage(eAnimation);
		gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, szText, eAnimation);
	}
}

/// What should an AI leader say for a particular situation?
const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer)
{
	return GetDiploStringForMessage(eDiploMessage, eForPlayer, Localization::String::Empty, Localization::String::Empty);
}

/// What should an AI leader say for a particular situation?
const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer, const Localization::String& strOptionalKey1)
{
	return GetDiploStringForMessage(eDiploMessage, eForPlayer, strOptionalKey1, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer, const Localization::String& strOptionalKey1, const Localization::String& strOptionalKey2)
{
	CvAssertMsg(eDiploMessage >= 0, "DIPLOMACY_AI: Invalid DiploMessageType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDiploMessage < NUM_DIPLO_MESSAGE_TYPES, "DIPLOMACY_AI: Invalid DiploMessageType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eForPlayer >= NO_PLAYER, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because eForPlayer is used when we need specific data (e.g. for declaring war)
	CvAssertMsg(eForPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	EraTypes eCurrentEra = GC.getGame().getCurrentEra();
	int iMessage = 0;

	const char* strText;
	switch(eDiploMessage)
	{
		//////////////////////////////////////////////////////////////
		// AI greeting messages
		//////////////////////////////////////////////////////////////

		// Intro
	case DIPLO_MESSAGE_INTRO:
		strText = GetDiploTextFromTag("RESPONSE_FIRST_GREETING");
		break;

		// Defeated
	case DIPLO_MESSAGE_DEFEATED:
		strText = GetDiploTextFromTag("RESPONSE_DEFEATED");
		break;

		// Repeat Hello (after the player has gone into the screen too many times)
	case DIPLO_MESSAGE_GREETING_REPEAT_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_REPEAT_TOO_MUCH");
		break;

		// Repeat Hello
	case DIPLO_MESSAGE_GREETING_REPEAT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_REPEAT");
		break;

		// Repeat Hello Hostile
	case DIPLO_MESSAGE_GREETING_HOSTILE_REPEAT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_REPEAT");
		break;

		// Polite Hello
	case DIPLO_MESSAGE_GREETING_FRIENDLY_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_POLITE_HELLO");
		break;

		// Neutral Hello
	case DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_NEUTRAL_HELLO");
		break;

		// Hostile Hello
	case DIPLO_MESSAGE_GREETING_HOSTILE_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HELLO");
		break;

		// Greeting: Human is crushing this AI
	case DIPLO_MESSAGE_GREETING_DESTRUCTION_LOOMS:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DESTRUCTION_LOOMS");
		break;

		// Greeting: At War with human but wants peace
	case DIPLO_MESSAGE_GREETING_AT_WAR_WANTS_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AT_WAR_WANTS_PEACE");
		break;

		// Greeting: At War with human and is being hostile
	case DIPLO_MESSAGE_GREETING_AT_WAR_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AT_WAR_HOSTILE");
		break;

		// Greeting: At War with human and now ready to accept surrender
	case DIPLO_MESSAGE_GREETING_WILL_ACCEPT_SURRENDER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WILL_ACCEPT_SURRENDER");
		break;

		// Greeting: Research Agreement
	case DIPLO_MESSAGE_GREETING_RESEARCH_AGREEMENT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_RESEARCH_AGREEMENT");
		break;

		// Greeting: Human has broken military promises
	case DIPLO_MESSAGE_GREETING_BROKEN_MILITARY_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_BROKEN_MILITARY_PROMISE");
		break;

		// Greeting: Players are working together
	case DIPLO_MESSAGE_GREETING_WORKING_WITH:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WORKING_WITH");
		break;

		// Greeting: Players are working together
	case DIPLO_MESSAGE_GREETING_WORKING_AGAINST:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WORKING_AGAINST", strOptionalKey1);
		break;

		// Greeting: Players in (or planning) a coop war against a third player
	case DIPLO_MESSAGE_GREETING_COOP_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_COOP_WAR", strOptionalKey1);
		break;

		// Greeting: Human at war Hostile
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_AT_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_AT_WAR");
		break;

		// Greeting: Human at war
	case DIPLO_MESSAGE_GREETING_HUMAN_AT_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HUMAN_AT_WAR");
		break;

		// Greeting: Human aggressive military (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_MILITARY");
		break;

		// Greeting: Human aggressive military
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_MILITARY");
		break;

		// Greeting: Human aggressive expansion (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION");
		break;

		// Greeting: Human aggressive expansion
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_EXPANSION:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_EXPANSION");
		break;

		// Greeting: Human aggressive plot buying (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING");
		break;

		// Greeting: Human aggressive plot buying
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_PLOT_BUYING:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_PLOT_BUYING");
		break;

		// Greeting: Human has a strong military
	case DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_FRIENDLY_STRONG_MILITARY");
		break;

		// Greeting: Human has a strong economy
	case DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_ECONOMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_FRIENDLY_STRONG_ECONOMY");
		break;

		// Greeting: Human has few Cities
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_FEW_CITIES:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_FEW_CITIES");
		break;

		// Greeting: Human has a small army
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_SMALL_ARMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_SMALL_ARMY");
		break;

		// Greeting: Human beats up people
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_IS_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_IS_WARMONGER");
		break;

		//////////////////////////////////////////////////////////////
		// AI has a trade offer for the human
		//////////////////////////////////////////////////////////////

		// AI asks the player what deal he's offering
	case DIPLO_MESSAGE_DOT_DOT_DOT:
		strText = GetDiploTextFromTag("RESPONSE_DOT_DOT_DOT");
		break;

		// AI asks the player what deal he's offering
	case DIPLO_MESSAGE_LETS_HEAR_IT:
		strText = GetDiploTextFromTag("RESPONSE_LETS_HEAR_IT");
		break;

		// AI asking the Human to make peace
	case DIPLO_MESSAGE_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_OFFER");
		break;

#if defined(MOD_BALANCE_CORE)
	case DIPLO_MESSAGE_WINNER_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_WINNER_PEACE_OFFER");
		break;
#endif

		// AI is making a demand
	case DIPLO_MESSAGE_DEMAND:
		strText = GetDiploTextFromTag("RESPONSE_DEMAND");
		break;

		// AI is making a request
	case DIPLO_MESSAGE_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_REQUEST");
		break;

		// AI wants a Luxury someone has
	case DIPLO_MESSAGE_LUXURY_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_LUXURY_TRADE");
		break;

		// AI offers equal embassy exchange agreement
	case DIPLO_MESSAGE_EMBASSY_EXCHANGE:
		strText = GetDiploTextFromTag("RESPONSE_EMBASSY_EXCHANGE");
		break;

        // AI asks for an embassy
	case DIPLO_MESSAGE_EMBASSY_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_EMBASSY_OFFER");
		break;

		// AI offers equal Open Borders agreement
	case DIPLO_MESSAGE_OPEN_BORDERS_EXCHANGE:
		strText = GetDiploTextFromTag("RESPONSE_OPEN_BORDERS_EXCHANGE");
		break;

		// AI asks for Open Borders
	case DIPLO_MESSAGE_OPEN_BORDERS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_OPEN_BORDERS_OFFER");
		break;

		// AI wants RA with player
	case DIPLO_MESSAGE_RESEARCH_AGREEMENT_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_RESEARCH_AGREEMENT_OFFER");
		break;

        // AI wants to renew an expired deal with player
	case DIPLO_MESSAGE_RENEW_DEAL:
		strText = GetDiploTextFromTag("RESPONSE_RENEW_DEAL");
		break;

        // AI wants to renew an expired deal with player, but they need more in exchange
	case DIPLO_MESSAGE_WANT_MORE_RENEW_DEAL:
		strText = GetDiploTextFromTag("RESPONSE_WANT_MORE_RENEW_DEAL");
		break;

		//////////////////////////////////////////////////////////////
		// Generic AI messages to another player; some friendship, some warnings, etc.
		//////////////////////////////////////////////////////////////

		// AI is warning player about his military placement
	case DIPLO_MESSAGE_HOSTILE_AGGRESSIVE_MILITARY_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING");
		break;

		// AI is warning player about his military placement
	case DIPLO_MESSAGE_AGGRESSIVE_MILITARY_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING");
		break;

		// AI is SERIOUSLY warning player about his expansion
	case DIPLO_MESSAGE_EXPANSION_SERIOUS_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_SERIOUS_WARNING");
		break;

		// AI is warning player about his expansion
	case DIPLO_MESSAGE_EXPANSION_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_WARNING");
		break;

		// AI is telling the player he broke a promise
	case DIPLO_MESSAGE_EXPANSION_BROKEN_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_BROKEN_PROMISE");
		break;

		// AI is SERIOUSLY warning player about his plot buying
	case DIPLO_MESSAGE_PLOT_BUYING_SERIOUS_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_SERIOUS_WARNING");
		break;

		// AI is warning player about his plot buying
	case DIPLO_MESSAGE_PLOT_BUYING_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_WARNING");
		break;

		// AI is telling the player he broke a promise
	case DIPLO_MESSAGE_PLOT_BUYING_BROKEN_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_BROKEN_PROMISE");
		break;

		// AI attacked a Minor the human has Friendship with (hostile)
	case DIPLO_MESSAGE_HOSTILE_WE_ATTACKED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI attacked a Minor the human has Friendship with
	case DIPLO_MESSAGE_WE_ATTACKED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI bullied a Minor the human has a PtP with (hostile)
	case DIPLO_MESSAGE_HOSTILE_WE_BULLIED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI bullied a Minor the human has a PtP with
	case DIPLO_MESSAGE_WE_BULLIED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI would like to work with a player
	case DIPLO_MESSAGE_WORK_WITH_US:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US");
		break;
#if defined(MOD_BALANCE_CORE)
	// AI wants a Strategic Resource that someone has
	case DIPLO_MESSAGE_STRATEGIC_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_STRATEGIC_TRADE");
		break;
		// AI would like to work with a player they do not trust
	case DIPLO_MESSAGE_DOF_UNTRUSTWORTHY:
		strText = GetDiploTextFromTag("RESPONSE_DOF_UNTRUSTWORTHY");
		break;
		// AI would like to work with a player they've been friends with
	case DIPLO_MESSAGE_DOF_FRIENDS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_FRIENDS");
		break;
		// AI would like to work with a player they've been good friends with
	case DIPLO_MESSAGE_DOF_OLD_FRIENDS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_ALLIES");
		break;
		// AI would like to work with a player they went on a coop war with
	case DIPLO_MESSAGE_DOF_BATTLE_BROTHERS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_BATTLE_BROTHERS");
		break;
#endif

		// AI is done working with a player
	case DIPLO_MESSAGE_END_WORK_WITH_US:
		strText = GetEndDoFMessage(eForPlayer);
		break;

		// AI would like to work against someone with a player
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE:
#if defined(MOD_BALANCE_CORE)
		iMessage = GetDenounceMessage(eForPlayer);
		strText = GetDenounceMessageValue(iMessage);
#else
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE", strOptionalKey1);
#endif
		break;

		// AI is done working with a player against someone
	case DIPLO_MESSAGE_END_WORK_AGAINST_SOMEONE:
		strText = GetEndWorkAgainstSomeoneMessage(eForPlayer, strOptionalKey1);
		break;

		// AI would like to declare war on someone with a player
	case DIPLO_MESSAGE_COOP_WAR_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_REQUEST", strOptionalKey1);
		break;

	/*
		// AI calls up and says it's time to declare war on someone with a player
	case DIPLO_MESSAGE_COOP_WAR_TIME:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_TIME", strOptionalKey1);
		break;
	*/

		// AI is telling player he's unforgivable
	case DIPLO_MESSAGE_NOW_UNFORGIVABLE:
		strText = GetDiploTextFromTag("RESPONSE_NOW_UNFORGIVABLE");
		break;

		// AI is telling player he's an enemy
	case DIPLO_MESSAGE_NOW_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_NOW_ENEMY");
		break;

		// AI is making fun of the player
	case DIPLO_MESSAGE_INSULT_ROOT:
		strText = GetInsultHumanMessage();
		break;

		// AI is making fun of the player
	case DIPLO_MESSAGE_INSULT_GENERIC:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_GENERIC");
		break;

		// AI is making fun of the player because of his military
	case DIPLO_MESSAGE_INSULT_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_MILITARY");
		break;

		// AI is making fun of the player because of his lack of nukes
	case DIPLO_MESSAGE_INSULT_NUKE:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_NUKE");
		break;

		// AI is making fun of the player because he picks on minors
	case DIPLO_MESSAGE_INSULT_BULLY:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_BULLY");
		break;

		// AI is making fun of the player because his people are unhappy
	case DIPLO_MESSAGE_INSULT_UNHAPPINESS:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_UNHAPPINESS");
		break;

		// AI is making fun of the player because he doesn't have many Cities
	case DIPLO_MESSAGE_INSULT_CITIES:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_CITIES");
		break;

		// AI is making fun of the player because of his population
	case DIPLO_MESSAGE_INSULT_POPULATION:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_POPULATION");
		break;

		// AI is making fun of the player because of his Culture
	case DIPLO_MESSAGE_INSULT_CULTURE:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_CULTURE");
		break;

		// AI is being nice to the player
	case DIPLO_MESSAGE_COMPLIMENT:
		strText = GetDiploTextFromTag("RESPONSE_COMPLIMENT");
		break;

		// AI is afraid of the player
	case DIPLO_MESSAGE_BOOT_KISSING:
		strText = GetDiploTextFromTag("RESPONSE_BOOT_KISSING");
		break;

		// AI is warning player about being a warmonger
	case DIPLO_MESSAGE_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_WARMONGER");
		break;

		// AI is warning player about getting too cozy with a minor
	case DIPLO_MESSAGE_MINOR_CIV_COMPETITION:
		strText = GetDiploTextFromTag("RESPONSE_MINOR_CIV_COMPETITION", strOptionalKey1);
		break;

		// AI is pleased with the human
	case DIPLO_MESSAGE_PLEASED:
		strText = GetDiploTextFromTag("RESPONSE_PLEASED");
		break;

		// AI is thankful towards the human
	case DIPLO_MESSAGE_THANKFUL:
		strText = GetDiploTextFromTag("RESPONSE_THANKFUL");
		break;

		// AI is disappointed in the human
	case DIPLO_MESSAGE_DISAPPOINTED:
		strText = GetDiploTextFromTag("RESPONSE_DISAPPOINTED");
		break;

		// Human has done something bad, and now we're gonna show 'em
	case DIPLO_MESSAGE_SO_BE_IT:
		strText = GetDiploTextFromTag("RESPONSE_SO_BE_IT");
		break;

		// Human returned a captured civilian to us!
	case DIPLO_MESSAGE_RETURNED_CIVILIAN:
		strText = GetDiploTextFromTag("RESPONSE_RETURNED_CIVILIAN");
		break;

		// Human Culture Bombed us!
	case DIPLO_MESSAGE_CULTURE_BOMBED:
		strText = GetDiploTextFromTag("RESPONSE_CULTURE_BOMBED");
		break;

		//////////////////////////////////////////////////////////////
		// AI has a public declaration to make to the world
		//////////////////////////////////////////////////////////////

		// AI is protecting a City-State
	case DIPLO_MESSAGE_DECLARATION_PROTECT_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_DECLARATION_PROTECT_CITY_STATE", strOptionalKey1, GetPlayer()->getCivilizationShortDescriptionKey());
		break;

		// AI is no longer protecting a City-State
	case DIPLO_MESSAGE_DECLARATION_ABANDON_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_DECLARATION_ABANDON_CITY_STATE", strOptionalKey1, GetPlayer()->getCivilizationShortDescriptionKey());
		break;

		//////////////////////////////////////////////////////////////
		// Human is asking the AI for something
		//////////////////////////////////////////////////////////////

		// Human has asked us about something recently, and we still say no
	case DIPLO_MESSAGE_REPEAT_NO:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_NO");
		break;

		// Human asks us not to settle near him, and we say yes
	case DIPLO_MESSAGE_DONT_SETTLE_YES:
		strText = GetDiploTextFromTag("RESPONSE_DONT_SETTLE_YES");
		break;

		// Human asks us not to settle near him, but we say no
	case DIPLO_MESSAGE_DONT_SETTLE_NO:
		strText = GetDiploTextFromTag("RESPONSE_DONT_SETTLE_NO");
		break;

		// Human asks us to work with him, and we say yes
	case DIPLO_MESSAGE_WORK_WITH_US_YES:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US_YES");
		break;

		// Human asks us to work with him, but we say no
	case DIPLO_MESSAGE_WORK_WITH_US_NO:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US_NO");
		break;

		// Human asks us to work against someone, and we say yes
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE_YES:
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE_YES");
		break;

		// Human asks us to work against someone, but we say no
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE_NO:
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE_NO");
		break;

		// Human asks us to declare war on someone, and we say yes
	case DIPLO_MESSAGE_COOP_WAR_YES:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_YES");
		break;

		// Human asks us to declare war on someone, but we say no
	case DIPLO_MESSAGE_COOP_WAR_NO:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_NO");
		break;

		// Human asks us to declare war someone, and we say soon
	case DIPLO_MESSAGE_COOP_WAR_SOON:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_SOON");
		break;

		// Human makes demand of us, and we say yes
	case DIPLO_MESSAGE_HUMAN_DEMAND_YES:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_YES");
		break;

		// Human makes demand of us, and we say no because they're too weak
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_WEAK:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_WEAK");
		break;

		// Human makes demand of us, and we say no because we hate them
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_HOSTILE");
		break;

		// Human makes demand of us, and we tell him he's asking for too much
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_TOO_MUCH");
		break;

		// Human makes demand of us, and we say it's been too soon since last time
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_SOON:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_TOO_SOON");
		break;

		//////////////////////////////////////////////////////////////
		// AI popped up to tell the human something, human responded and now we're responding back
		//////////////////////////////////////////////////////////////

		// We noticed human military buildup and he said he was going to kill us now (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD");
		break;

		// We noticed human military buildup and he said betsu ni (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD");
		break;

		// We noticed human military buildup and he said he was going to kill us now :(
	case DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING_BAD");
		break;

		// We noticed human military buildup and he said betsu ni
	case DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING_GOOD");
		break;

		// AI attacked human's Minor, human vows revenge, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_MINOR_BAD");
		break;

		// AI attacked human's Minor, human forgives us, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_MINOR_GOOD");
		break;

		// AI attacked human's Minor, human vows revenge, our response
	case DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_MINOR_BAD");
		break;

		// AI attacked human's Minor, human forgives us, our response
	case DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_MINOR_GOOD");
		break;

		// AI bullied human's Minor, human vows revenge, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_MINOR_BAD");
		break;

		// AI bullied human's Minor, human forgives us, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_MINOR_GOOD");
		break;

		// AI bullied human's Minor, human vows revenge, our response
	case DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_MINOR_BAD");
		break;

		// AI bullied human's Minor, human forgives us, our response
	case DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_MINOR_GOOD");
		break;

		// Other player attacked a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_ATTACKED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human won't stop attacking a Minor
	case DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_ATTACKED_MINOR_BAD");
		break;

		// AI is happy that human says he'll stop attacking a Minor
	case DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_ATTACKED_MINOR_GOOD");
		break;

		// Other player killed a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_KILLED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human killed a Minor
	case DIPLO_MESSAGE_HUMAN_KILLED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MINOR_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after killing a protected Minor
	case DIPLO_MESSAGE_HUMAN_KILLED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MINOR_GOOD");
		break;

		// Other player bullied a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_BULLIED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_BULLIED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human won't stop bullying a Minor
	case DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_BULLIED_MINOR_BAD");
		break;

		// AI is happy that human says he'll stop bullying a Minor
	case DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_BULLIED_MINOR_GOOD");
		break;

		// AI mad at human because he won't heed our serious expansion warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_EXPANSION_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_EXPANSION_WARNING_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after serious expansion warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_EXPANSION_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_EXPANSION_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our expansion warning
	case DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_EXPANSION_WARNING_BAD");
		break;

		// AI is happy human has said he won't expand near him in the future
	case DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_EXPANSION_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our serious plot buying warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after serious plot buying warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our plot buying warning
	case DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_PLOT_BUYING_WARNING_BAD");
		break;

		// AI is happy human has said he won't buy plots near him in the future
	case DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_PLOT_BUYING_WARNING_GOOD");
		break;

		//////////////////////////////////////////////////////////////
		// Peace messages - DEPRECATED???
		//////////////////////////////////////////////////////////////

		// Player requests peace from AI, AI is is curious what the offer will be
	case DIPLO_MESSAGE_PEACE_WHAT_WILL_HUMAN_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_WHAT_WILL_HUMAN_OFFER");
		break;

		// Player requests peace from AI, AI is happy
	case DIPLO_MESSAGE_PEACE_MADE_BY_HUMAN_GRACIOUS:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_MADE_BY_HUMAN_GRACIOUS");
		break;

		// Player requests peace from AI but it says no
	case DIPLO_MESSAGE_NO_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_NO_PEACE");
		break;

		// Player requests peace from AI on the same turn it attacked...
	case DIPLO_MESSAGE_TOO_SOON_NO_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_NO_PEACE");
		break;

		//////////////////////////////////////////////////////////////
		// Trade responses
		//////////////////////////////////////////////////////////////

		// Human asks the AI to accept a bad deal too many times
	case DIPLO_MESSAGE_REPEAT_TRADE_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_TRADE_TOO_MUCH");
		break;

		// Human asks the AI to accept a bad deal again
	case DIPLO_MESSAGE_REPEAT_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_TRADE");
		break;

		// AI accepts a generous trade offer
	case DIPLO_MESSAGE_TRADE_ACCEPT_GENEROUS:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_GENEROUS");
		break;

		// AI accepts a reasonable trade offer
	case DIPLO_MESSAGE_TRADE_ACCEPT_ACCEPTABLE:
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if(MOD_DIPLOMACY_CIV4_FEATURES && IsOfferedGift(eForPlayer))
		{
			SetOfferedGift(eForPlayer, false);
			SetOfferingGift(eForPlayer, false);
			strText = GetDiploTextFromTag("RESPONSE_PLEASED");
		}
		else
		{
#endif
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_ACCEPTABLE");
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		}
#endif
		break;

		// Human gave in to AI demand
	case DIPLO_MESSAGE_TRADE_ACCEPT_AI_DEMAND:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_AI_DEMAND");
		break;

		// AI accepts concessions from the human
	case DIPLO_MESSAGE_TRADE_ACCEPT_HUMAN_CONCESSIONS:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_HUMAN_CONCESSIONS");
		break;

		// AI rejects an unreasonable trade offer
	case DIPLO_MESSAGE_TRADE_REJECT_UNACCEPTABLE:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_REJECT_UNACCEPTABLE");
		break;

		// AI rejects an insulting trade offer
	case DIPLO_MESSAGE_TRADE_REJECT_INSULTING:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_REJECT_INSULTING");
		break;

		// AI sees a good deal it doesn't need to change
	case DIPLO_MESSAGE_TRADE_DEAL_UNCHANGED:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_DEAL_UNCHANGED");
		break;

		// AI offers a counter-deal
	case DIPLO_MESSAGE_TRADE_AI_MAKES_OFFER:
#if defined(MOD_BALANCE_CORE)
		strText = GetOfferText(eForPlayer);
#else
		strText = GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
#endif
		break;

		// AI doesn't see a way to make proposed deal work
	case DIPLO_MESSAGE_TRADE_NO_DEAL_POSSIBLE:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_NO_DEAL_POSSIBLE");
		break;

       // AI can't fairly match human's trade offer
	case DIPLO_MESSAGE_TRADE_CANT_MATCH_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
		break;

		//////////////////////////////////////////////////////////////
		// Human declared war on AI, what is the AI's response?
		//////////////////////////////////////////////////////////////

		// AI attacked by human player
	case DIPLO_MESSAGE_ATTACKED_ROOT:
		strText = GetAttackedByHumanMessage();
		break;

		// Attacked: Hostile response
	case DIPLO_MESSAGE_ATTACKED_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_HOSTILE");
		break;

		// Attacked: Hostile response (Weak player)
	case DIPLO_MESSAGE_ATTACKED_WEAK_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_HOSTILE");
		break;

		// Attacked: Hostile response (Strong player)
	case DIPLO_MESSAGE_ATTACKED_STRONG_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_HOSTILE");
		break;

		// Attacked: Excited response
	case DIPLO_MESSAGE_ATTACKED_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_EXCITED");
		break;

		// Attacked: Excited response (Weak Player)
	case DIPLO_MESSAGE_ATTACKED_WEAK_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_EXCITED");
		break;

		// Attacked: Excited response (Strong player)
	case DIPLO_MESSAGE_ATTACKED_STRONG_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_EXCITED");
		break;

		// Attacked: Sad response
	case DIPLO_MESSAGE_ATTACKED_SAD:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_SAD");
		break;

		// Attacked: Betrayed response
	case DIPLO_MESSAGE_ATTACKED_BETRAYED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_BETRAYED");
		break;

		// Attacked: Broken military promise response
	case DIPLO_MESSAGE_ATTACKED_MILITARY_PROMISE_BROKEN:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_MILITARY_PROMISE_BROKEN");
		break;

		// Attacked: Human is warmonger and AI is stronger
	case DIPLO_MESSAGE_ATTACKED_STRONG_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_WARMONGER");
		break;

		// Attacked: Human is warmonger and AI is weaker
	case DIPLO_MESSAGE_ATTACKED_WEAK_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_WARMONGER");
		break;

		// Attacked: Human is warmonger
	case DIPLO_MESSAGE_ATTACKED_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WARMONGER");
		break;

		// Attacked: Human and AI have different ideologies
	case DIPLO_MESSAGE_ATTACKED_IDEOLOGY_DIFFERENCE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_IDEOLOGY_DIFFERENCE");
		break;

		// Attacked: Human and AI have the same ideology
	case DIPLO_MESSAGE_ATTACKED_IDEOLOGY_SAME:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_IDEOLOGY_SAME");
		break;	

		// AI DP request
	case DIPLO_MESSAGE_DEFENSE_PACT_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_DEFENSIVE_PACT_REQUEST");
		break;

		// Trade Cities request
	case DIPLO_MESSAGE_TRADE_CITIES_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_CITIES_REQUEST");
		break;

		// Exchange Cities request		
	case DIPLO_MESSAGE_EXCHANGE_CITIES_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_EXCHANGE_CITIES_REQUEST");
		break;	

		// Third party peace
	case DIPLO_MESSAGE_THIRDPARTY_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_THIRD_PARTY_PEACE_REQUEST");
		break;

		// Third party war
	case DIPLO_MESSAGE_THIRDPARTY_WAR_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_THIRD_PARTY_WAR_REQUEST");
		break;

		// World Congress vote
	case DIPLO_MESSAGE_VOTE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_VOTE_COMMITMENT_REQUEST");
		break;

		//////////////////////////////////////////////////////////////
		// AI is declaring war on human, what does he say?
		//////////////////////////////////////////////////////////////

		// AI declaring war on human
	case DIPLO_MESSAGE_DOW_ROOT:
		strText = GetWarMessage(eForPlayer);
		break;

		// AI DoW: Generic declaration
	case DIPLO_MESSAGE_DOW_GENERIC:
		strText = GetDiploTextFromTag("RESPONSE_DOW_GENERIC");
		break;

		// AI DoW: Declared war over land dispute
	case DIPLO_MESSAGE_DOW_LAND:
		strText = GetDiploTextFromTag("RESPONSE_DOW_LAND");
		break;

	// AI DoW: AI and human have gone to war several times
	case DIPLO_MESSAGE_DOW_OLD_ENEMIES:
		strText = GetDiploTextFromTag("RESPONSE_DOW_OLD_ENEMIES");
		break;

	// AI DoW: AI is putting an end to the human's warmongering
	case DIPLO_MESSAGE_DOW_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WARMONGER");
		break;

	// AI DoW: AI and human have different ideologies
	case DIPLO_MESSAGE_DOW_IDEOLOGY_DIFFERENCE:
		strText = GetDiploTextFromTag("RESPONSE_DOW_IDEOLOGY_DIFFERENCE");
		break;

	// AI DoW: AI and human have the same ideology
	case DIPLO_MESSAGE_DOW_IDEOLOGY_SAME:
		strText = GetDiploTextFromTag("RESPONSE_DOW_IDEOLOGY_SAME");
		break;

		// AI DoW: AI is going for world conquest
	case DIPLO_MESSAGE_DOW_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WORLD_CONQUEST");
		break;

		// AI DoW: AI is attacking because the player is weak
	case DIPLO_MESSAGE_DOW_OPPORTUNITY:
		strText = GetDiploTextFromTag("RESPONSE_DOW_OPPORTUNITY");
		break;

		// AI DoW: AI is attacking out of desperation
	case DIPLO_MESSAGE_DOW_DESPERATE:
		strText = GetDiploTextFromTag("RESPONSE_DOW_DESPERATE");
		break;

		// AI DoW: AI was pretending to be friendly beforehand
	case DIPLO_MESSAGE_DOW_BETRAYAL:
		strText = GetDiploTextFromTag("RESPONSE_DOW_BETRAYAL");
		break;

		// AI DoW: AI was pretending to be friendly beforehand AND human is weaker
	case DIPLO_MESSAGE_DOW_WEAK_BETRAYAL:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WEAK_BETRAYAL");
		break;

		// AI DoW: AI regrets declaring war
	case DIPLO_MESSAGE_DOW_REGRET:
		strText = GetDiploTextFromTag("RESPONSE_DOW_REGRET");
		break;

		// AI declares war because human refused to give in to a demand
	case DIPLO_MESSAGE_WAR_DEMAND_REFUSED:
		strText = GetDiploTextFromTag("RESPONSE_WAR_DEMAND_REFUSED");
		break;

	// AI declares war because human insulted them.
	case DIPLO_MESSAGE_WAR_RUDE_INSULT:
		strText = GetDiploTextFromTag("RESPONSE_WAR_DEMAND_INSULTED");
		break;

		/////////////////////////////////
		// Post Civ 5 Release Mish-Mash of stuff
		/////////////////////////////////

		// AI asks a friend to denounce another player
	case DIPLO_MESSAGE_DOF_AI_DENOUNCE_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOF_AI_DENOUNCE_REQUEST", strOptionalKey1);
		break;

		// AI asks a friend to declare war on another player
	case DIPLO_MESSAGE_DOF_AI_WAR_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOF_AI_WAR_REQUEST", strOptionalKey1);
		break;

		// AI asked a friend to do something, but they didn't and now the AI is pissed
	case DIPLO_MESSAGE_DOF_NOT_HONORED:
		strText = GetDiploTextFromTag("RESPONSE_DOF_NOT_HONORED");
		break;

		// AI is denouncing the human, who had been a friend
	case DIPLO_MESSAGE_AI_DOF_BACKSTAB:
		strText = GetDiploTextFromTag("RESPONSE_AI_DOF_BACKSTAB");
		break;

		// AI response to being denounced by the human
	case DIPLO_MESSAGE_RESPONSE_TO_BEING_DENOUNCED:
		strText = GetDiploTextFromTag("RESPONSE_RESPONSE_TO_BEING_DENOUNCED");
		break;

		// AI response to human DoFing a friend
	case DIPLO_MESSAGE_HUMAN_DOFED_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOFED_FRIEND", strOptionalKey1);
		break;

		// AI response to human DoFing an enemy
	case DIPLO_MESSAGE_HUMAN_DOFED_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOFED_ENEMY", strOptionalKey1);
		break;

		// AI response to human denouncing a friend
	case DIPLO_MESSAGE_HUMAN_DENOUNCED_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCED_FRIEND", strOptionalKey1);
		break;

		// AI response to human denouncing an enemy
	case DIPLO_MESSAGE_HUMAN_DENOUNCED_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCED_ENEMY", strOptionalKey1);
		break;

		// AI DoFed someone because the human DoFed them (nice)
	case DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DOF:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOF_SO_AI_DOF", strOptionalKey1);
		break;

		// AI denounced someone because the human denounced them (nice)
	case DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DENOUNCE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCE_SO_AI_DENOUNCE", strOptionalKey1);
		break;

		// AI denounced someone because the human DoFed them (mean)
	case DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DENOUNCE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOF_SO_AI_DENOUNCE", strOptionalKey1);
		break;

		// AI DoFed someone because the human denounced them (mean)
	case DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DOF:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCE_SO_AI_DOF", strOptionalKey1);
		break;

		// Saying hello - AI denounced the human
	case DIPLO_MESSAGE_GREETING_DENOUNCED_BY_AI:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_BY_AI");
		break;

		// Saying hello - human denounced the AI
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_AI");
		break;

		// Saying hello - Human has a DoF with an enemy of the AI's
	case DIPLO_MESSAGE_GREETING_OUR_DOF_WITH_AI_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_OUR_DOF_WITH_ENEMY_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has a DoF with a friend of the AI's
	case DIPLO_MESSAGE_GREETING_OUR_DOF_WITH_AI_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_OUR_DOF_WITH_FRIEND_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has denounced a friend of the AI's
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_FRIEND_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has denounced an enemy of the AI's
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_ENEMY_OF_AI", strOptionalKey1);
		break;

		// Human asked for a DoF, but the AI hasn't known him for long enough
	case DIPLO_MESSAGE_TOO_SOON_FOR_DOF:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_FOR_DOF");
		break;

		// Same late game policy tree
	case DIPLO_MESSAGE_SAME_POLICIES_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_FREEDOM");
		break;
	case DIPLO_MESSAGE_SAME_POLICIES_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_ORDER");
		break;
	case DIPLO_MESSAGE_SAME_POLICIES_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_AUTOCRACY");
		break;

		/////////////////////////////////
		// Espionage messages
		/////////////////////////////////

		// AI response to catching one of human's spies
	case DIPLO_MESSAGE_CAUGHT_YOUR_SPY:
		strText = GetDiploTextFromTag("RESPONSE_CAUGHT_YOUR_SPY");
		break;

		// AI response to killing one of human's spies
	case DIPLO_MESSAGE_KILLED_YOUR_SPY:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_YOUR_SPY");
		break;

		// AI response to human killing one of their spies
	case DIPLO_MESSAGE_KILLED_MY_SPY:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_MY_SPY");
		break;

        // Human confronts AI about having killed their spy through the notification
	case DIPLO_MESSAGE_CONFRONT_YOU_KILLED_MY_SPY:
		strText = GetDiploTextFromTag("RESPONSE_CONFRONT_YOU_KILLED_MY_SPY");
		break;

		// AI asks human to stop sending missionaries and prophets
	case DIPLO_MESSAGE_STOP_CONVERSIONS:
		strText = GetDiploTextFromTag("RESPONSE_STOP_CONVERSIONS");
		break;

        // Human agreed to stop spying on AI
	case DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_CAUGHT_YOUR_SPY_GOOD");
		break;

        // Human did not agree to stop spying on AI
	case DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_CAUGHT_YOUR_SPY_BAD");
		break;

		// Human asks us not to spy on him, and we say yes
	case DIPLO_MESSAGE_STOP_SPYING_YES:
		strText = GetDiploTextFromTag("RESPONSE_STOP_SPYING_YES");
		break;

		// Human asks us not to spy on him, but we say no
	case DIPLO_MESSAGE_STOP_SPYING_NO:
		strText = GetDiploTextFromTag("RESPONSE_STOP_SPYING_NO");
		break;

       // Human warns AI about another civ's war plans/deception towards them
	case DIPLO_MESSAGE_WARNED_ABOUT_INTRIGUE:
		strText = GetDiploTextFromTag("RESPONSE_WARNED_ABOUT_INTRIGUE", strOptionalKey1);
		break;

      // AI warns human that another leader is plotting against them
	case DIPLO_MESSAGE_SHARE_INTRIGUE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_DECEPTION", strOptionalKey1);
		break;

      // AI warns human that another civ is planning a sneak attack against a specific city of theirs
	case DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY", strOptionalKey1, strOptionalKey2);
		break;

      // AI warns human that another civ is planning a sneak attack against them, but don't know which city
	case DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY", strOptionalKey1);
		break;

      // AI warns human that another civ is planning a sneak attack against a specific city of theirs (amphibious)
	case DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY", strOptionalKey1, strOptionalKey2);
		break;

      // AI warns human that another civ is planning a sneak attack against them, but don't know which city (amphibious)
	case DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY", strOptionalKey1);
		break;

		// Human catches enemy spy and does not forgive the thief
	case DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_UNFORGIVEN:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MY_SPY_UNFORGIVEN");
		break;

		// Human catches enemy spy and forgives the thief
	case DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_FORGIVEN:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MY_SPY_FORGIVEN");
		break;

        // AI asks human to stop sending missionaries and prophets. The human agrees.
	case DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_GOOD");
		break;

        // AI asks human to stop sending missionaries and prophets. The human disagrees.
	case DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_BAD");
		break;

	   // Human asks AI to stop sending missionaries and prophets. The AI player agrees.
	case DIPLO_MESSAGE_STOP_CONVERSIONS_AGREE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_AGREE");
		break;

	   // Human asks AI to stop sending missionaries and prophets. The AI player disagrees.
	case DIPLO_MESSAGE_STOP_CONVERSIONS_DISAGREE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_DISAGREE");
		break;

       // AI asks human to stop digging up their artifacts.
	case DIPLO_MESSAGE_STOP_DIGGING:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING");
		break;

       // Human asks AI to stop digging up their artifacts. The AI player agrees.
	case DIPLO_MESSAGE_STOP_DIGGING_AGREE:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING_AGREE");
		break;

       // Human asks AI to stop digging up their artifacts. The AI player disagrees.
	case DIPLO_MESSAGE_STOP_DIGGING_DISAGREE:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING_DISAGREE");
		break;

       // AI asks human to stop digging up their artifacts. The human disagrees.
	case DIPLO_MESSAGE_HUMAN_STOP_DIGGING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_DIGGING_BAD");
		break;

      // AI asks human to stop digging up their artifacts. The human agrees.
	case DIPLO_MESSAGE_HUMAN_STOP_DIGGING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_DIGGING_GOOD");
		break;

		/////////////////////////////////
		// League messages
		/////////////////////////////////

       // AI tells human they liked human's proposal to the World Congress
	case DIPLO_MESSAGE_WE_LIKED_THEIR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_WE_LIKE_HUMAN_PROPOSAL", strOptionalKey1);
		break;

       // AI tells human they disliked human's proposal to the World Congress
	case DIPLO_MESSAGE_WE_DISLIKED_THEIR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_WE_DISLIKE_HUMAN_PROPOSAL", strOptionalKey1);
		break;

       // AI thanks human for supporting their proposal to the World Congress
	case DIPLO_MESSAGE_THEY_SUPPORTED_OUR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SUPPORTED_OUR_PROPOSAL", strOptionalKey1);
		break;

       // AI is angry at human for helping their proposal fail in the World Congress
	case DIPLO_MESSAGE_THEY_FOILED_OUR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_FOILED_OUR_PROPOSAL", strOptionalKey1);
		break;

       // AI thanks human for helping make the AI host of the World Congress
	case DIPLO_MESSAGE_THEY_SUPPORTED_OUR_HOSTING:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SUPPORTED_OUR_HOSTING", strOptionalKey1);
		break;

	  // Ideological messages
	  // Human has Freedom, AI does not and AI's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_FREEDOM");
		break;
	  // Human has Order, AI does not and AI's people are unhappy with their choice of ideology	
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_ORDER");
		break;
	  // Human has Autocracy, AI does not and AI's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_AUTOCRACY");
		break;
	  // AI has Freedom, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_FREEDOM");
		break;
	  // AI has Order, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_ORDER");
		break;
	  // AI has Autocracy, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_AUTOCRACY");
		break;
	  // Human switched to Freedom and AI has Freedom
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_FREEDOM");
		break;
	  // Human switched to Order and AI has Order
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_ORDER");
		break;
	  // Human switched to Autocracy and AI has Autocracy
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_AUTOCRACY");
		break;
		
	// Human is influential over the AI - defeat message based on era
	case DIPLO_MESSAGE_YOUR_CULTURE_INFLUENTIAL:
		if (MOD_BALANCE_CORE_DIPLOMACY_ERA_INFLUENCE)
		{
			if (eCurrentEra <= 1)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_CLASSICAL");
			}
			else if (eCurrentEra >= 2 && eCurrentEra < 4)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_RENAISSANCE");
			}
			else if (eCurrentEra >= 4 && eCurrentEra < 6)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_MODERN");
			}
			else
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI");
			}
		}
		else
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI");
		}
		break;
	
	// AI is influential over human - victory message based on era
	case DIPLO_MESSAGE_OUR_CULTURE_INFLUENTIAL:
		if (MOD_BALANCE_CORE_DIPLOMACY_ERA_INFLUENCE)
		{
			if (eCurrentEra <= 1)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_CLASSICAL");
			}
			else if (eCurrentEra >= 2 && eCurrentEra < 4)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_RENAISSANCE");
			}
			else if (eCurrentEra >= 4 && eCurrentEra < 6)
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_MODERN");
			}
			else
			{
				strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN");
			}
		}
		else
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN");
		}
		break;
	// AI announces that they're competing with human over Domination Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST");
		break;
	// AI announces that they're competing with human over Diplomatic Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS");
		break;
	// AI announces that they're competing with human over Cultural Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE");
		break;
	// AI announces that they're competing with human over Science Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP");
		break;
	// AI announces that they're competing with human but doesn't know what victory human is going for
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED");
		break;
	// AI announces that they want to stop the human's Domination Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST");
		break;
	// AI announces that they want to stop the human's Diplomatic Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS");
		break;
	// AI announces that they want to stop the human's Cultural Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE");
		break;
	// AI announces that they want to stop the human's Science Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP");
		break;
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Human repeatedly asks AI for opinion of another player after they said no (hostile)
	case DIPLO_MESSAGE_HOSTILE_REPEAT_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_REPEAT_SHARE_OPINION_NO");
		break;
	// Human repeatedly asks AI for opinion of another player after they said no
	case DIPLO_MESSAGE_REPEAT_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_SHARE_OPINION_NO");
		break;
	// Human asks AI for their opinion of another player. The AI refuses. (hostile)
	case DIPLO_MESSAGE_HOSTILE_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_SHARE_OPINION_NO");
		break;
    // Human asks AI for their opinion of another player. The AI refuses.
	case DIPLO_MESSAGE_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_NO");
		break;
    // AI tells human its approach towards another player (FRIENDLY)
	case DIPLO_MESSAGE_SHARE_OPINION_FRIENDLY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_FRIENDLY", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (NEUTRAL)
	case DIPLO_MESSAGE_SHARE_OPINION_NEUTRAL:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_NEUTRAL", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (GUARDED)
	case DIPLO_MESSAGE_SHARE_OPINION_GUARDED:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_GUARDED", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (HOSTILE)
	case DIPLO_MESSAGE_SHARE_OPINION_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_HOSTILE", strOptionalKey1);
		break;
    // AI tells human it is at war with another player
	case DIPLO_MESSAGE_SHARE_OPINION_WAR:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_WAR", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (AFRAID)
	case DIPLO_MESSAGE_SHARE_OPINION_AFRAID:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_AFRAID", strOptionalKey1);
		break;
    // AI tells human it is planning war against another player
	case DIPLO_MESSAGE_SHARE_OPINION_PLANNING_WAR:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_PLANNING_WAR", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (DECEPTIVE)
	case DIPLO_MESSAGE_SHARE_OPINION_DECEPTIVE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_DECEPTIVE", strOptionalKey1);
		break;
    // AI tells human it hasn't known them long enough to share its opinion of others
	case DIPLO_MESSAGE_TOO_SOON_FOR_SHARE_OPINION:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_FOR_SHARE_OPINION");
		break;
    // AI wants to trade for the player's World Map
	case DIPLO_MESSAGE_MAPS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_MAPS_OFFER");
		break;
    // AI wants to trade for one of the player's technologies
	case DIPLO_MESSAGE_TECH_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TECH_OFFER");
		break;
    // AI is making a generous offer towards the player
	case DIPLO_MESSAGE_GENEROUS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_GENEROUS_OFFER");
		break;
    // AI accepts a human's request for help
	case DIPLO_MESSAGE_HUMAN_REQUEST_YES:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_YES");
		break;
    // AI refuses a human's request for help (too much)
	case DIPLO_MESSAGE_HUMAN_REQUEST_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_REFUSE_TOO_MUCH");
		break;
    // AI refuses a human's request for help (too soon since last request)
	case DIPLO_MESSAGE_HUMAN_REQUEST_TOO_SOON:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_REFUSE_TOO_SOON");
		break;
    // Human attacked his AI vassal
	case DIPLO_MESSAGE_VASSALAGE_ATTACKED_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_ATTACKED_VASSAL");
		break;

	// AI vassal greets his human master (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_VASSALAGE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_VASSAL_HOSTILE");
		break;

	// AI vassal greets his human master
	case DIPLO_MESSAGE_GREETING_VASSALAGE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_VASSAL");
		break;

	// AI master greets his human vassal (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_VASSALAGE_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_VASSALAGE_MASTER");
		break;

	// AI master greets his human vassal
	case DIPLO_MESSAGE_GREETING_VASSALAGE_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_MASTER");
		break;

	// Ai wants the player to liberate his vassals (trade offer)
	case DIPLO_MESSAGE_REVOKE_VASSAL_THIRD_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_TRADE_REVOKE");
		break;

	// AI asks human to revoke his vassalage of them (hostile)
	case DIPLO_MESSAGE_REVOKE_VASSALAGE_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKE_VASSALAGE_HOSTILE");
		break;

    // AI asks human to revoke his vassalage of them
	case DIPLO_MESSAGE_REVOKE_VASSALAGE:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKE_VASSALAGE");
		break;

	// Human revokes AI vassalage peacefully
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_PEACEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_HUMAN_PEACEFUL");
		break;

	// Human tells AI to die
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_WAR:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_HUMAN_WAR");
		break;

	// AI grants human independence
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_PEACEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_PEACEFUL");
		break;

	// AI tells human to die
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_FORCEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_FORCEFUL");
		break;

    // AI agrees to remove their troops from human's borders
	case DIPLO_MESSAGE_MOVE_TROOPS_ACCEPT:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_ACCEPT");
		break;
    // AI promises their troops are not on human's borders for war
	case DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_NEUTRAL");
		break;
    // AI promises their troops are not on human's borders for war (hostile)
	case DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_NEUTRAL_HOSTILE");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_CONQUEST:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_CONQUEST");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_DECEPTIVE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_DECEPTIVE");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_HOSTILE");
		break;
	// AI liberates human vassal without being asked
	case DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_LIBERATED_HUMAN");
		break;
	// AI vassal is unhappy that human raised their taxes
	case DIPLO_MESSAGE_VASSAL_TAXES_RAISED_HUMAN_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_RAISED_HUMAN_MASTER");
		break;
	// AI tells human vassal their taxes are now raised
	case DIPLO_MESSAGE_VASSAL_TAXES_RAISED_AI_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_RAISED_AI_MASTER");
		break;
	// AI vassal is happy that human lowered their taxes
	case DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_HUMAN_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_LOWERED_HUMAN_MASTER");
		break;
	// AI tells human vassal their taxes are now lowered
	case DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_AI_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_LOWERED_AI_MASTER");
		break;
	// Human liberates AI vassal without being asked
	case DIPLO_MESSAGE_VASSALAGE_LIBERATE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_LIBERATE_VASSAL");
		break;
		// Human liberates AI vassal without being asked
	case DIPLO_MESSAGE_VASSALAGE_BECOME_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_BECOME_VASSAL");
		break;
#endif

		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////

		// Should always have a state we're handling
	default:
		strText = "NO MESSAGE. Trying to get Diplo string.  Something has gone wrong, somehow.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.";
		CvAssert(false);
		break;
	}

	return strText;
}


/// Message from UI to gameplay about something that should happen with regards to diplomacy
void CvDiplomacyAI::DoFromUIDiploEvent(PlayerTypes eFromPlayer, FromUIDiploEventTypes eEvent, int iArg1, int iArg2)
{
	CvAssertMsg(eEvent >= 0, "DIPLOMACY_AI: Invalid FromUIDiploEventType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eEvent < NUM_FROM_UI_DIPLO_EVENTS, "DIPLOMACY_AI: Invalid FromUIDiploEventType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "";

	TeamTypes eFromTeam = GET_PLAYER(eFromPlayer).getTeam();

	// Are we processing this message on the active player's computer?
	bool bActivePlayer = GC.getGame().getActivePlayer() == eFromPlayer;

	PlayerTypes eMyPlayer = GetID();

	switch (eEvent)
	{
	// *********************************************
	// Player declares war on the AI
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DECLARES_WAR:
	{
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// Changed some logic around so player can see the special declared war on vassal logic
		if (!(MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(eFromPlayer)))
		{
#endif
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam());

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_ROOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_WAR_DECLARED_BY_HUMAN, strText, LEADERHEAD_ANIM_ATTACKED, iArg1);
			}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		}
		if (MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(eFromPlayer))
		{
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam());
		}
#endif
		break;
	}

	// *********************************************
	// Player requests peace
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_NEGOTIATE_PEACE:
	{
		if (bActivePlayer)
		{
			PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eFromPlayer);
			PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eFromPlayer);

			// Does the AI actually want peace?
			if (ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE && ePeaceTreatyImWillingToAccept >= PEACE_TREATY_WHITE_PEACE)
			{
				// This is essentially the same as the human opening the trade screen
				GetPlayer()->GetDealAI()->DoTradeScreenOpened();

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PEACE_WHAT_WILL_HUMAN_OFFER);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_TRADE, strText, LEADERHEAD_ANIM_LETS_HEAR_IT);
			}
			else
			{
				// Player declared war and wants peace right away.  Uh huh, right.
				if (GetPlayerNumTurnsAtWar(eFromPlayer) <= 1)
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_NO_PEACE);
				// Don't want peace for some other reason
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_NO_PEACE);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_WAR_DECLARED_BY_HUMAN, strText, LEADERHEAD_ANIM_NO);
			}
		}

		break;
	}

	// *********************************************
	// Player wants to discuss something with the AI
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_WANTS_DISCUSSION:
	{
		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_LETS_HEAR_IT);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_LETS_HEAR_IT);
		}

		break;
	}

	// *********************************************
	// Player told the AI to not settle near him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_DONT_SETTLE:
	{
		bool bAcceptable = IsDontSettleAcceptable(eFromPlayer);

		if (bAcceptable)
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerExpansionPromiseState(eMyPlayer, PROMISE_STATE_MADE);
		else
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerExpansionPromiseState(eMyPlayer, PROMISE_STATE_IGNORED);

		if (bActivePlayer)
		{
			if (bAcceptable)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DONT_SETTLE_YES);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DONT_SETTLE_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}

		break;
	}

	// *********************************************
	// Player told the AI to not spy on him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_SPYING:
	{
		bool bAcceptable = IsStopSpyingAcceptable(eFromPlayer);

		if (bAcceptable)
		{
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerSpyPromiseState(eMyPlayer, PROMISE_STATE_MADE);
			m_pPlayer->GetEspionageAI()->EvaluateSpiesAssignedToTargetPlayer(eFromPlayer);
		}

		if (bActivePlayer)
		{
			DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
			if (iArg1 == 1)
			{
				eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
			}

			LeaderheadAnimationTypes eAnimType;

			if (bAcceptable)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_SPYING_YES);
				eAnimType = LEADERHEAD_ANIM_NEGATIVE;
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_SPYING_NO);
				eAnimType = LEADERHEAD_ANIM_NO;
			}

			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
		}

		break;
	}

	// *********************************************
	// Player told the AI to not spread their religion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_SPREADING_RELIGION:
	{
		if (bActivePlayer)
		{
			SetPlayerAskedNotToConvert(eFromPlayer, true);

			DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
			if (iArg1 == 1)
			{
				eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
			}

			LeaderheadAnimationTypes eAnimType;

			if (IsStopSpreadingReligionAcceptable(eFromPlayer))
			{
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerNoConvertPromiseState(GetID(), PROMISE_STATE_MADE);
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS_AGREE);
				eAnimType = LEADERHEAD_ANIM_NEGATIVE;
			}
			else
			{
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerNoConvertPromiseState(GetID(), PROMISE_STATE_IGNORED);
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS_DISAGREE);
				eAnimType = LEADERHEAD_ANIM_NO;
			}

			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
		}
		break;
	}

	// *********************************************
	// Player told the AI to not dig up their yard (artifacts)
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_DIGGING:
	{
		if (bActivePlayer)
		{	
			SetPlayerAskedNotToDig(eFromPlayer, true);

			DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
			if (iArg1 == 1)
			{
				eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
			}

			LeaderheadAnimationTypes eAnimType;

			if (IsStopDiggingAcceptable(eFromPlayer))
			{
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerNoDiggingPromiseState(eMyPlayer, PROMISE_STATE_MADE);
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING_AGREE);
				eAnimType = LEADERHEAD_ANIM_NEGATIVE;
			}
			else
			{
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerNoDiggingPromiseState(eMyPlayer, PROMISE_STATE_IGNORED);
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING_DISAGREE);
				eAnimType = LEADERHEAD_ANIM_NO;
			}

			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
		}
		break;
	}

	// *********************************************
	// Player asked if the AI will work with him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_WORK_WITH_US:
	{
		// AI hasn't known the human for long enough yet
		if (IsTooEarlyForDoF(eFromPlayer) && !GC.getGame().IsAIMustAcceptHumanDiscussRequests())
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_FOR_DOF);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// Already have a DoF? This should never happen, but just in case...
		else if (IsDoFAccepted(eFromPlayer))
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOT_DOT_DOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// AI gives a new answer
		else
		{
			bool bAcceptable = IsDoFAcceptable(eFromPlayer) || GC.getGame().IsAIMustAcceptHumanDiscussRequests();
			if (bAcceptable)
			{
				SetDoFAccepted(eFromPlayer, true);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, true);

				if(GetDoFType(eFromPlayer) == DOF_TYPE_ALLIES || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_ALLIES)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_BATTLE_BROTHERS);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_BATTLE_BROTHERS);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_FRIENDS || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_FRIENDS)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_ALLIES);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_ALLIES);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_NEW || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_NEW)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_FRIENDS);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_FRIENDS);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_UNTRUSTWORTHY || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_UNTRUSTWORTHY)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_NEW);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_NEW);
				}		

				vector<PlayerTypes> v;
				v.push_back(eFromPlayer);
				DoReevaluatePlayers(v, false, false);
			}

			if (bActivePlayer)
			{
				if (bAcceptable)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US_YES);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US_NO);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
				}
			}
		}
		break;
	}

	// *********************************************
	// Player said he's done working with the AI
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_END_WORK_WITH_US:
	{
		SetDoFAccepted(eFromPlayer, false);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
		SetDoFType(eFromPlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_UNTRUSTWORTHY);

		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// Human refused to give in to demand
	// *********************************************
	case FROM_UI_DIPLO_EVENT_DEMAND_HUMAN_REFUSAL:
	{
		// Does the AI declare war?
		bool bDeclareWar = false;

		if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) >= ((GetMeanness() + GetBoldness()) / 2))
		{
			bDeclareWar = true;
		}
		
		// If we're stronger than them, declare war!
		if (GetPlayerMilitaryStrengthComparedToUs(eFromPlayer) < STRENGTH_AVERAGE && GetPlayerEconomicStrengthComparedToUs(eFromPlayer) < STRENGTH_AVERAGE)
		{
			bDeclareWar = true;
		}

		if (GetPlayer()->IsVassalOfSomeone() || GET_PLAYER(eFromPlayer).IsVassalOfSomeone())
		{
			bDeclareWar = false;
		}

		if (bDeclareWar && GetPlayer()->IsNoNewWars())
		{
			bDeclareWar = false;
		}

		if (bDeclareWar && !IsPotentialWarTarget(eFromPlayer))
		{
			bDeclareWar = false;
		}

		// Sanity check - who else would we go to war with?
		if (bDeclareWar && !DoUpdateOnePlayerSaneDiplomaticTarget(eFromPlayer, true))
		{
			bDeclareWar = false;
		}
		
		// Sanity check - avoid going bankrupt
		int iMinIncome = 2 + (GetPlayer()->GetCurrentEra() * 2);
		if (bDeclareWar && IsWarWouldBankruptUs(eFromPlayer, false, iMinIncome))
		{
			bDeclareWar = false;
		}

		// Sanity check - who else would we go to war with?
		if (bDeclareWar)
		{
			vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eFromPlayer, false, true, false);

			for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
			{
				// Would we be declaring war on a powerful neighbor?
				if (GetPlayer()->GetProximityToPlayer(*it) >= PLAYER_PROXIMITY_CLOSE)
				{
					if (GET_PLAYER(*it).isMajorCiv())
					{
						if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_AFRAID)
						{
							bDeclareWar = false;
							break;
						}
						// If we're already planning a war/demand against them, then we don't care.
						else if (GetMajorCivApproach(*it) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(*it) != WAR_GOAL_DEMAND)
						{
							// Bold AIs will take more risks.
							if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_STRONG)
							{
								bDeclareWar = false;
								break;
							}
							else if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
							{
								bDeclareWar = false;
								break;
							}
						}
					}
					else
					{
						if (GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_CONQUEST && GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_BULLY)
						{
							if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
							{
								bDeclareWar = false;
								break;
							}
						}
					}
				}
			}
		}
	
		if (bDeclareWar)
		{
			if (DeclareWar(eFromPlayer))
			{
				bool bCareful = GetPlayer()->GetNumDangerousMajorsAtWarWith(true, true) > 0 && GetGlobalCoopWarAgainstState(eFromPlayer) < COOP_WAR_STATE_PREPARING;

				if (!GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(eFromPlayer))
				{
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eFromPlayer, 3, bCareful);
				}
			}
		}

		if (bActivePlayer)
		{
			if (bDeclareWar)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_WAR_DEMAND_REFUSED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_SO_BE_IT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human refused to give in to a request
	// *********************************************
	case FROM_UI_DIPLO_EVENT_REQUEST_HUMAN_REFUSAL:
	{
		//If player is offended, AI should take note as penalty to assistance.
		if (GetForgiveness() < 7 || GetNeediness() > 7)
		{
			ChangeRecentAssistValue(eFromPlayer, 150);
		}
		else
		{
			ChangeRecentAssistValue(eFromPlayer, 75);
		}
		
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			//End the gift exchange after this.
			GetPlayer()->GetDiplomacyAI()->SetOfferingGift(eFromPlayer, false);
			GetPlayer()->GetDiplomacyAI()->SetOfferedGift(eFromPlayer, false);
		}
#endif
		if (bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// AI is telling us he sees our military buildup on his borders
	// *********************************************
	case FROM_UI_DIPLO_EVENT_AGGRESSIVE_MILITARY_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human says he means no harm
		if (iArg1 == 1)
		{
			SetPlayerMilitaryPromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human told the AI to die
		else if (iArg1 == 2)
		{
			SetPlayerMilitaryPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam()))
			{
				if (bActivePlayer)
				{
					if (IsActHostileTowardsHuman(eFromPlayer))
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD);
					else
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_BAD);

					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
			}
		}

		break;
	}

	// *********************************************
	// AI has attacked a Minor the human is friends with, what did the human say in response?
	// *********************************************
	case FROM_UI_DIPLO_EVENT_I_ATTACKED_YOUR_MINOR_CIV_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID,  iArg2 is MINOR ID from DiscussionDialog.lua
		PlayerTypes eMinor = (PlayerTypes) iArg2;
		CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		if (!(eMinor >= MAX_MAJOR_CIVS && eMinor < MAX_CIV_PLAYERS))
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}

		CvPlayer* pMinor = &GET_PLAYER(eMinor);
		CvAssertMsg(pMinor, "Error triggering gameplay effects for diplomacy event involving a Protected city-state. Please send Anton your save file and version.");
		if (!pMinor)
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvAssertMsg(pMinor->GetMinorCivAI()->IsProtectedByMajor(eFromPlayer), "Diplomacy event involving a Protected city-state when there was no Pledge active. Please send Anton your save file and Version.");

		// Human says he forgives the AI
		if (iArg1 == 1)
		{
			GC.getGame().DoMinorPledgeProtection(eFromPlayer, eMinor, false, true); // Pledge is broken!
			
			if (bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human said he'd get revenge
		else if (iArg1 == 2)
		{
			SetOtherPlayerSidedWithProtectedMinorTurn(eFromPlayer, GC.getGame().getGameTurn());

			// Does the AI declare war?
			bool bDeclareWar = false;

			if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetID()))
			{
				int iChance = 20;
				if (GetMajorCivOpinion(eFromPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
				{
					iChance += 5;
				}
				else if (GetMajorCivOpinion(eFromPlayer) <= MAJOR_CIV_OPINION_COMPETITOR)
				{
					iChance -= 5;
				}
				if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) > (iChance - GetMeanness() - GetBoldness()))
				{
					bDeclareWar = true;
				}
				if (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_AFRAID)
				{
					bDeclareWar = false;
				}
				if (GetPlayer()->IsVassalOfSomeone() || GET_PLAYER(eFromPlayer).IsVassalOfSomeone())
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && GetPlayer()->IsNoNewWars())
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && !IsPotentialWarTarget(eFromPlayer))
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && !DoUpdateOnePlayerSaneDiplomaticTarget(eFromPlayer, true))
				{
					bDeclareWar = false;
				}
				
				// Sanity check - avoid going bankrupt
				int iMinIncome = 2 + (GetPlayer()->GetCurrentEra() * 2);
				if (bDeclareWar && IsWarWouldBankruptUs(eFromPlayer, false, iMinIncome))
				{
					bDeclareWar = false;
				}

				// Sanity check - who else would we go to war with?
				if (bDeclareWar)
				{
					vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eFromPlayer, false, true, false);

					for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
					{
						// Would we be declaring war on a powerful neighbor?
						if (GetPlayer()->GetProximityToPlayer(*it) >= PLAYER_PROXIMITY_CLOSE)
						{
							if (GET_PLAYER(*it).isMajorCiv())
							{
								if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_AFRAID)
								{
									bDeclareWar = false;
									break;
								}
								// If we're already planning a war/demand against them, then we don't care.
								else if (GetMajorCivApproach(*it) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(*it) != WAR_GOAL_DEMAND)
								{
									// Bold AIs will take more risks.
									if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_STRONG)
									{
										bDeclareWar = false;
										break;
									}
									else if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
									{
										bDeclareWar = false;
										break;
									}
								}
							}
							else
							{
								if (GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_CONQUEST && GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_BULLY)
								{
									if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
									{
										bDeclareWar = false;
										break;
									}
								}
							}
						}
					}
				}
			}

			if (bDeclareWar)
			{
				bDeclareWar = DeclareWar(GET_PLAYER(eFromPlayer).getTeam());
				if (bDeclareWar)
				{
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eFromPlayer,2);
				}
			}

			if (bActivePlayer)
			{
				if (bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
				else
				{
					if (IsActHostileTowardsHuman(eFromPlayer))
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
					else
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_BAD);

					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
				}
			}
		}

		break;
	}

	// *********************************************
	// AI has bullied a Minor the human has a PtP with, what did the human say in response?
	// *********************************************
	case FROM_UI_DIPLO_EVENT_I_BULLIED_YOUR_MINOR_CIV_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID,  iArg2 is MINOR ID from DiscussionDialog.lua
		PlayerTypes eMinor = (PlayerTypes) iArg2;
		CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		if (!(eMinor >= MAX_MAJOR_CIVS && eMinor < MAX_CIV_PLAYERS))
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvPlayer* pMinor = &GET_PLAYER(eMinor);
		CvAssertMsg(pMinor, "Error triggering gameplay effects for breaking a Pledge to Protect a city-state. Please send Anton your save file and version.");
		if (!pMinor)
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvAssertMsg(pMinor->GetMinorCivAI()->IsProtectedByMajor(eFromPlayer), "Diplomacy event involving a Protected city-state when there was no Pledge active. Please send Anton your save file and Version.");

		// Human says he forgives the AI
		if(iArg1 == 1)
		{
			GC.getGame().DoMinorPledgeProtection(eFromPlayer, eMinor, false, true); // Pledge is broken!
		
			if (bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human said he'd get revenge
		else if (iArg1 == 2)
		{
			SetOtherPlayerSidedWithProtectedMinorTurn(eFromPlayer, GC.getGame().getGameTurn());

			// Does the AI declare war?
			bool bDeclareWar = false;

			if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetID()))
			{
				int iChance = 20;
				if (GetMajorCivOpinion(eFromPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
				{
					iChance += 7;
				}
				else if (GetMajorCivOpinion(eFromPlayer) <= MAJOR_CIV_OPINION_COMPETITOR)
				{
					iChance -= 3;
				}
				if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) > (iChance - GetMeanness() - GetBoldness()))
				{
					bDeclareWar = true;
				}
				if (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_AFRAID)
				{
					bDeclareWar = false;
				}
				if (GetPlayer()->IsVassalOfSomeone() || GET_PLAYER(eFromPlayer).IsVassalOfSomeone())
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && GetPlayer()->IsNoNewWars())
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && !IsPotentialWarTarget(eFromPlayer))
				{
					bDeclareWar = false;
				}

				if (bDeclareWar && !DoUpdateOnePlayerSaneDiplomaticTarget(eFromPlayer, true))
				{
					bDeclareWar = false;
				}
				
				// Sanity check - avoid going bankrupt
				int iMinIncome = 2 + (GetPlayer()->GetCurrentEra() * 2);
				if (bDeclareWar && IsWarWouldBankruptUs(eFromPlayer, false, iMinIncome))
				{
					bDeclareWar = false;
				}
				
				// Sanity check - who else would we go to war with?
				if (bDeclareWar)
				{
					vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eFromPlayer, false, true, false);

					for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
					{
						// Would we be declaring war on a powerful neighbor?
						if (GetPlayer()->GetProximityToPlayer(*it) >= PLAYER_PROXIMITY_CLOSE)
						{
							if (GET_PLAYER(*it).isMajorCiv())
							{
								if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_AFRAID)
								{
									bDeclareWar = false;
									break;
								}
								// If we're already planning a war/demand against them, then we don't care.
								else if (GetMajorCivApproach(*it) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(*it) != WAR_GOAL_DEMAND)
								{
									// Bold AIs will take more risks.
									if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_STRONG)
									{
										bDeclareWar = false;
										break;
									}
									else if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
									{
										bDeclareWar = false;
										break;
									}
								}
							}
							else
							{
								if (GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_CONQUEST && GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_BULLY)
								{
									if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
									{
										bDeclareWar = false;
										break;
									}
								}
							}
						}
					}
				}
			}

			if (bDeclareWar)
			{
				bDeclareWar = DeclareWar(GET_PLAYER(eFromPlayer).getTeam());
				if (bDeclareWar)
				{
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eFromPlayer,2);
				}
			}

			if (bActivePlayer)
			{
				if (bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
				else
				{
					if (IsActHostileTowardsHuman(eFromPlayer))
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_BAD);
					else
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_BAD);

					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
				}
			}
		}

		break;
	}

	// *********************************************
	// AI warned human about attacking a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_ATTACKED_MINOR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if (iArg1 == 1)
		{
			SetPlayerAttackCityStatePromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if (iArg1 == 2)
		{
			SetPlayerAttackCityStatePromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is mad at human for killing a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_KILLED_MINOR_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about bullying a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_BULLIED_MINOR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if (iArg1 == 1)
		{
			SetPlayerBullyCityStatePromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if (iArg1 == 2)
		{
			SetPlayerBullyCityStatePromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is seriously warning the human about his expansion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_EXPANSION_SERIOUS_WARNING_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about his expansion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_EXPANSION_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of their business
		if (iArg1 == 1)
		{
			SetPlayerExpansionPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he wouldn't settle near us again
		else if (iArg1 == 2)
		{
			SetPlayerExpansionPromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is seriously warning the human about his plot buying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLOT_BUYING_SERIOUS_WARNING_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about his plot buying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLOT_BUYING_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of their business
		if (iArg1 == 1)
		{
			SetPlayerBorderPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			//Reset city tile numbers so that this can't fire again immediately after the plot warning is up.
			int iLoop;
			for (CvCity* pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))
			{
				if (pLoopCity != NULL)
				{
					int iTilesBought = pLoopCity->AI_GetNumPlotsAcquiredByOtherPlayer(eFromPlayer);
					if (iTilesBought > 0)
					{
						pLoopCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(eFromPlayer, -iTilesBought);
					}
				}
			}

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he wouldn't buy land near us again
		else if (iArg1 == 2)
		{
			SetPlayerBorderPromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd like to work together
	// *********************************************
	case FROM_UI_DIPLO_EVENT_WORK_WITH_US_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua
		// Human agrees
		if (iArg1 == 1)
		{
			SetDoFAccepted(eFromPlayer, true);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, true);

			if (GetDoFType(eFromPlayer) == DOF_TYPE_ALLIES || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_ALLIES)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_BATTLE_BROTHERS);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_BATTLE_BROTHERS);
			}
			else if (GetDoFType(eFromPlayer) == DOF_TYPE_FRIENDS || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_FRIENDS)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_ALLIES);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_ALLIES);
			}
			else if (GetDoFType(eFromPlayer) == DOF_TYPE_NEW || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_NEW)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_FRIENDS);
			}
			else if (GetDoFType(eFromPlayer) == DOF_TYPE_UNTRUSTWORTHY || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetID()) == DOF_TYPE_UNTRUSTWORTHY)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_NEW);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_NEW);
			}		

			// Update diplomacy stuff
			vector<PlayerTypes> v;
			v.push_back(eFromPlayer);
			DoReevaluatePlayers(v);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if (iArg1 == 2)
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human ends AI cooperation
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_END_WORK_WITH_US_RESPONSE:
	{
		if (IsDoFAccepted(eMyPlayer) || GET_PLAYER(eMyPlayer).GetDiplomacyAI()->IsDoFAccepted(eFromPlayer))
		{
			SetDoFAccepted(eFromPlayer, false);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);

			ChangeRecentAssistValue(eFromPlayer, 300);

			SetDoFType(eFromPlayer, DOF_TYPE_UNTRUSTWORTHY);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_UNTRUSTWORTHY);

			SetDoFBroken(eFromPlayer, true, false);

			GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eFromPlayer).getTeam(), false);
			GET_TEAM(GET_PLAYER(eFromPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);
			
			// End all coop war agreements with this player
			CancelCoopWarsWithPlayer(eFromPlayer, true);

			if (GetMajorCivApproach(eFromPlayer) > MAJOR_CIV_APPROACH_GUARDED)
			{
				SetMajorCivApproach(eFromPlayer, MAJOR_CIV_APPROACH_GUARDED);
			}

			// Other players' reactions
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
				
				if (IsPlayerValid(eLoopPlayer, true) && !GET_PLAYER(eLoopPlayer).isHuman() && eLoopPlayer != eFromPlayer && eLoopPlayer != eMyPlayer)
				{
					// Their teammates
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(eFromPlayer))
					{
						if (GET_PLAYER(eMyPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(eMyPlayer))
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -300);
						}
					}
					else if (GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(eMyPlayer).getTeam())
					{
						// Player might apply a diplo bonus if they don't hate them
						if (!GET_TEAM(GET_PLAYER(eFromPlayer).getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && !GET_PLAYER(eFromPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer) &&
							!GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eFromPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(eFromPlayer) &&
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(eFromPlayer) != MAJOR_CIV_OPINION_UNFORGIVABLE)
						{
							// Bonus for ending a DoF with us, if we're a backstabber
							if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(eMyPlayer))
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -75);
							}
							// Bonus for ending a DoF with us, if we're at war with them
							else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(eMyPlayer).getTeam()))
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -50);
								
								// Extra bonus if they're doing badly in the war
								if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarState(eMyPlayer) <= WAR_STATE_DEFENSIVE)
								{
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -25);
								}
							}
							// Bonus for ending a DoF with us, if we denounced them
							else if (GET_PLAYER(eMyPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -50);
							}
							// Penalty for ending a DoF with us, for players that consider us a friend, DP or ally
							else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(eMyPlayer) || 
									GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam()) ||
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(eMyPlayer) == MAJOR_CIV_OPINION_ALLY)
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 75);
							}						
						}
						// Penalty for ending a DoF with us, for players that consider us a friend, DP or ally (the player hates them)
						else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(eMyPlayer) || 
								GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam()) ||
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(eMyPlayer) == MAJOR_CIV_OPINION_ALLY)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 150);
						}
					}
					// Our teammates
					else if (IsTeammate(eLoopPlayer))
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
					}
				}
			}

			// AI message
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_UNFORGIVABLE);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}
		else
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOT_DOT_DOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
			}
		}
		break;
	}
	// *********************************************
	// Human responds to AI action in a positive or negative way.
	// *********************************************
	case FROM_UI_DIPLO_EVENT_MEAN_RESPONSE:
	{		
		// Does the AI declare war?
		bool bDeclareWar = false;

		if (!IsAtWar(eFromPlayer) && GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetID()))
		{
			int iChance = 20;
			if (GetMajorCivOpinion(eFromPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
			{
				iChance += 5;
			}
			if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) > (iChance - GetMeanness() - GetBoldness()))
			{
				bDeclareWar = true;
			}
			if (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_AFRAID)
			{
				bDeclareWar = false;
			}
			if (GetPlayer()->IsVassalOfSomeone() || GET_PLAYER(eFromPlayer).IsVassalOfSomeone())
			{
				bDeclareWar = false;
			}

			if (bDeclareWar && GetPlayer()->IsNoNewWars())
			{
				bDeclareWar = false;
			}

			if (bDeclareWar && !IsPotentialWarTarget(eFromPlayer))
			{
				bDeclareWar = false;
			}

			if (bDeclareWar && !DoUpdateOnePlayerSaneDiplomaticTarget(eFromPlayer, true))
			{
				bDeclareWar = false;
			}
			
			// Sanity check - avoid going bankrupt
			int iMinIncome = 2 + (GetPlayer()->GetCurrentEra() * 2);
			if (bDeclareWar && IsWarWouldBankruptUs(eFromPlayer, false, iMinIncome))
			{
				bDeclareWar = false;
			}
			
			// Sanity check - who else would we go to war with?
			if (bDeclareWar)
			{
				vector<PlayerTypes> vLinkedWarPlayers = GetLinkedWarPlayers(eFromPlayer, false, true, false);

				for (std::vector<PlayerTypes>::iterator it = vLinkedWarPlayers.begin(); it != vLinkedWarPlayers.end(); it++)
				{
					// Would we be declaring war on a powerful neighbor?
					if (GetPlayer()->GetProximityToPlayer(*it) >= PLAYER_PROXIMITY_CLOSE)
					{
						if (GET_PLAYER(*it).isMajorCiv())
						{
							if (GetMajorCivApproach(*it) == MAJOR_CIV_APPROACH_AFRAID)
							{
								bDeclareWar = false;
								break;
							}
							// If we're already planning a war/demand against them, then we don't care.
							else if (GetMajorCivApproach(*it) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(*it) != WAR_GOAL_DEMAND)
							{
								// Bold AIs will take more risks.
								if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_STRONG)
								{
									bDeclareWar = false;
									break;
								}
								else if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
								{
									bDeclareWar = false;
									break;
								}
							}
						}
						else
						{
							if (GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_CONQUEST && GetMinorCivApproach(*it) != MINOR_CIV_APPROACH_BULLY)
							{
								if (GetPlayerMilitaryStrengthComparedToUs(*it) > STRENGTH_AVERAGE)
								{
									bDeclareWar = false;
									break;
								}
							}
						}
					}
				}
			}
			if (bDeclareWar)
			{
				bDeclareWar = DeclareWar(GET_PLAYER(eFromPlayer).getTeam());
				if (bDeclareWar)
					GetPlayer()->GetMilitaryAI()->RequestCityAttack(eFromPlayer,3);
			}
			//check again, might have failed.
			if (!bDeclareWar)
			{
				SetMajorCivApproach(eFromPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
				
				// If player is offended, AI should take note as penalty to assistance.
				GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
			}
			if (bActivePlayer)
			{
				if (bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WAR_RUDE_INSULT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_SO_BE_IT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
				}
			}
		}
		else
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOT_DOT_DOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
			}
		}
		break;
	}

	// *********************************************
	// Human denounced us!
	// *********************************************
	case FROM_UI_DIPLO_EVENT_DENOUNCE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DoDenouncePlayer(eMyPlayer);

		if (bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_RESPONSE_TO_BEING_DENOUNCED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// Human asked AI to go to war against someone
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_OFFER:
	{
		// **** NOTE **** - iArg1 is Player ID from DiscussionDialog.lua
		PlayerTypes eTargetPlayer = (PlayerTypes) iArg1;

		CoopWarStates eResponse = RespondToCoopWarRequest(eFromPlayer, eTargetPlayer);

		switch (eResponse)
		{
		case COOP_WAR_STATE_ONGOING:
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_YES);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
			break;
		case COOP_WAR_STATE_PREPARING:
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_SOON);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
			break;
		case COOP_WAR_STATE_REJECTED:
		case COOP_WAR_STATE_WARNED_TARGET:
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
			break;
		}
		break;
	}

	// *********************************************
	// AI asked human if he'd declare war against someone
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		PlayerTypes eTargetPlayer = (PlayerTypes) iArg2;

		// Human says sorry, no
		if (iArg1 == 1 || iArg1 == 2)
		{
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}

			// Diplo penalty!
			// Small penalty for a normal refusal
			if (iArg1 == 1)
			{
				int iAssistPenalty = 100 - (GetDifferenceFromAverageFlavorValue(GetForgiveness()) * 10);
				ChangeRecentAssistValue(eFromPlayer, iAssistPenalty);
				ChangeCoopWarScore(eFromPlayer, -1);
			}
			// Big penalty for warning the target
			else
			{
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DoWarnCoopWarTarget(GetID(), eTargetPlayer);
			}
		}
		// Human agrees
		else if (iArg1 == 3 || iArg1 == 4)
		{
			// Human says he needs to prepare
			if (iArg1 == 3)
			{
				SetCoopWarState(eFromPlayer, eTargetPlayer, COOP_WAR_STATE_PREPARING);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, COOP_WAR_STATE_PREPARING);
				SetWarGoal(eTargetPlayer, WAR_GOAL_PREPARE);
			}
			// Human agrees to war immediately
			else
			{
				SetCoopWarState(eFromPlayer, eTargetPlayer, COOP_WAR_STATE_READY);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, COOP_WAR_STATE_READY);
				DoStartCoopWar(eFromPlayer, eTargetPlayer);
				SetWarGoal(eTargetPlayer, WAR_GOAL_CONQUEST);
			}

			// Update approach to WAR
			SetMajorCivApproach(eTargetPlayer, MAJOR_CIV_APPROACH_WAR);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	/*
	// *********************************************
	// AI asked human if he'd declare war against someone earlier, and now it's time to put your money where your mouth is
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_NOW_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

		SetCoopWarCounter(eFromPlayer, eAgainstPlayer, 0);

		// Human agrees
		if (iArg1 == 1)
		{
			if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(eAgainstPlayer))
			{
				SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, COOP_WAR_STATE_ACCEPTED);

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}

				// AI declaration
				if (DeclareWar(eAgainstPlayer))
				{
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 3);
				}
				// Human declaration
				TeamTypes eAgainstTeam = GET_PLAYER(eAgainstPlayer).getTeam();
				int iLockedTurns = GC.getCOOP_WAR_LOCKED_LENGTH();
				GET_TEAM(GetTeam()).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
				GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
			}
		}
		// Human says no
		if (iArg1 == 2)
		{
			SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, NO_COOP_WAR_STATE);
			
			// No penalty for teammates; otherwise, the AI gets mad
			if (!IsTeammate(eFromPlayer))
			{
				SetPlayerBrokenCoopWarPromise(eFromPlayer, true);
#if defined(MOD_BALANCE_CORE)
				ChangeRecentAssistValue(eFromPlayer, 300);
				ChangeCoopWarScore(eFromPlayer, -2);
#endif
			}

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}
	*/

	// *********************************************
	// Human made a demand. NOTE: Unlike the other messages in here, this one is actually triggered from inside CvDealAI on a player's local machine
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DEMAND:
	{
		// **** NOTE **** - iArg1 is RESPONSE TYPE from CvDealAI::DoHumanDemand()
		DemandResponseTypes eResponse = (DemandResponseTypes) iArg1;

		// THIS is the important part of the message - it seeds the demand timer on all players' machines
		DoDemandMade(eFromPlayer, eResponse);

		if(bActivePlayer)
		{
			// Demand agreed to
			if(eResponse == DEMAND_RESPONSE_ACCEPT)
			{
				strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_YES);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_YES);
			}
			// Demand rebuffed
			else
			{
				if(eResponse == DEMAND_RESPONSE_REFUSE_WEAK)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_WEAK);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_HOSTILE)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_HOSTILE);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_TOO_MUCH)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_MUCH);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_TOO_SOON)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_SOON);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_NO);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd like to make a Research Agreement in the future
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLAN_RA_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human agrees
		if(iArg1 == 1)
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if(iArg1 == 2)
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd denounce a third party
	// *********************************************
	case FROM_UI_DIPLO_EVENT_AI_REQUEST_DENOUNCE_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua
		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

		// Human agrees
		if(iArg1 == 1)
		{
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DoDenouncePlayer(eAgainstPlayer);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if(iArg1 == 2)
		{
			// Oh, you're gonna say no, are you?
			if(IsFriendDenounceRefusalUnacceptable(eFromPlayer, eAgainstPlayer))
			{
				DoDenouncePlayer(eFromPlayer);
				LogDenounce(eFromPlayer, /*bBackstab*/ false, /*bRefusal*/ true);

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_NOT_HONORED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
			else if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI warned human about spying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_CAUGHT_YOUR_SPY_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if (iArg1 == 1)
		{
			SetPlayerSpyPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if (iArg1 == 2)
		{
			SetPlayerSpyPromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human warn AI about spying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_KILLED_MY_SPY_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human did not forgive AI player
		if (iArg1 == 1)
		{
			//TODO: AI should either promise or not
			SetPlayerForgaveForSpying(eFromPlayer, false);
			m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[eFromPlayer] = 0;

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_UNFORGIVEN);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}
		// Human forgave AI player
		else if (iArg1 == 2)
		{
			SetPlayerForgaveForSpying(eFromPlayer, true);
			m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[eFromPlayer] = 0;
			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_FORGIVEN);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_SHARE_INTRIGUE:
	{
		PlayerTypes ePlottingPlayer = (PlayerTypes)iArg1;
		CvIntrigueType eIntrigueType = (CvIntrigueType)iArg2;
		CvAssert(CvPlayerAI::IsValid(ePlottingPlayer));
		if (CvPlayerAI::IsValid(ePlottingPlayer))
		{
			ChangeNumTimesIntrigueSharedBy(eFromPlayer, 1);
			GET_PLAYER(eFromPlayer).GetEspionage()->MarkRecentIntrigueAsShared(eMyPlayer, ePlottingPlayer, eIntrigueType);

			if (bActivePlayer)
			{
#if !defined(NO_ACHIEVEMENTS)
				if(GET_PLAYER(eFromPlayer).GetEspionage()->HasSharedIntrigueAboutMe(eMyPlayer))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_37);
				}

				bool bUsingXP1Scenario3 = gDLL->IsModActivated(CIV5_XP1_SCENARIO3_MODID);
				if(bUsingXP1Scenario3)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_45);
				}
#endif

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_WARNED_ABOUT_INTRIGUE, NO_PLAYER, GET_PLAYER(ePlottingPlayer).getCivilizationAdjectiveKey());
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		break;
	}

	// *********************************************
	// AI warned about religious conversions
	// *********************************************
	case FROM_UI_DIPLO_EVENT_STOP_CONVERSIONS:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerAskedNotToConvert(eMyPlayer, true);

		// Human told the AI it's none of his business
		if (iArg1 == 1)
		{
			SetPlayerNoConvertPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if (iArg1 == 2)
		{
			SetPlayerNoConvertPromiseState(eFromPlayer, PROMISE_STATE_MADE);

			if (GetNegativeReligiousConversionPoints(eFromPlayer) >= GC.getRELIGION_DIPLO_HIT_THRESHOLD())
			{
				int iAdjustmentToJustBelowThreshold = (GC.getRELIGION_DIPLO_HIT_THRESHOLD() - 1);
				SetNegativeReligiousConversionPoints(eFromPlayer, iAdjustmentToJustBelowThreshold);
			}

			if (bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}


	// *********************************************
	// AI warned about Digging on my turf
	// *********************************************
	case FROM_UI_DIPLO_EVENT_STOP_DIGGING:
		{
			// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

			// Human told the AI it's none of their business
			if (iArg1 == 1)
			{
				SetPlayerNoDiggingPromiseState(eFromPlayer, PROMISE_STATE_IGNORED);

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_DIGGING_BAD);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
			}
			// Human said he'd withdraw
			else if (iArg1 == 2)
			{
				SetPlayerNoDiggingPromiseState(eFromPlayer, PROMISE_STATE_MADE);

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_DIGGING_GOOD);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}

			break;
		}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// *********************************************
		// Player asked the AI about other civilizations
		// *********************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_SHARE_OPINION:
		{
			PlayerTypes eTargetPlayer = (PlayerTypes) iArg1;
			bool bHostile = (IsAtWar(eFromPlayer) || IsActHostileTowardsHuman(eFromPlayer) || IsDenouncedPlayer(eFromPlayer) || IsDenouncedByPlayer(eFromPlayer) || IsUntrustworthy(eFromPlayer));
			bool bAcceptable = (!bHostile && !IsTooEarlyForShareOpinion(eFromPlayer) && !IsAtWar(eFromPlayer) && GET_PLAYER(eFromPlayer).isAlive() && !GET_PLAYER(eFromPlayer).isObserver() && (IsShareOpinionAccepted(eFromPlayer) || IsShareOpinionAcceptable(eFromPlayer)));
			bool bOverride = (IsAtWar(eTargetPlayer) || IsVassal(eFromPlayer) || GC.getGame().IsDiploDebugModeEnabled() || GET_PLAYER(eFromPlayer).isObserver());

			// We refuse! Choose a hostile response.
			if (bHostile && !bOverride)
			{
				if (bActivePlayer)
				{
					if (IsShareOpinionEverAsked(eFromPlayer) && !IsShareOpinionAccepted(eFromPlayer))
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_REPEAT_SHARE_OPINION_NO);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_SHARE_OPINION_NO);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
					}
				}

				SetShareOpinionEverAsked(eFromPlayer, true);
				SetShareOpinionAccepted(eFromPlayer, false);
			}
			// We accepted! Share our approach towards this player with them.
			else if (bAcceptable || bOverride)
			{
				if (bAcceptable)
				{
					SetShareOpinionEverAsked(eFromPlayer, false);
					SetShareOpinionAccepted(eFromPlayer, true);
				}

				bool bHonest = (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_FRIENDLY && GetMajorCivOpinion(eFromPlayer) >= MAJOR_CIV_OPINION_FRIEND);
				MajorCivApproachTypes eTargetApproach = (bHonest || bOverride) ? GetMajorCivApproach(eTargetPlayer) : GetSurfaceApproach(eTargetPlayer);

				if (bActivePlayer)
				{
					if (IsAtWar(eTargetPlayer))
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_WAR, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
					}
					else
					{
						switch (eTargetApproach)
						{
						case MAJOR_CIV_APPROACH_FRIENDLY:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_FRIENDLY, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_NEUTRAL:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_NEUTRAL, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_GUARDED:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_GUARDED, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_HOSTILE:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_HOSTILE, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_AFRAID:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_AFRAID, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_WAR:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_PLANNING_WAR, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						case MAJOR_CIV_APPROACH_DECEPTIVE:
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_DECEPTIVE, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
							break;
						}
					}
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
			// We declined!
			else
			{
				if (IsTooEarlyForShareOpinion(eFromPlayer))
				{
					if (bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_FOR_SHARE_OPINION);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
					}
				}
				else
				{
					if (bActivePlayer)
					{
						if (IsShareOpinionEverAsked(eFromPlayer) && !IsShareOpinionAccepted(eFromPlayer))
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_SHARE_OPINION_NO);
							gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
						}
						else
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_NO);
							gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
						}
					}

					SetShareOpinionEverAsked(eFromPlayer, true);
					SetShareOpinionAccepted(eFromPlayer, false);
				}
			}

			break;
		}
		// *********************************************
		// Human asked for or received a generous offer. NOTE: Unlike the other messages in here, this one is actually triggered from inside CvDealAI on a player's local machine
		// *********************************************
		// NOTE: This is going to be called for both AI offering a generous offer and human requesting help
		// Done this way because AI offering is actually treated as a fake human "demand"
		case FROM_UI_DIPLO_EVENT_HUMAN_REQUEST:
		{
			// **** NOTE **** - iArg1 is RESPONSE TYPE from CvDealAI::DoHumanDemand()
			DemandResponseTypes eResponse = (DemandResponseTypes) iArg1;

			// THIS is the important part of the message - it seeds the help request timer on all players' machines
			DoHelpRequestMade(eFromPlayer, eResponse);

			if (bActivePlayer)
			{
				// Help Request agreed to
				if (eResponse == DEMAND_RESPONSE_GIFT_ACCEPT)
				{
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_YES);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_POSITIVE);
				}
				// Help Request rebuffed
				else
				{
					if (eResponse == DEMAND_RESPONSE_GIFT_REFUSE_TOO_MUCH)
						strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_TOO_MUCH);

					else if (eResponse == DEMAND_RESPONSE_GIFT_REFUSE_TOO_SOON)
						strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_TOO_SOON);

					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_NEGATIVE);
				}
			}

			break;
		}
		// *********************************************
		// Player revokes Vassalage with AI
		// *********************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_ENDS_VASSALAGE:
		{
			bool bPeaceful = false;
			bool bHumanWasMyVassal = false;
			bool bAcceptable = false;

			// Human told AI to die
			if(iArg1 == 1)
			{
				bPeaceful = false;
			}
			// Human allows AI to leave vassalage
			else if(iArg1 == 2)
			{
				bPeaceful = true;
			}
		
			// Who is revoking?
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if (GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
				{
					// Is this player the vassal of eFromPlayer?
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsVassal(eFromPlayer))
					{
						// Player peacefully revoked our vassalage! Happy AI! :)
						if (bPeaceful)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetVassalagePeacefullyRevokedTurn(eFromPlayer, GC.getGame().getGameTurn());
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -300);
							
							// Friends of the vassal - bonus to recent assistance!
							for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
							{
								PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
								
								if (eThirdParty == eLoopPlayer || eThirdParty == eFromPlayer || GET_PLAYER(eThirdParty).getTeam() == GET_PLAYER(eFromPlayer).getTeam())
									continue;
								
								if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->IsPlayerValid(eThirdParty) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eThirdParty) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(eThirdParty))
								{
									GET_PLAYER(eThirdParty).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -300);
								}
							}
						}
						else
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetVassalageForcefullyRevokedTurn(eFromPlayer, GC.getGame().getGameTurn());
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetBackstabbedBy(eFromPlayer, true);
							
							// Friends of the vassal - penalty to recent assistance!
							for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
							{
								PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
								
								if (eThirdParty == eLoopPlayer || eThirdParty == eFromPlayer || GET_PLAYER(eThirdParty).getTeam() == GET_PLAYER(eFromPlayer).getTeam())
									continue;
								
								if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->IsPlayerValid(eThirdParty) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eThirdParty) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(eThirdParty))
								{
									GET_PLAYER(eThirdParty).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
								}
							}
						}
					}
				}
			}

			// AI team no longer vassal of human. If it's forcefully, bPeaceful = false
			if (GET_TEAM(GetTeam()).IsVassal(eFromTeam))
			{
				GET_TEAM(GetTeam()).DoEndVassal(eFromTeam, bPeaceful, false);
			}
			// Human was our vassal - what is our response?
			else if (GET_TEAM(eFromTeam).IsVassal(GetTeam()))
			{
				bHumanWasMyVassal = true;

				bAcceptable = IsEndVassalageRequestAcceptable(eFromPlayer);

				GET_TEAM(eFromTeam).DoEndVassal(GetTeam(), bAcceptable, false);
			}

			// AI message
			if (bActivePlayer)
			{
				// Human revoking AI vassalage
				if (!bHumanWasMyVassal)
				{
					if (bPeaceful)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_PEACEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_YES);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_WAR);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_ATTACKED);
					}
				}
				// Human requests AI to end vassalage
				else
				{
					if (bAcceptable)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_PEACEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_YES);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_FORCEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_ATTACKED); // Anim attacked correct. Not ideal, but otherwise leader won't react to your request
					}
				}
			}

			break;
		}
		// **********************************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_MOVE_TROOPS_RESPONSE:
		{
			MoveTroopsResponseTypes eResponse = GetMoveTroopsRequestResponse(eFromPlayer, /*bJustChecking*/ false);

			if (eResponse == MOVE_TROOPS_RESPONSE_REFUSE && !GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetID()))
				eResponse = MOVE_TROOPS_RESPONSE_NEUTRAL;

			// AI says yes, they will move their troops, and even better, they will leave the human alone
			if (eResponse == MOVE_TROOPS_RESPONSE_ACCEPT)
			{
				// AI accepts move troops request
				// Make sure all players on this team get this check, so that teammates don't screw each other over.
				for (int iI=0; iI < MAX_MAJOR_CIVS; iI++)
				{
					TeamTypes eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
					if (eLoopTeam == GetTeam())
					{
						GET_PLAYER((PlayerTypes)iI).GetDiplomacyAI()->SetPlayerMoveTroopsRequestAccepted(eFromPlayer, true);
						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState((PlayerTypes)iI, PROMISE_STATE_MADE);
					}
				}

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_ACCEPT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}

				// lower weight for crossing tiles around this player's cities
				/*
				int iLoop;
				for (CvCity* pLoopCity = GET_PLAYER(eFromPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eFromPlayer).nextCity(&iLoop))
				{
					//todo: mark cities for pathfinder
					//open question: when to unmark?? 
				}
				*/
			}
			// AI says they are just moving their troops through
			else if (eResponse == MOVE_TROOPS_RESPONSE_NEUTRAL)
			{
				// AI agrees not to attack
				// Make sure all players on this team get this check, so that teammates don't screw each other over.
				for (int iI=0; iI < MAX_MAJOR_CIVS; iI++)
				{
					TeamTypes eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
					if (eLoopTeam == GetTeam())
					{
						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState((PlayerTypes)iI, PROMISE_STATE_MADE);
					}
				}

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}
			}
			// AI tells human to die
			else if (eResponse == MOVE_TROOPS_RESPONSE_REFUSE)
			{
				// Declare war on human!
				if (DeclareWar(eFromTeam))
				{
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState(eMyPlayer, PROMISE_STATE_IGNORED);

					if (bActivePlayer)
					{
						if (IsGoingForWorldConquest())
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_CONQUEST);
						}
						// Was deceptive
						else if (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_DECEPTIVE)
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_DECEPTIVE);
						}
						// Default case
						else
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_HOSTILE);
						}

						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
					}
				}
				else
				{
					// AI agrees not to attack
					for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
					{
						TeamTypes eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
						if (eLoopTeam == GetTeam())
						{
							GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState((PlayerTypes)iI, PROMISE_STATE_MADE);
						}
					}

					if (bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
					}
				}
			}
			// Something happened! (will generate an error message)
			else
			{
				CvAssert(false);

				if (bActivePlayer)
				{
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}
			}

			break;
		}
#endif


	// Should always have a state we're handling
	default:
		CvAssert(false);
		break;
	}
}

/// Is the AI acting mean to the active human player?
bool CvDiplomacyAI::IsActHostileTowardsHuman(PlayerTypes eHuman, bool bIgnoreCurrentWar) const
{
	if (IsTeammate(eHuman) || IsDoFAccepted(eHuman) || GET_PLAYER(eHuman).isObserver())
		return false;

	bool bAtWar = IsAtWar(eHuman);
	bool bAtWarButWantsPeace = bAtWar && GetTreatyWillingToOffer(eHuman) >= PEACE_TREATY_WHITE_PEACE && GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_WHITE_PEACE; // Have to be at war, high level AI has to want peace

	if (bAtWar && !bIgnoreCurrentWar)
	{
		if (bAtWarButWantsPeace)
			return false;

		return true;
	}

	MajorCivApproachTypes eSurfaceApproach = GetSurfaceApproach(eHuman);
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(eHuman);

	if (eSurfaceApproach == MAJOR_CIV_APPROACH_HOSTILE) // Hostile approach
		return true;

	if (eSurfaceApproach == MAJOR_CIV_APPROACH_AFRAID) // Afraid approach
		return false;

	// Denounced them?
	if (IsDenouncedPlayer(eHuman))
		return true;

	if (eSurfaceApproach == MAJOR_CIV_APPROACH_FRIENDLY) // Friendly approach
		return false;

	// NOTE: If we got here, the surface approach must be either NEUTRAL or GUARDED

	// Backstabber!
	if (IsUntrustworthy(eHuman))
		return true;

	// Liberator
	if (WasResurrectedBy(eHuman) || IsPlayerLiberatedCapital(eHuman))
		return false;

	// Defensive Pact
	if (IsHasDefensivePact(eHuman))
		return false;

	// Coop war planned or ongoing?
	if (GetGlobalCoopWarWithState(eHuman) >= COOP_WAR_STATE_PREPARING)
		return false;

	// Are we in bad shape for war? Don't act hostile.
	if (GetPlayer()->IsNoNewWars())
		return false;

	// Different ideology
	if (IsPlayerOpposingIdeology(eHuman) && !IsIgnoreIdeologyDifferences(eHuman))
		return true;

	// High threat
	ThreatTypes eWarmongerThreat = GetWarmongerThreat(eHuman);

	if (eWarmongerThreat == THREAT_CRITICAL)
		return true;

	if (GetPlayer()->GetProximityToPlayer(eHuman) >= PLAYER_PROXIMITY_CLOSE && eWarmongerThreat == THREAT_SEVERE)
		return true;

	if (IsEndgameAggressiveTo(eHuman))
		return true;

	// Same ideology and not denounced/unforgivable
	if (IsPlayerSameIdeology(eHuman) && !IsDenouncedByPlayer(eHuman) && eOpinion != MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;

	// Poor target value
	TargetValueTypes eTargetValue = GetPlayerTargetValue(eHuman);

	if (eTargetValue == TARGET_VALUE_IMPOSSIBLE)
		return false;

	if (eSurfaceApproach == MAJOR_CIV_APPROACH_NEUTRAL && eTargetValue == TARGET_VALUE_BAD)
		return false;

	// Planning war? Let's not tip them off about our plans.
	bool bPlanningWar = GetMajorCivApproach(eHuman) == MAJOR_CIV_APPROACH_WAR;
	bPlanningWar |= IsWantsSneakAttack(eHuman);
	bPlanningWar |= IsArmyInPlaceForAttack(eHuman);
	bPlanningWar |= GetGlobalCoopWarAgainstState(eHuman) >= COOP_WAR_STATE_PREPARING;

	if (bPlanningWar)
	{
		if (!IsEasyTarget(eHuman) && eTargetValue != TARGET_VALUE_SOFT)
			return false;

		if (IsEasyTarget(eHuman) && eTargetValue == TARGET_VALUE_AVERAGE)
			return false;

		return true;
	}

	// They denounced us?
	if (IsDenouncedByPlayer(eHuman))
		return true;

	// Poor opinion?
	if (eOpinion <= MAJOR_CIV_OPINION_ENEMY)
		return true;

	if (eSurfaceApproach == MAJOR_CIV_APPROACH_GUARDED && eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
		return true;

	return false;
}

/// AI is greeting the human - what does he say?
const char* CvDiplomacyAI::GetGreetHumanMessage(LeaderheadAnimationTypes& eAnimation)
{
	PlayerTypes eHuman = GC.getGame().getActivePlayer();
	CvPlayer* pHuman = &GET_PLAYER(eHuman);
	TeamTypes eHumanTeam = pHuman->getTeam();
	CvTeam* pHumanTeam = &GET_TEAM(eHumanTeam);

	DoUpdateWarDamage();

	MajorCivApproachTypes eVisibleApproach = GetSurfaceApproach(eHuman);
	WarProjectionTypes eWarProjection = GetWarProjection(eHuman);
	DisputeLevelTypes eLandDispute = GetLandDisputeLevel(eHuman);
	AggressivePostureTypes eMilitaryPosture = GetMilitaryAggressivePosture(eHuman);
	AggressivePostureTypes eExpansionPosture = GetExpansionAggressivePosture(eHuman);
	AggressivePostureTypes ePlotBuyingPosture = GetPlotBuyingAggressivePosture(eHuman);
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(eHuman);
	StrengthTypes eEconomicStrength = GetPlayerEconomicStrengthComparedToUs(eHuman);
	int iNumPlayersAttacked = GetOtherPlayerNumMinorsAttacked(eHuman) + GetOtherPlayerNumMajorsAttacked(eHuman);
	int iNumPlayersKilled = GetPlayerNumMinorsConquered(eHuman) + GetPlayerNumMajorsConquered(eHuman);

	bool bAtWar = IsAtWar(eHuman);
	bool bAtWarButWantsPeace = bAtWar && GetTreatyWillingToOffer(eHuman) >= PEACE_TREATY_WHITE_PEACE && GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_WHITE_PEACE; // Have to be at war, high level AI has to want peace

	// Most Greetings are added to a vector to be picked from randomly
	// However, some are returned immediately, as they "fit" well enough that we DEFINITELY want to use that specific greeting
	FStaticVector<DiploMessageTypes, NUM_DIPLO_MESSAGE_TYPES, true, c_eCiv5GameplayDLL, 0> veValidGreetings;

	// Determine if the AI is being hostile to the player
	bool bHostile = IsActHostileTowardsHuman(eHuman);

	////////////////////////////////////////////
	// Pick Greeting Animation
	////////////////////////////////////////////

	if (bHostile)
		eAnimation = LEADERHEAD_ANIM_HATE_HELLO;
	else
		eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;

	////////////////////////////////////////////
	// Repeated Greetings
	////////////////////////////////////////////

	int iTimesScreenOpened = GC.GetEngineUserInterface()->GetStartDiploRepeatCount();

	if (iTimesScreenOpened > 4)
		return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_REPEAT_TOO_MUCH);

	else if (iTimesScreenOpened > 2)
	{
		if (bHostile)
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_HOSTILE_REPEAT);
		else
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_REPEAT);
	}

	////////////////////////////////////////////
	// War Greetings
	////////////////////////////////////////////

	// At war but wants peace
	if (bAtWarButWantsPeace)
	{
		if (eWarProjection == WAR_PROJECTION_DESTRUCTION)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_DESTRUCTION_LOOMS);
		}
		else if (GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_CAPITULATION)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_WILL_ACCEPT_SURRENDER);
		}
		else
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_AT_WAR_WANTS_PEACE);
		}
	}
	else if (bAtWar)
		return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_AT_WAR_HOSTILE);

	////////////////////////////////////////////
	// Situational Greetings
	////////////////////////////////////////////

	// Working on a Research Agreement - JON: Disabled because this could be invoked if the AI wanted one without the human's knowledge
	//if (IsWantsResearchAgreementWithPlayer(eHuman))
	//	return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_RESEARCH_AGREEMENT);

	// Player has broken promises about playing nice militarily
	if (eVisibleApproach != MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if (IsPlayerBrokenMilitaryPromise(eHuman) || GetBrokenMilitaryPromiseWithAnybodyScore(eHuman) > 0)
		{
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_BROKEN_MILITARY_PROMISE);
		}
	}

	// Players are working together
	if(IsDoFAccepted(eHuman))
		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_WORKING_WITH);

	// Coop War against anyone?
	if (GetGlobalCoopWarWithState(eHuman) >= COOP_WAR_STATE_PREPARING)
	{
		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_COOP_WAR);
	}

	// Human at war with someone?
	if(pHumanTeam->getAtWarCount(true) > 0)
	{
		if(bHostile)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_AT_WAR);
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HUMAN_AT_WAR);
	}

	// Military Aggressive Posture
	if(eMilitaryPosture >= AGGRESSIVE_POSTURE_MEDIUM)
		if(bHostile)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_MILITARY);
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_MILITARY);

	// Land Dispute
	if(eLandDispute >= DISPUTE_LEVEL_STRONG)
	{
		// Expansion
		if(eExpansionPosture >= AGGRESSIVE_POSTURE_MEDIUM)
			if(bHostile)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION);
			else
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_EXPANSION);

		// Plot buying
		if(ePlotBuyingPosture >= AGGRESSIVE_POSTURE_MEDIUM)
			if(bHostile)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING);
			else
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_PLOT_BUYING);
	}

	////////////////////////////////////////////
	// Friendly Greetings
	////////////////////////////////////////////

	if(!bHostile)
	{
		if(eVisibleApproach == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_HELLO);

			// Military Strength
			if(eMilitaryStrength >= STRENGTH_STRONG)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_MILITARY);

			// Economic Strength
			if(eEconomicStrength >= STRENGTH_STRONG)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_ECONOMY);
		}
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO);
	}

	////////////////////////////////////////////
	// Hostile Greetings
	////////////////////////////////////////////

	else
	{
		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HELLO);

		// Human has at least 1 fewer City
		if(pHuman->getNumCities() < GetPlayer()->getNumCities())
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_FEW_CITIES);

		// Human's military is weak
		if(eMilitaryStrength <= STRENGTH_POOR)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_SMALL_ARMY);

		// Human has attacked/killed some folks
		if(iNumPlayersAttacked >= 2 || iNumPlayersKilled >= 1)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_IS_WARMONGER);
	}

	// Pick a random greeting from the valid ones (if there are any)
	if (veValidGreetings.size() > 0)
	{
		int iIndex = GC.getGame().getAsyncRandNum(veValidGreetings.size(), "Diplomacy AI: Picking random Greeting for AI to give to human.");

		DiploMessageTypes eGreetingType = veValidGreetings[iIndex];
		const char* strOptionalKey = "";
		bool bFoundPlayer = false;

		// Coop War picked?
		if (eGreetingType == DIPLO_MESSAGE_GREETING_COOP_WAR)
		{
			int iThirdPartyLoop = 0;

			// Loop until we've picked a random guy
			do
			{
				// Reset to beginning of list
				if (iThirdPartyLoop >= MAX_MAJOR_CIVS)
					iThirdPartyLoop = 0;

				if (GetCoopWarState(eHuman, (PlayerTypes) iThirdPartyLoop) >= COOP_WAR_STATE_PREPARING)
				{
					// Rand roll
					if (GC.getGame().getAsyncRandNum(100, "Diplomacy AI: Random coop war greeting.") < 33)
					{
						strOptionalKey = GET_PLAYER((PlayerTypes) iThirdPartyLoop).getNameKey();
						bFoundPlayer = true;
					}
				}

				iThirdPartyLoop++;

			}
			while(!bFoundPlayer);
		}

		return GetDiploStringForMessage(eGreetingType, NO_PLAYER, strOptionalKey);
	}

	// NOTHING else fits so use generic neutral greeting
	return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO);
}

/// AI cant match human deal.
const char* CvDiplomacyAI::GetOfferText(PlayerTypes ePlayer)
{
	if(ePlayer == NO_PLAYER)
	{
		ePlayer = GC.getGame().getActivePlayer();
		if(ePlayer != NO_PLAYER)
		{
			MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);
			if(IsCantMatchDeal(ePlayer))
			{
				SetCantMatchDeal(ePlayer, false);
				if(eApproach >= MAJOR_CIV_APPROACH_AFRAID)
				{
					return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
				}
				else
				{
					return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER_NEGATIVE");
				}
			}
			else
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
			}
		}
		else
		{
			return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
		}
	}
	else
	{
		MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);
		if(IsCantMatchDeal(ePlayer))
		{
			SetCantMatchDeal(ePlayer, false);
			if(eApproach >= MAJOR_CIV_APPROACH_AFRAID)
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
			}
			else
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER_NEGATIVE");
			}
		}
		else
		{
			return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
		}
	}
}

/// The AI is denouncing the human
int CvDiplomacyAI::GetDenounceMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iMessage = 0;
	if(GetPlayer()->isHuman())
	{
		return iMessage;
	}
	if(ePlayer == NO_PLAYER)
	{
		ePlayer = GC.getGame().getActivePlayer();
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		bool bDogpile = false;

		PlayerTypes eTargetPlayerLoop;
		for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
		{
			eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

			if(eTargetPlayerLoop == NO_PLAYER)
				continue;

			// Player must be valid
			if(!IsPlayerValid(eTargetPlayerLoop))
				continue;

			// Don't test player Target himself
			if(eTargetPlayerLoop == ePlayer)
			continue;

			if(GET_PLAYER(eTargetPlayerLoop).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer))
			{
				bDogpile = true;
				break;
			}
		}

		// Guy is a different ideology
		if (GetDiploBalance() > 5 && IsPlayerOpposingIdeology(ePlayer))
		{
			if (m_pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology() == GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
			{
				if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					return 1;
				}
				else if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
				{
					return 2;
				}
				else if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
				{
					return 3;
				}
			}
			else if (GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree())
			{
				if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					return 4;
				}
				else if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
				{
					return 5;
				}
				else if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
				{
					return 6;
				}
			}
			else
			{
				return 7;
			}
		}

		// Guy is a warmonger
		else if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR && GetDiploBalance() > 5)
		{
			return 8;
		}
		// Guy is getting too friendly with our minors
		else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetMinorCivCompetitiveness() > 5)
		{
			return 9;
		}
		// Guy is bullying our minors
		else if(GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 0 && GetMinorCivCompetitiveness() > 5)
		{
			return 10;
		}
		// Guy nuked us!
		else if(IsNukedBy(ePlayer))
		{
			return 11;
		}
		// Guy is a thief!
		else if(IsPlayerBrokenSpyPromise(ePlayer) && GetLoyalty() > 5)
		{
			return 12;
		}
		// Guy is settling near us and we don't like it
		else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
		{
			return 13;
		}
		// Guy has bad friends!
		else if(IsPlayerDoFWithAnyEnemy(ePlayer) && GetDenounceWillingness() > 5)
		{
			return 14;
		}
		// Is denounced already
		else if(bDogpile && GetDenounceWillingness() > 5)
		{
			return 15;
		}
		// Is untrustworthy
		else if(IsUntrustworthy(ePlayer))
		{
			return 16;
		}
		// Previous wars
		else if(eOpinion < MAJOR_CIV_OPINION_NEUTRAL && (GetNumTimesRazed(ePlayer) > 0 || GetNumCitiesCapturedBy(ePlayer) > 0) && GetForgiveness() <= 5)
		{
			return 17;
		}
		// Guy is a different faith
		else if(GetMeanness() > 4 && m_pPlayer->GetReligions()->HasCreatedReligion(true) && GET_PLAYER(ePlayer).GetReligions()->HasCreatedReligion(true) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		{
			return 18;
		}
		// Artifacts
		else if(IsPlayerBrokenNoDiggingPromise(ePlayer) && GetForgiveness() <= 5)
		{
			return 19;
		}
		// Guy built wonders we wanted
		else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetWonderCompetitiveness() > 5)
		{
			return 20;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 21;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 22;
		}
	}
	else
	{
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		
		bool bDogpile = false;

		PlayerTypes eTargetPlayerLoop;
		for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
		{
			eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

			if(eTargetPlayerLoop == NO_PLAYER)
				continue;

			// Player must be valid
			if(!IsPlayerValid(eTargetPlayerLoop))
				continue;

			// Don't test player Target himself
			if(eTargetPlayerLoop == ePlayer)
			continue;

			if(GET_PLAYER(eTargetPlayerLoop).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer))
			{
				bDogpile = true;
			}
		}
		iMessage = 0;

		// Guy is a different ideology
		if (GetDiploBalance() > 5 && IsPlayerOpposingIdeology(ePlayer))
		{
			if (m_pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology() == GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
			{
				if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					return 1;
				}
				else if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
				{
					return 2;
				}
				else if (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
				{
					return 3;
				}
			}
			else if (GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree())
			{
				if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					return 4;
				}
				else if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
				{
					return 5;
				}
				else if (m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
				{
					return 6;
				}
			}
			else
			{
				return 7;
			}
		}
		// Guy is a warmonger
		else if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR && GetDiploBalance() > 5)
		{
			return 8;
		}
		// Guy is getting too friendly with our minors
		else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetMinorCivCompetitiveness() > 5)
		{
			return 9;
		}
		// Guy is getting too friendly with our minors
		else if(GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 0 && GetMinorCivCompetitiveness() > 5)
		{
			return 10;
		}
		// Guy nuked us!
		else if(IsNukedBy(ePlayer))
		{
			return 11;
		}
		// Guy is a thief!
		else if(IsPlayerBrokenSpyPromise(ePlayer) && GetLoyalty() > 5)
		{
			return 12;
		}
		// Guy is setting near us and we don't like it
		else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
		{
			return 13;
		}
		// Guy has bad friends!
		else if(IsPlayerDoFWithAnyEnemy(ePlayer) && GetDenounceWillingness() > 5)
		{
			return 14;
		}
		// Is denounced already
		else if(bDogpile && GetDenounceWillingness() > 5)
		{
			return 15;
		}
		//Is untrustworthy
		else if(IsUntrustworthy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(m_pPlayer->GetID()))
		{
			return 16;
		}
		//Previous wars
		else if(eOpinion < MAJOR_CIV_OPINION_NEUTRAL && GetNumWarsFought(ePlayer) > 0 && GetForgiveness() <= 5)
		{
			return 17;
		}
		// Guy is a different faith
		else if(GetMeanness() > 4 && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		{
			return 18;
		}
		//Artifacts
		else if(IsPlayerBrokenNoDiggingPromise(ePlayer) && GetForgiveness() <= 5)
		{
			return 19;
		}
		// Guy built wonders we wanted
		else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetWonderCompetitiveness() > 5)
		{
			return 20;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 21;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 22;
		}
	}

	return iMessage;
}

const char* CvDiplomacyAI::GetDenounceMessageValue(int iValue)
{
	const char* strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE");
	// Guy is a different ideology
	if(iValue == 1)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_AUTOCRACY");
	}
	else if(iValue == 2)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_ORDER");
	}
	else if(iValue == 3)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_FREEDOM");
	}
	else if(iValue == 4)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_AUTOCRACY_OTHER");
	}
	else if(iValue == 5)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_ORDER_OTHER");
	}
	else if(iValue == 6)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_FREEDOM_OTHER");
	}
	else if(iValue == 7)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_GENERIC");
	}
	// Guy is a warmonger
	else if(iValue == 8)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_WARMONGER");
	}
	// Guy is getting too friendly with our minors
	else if(iValue == 9)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_MINORS");
	}
	// Guy is getting too friendly with our minors
	else if(iValue == 10)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_MINORS_BULLY");
	}
	// Guy nuked us!
	else if(iValue == 11)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_NUKED");
	}
	// Guy is a thief!
	else if(iValue == 12)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_SPIES");
	}
	// Guy is setting near us and we don't like it
	else if(iValue == 13)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_LAND");
	}
	// Guy has bad friends!
	else if(iValue == 14)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_ENEMY");
	}
	// Is denounced already
	else if(iValue == 15)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_DOGPILE");
	}
	//Is untrustworthy
	else if(iValue == 16)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_UNTRUSTWORTHY");
	}
	//Previous wars
	else if(iValue == 17)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_UNFORGIVEABLE");
	}
	// Guy is a different faith
	else if(iValue == 18)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_FAITH");
	}
	//Artifacts
	else if(iValue == 19)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DIGGING");
	}
	// Guy built wonders we wanted
	else if(iValue == 20)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_WONDERS");
	}
	// Guy is pursuing victory too hard
	else if(iValue == 21)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_VICTORY_DISPUTE");
	}
	// Guy is pursuing victory too hard
	else if(iValue == 22)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_VICTORY_BLOCK");
	}
	else
	{
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE");
	}

	return strText;
}

/// AI is insulting the human
const char* CvDiplomacyAI::GetInsultHumanMessage()
{
	PlayerTypes ePlayer = GC.getGame().getActivePlayer();
	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

	FStaticVector<DiploMessageTypes, NUM_DIPLO_MESSAGE_TYPES, true, c_eCiv5GameplayDLL, 0> veValidInsults;

	// They're weak militarily
	if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_MILITARY);

	// We have nukes and they don't
	if(kPlayer.getNumNukeUnits() == 0 && m_pPlayer->getNumNukeUnits() > 0)
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_NUKE);

	// They've attacked a lot of minor civs
	else if(GetOtherPlayerNumMinorsAttacked(ePlayer) > 2)
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_BULLY);

	// Their empire is unhappy
	else if(kPlayer.IsEmpireVeryUnhappy())
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_UNHAPPINESS);

	// They have fewer Cities than us
	else if((kPlayer.getNumCities() * 2) < m_pPlayer->getNumCities() && m_pPlayer->getNumCities() > 4)
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_CITIES);

	// They have a low population
	else if((kPlayer.getTotalPopulation() * 2) <= m_pPlayer->getTotalPopulation())
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_POPULATION);

	// They have less Culture us
	else if((kPlayer.GetJONSCultureEverGenerated() * 2) <= m_pPlayer->GetJONSCultureEverGenerated())
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_CULTURE);

	// Pick a random insult from the valid ones
	if(veValidInsults.size() > 0)
	{
		int iIndex = GC.getGame().getAsyncRandNum(veValidInsults.size(), "Picking random insult for AI to give to human.");

		return GetDiploStringForMessage(veValidInsults[iIndex]);
	}

	// Needed to fall back on generic insult
	return GetDiploStringForMessage(DIPLO_MESSAGE_INSULT_GENERIC);
}

/// The human declares war on the AI, how does he respond?
const char* CvDiplomacyAI::GetAttackedByHumanMessage()
{
	PlayerTypes ePlayer = GC.getGame().getActivePlayer();

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

	// Military Promise Broken
	// This player said he wasn't going to attack us but did anyways
	if(IsPlayerBrokenMilitaryPromise(ePlayer))
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_MILITARY_PROMISE_BROKEN);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Player broke our vassal agreement (declared war on vassal)
	if(MOD_DIPLOMACY_CIV4_FEATURES && IsPlayerBrokenVassalAgreement(ePlayer))
		return GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_ATTACKED_VASSAL);
#endif

	//Warmonger
	//If this person is a major warmonger, we should not be surprised
	if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
	{
		// They are WEAKER than us
		if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_WARMONGER);

		// They are STRONGER than us
		else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_WARMONGER);

		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WARMONGER);
	}

	//Ideology
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch != eTheirBranch)
	{
		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_IDEOLOGY_DIFFERENCE);
	}
	if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
	{
		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_IDEOLOGY_SAME);
	}

	// Sad
	// If we felt the other player was an Ally or Friend then we're just plain sad that they attacked us
	if(eOpinion == MAJOR_CIV_OPINION_ALLY ||
	        eOpinion == MAJOR_CIV_OPINION_FRIEND)
	{
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_SAD);
	}

	// Betrayed	-	TBD
	// This should be related to active deals, e.g. Open Borders, luxuries, etc.
	if(false)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_BETRAYED);

	// Excited
	// A player with the Conquest Grand Strategy will be excited
	// May also look at Boldness or Offense flavor in here eventually
	{
		if(IsGoingForWorldConquest())
		{
			// They are WEAKER than us
			if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
				return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_EXCITED);

			// They are STRONGER than us
			else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
				return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_EXCITED);

			// Average strength
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_EXCITED);
		}
	}

	// Hostile
	// This is the default response to being attacked
	// We are STRONGER than the person who attacked us
	if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_HOSTILE);

	// We are WEAKER than the person who attacked us
	else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_HOSTILE);

	// Average strength
	return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_HOSTILE);
}

/// The AI is declaring war on a human, what does he say?
const char* CvDiplomacyAI::GetWarMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	// Only show the message for the active human
	if(GC.getGame().getActivePlayer() == ePlayer)
	{
		MajorCivApproachTypes eApproachHidingTrueFeelings = GetSurfaceApproach(ePlayer);
		StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

		// Betrayal
		// We were Friendly (either real or fake), so we can presume this AI is betraying
		if(eApproachHidingTrueFeelings == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			// Betrayal, and we're weak
			if(eMilitaryStrengthComparedToUs >= STRENGTH_STRONG)
				return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WEAK_BETRAYAL);

			// Normal betrayal
			else
				return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_BETRAYAL);
		}

		// Old Enemies
		// If we have gone to war in the past more than once, we're old enemies
		if(GetNumWarsFought(ePlayer) > 1)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_OLD_ENEMIES);

		//Warmonger
		//If this person is a major warmonger, we should tell them about it
		if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WARMONGER);

		//Ideology
		//If we're different ideologies, that's probably a big factor.
		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch != eTheirBranch)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_IDEOLOGY_DIFFERENCE);
		}
		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_IDEOLOGY_SAME);
		}

		// Land Dispute
		// If Land Dispute is Strong or higher then this is probably a strong contributor to the DoW
		if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_LAND);

		// Desperate
		// The AI is desperate at this point in the game, and views a DoW as one of its only ways to slow an opponent
		if(eMilitaryStrengthComparedToUs >= STRENGTH_STRONG)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_DESPERATE);

		// World Conquest
		// A player with the Conquest Grand Strategy brags about his goals
		if(IsGoingForWorldConquest())
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WORLD_CONQUEST);

		// Opportunity
		// The AI sees an opportunity because the opponent is weak
		if(eMilitaryStrengthComparedToUs <= STRENGTH_POOR)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_OPPORTUNITY);

		// Generic DoW... probably shouldn't ever really use this
		return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
	}

	return strText;
}

/// The AI is breaking up with the human
const char* CvDiplomacyAI::GetEndDoFMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	// Guy is a warmonger
	if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_WARMONGER");
	// Guy is a different ideology
	else if((GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_IDEOLOGY");
	// Guy is a different faith
	else if((GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_FAITH");
	// Guy is getting too friendly with our minors
	else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_MINORS");
	// Guy is setting near us and we don't like it
	else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_LAND");
	// Guy built wonders we wanted
	else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_WONDERS");
	// Guy is competing with us for victory
	else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_VICTORY");
	// Guy is pursuing victory too hard
	else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_BLOCK_VICTORY");
	else
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_DEFAULT");

	return strText;
}

/// The AI is done working against someone
const char* CvDiplomacyAI::GetEndWorkAgainstSomeoneMessage(PlayerTypes ePlayer, const Localization::String& strAgainstPlayerKey)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	if(ePlayer >=0 && ePlayer < MAX_MAJOR_CIVS)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_AGAINST_SOMEONE_DEFAULT", strAgainstPlayerKey);

	return strText;
}

/// Wrapper function for getting text from the Diplo Text system
const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag)
{
	return GetDiploTextFromTag(strTag, Localization::String::Empty, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag, const Localization::String& strOptionalKey1)
{
	return GetDiploTextFromTag(strTag, strOptionalKey1, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag, const Localization::String& strOptionalKey1, const Localization::String& strOptionalKey2)
{
	// This is the leader text tag from the XML
	const char* strLeaderTag = GetPlayer()->getLeaderInfo().GetType();

	// This has to be a member so that our strings don't go out of scope when we leave this function
	m_strDiploText = GC.getGame().GetDiploResponse(strLeaderTag, strTag, strOptionalKey1, strOptionalKey2);

	return m_strDiploText.toUTF8();
}


// ////////////////////////////////////
// COOP WARS
// ////////////////////////////////////

/// Are we able to start a coop war against eTargetPlayer?
bool CvDiplomacyAI::IsValidCoopWarTarget(PlayerTypes eTargetPlayer, bool bIgnoreCanDeclareWar)
{
	// Exclude vassals and invalid players from consideration
	if (GetPlayer()->IsVassalOfSomeone() || !GetPlayer()->isMajorCiv() || !GetPlayer()->isAlive() || (GetPlayer()->getNumCities() <= 0))
		return false;

	if (GET_PLAYER(eTargetPlayer).IsVassalOfSomeone() || !GET_PLAYER(eTargetPlayer).isMajorCiv() || !GET_PLAYER(eTargetPlayer).isAlive() || (GET_PLAYER(eTargetPlayer).getNumCities() <= 0))
		return false;

	TeamTypes eMyTeam = GetTeam();
	TeamTypes eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();

	// Can't be teammates with the target
	if (eMyTeam == eTargetTeam)
		return false;

	// Can't be already at war with the target
	if (IsAtWar(eTargetPlayer))
		return false;

	// Can't declare war on an unmet player
	if (!IsHasMet(eTargetPlayer))
		return false;

	// Can't be a vassal or master of the target
	if (IsVassal(eTargetPlayer) || IsMaster(eTargetPlayer))
		return false;

	// Can't have a Defensive Pact with the target
	if (IsHasDefensivePact(eTargetPlayer))
		return false;

	// Can't have a Declaration of Friendship with the target
	if (IsDoFAccepted(eTargetPlayer))
		return false;

	// Must be able to declare war on the target
	if (!bIgnoreCanDeclareWar && !GET_TEAM(eMyTeam).canDeclareWar(eTargetTeam, GetID()))
	{
		return false;
	}

	return true;
}

/// Are we able to request a coop war with eAllyPlayer against eTargetPlayer?
bool CvDiplomacyAI::CanRequestCoopWar(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer)
{
	// Must be teammates or have a Declaration of Friendship with eAllyPlayer to start any coop wars
	if (!IsTeammate(eAllyPlayer) && !IsDoFAccepted(eAllyPlayer))
		return false;

	// Do we already have a coop war planned?
	CoopWarStates eCoopWarState = GetCoopWarState(eAllyPlayer, eTargetPlayer);
	if (eCoopWarState >= COOP_WAR_STATE_PREPARING)
		return false;

	// Do we already have a coop war planned against the guy we're asking?
	if (GetGlobalCoopWarAgainstState(eAllyPlayer) >= COOP_WAR_STATE_PREPARING)
		return false;

	return IsValidCoopWarTarget(eTargetPlayer, false) && GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsValidCoopWarTarget(eTargetPlayer, false);
}

/// Do we want to declare war on anyone with ePlayer?
bool CvDiplomacyAI::DoTestCoopWarDesire(PlayerTypes eAllyPlayer, PlayerTypes& eChosenTargetPlayer)
{
	// We can only ask our friends.
	if (!IsDoFAccepted(eAllyPlayer))
		return false;

	// If we hate them for some reason, don't bother.
	if (GetMajorCivApproach(eAllyPlayer) <= MAJOR_CIV_APPROACH_GUARDED)
		return false;

	if (GetMajorCivOpinion(eAllyPlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	if (IsUntrustworthy(eAllyPlayer))
		return false;

	// Find the best target!
	PlayerTypes eBestTarget = NO_PLAYER;
	int iBestTargetScore = /*40*/ GC.getCOOP_WAR_DESIRE_THRESHOLD();

	for (int iTargetLoop = 0; iTargetLoop < MAX_MAJOR_CIVS; iTargetLoop++)
	{
		PlayerTypes eTarget = (PlayerTypes) iTargetLoop;

		// Don't ask if they've rejected us recently.
		CoopWarStates eCoopWarState = GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->GetCoopWarState(GetID(), eTarget);
		if (eCoopWarState == COOP_WAR_STATE_REJECTED || eCoopWarState == COOP_WAR_STATE_WARNED_TARGET)
			continue;

		// Must be able to make the request
		if (!CanRequestCoopWar(eAllyPlayer, eTarget))
			continue;

		// Only ask if we're sufficiently upset with the target
		if (GetBiggestCompetitor() != eTarget && GetMajorCivApproach(eTarget) > MAJOR_CIV_APPROACH_DECEPTIVE && !IsWantsSneakAttack(eTarget) && GetGlobalCoopWarAgainstState(eTarget) < COOP_WAR_STATE_PREPARING)
			continue;

		int iScore = GetCoopWarDesireScore(eAllyPlayer, eTarget);

		if (iScore > iBestTargetScore)
		{
			eBestTarget = eTarget;
			iBestTargetScore = iScore;
		}
	}

	// Found someone?
	if (eBestTarget != NO_PLAYER)
	{
		eChosenTargetPlayer = eBestTarget;
		return true;
	}

	return false;
}

/// What is this AI's willingness to go to war with eAllyPlayer against eTargetPlayer?
int CvDiplomacyAI::GetCoopWarDesireScore(PlayerTypes eAllyPlayer, PlayerTypes eTargetPlayer)
{
	// Must be a potential war target
	if (!IsPotentialWarTarget(eTargetPlayer))
		return 0;

	// If we're in bad shape for war, we're not interested.
	if (GetPlayer()->IsNoNewWars() && !IsEndgameAggressiveTo(eTargetPlayer) && !IsCapitalCapturedBy(eTargetPlayer, true, false))
		return 0;

	// No coop wars with players about to win the game.
	if (IsEndgameAggressiveTo(eAllyPlayer))
		return 0;

	// Need a valid attack target
	if (!GetPlayer()->GetMilitaryAI()->HavePossibleAttackTarget(eTargetPlayer))
		return 0;

	if (!GET_PLAYER(eAllyPlayer).isHuman() && !GET_PLAYER(eAllyPlayer).GetMilitaryAI()->HavePossibleAttackTarget(eTargetPlayer))
		return 0;

	// Sanity checks!
	if (!IsWarSane(eTargetPlayer))
		return 0;

	// If we don't trust them, we're not interested.
	if (IsUntrustworthy(eAllyPlayer))
		return 0;

	// No coop wars if we recently made peace.
	if (GetNumWarsFought(eTargetPlayer) > 0)
	{
		int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(GET_PLAYER(eTargetPlayer).getTeam());
		if (iPeaceTreatyTurn > -1)
		{
			int iTurnsSincePeace = GC.getGame().getGameTurn() - iPeaceTreatyTurn;
			int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

			if (iTurnsSincePeace < iPeaceDampenerTurns)
			{
				return 0;
			}
		}
	}

	int iScore = 0;
	bool bBadness = false;

	// How do we feel about the other player?
	switch (GetMajorCivApproach(eAllyPlayer))
	{
	case MAJOR_CIV_APPROACH_WAR:
	case MAJOR_CIV_APPROACH_HOSTILE:
	case MAJOR_CIV_APPROACH_GUARDED:
		return 0;
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
		iScore -= 5;
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		iScore -= 2;
		break;
	case MAJOR_CIV_APPROACH_AFRAID:
		iScore += 2;
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		iScore += 5;
		break;
	}

	switch (GetMajorCivOpinion(eAllyPlayer))
	{
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
	case MAJOR_CIV_OPINION_ENEMY:
		return 0;
		break;
	case MAJOR_CIV_OPINION_COMPETITOR:
		iScore -= 5;
		break;
	case MAJOR_CIV_OPINION_NEUTRAL:
		iScore -= 2;
		break;
	case MAJOR_CIV_OPINION_FAVORABLE:
		iScore += 2;
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		iScore += 5;
		break;
	case MAJOR_CIV_OPINION_ALLY:
		iScore += 10;
		break;
	}

	switch (GetDoFType(eAllyPlayer))
	{
	case DOF_TYPE_FRIENDS:
		iScore += 2;
		break;
	case DOF_TYPE_ALLIES:
		iScore += 5;
		break;
	case DOF_TYPE_BATTLE_BROTHERS:
		iScore += 10;
		break;
	}

	// Defensive Pact with ally?
	if (IsHasDefensivePact(eAllyPlayer))
	{
		iScore += 5;
	}

	// Resurrected by ally?
	if (WasResurrectedBy(eAllyPlayer))
	{
		iScore += 5;
	}

	// Coop war score with ally?
	iScore += (GetCoopWarScore(eAllyPlayer) * 3);

	// How do we feel about the target?
	switch (GetMajorCivApproach(eTargetPlayer))
	{
	case MAJOR_CIV_APPROACH_WAR:
		iScore += 1000; // if already planning war, we want allies!
		break;
	case MAJOR_CIV_APPROACH_HOSTILE:
		iScore += 10;
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
	case MAJOR_CIV_APPROACH_GUARDED:
		iScore += 5;
		break;
	case MAJOR_CIV_APPROACH_AFRAID:
		iScore += 2;
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		iScore -= 5;
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		return 0;
		break;
	}

	switch (GetMajorCivOpinion(eTargetPlayer))
	{
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
		iScore += 25;
		break;
	case MAJOR_CIV_OPINION_ENEMY:
		iScore += 10;
		break;
	case MAJOR_CIV_OPINION_COMPETITOR:
		iScore += 5;
		break;
	case MAJOR_CIV_OPINION_NEUTRAL:
		iScore -= 2;
		break;
	case MAJOR_CIV_OPINION_FAVORABLE:
		iScore -= 5;
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		iScore -= 10;
		break;
	case MAJOR_CIV_OPINION_ALLY:
		bBadness = true;
		break;
	}

	switch (GetDoFType(eTargetPlayer))
	{
	case DOF_TYPE_UNTRUSTWORTHY:
		iScore += 5;
		break;
	case DOF_TYPE_NEW:
		iScore += 2;
		break;
	case DOF_TYPE_FRIENDS:
		iScore -= 5;
		break;
	case DOF_TYPE_ALLIES:
		iScore -= 15;
		break;
	case DOF_TYPE_BATTLE_BROTHERS:
		bBadness = true;
		break;
	}

	// Resurrected by target?
	if (WasResurrectedBy(eTargetPlayer) || IsPlayerLiberatedCapital(eTargetPlayer))
		bBadness = true;

	// Coop war score with target?
	iScore -= (GetCoopWarScore(eTargetPlayer) * 3);

	// Coop war already planned against this target with somebody else?
	if (GetGlobalCoopWarAgainstState(eTargetPlayer) >= COOP_WAR_STATE_PREPARING)
	{
		iScore += 1000;
	}

	// Already in another coop war?
	if (GetNumCoopWarTargets() > 0)
		bBadness = true;

	// Proximity to target?
	if (GetPlayer()->CanCrossOcean())
	{
		switch (GetPlayer()->GetProximityToPlayer(eTargetPlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iScore += 5;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iScore += 2;
			break;
		case PLAYER_PROXIMITY_FAR:
			iScore -= 25;
			break;
		case PLAYER_PROXIMITY_DISTANT:
			iScore -= 50;
			break;
		}
	}
	else
	{
		switch (GetPlayer()->GetProximityToPlayer(eTargetPlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iScore += 10;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iScore += 5;
			break;
		case PLAYER_PROXIMITY_FAR:
		case PLAYER_PROXIMITY_DISTANT:
			iScore -= 500;
			break;
		}
	}

	// Ally's proximity to target?
	if (GET_PLAYER(eAllyPlayer).CanCrossOcean())
	{
		switch (GET_PLAYER(eAllyPlayer).GetProximityToPlayer(eTargetPlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iScore += 10;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iScore += 5;
			break;
		case PLAYER_PROXIMITY_FAR:
			iScore -= 25;
			break;
		case PLAYER_PROXIMITY_DISTANT:
			iScore -= 50;
			break;
		}
	}
	else
	{
		switch (GET_PLAYER(eAllyPlayer).GetProximityToPlayer(eTargetPlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iScore += 10;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iScore += 5;
			break;
		case PLAYER_PROXIMITY_FAR:
		case PLAYER_PROXIMITY_DISTANT:
			iScore -= 500;
			break;
		}
	}

	// Competitor?
	if (GetBiggestCompetitor() == eTargetPlayer)
	{
		iScore += 25;
	}
	else if (IsMajorCompetitor(eTargetPlayer) || IsEarlyGameCompetitor(eTargetPlayer))
	{
		iScore += 10;
	}
	else
	{
		iScore -= 10;
	}

	// Natural warmonger?
	if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
	{
		iScore += 10;
	}

	// World Conquest?
	if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
	{
		iScore += (GetBoldness() * 2);
	}

	// Diplomatic Victory?
	if (IsGoingForDiploVictory())
	{
		iScore -= GetDoFWillingness();

		if (IsCloseToDiploVictory())
		{
			iScore -= 25;
		}
	}

	// Endgame aggressive?
	if (IsEndgameAggressiveTo(eTargetPlayer))
	{
		iScore += 25;

		// Doubly so if we're also close to winning
		if (IsCloseToAnyVictoryCondition())
		{
			iScore += 25;
		}
	}

	// Weight for expanding too fast
	if (IsPlayerRecklessExpander(eTargetPlayer))
	{
		iScore += 10;
	}
	// Weight for spamming World Wonders
	if (IsPlayerWonderSpammer(eTargetPlayer))
	{
		iScore += 5;
	}

	// Weight for warmonger threat
	switch (GetWarmongerThreat(eTargetPlayer))
	{
	case THREAT_NONE:
	case THREAT_MINOR:
		iScore -= 2;
		break;
	case THREAT_MAJOR:
		iScore += 2;
		break;
	case THREAT_SEVERE:
		iScore += 5;
		break;
	case THREAT_CRITICAL:
		iScore += 10;
		break;
	}

	// Weight for land dispute
	switch (GetLandDisputeLevel(eTargetPlayer))
	{
	case DISPUTE_LEVEL_NONE:
		iScore -= 5;
		break;
	case DISPUTE_LEVEL_WEAK:
		iScore += 5;
		break;
	case DISPUTE_LEVEL_STRONG:
		iScore += 10;
		break;
	case DISPUTE_LEVEL_FIERCE:
		iScore += 15;
		break;
	}

	// Weight for victory issues
	switch (GetVictoryDisputeLevel(eTargetPlayer))
	{
	case DISPUTE_LEVEL_NONE:
		iScore -= 2;
		break;
	case DISPUTE_LEVEL_WEAK:
		iScore += 2;
		break;
	case DISPUTE_LEVEL_STRONG:
		iScore += 5;
		break;
	case DISPUTE_LEVEL_FIERCE:
		iScore += 10;
		break;
	}

	switch (GetVictoryBlockLevel(eTargetPlayer))
	{
	case BLOCK_LEVEL_NONE:
		iScore -= 2;
		break;
	case BLOCK_LEVEL_WEAK:
		iScore += 2;
		break;
	case BLOCK_LEVEL_STRONG:
		iScore += 5;
		break;
	case BLOCK_LEVEL_FIERCE:
		iScore += 10;
		break;
	}

	bool bWeHaveGoodAttackTarget = GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(eTargetPlayer);
	bool bTheyHaveGoodAttackTarget = GET_PLAYER(eAllyPlayer).isHuman() || GET_PLAYER(eAllyPlayer).GetMilitaryAI()->HavePreferredAttackTarget(eTargetPlayer);

	// Good city attack target?
	if (bWeHaveGoodAttackTarget)
	{
		iScore += 10;
	}
	else
	{
		iScore -= 10;
	}

	StrengthTypes eLowestStrength = GetPlayerMilitaryStrengthComparedToUs(eTargetPlayer);
	bool bStrongerOrEqual = (!IsEasyTarget(eTargetPlayer) && (eLowestStrength >= STRENGTH_AVERAGE));

	if (GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eTargetPlayer) < eLowestStrength)
	{
		eLowestStrength = GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eTargetPlayer);
	}

	if (!bStrongerOrEqual)
	{
		switch (eLowestStrength)
		{
		case STRENGTH_PATHETIC:
			iScore -= 30;
			break;
		case STRENGTH_WEAK:
			iScore -= 20;
			break;
		case STRENGTH_POOR:
			iScore -= 10;
			break;
		}

		if (IsEasyTarget(eTargetPlayer) && bWeHaveGoodAttackTarget)
		{
			iScore -= 15;
		}
	}
	else
	{
		switch (eLowestStrength)
		{
		case STRENGTH_PATHETIC:
			iScore += 20;
			break;
		case STRENGTH_WEAK:
			iScore += 10;
			break;
		case STRENGTH_POOR:
			iScore += 5;
			break;
		case STRENGTH_AVERAGE:
			iScore -= 5;
			break;
		case STRENGTH_STRONG:
			iScore -= 10;
			break;
		case STRENGTH_POWERFUL:
			iScore -= 20;
			break;
		case STRENGTH_IMMENSE:
			iScore -= 30;
			break;
		}

		if (GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsEasyTarget(eTargetPlayer) && bTheyHaveGoodAttackTarget)
		{
			iScore += 15;
		}
	}

	// Are we in danger of getting conquered by the target?
	int iDangerMod = GetPlayerNumMajorsConquered(eTargetPlayer) + GET_PLAYER(eTargetPlayer).GetNumCapitalCities() + GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).GetNumVassals();
	iDangerMod += ((int)GetPlayer()->GetProximityToPlayer(eTargetPlayer) - 3); // -0 for neighbors, -1 for close, -2 for far, -3 for distant
	
	if (iDangerMod > 0)
	{
		// Avoid direct military action if they're stronger than us ... favor other approaches
		iDangerMod -= ((int)GetPlayerMilitaryStrengthComparedToUs(eTargetPlayer) - 3);
		if (IsEasyTarget(eTargetPlayer) && bWeHaveGoodAttackTarget)
		{
			iDangerMod += 2;
		}

		// Factor in our ally's strength as well (prefer stronger allies!)
		iDangerMod -= ((int)GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eTargetPlayer) - 3);
		if (GET_PLAYER(eAllyPlayer).GetDiplomacyAI()->IsEasyTarget(eTargetPlayer) && bTheyHaveGoodAttackTarget)
		{
			iDangerMod += 2;
		}

		// Dangerous player is a neighbor, other player is at least close
		if (GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_NEIGHBORS && GetPlayer()->GetProximityToPlayer(eAllyPlayer) >= PLAYER_PROXIMITY_CLOSE)
		{
			iScore += (5 * iDangerMod);
		}
		// Dangerous player and other player are close, but dangerous player is not a neighbor...yet
		else if (GetPlayer()->GetProximityToPlayer(eTargetPlayer) >= PLAYER_PROXIMITY_CLOSE && GetPlayer()->GetProximityToPlayer(eAllyPlayer) >= PLAYER_PROXIMITY_CLOSE)
		{
			iScore += (4 * iDangerMod);
		}
		// Dangerous player OR other player are close
		else if (GetPlayer()->GetProximityToPlayer(eTargetPlayer) >= PLAYER_PROXIMITY_CLOSE || GetPlayer()->GetProximityToPlayer(eAllyPlayer) >= PLAYER_PROXIMITY_CLOSE)
		{
			if (m_pPlayer->CanCrossOcean() || GET_PLAYER(eAllyPlayer).CanCrossOcean())
				iScore += (2 * iDangerMod);
		}
		// Dangerous player and other player are far
		else if (GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_FAR && GetPlayer()->GetProximityToPlayer(eAllyPlayer) == PLAYER_PROXIMITY_FAR)
		{
			if (m_pPlayer->CanCrossOcean())
				iScore += iDangerMod;
		}
	}

	// Scale weight by target value
	if (IsMajorCompetitor(eTargetPlayer) || IsEarlyGameCompetitor(eTargetPlayer) || (bWeHaveGoodAttackTarget && IsEasyTarget(eTargetPlayer)))
	{
		switch (GetPlayerTargetValue(eTargetPlayer))
		{
		case TARGET_VALUE_IMPOSSIBLE:
			iScore *= 40;
			break;
		case TARGET_VALUE_BAD:
			iScore *= 60;
			break;
		case TARGET_VALUE_AVERAGE:
			iScore *= 100;
			break;
		case TARGET_VALUE_FAVORABLE:
			iScore *= 150;
			break;
		case TARGET_VALUE_SOFT:
			iScore *= 200;
			break;
		}
	}
	else
	{
		switch (GetPlayerTargetValue(eTargetPlayer))
		{
		case TARGET_VALUE_IMPOSSIBLE:
		case TARGET_VALUE_BAD:
			bBadness = true;
			break;
		case TARGET_VALUE_AVERAGE:
			iScore *= 75;
			break;
		case TARGET_VALUE_FAVORABLE:
			iScore *= 125;
			break;
		case TARGET_VALUE_SOFT:
			iScore *= 150;
			break;
		}
	}
	
	// Scale weight by economic value of closest city to us
	CvCity* pClosestCityToUs = GetPlayer()->GetClosestCityToUsByPlots(eTargetPlayer);
	if (pClosestCityToUs != NULL)
	{
		int iHighestEconomicPower = GC.getGame().getHighestEconomicValue();
		int iLocalEconomicPower = pClosestCityToUs->getEconomicValue(eTargetPlayer);

		//cities rated on a 0-100 scale, where 0 = worthless, and 100 = most valuable in the world.
		int iEconomicValue = (iLocalEconomicPower * 100) / max(1, iHighestEconomicPower);
		if (iEconomicValue <= 0)
		{
			iEconomicValue = 1;
		}

		if (pClosestCityToUs->IsOriginalMajorCapital())
		{
			if (IsCloseToDominationVictory())
			{
				iEconomicValue *= 400;
				iEconomicValue /= 100;
			}
			else if (IsGoingForWorldConquest())
			{
				iEconomicValue *= 300;
				iEconomicValue /= 100;
			}
			else
			{
				iEconomicValue *= 200;
				iEconomicValue /= 100;
			}
		}

		iScore *= (iEconomicValue + 50);
		iScore /= 10000;
	}
	else
	{
		return 0;
	}

	if (bBadness && !m_pPlayer->HasAnyOffensiveOperationsAgainstPlayer(eTargetPlayer) && !AvoidExchangesWithPlayer(eTargetPlayer, /*bWarOnly*/ true))
		return 0;

	return iScore;
}

/// Processes this player's response to a coop war request
CoopWarStates CvDiplomacyAI::RespondToCoopWarRequest(PlayerTypes eAskingPlayer, PlayerTypes eTargetPlayer)
{
	CoopWarStates eResponse = COOP_WAR_STATE_REJECTED;
	CoopWarStates eCurrentState = GetCoopWarState(eAskingPlayer, eTargetPlayer);

	// Failsafe
	if (!GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->CanRequestCoopWar(GetID(), eTargetPlayer))
	{
		return COOP_WAR_STATE_REJECTED;
	}

	bool bBold = GetBoldness() > 6 || GetPlayer()->GetPlayerTraits()->IsWarmonger() || (IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION);
	bool bCloseToTarget = GetPlayer()->CanCrossOcean() ? GetPlayer()->GetProximityToPlayer(eTargetPlayer) >= PLAYER_PROXIMITY_CLOSE : GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_NEIGHBORS;

	// Teammates will always agree when a human asks
	if (IsTeammate(eAskingPlayer) || GC.getGame().IsAIMustAcceptHumanDiscussRequests())
	{
		if (bBold && bCloseToTarget && GetPlayerTargetValue(eTargetPlayer) >= TARGET_VALUE_FAVORABLE)
		{
			eResponse = COOP_WAR_STATE_READY;
		}
		else if (bCloseToTarget && IsEasyTarget(eTargetPlayer) && GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(eTargetPlayer))
		{
			eResponse = COOP_WAR_STATE_READY;
		}
		else
		{
			eResponse = COOP_WAR_STATE_PREPARING;
		}
	}
	// Not teammates
	else
	{
		// A coop war is desirable
		if (GetCoopWarDesireScore(eAskingPlayer, eTargetPlayer) >= /*40*/ GC.getCOOP_WAR_DESIRE_THRESHOLD())
		{
			if (bBold && bCloseToTarget && GetPlayerTargetValue(eTargetPlayer) >= TARGET_VALUE_FAVORABLE)
			{
				eResponse = COOP_WAR_STATE_READY;
			}
			else if (bCloseToTarget && IsEasyTarget(eTargetPlayer) && GetPlayer()->GetMilitaryAI()->HavePreferredAttackTarget(eTargetPlayer))
			{
				eResponse = COOP_WAR_STATE_READY;
			}
			else
			{
				eResponse = COOP_WAR_STATE_PREPARING;
			}
		}
		else if (eCurrentState != COOP_WAR_STATE_REJECTED && eCurrentState != COOP_WAR_STATE_WARNED_TARGET && IsCoopWarRequestUnacceptable(eAskingPlayer, eTargetPlayer))
		{
			eResponse = COOP_WAR_STATE_WARNED_TARGET;
		}
	}

	switch (eResponse)
	{
	case COOP_WAR_STATE_READY:
		SetCoopWarState(eAskingPlayer, eTargetPlayer, eResponse);
		GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, eResponse);
		DoStartCoopWar(eAskingPlayer, eTargetPlayer);
		eResponse = COOP_WAR_STATE_ONGOING;
		break;
	case COOP_WAR_STATE_PREPARING:
		SetCoopWarState(eAskingPlayer, eTargetPlayer, eResponse);
		GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eTargetPlayer, eResponse);
		break;
	case COOP_WAR_STATE_WARNED_TARGET:
		SetCoopWarState(eAskingPlayer, eTargetPlayer, eResponse);
		DoWarnCoopWarTarget(eAskingPlayer, eTargetPlayer);
		break;
	default:
		if (eCurrentState != COOP_WAR_STATE_WARNED_TARGET)
		{
			SetCoopWarState(eAskingPlayer, eTargetPlayer, COOP_WAR_STATE_REJECTED);
		}
		break;
	}

	if (eResponse == COOP_WAR_STATE_ONGOING || eResponse == COOP_WAR_STATE_PREPARING)
	{
		// Update approach to WAR
		SetMajorCivApproach(eTargetPlayer, MAJOR_CIV_APPROACH_WAR);

		if (eResponse == COOP_WAR_STATE_ONGOING)
		{
			SetWarGoal(eTargetPlayer, WAR_GOAL_CONQUEST);
		}
		else
		{
			SetWarGoal(eTargetPlayer, WAR_GOAL_PREPARE);
		}

		if (!GET_PLAYER(eAskingPlayer).isHuman())
		{
			// Update their approach to WAR
			GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->SetMajorCivApproach(eAskingPlayer, MAJOR_CIV_APPROACH_WAR);

			if (eResponse == COOP_WAR_STATE_ONGOING)
			{
				GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->SetWarGoal(eTargetPlayer, WAR_GOAL_CONQUEST);
			}
			else
			{
				GET_PLAYER(eAskingPlayer).GetDiplomacyAI()->SetWarGoal(eTargetPlayer, WAR_GOAL_PREPARE);
			}
		}
	}

	return eResponse;
}

/// We rejected eAskingPlayer's request to go to war with eTargetPlayer, but should we warn the target?
bool CvDiplomacyAI::IsCoopWarRequestUnacceptable(PlayerTypes eAskingPlayer, PlayerTypes eTargetPlayer)
{
	// Don't warn humans - no dialogue for this
	if (GET_PLAYER(eTargetPlayer).isHuman())
	{
		return false;
	}

	MajorCivApproachTypes eApproachTowardsAsker = GetMajorCivApproach(eAskingPlayer);
	MajorCivOpinionTypes  eOpinionOfAsker = GetMajorCivOpinion(eAskingPlayer);
	MajorCivApproachTypes eApproachTowardsTarget = GetMajorCivApproach(eTargetPlayer);
	MajorCivOpinionTypes  eOpinionOfTarget = GetMajorCivOpinion(eTargetPlayer);

	// Do we want war against the target?
	if (eApproachTowardsTarget == MAJOR_CIV_APPROACH_WAR || IsArmyInPlaceForAttack(eTargetPlayer) || IsWantsSneakAttack(eTargetPlayer) ||
		GetWarGoal(eTargetPlayer) == WAR_GOAL_PREPARE || GetWarGoal(eTargetPlayer) == WAR_GOAL_DEMAND)
	{
		return false;
	}

	// Backstabbed by the target?
	if (IsPlayerCapturedCapital(eTargetPlayer) || IsPlayerCapturedHolyCity(eTargetPlayer) || IsUntrustworthy(eTargetPlayer) || WasEverBackstabbedBy(eTargetPlayer))
	{
		return false;
	}

	// Do we want war against the asker?
	if (eApproachTowardsAsker == MAJOR_CIV_APPROACH_WAR || IsArmyInPlaceForAttack(eAskingPlayer) || IsWantsSneakAttack(eAskingPlayer) ||
		GetWarGoal(eAskingPlayer) == WAR_GOAL_PREPARE || GetWarGoal(eAskingPlayer) == WAR_GOAL_DEMAND)
	{
		return true;
	}

	// Backstabbed by the asker?
	if (IsPlayerCapturedCapital(eAskingPlayer) || IsPlayerCapturedHolyCity(eAskingPlayer) || IsUntrustworthy(eAskingPlayer))
	{
		return true;
	}

	// We really like the asker?
	if (WasResurrectedBy(eAskingPlayer) || eOpinionOfAsker == MAJOR_CIV_OPINION_ALLY)
	{
		return false;
	}
	else if (eApproachTowardsAsker > MAJOR_CIV_APPROACH_AFRAID && eOpinionOfAsker >= MAJOR_CIV_OPINION_FRIEND)
	{
		if (GetMostValuableFriend() == eAskingPlayer || GetMostValuableAlly() == eAskingPlayer)
		{
			return false;
		}
	}

	// We really like the target?
	if (WasResurrectedBy(eTargetPlayer) || eOpinionOfTarget == MAJOR_CIV_OPINION_ALLY)
	{
		return true;
	}
	else if (eApproachTowardsTarget > MAJOR_CIV_APPROACH_AFRAID && eOpinionOfTarget >= MAJOR_CIV_OPINION_FRIEND)
	{
		if (GetMostValuableFriend() == eTargetPlayer || GetMostValuableAlly() == eTargetPlayer)
		{
			return true;
		}
	}

	// Hate the target or fear the asker?
	if (eApproachTowardsAsker == MAJOR_CIV_APPROACH_AFRAID || eApproachTowardsTarget <= MAJOR_CIV_APPROACH_GUARDED || eOpinionOfTarget <= MAJOR_CIV_OPINION_ENEMY)
	{
		return false;
	}

	// Hate the asker?
	if (eApproachTowardsAsker <= MAJOR_CIV_APPROACH_GUARDED || eOpinionOfAsker <= MAJOR_CIV_OPINION_ENEMY)
	{
		return true;
	}

	// Fiercely competitive with asker?
	if (IsMajorCompetitor(eAskingPlayer))
	{
		return true;
	}

	// Fiercely competitive with target?
	if (IsMajorCompetitor(eTargetPlayer))
	{
		return false;
	}

	// Any flavors that should influence the decision?
	if (GetLoyalty() > 6 && eOpinionOfTarget >= MAJOR_CIV_OPINION_FRIEND)
	{
		return true;
	}
	if (GetDiploBalance() > 7 && eOpinionOfTarget >= MAJOR_CIV_OPINION_FAVORABLE)
	{
		return true;
	}
	
	// Otherwise, warn the target if we like them more than the asker
	if (eOpinionOfTarget > eOpinionOfAsker)
	{
		if (eOpinionOfTarget >= MAJOR_CIV_OPINION_FAVORABLE || eOpinionOfAsker <= MAJOR_CIV_OPINION_COMPETITOR)
		{
			return true;
		}
	}
	
	return false;
}

/// Warn the target of a coop war requested by eAskingPlayer
void CvDiplomacyAI::DoWarnCoopWarTarget(PlayerTypes eAskingPlayer, PlayerTypes eTargetPlayer)
{
	PlayerTypes eMyPlayer = GetID();
	TeamTypes eAskingTeam = GET_PLAYER(eAskingPlayer).getTeam();
	TeamTypes eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != eMyPlayer)
		{
			bool bTargetSide = false;
			bool bAskerSide = false;
			bool bTargetFriend = false;
			bool bAskerFriend = false;
			TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();
			CvDiplomacyAI* pDiplo = GET_PLAYER(eLoopPlayer).GetDiplomacyAI();

			if (eLoopTeam == eTargetTeam || GET_TEAM(eLoopTeam).IsHasDefensivePact(eTargetTeam))
			{
				bTargetSide = true;
			}
			else if (eLoopTeam == eAskingTeam)
			{
				bAskerSide = true;
			}
			else if (pDiplo->IsDoFAccepted(eTargetPlayer))
			{
				if (!pDiplo->WasEverBackstabbedBy(eTargetPlayer) && pDiplo->GetMajorCivApproach(eTargetPlayer) > MAJOR_CIV_APPROACH_AFRAID && pDiplo->GetBiggestCompetitor() != eTargetPlayer)
				{
					bTargetFriend = true;
				}
			}
			else if (pDiplo->IsDoFAccepted(eAskingPlayer) || GET_TEAM(eLoopTeam).IsHasDefensivePact(eAskingTeam))
			{
				if (!pDiplo->WasEverBackstabbedBy(eAskingPlayer) && pDiplo->GetMajorCivApproach(eAskingPlayer) > MAJOR_CIV_APPROACH_AFRAID && pDiplo->GetBiggestCompetitor() != eAskingPlayer)
				{
					bAskerFriend = true;
				}
			}

			if (bTargetSide || bTargetFriend)
			{
				// Target is mad at asker
				if (bTargetSide)
				{
					pDiplo->ChangeNumTimesTheyPlottedAgainstUs(eAskingPlayer, 1);
					pDiplo->ChangeRecentAssistValue(eAskingPlayer, 300);
				}
				else
				{
					pDiplo->ChangeRecentAssistValue(eAskingPlayer, 150);
				}

				// Target is happy with reporter
				pDiplo->ChangeNumTimesIntrigueSharedBy(eMyPlayer, 1);
				int iAssistBonus = 0;

				if (eLoopPlayer == eTargetPlayer)
				{
					iAssistBonus = -300;
				}
				else
				{
					switch (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eAskingPlayer))
					{
					case PLAYER_PROXIMITY_NEIGHBORS:
						iAssistBonus = -150;
						break;
					case PLAYER_PROXIMITY_CLOSE:
						iAssistBonus = -100;
						break;
					case PLAYER_PROXIMITY_FAR:
						iAssistBonus = -50;
						break;
					}

					if (eLoopTeam == eTargetTeam)
					{
						iAssistBonus -= 50;
					}
				}

				pDiplo->ChangeRecentAssistValue(eMyPlayer, iAssistBonus);
			}
			else if (bAskerSide || bAskerFriend)
			{
				// Asker is mad at reporter
				if (bAskerSide)
				{
					pDiplo->ChangeRecentAssistValue(eMyPlayer, 300);
					pDiplo->ChangeCoopWarScore(eMyPlayer, -2);

					//todo: consider denouncing here
				}
				else if (!pDiplo->IsTeammate(eMyPlayer) && !pDiplo->IsDoFAccepted(eMyPlayer) && !pDiplo->IsHasDefensivePact(eMyPlayer))
				{
					int iAssistPenalty = 100 - (GetDifferenceFromAverageFlavorValue(GetForgiveness()) * 10);
					pDiplo->ChangeRecentAssistValue(eMyPlayer, iAssistPenalty);
				}
			}
		}
	}
}

void CvDiplomacyAI::CancelCoopWarsAgainstPlayer(PlayerTypes ePlayer)
{
	for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
	{
		PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
		SetCoopWarState(eThirdParty, ePlayer, NO_COOP_WAR_STATE);
		GET_PLAYER(eThirdParty).GetDiplomacyAI()->SetCoopWarState(GetID(), ePlayer, NO_COOP_WAR_STATE);
	}
}

void CvDiplomacyAI::CancelCoopWarsWithPlayer(PlayerTypes ePlayer, bool bPenalty)
{
	for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
	{
		PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
		CoopWarStates eCoopWarState = GetCoopWarState(ePlayer, eThirdParty);

		if (IsPlayerValid(eThirdParty) && bPenalty)
		{
			if (eCoopWarState == COOP_WAR_STATE_PREPARING || eCoopWarState == COOP_WAR_STATE_READY)
			{
				SetPlayerBrokenCoopWarPromise(ePlayer, true);
				ChangeCoopWarScore(ePlayer, -2);
				ChangeRecentAssistValue(ePlayer, 300);
			}
		}

		SetCoopWarState(eThirdParty, ePlayer, NO_COOP_WAR_STATE);
		GET_PLAYER(eThirdParty).GetDiplomacyAI()->SetCoopWarState(GetID(), ePlayer, NO_COOP_WAR_STATE);
	}
}

void CvDiplomacyAI::CancelAllCoopWars()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
		{
			PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
			SetCoopWarState(eLoopPlayer, eThirdParty, NO_COOP_WAR_STATE);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarState(GetID(), eThirdParty, NO_COOP_WAR_STATE);
		}
	}
}


/////////////////////////////////////////////////////////
// Human Demand
/////////////////////////////////////////////////////////

/// Human made a demand against this AI, handle everything that means
void CvDiplomacyAI::DoDemandMade(PlayerTypes ePlayer, DemandResponseTypes eResponse)
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	// Don't apply further penalties if it's too soon since the last demand
	if (eResponse == DEMAND_RESPONSE_REFUSE_TOO_SOON)
		return;

	// We accepted the demand
	if (eResponse == DEMAND_RESPONSE_ACCEPT)
	{
		ChangeNumDemandEverMade(ePlayer, 1);

		// See how long it'll be before we might agree to another demand
		int iNumTurns = /*20*/ GC.getDEMAND_TURN_LIMIT_MIN();
		iNumTurns += GC.getGame().isReallyNetworkMultiPlayer() ? 5 : GC.getGame().getSmallFakeRandNum(GC.getDEMAND_TURN_LIMIT_RAND(), (int)GetID());
		SetDemandTooSoonNumTurns(ePlayer, iNumTurns);

		if (IsVassal(ePlayer))
		{
			ChangeNumTimesDemandedWhileVassal(ePlayer, 1);
			SetHasPaidTributeTo(ePlayer, true);
		}
	}
	// We refused the demand
	else
	{
		// Prevent exploit wherein the human spams the demand button to reduce AI Opinion - only allow for one penalty unless the demand is accepted
		if (GetNumDemandEverMade(ePlayer) <= 0)
		{
			SetNumDemandEverMade(ePlayer, 1);
		}
		if (IsVassal(ePlayer) && GetNumTimesDemandedWhileVassal(ePlayer) <= 0)
		{
			SetNumTimesDemandedWhileVassal(ePlayer, 1);
		}

		// Do, however, reset the turn counter for the penalty
		SetDemandMadeTurn(ePlayer, GC.getGame().getGameTurn());
	}
}

/////////////////////////////////////////////////////////
// Don't Settle Request
/////////////////////////////////////////////////////////


/// Will this AI agree not to settle near ePlayer?
bool CvDiplomacyAI::IsDontSettleAcceptable(PlayerTypes ePlayer) const
{
	// Debug mode
	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsAIMustAcceptHumanDiscussRequests())
		return true;
	
	// Always acceptable if they resurrected or liberated us
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
		return true;
	
	// If we control 33%+ of other players' original capitals, don't make a promise unless we like them
	if (GetPlayer()->GetFractionOriginalCapitalsUnderControl() >= 33)
	{
		if (GetMajorCivApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY || GetMajorCivOpinion(ePlayer) < MAJOR_CIV_OPINION_FRIEND)
		{
			if (!IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer) && GetCoopWarScore(ePlayer) <= 0)
			{
				return false;
			}
		}
	}
	
	// Refuse all promises if close to world conquest and they still have their original capital
	if (IsCloseToDominationVictory() && GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
		return false;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

	// If player is afraid, always say yes
	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// If player is Hostile or planning War, always say no
	if (eApproach <= MAJOR_CIV_APPROACH_HOSTILE)
		return false;
	
	// If player is a backstabber, always say no
	if (IsUntrustworthy(ePlayer))
		return false;
	
	// If player is an enemy or unforgivable, always say no
	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	// If player is plotting against us, always say no
	if (GetNumTimesTheyPlottedAgainstUs(ePlayer) > 0)
		return false;

	// If they've broken or ignored an expansion promise, always say no
	if (IsPlayerIgnoredExpansionPromise(ePlayer) || IsPlayerBrokenExpansionPromise(ePlayer))
		return false;

	// Acceptable if we're friends
	if ((IsDoFAccepted(ePlayer) && !IsWantsToEndDoFWithPlayer(ePlayer)) || (IsHasDefensivePact(ePlayer) && !IsWantsToEndDefensivePactWithPlayer(ePlayer)))
		return true;
	else if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES || GetMostValuableFriend() == ePlayer || GetMostValuableAlly() == ePlayer || GetCoopWarScore(ePlayer) > 0 || GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
			return true;
	}

	// If we're fiercely competitive, always say no
	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG || GetBiggestCompetitor() == ePlayer || GetPrimeLeagueCompetitor() == ePlayer || IsEndgameAggressiveTo(ePlayer))
		return false;

	// If the player has deleted the EXPANSION Flavor we have to account for that
	int iExpansionFlavor = /*5*/ GC.getGame().GetDefaultFlavorValue();

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")
		{
			iExpansionFlavor = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
			break;
		}
	}

	// Default threshold
	// EX: 8 - 10 Expansion = -2 * 5 = -10%
	// EX: 8 - 7 Expansion = 1 * 5 = 5%
	// EX: 8 - 5 Expansion = 3 * 5 = 15%
	// EX: 8 - 2 Expansion = 6 * 5 = 30%
	int iThreshold = (/*8*/ GC.getDONT_SETTLE_FLAVOR_BASE() - iExpansionFlavor) * /*5*/ GC.getDONT_SETTLE_FLAVOR_MULTIPLIER();

	bool bFriendly = eApproach == MAJOR_CIV_APPROACH_FRIENDLY;

	// If player is Friendly, add weight
	if(bFriendly)
		iThreshold += /*30*/ GC.getDONT_SETTLE_FRIENDLY();

	int iMilitaryMod = 0;

	// Military Strength compared to us
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		if(!bFriendly)
			iMilitaryMod += /*-30*/ GC.getDONT_SETTLE_STRENGTH_PATHETIC();
		break;
	case STRENGTH_WEAK:
		if(!bFriendly)
			iMilitaryMod += /*-20*/ GC.getDONT_SETTLE_STRENGTH_WEAK();
		break;
	case STRENGTH_POOR:
		if(!bFriendly)
			iMilitaryMod += /*-10*/ GC.getDONT_SETTLE_STRENGTH_POOR();
		break;
	case STRENGTH_AVERAGE:
		iMilitaryMod += /*0*/ GC.getDONT_SETTLE_STRENGTH_AVERAGE();
		break;
	case STRENGTH_STRONG:
		iMilitaryMod += /*25*/ GC.getDONT_SETTLE_STRENGTH_STRONG();
		break;
	case STRENGTH_POWERFUL:
		iMilitaryMod += /*40*/ GC.getDONT_SETTLE_STRENGTH_POWERFUL();
		break;
	case STRENGTH_IMMENSE:
		iMilitaryMod += /*60*/ GC.getDONT_SETTLE_STRENGTH_IMMENSE();
		break;
	}

	// Military Aggressive Posture - MULTIPLIER
	switch(GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		iMilitaryMod *= /*100*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_NONE();
		break;
	case AGGRESSIVE_POSTURE_LOW:
		iMilitaryMod *= /*100*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_LOW();
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		iMilitaryMod *= /*150*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_MEDIUM();
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		iMilitaryMod *= /*200*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_HIGH();
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		iMilitaryMod *= /*300*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_INCREDIBLE();
		break;
	}

	// Bring it out of hundreds
	iMilitaryMod /= 100;

	iThreshold += iMilitaryMod;

	//Base it on boldness.
	int iRand = (GetBoldness() * 10);

	// Passes the test?
	if(iRand < iThreshold)
		return true;

	return false;
}

/////////////////////////////////////////////////////////
// Stop Spying Request
/////////////////////////////////////////////////////////

/// Will this AI agree to stop spying on ePlayer?
bool CvDiplomacyAI::IsStopSpyingAcceptable(PlayerTypes ePlayer) const
{
	// Debug mode
	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsAIMustAcceptHumanDiscussRequests())
		return true;
	
	// Always acceptable if they resurrected or liberated us
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
		return true;
	
	// If we control 33%+ of other players' original capitals, don't make a promise unless we like them
	if (GetPlayer()->GetFractionOriginalCapitalsUnderControl() >= 33)
	{
		if (GetMajorCivApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY || GetMajorCivOpinion(ePlayer) < MAJOR_CIV_OPINION_FRIEND)
		{
			if (!IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer) && GetCoopWarScore(ePlayer) <= 0)
			{
				return false;
			}
		}
	}
	
	// Refuse all promises if close to world conquest and they still have their original capital
	if (IsCloseToDominationVictory() && GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
		return false;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

	// If player is Afraid, always say yes
	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// If player is Guarded, Hostile or planning War, always say no
	if (eApproach == MAJOR_CIV_APPROACH_GUARDED || eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_WAR)
		return false;
	
	// If player has used spies offensively against us, always say no
	if (GetNumTimesRobbedBy(ePlayer) > 0 || GetNumTimesPerformedCoupAgainstUs(ePlayer) > 0)
		return false;
	
	// If player is plotting against us, always say no
	if (GetNumTimesTheyPlottedAgainstUs(ePlayer) > 0)
		return false;
	
	// If player has broken or ignored a spying promise, always say no
	if (IsPlayerIgnoredSpyPromise(ePlayer) || IsPlayerBrokenSpyPromise(ePlayer))
		return false;

	// If player is an Enemy or Unforgivable, always say no
	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	// If player is a backstabber, always say no
	if (IsUntrustworthy(ePlayer))
		return false;

	// Acceptable if we're friends
	if ((IsDoFAccepted(ePlayer) && !IsWantsToEndDoFWithPlayer(ePlayer)) || (IsHasDefensivePact(ePlayer) && !IsWantsToEndDefensivePactWithPlayer(ePlayer)))
		return true;
	else if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES || GetMostValuableFriend() == ePlayer || GetMostValuableAlly() == ePlayer || GetCoopWarScore(ePlayer) > 0 || GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
			return true;
	}

	// If we're fiercely competitive, always say no
	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG || GetBiggestCompetitor() == ePlayer || GetPrimeLeagueCompetitor() == ePlayer || IsEndgameAggressiveTo(ePlayer))
		return false;

	return true;
}


///////////////////////////////
// Working With Player
///////////////////////////////



/// Is this AI willing to work with ePlayer?
bool CvDiplomacyAI::IsDoFAcceptable(PlayerTypes ePlayer)
{
	if (IsAtWar(ePlayer))
		return false;

	// We'll agree to a DoF if we're afraid of them and they're not a backstabber, but we won't ask for one unless we want one
	if (GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_AFRAID && !IsUntrustworthy(ePlayer))
		return true;

	// Not if they broke a DoF this turn...
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->HasEndedFriendshipThisTurn())
		return false;

	if (IsWantsDoFWithPlayer(ePlayer))
		return true;

	return false;
}

/// Do we want to end our friendship with ePlayer early?
bool CvDiplomacyAI::IsEndDoFAcceptable(PlayerTypes ePlayer, bool bIgnoreCurrentDoF)
{
	if (!bIgnoreCurrentDoF && !IsDoFAccepted(ePlayer))
		return false;

	if (IsUntrustworthy(ePlayer))
		return true;

	// We're planning war and not willing to backstab!
	if (AvoidExchangesWithPlayer(ePlayer) && (bIgnoreCurrentDoF || !IsWarSane(ePlayer)))
		return true;

	// Don't end friendships we just made.
	if (!bIgnoreCurrentDoF && GetTurnsSinceBefriendedPlayer(ePlayer) <= 15)
		return false;

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
	if (eApproach == MAJOR_CIV_APPROACH_AFRAID || eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
		return false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	if (eOpinion >= MAJOR_CIV_OPINION_FRIEND)
		return false;

	if (eOpinion <= MAJOR_CIV_OPINION_ENEMY)
		return true;

	// If we got this far and there's reason to end our friendship with a vassal or our master, then do so.
	if (IsVassal(ePlayer) || GET_PLAYER(ePlayer).IsVassalOfSomeone())
		return true;

	int iChance = 10 + GetLoyalty();

	// Liberator?
	if (WasResurrectedBy(ePlayer))
	{
		iChance += 20;
	}
	if (IsPlayerLiberatedCapital(ePlayer))
	{
		iChance += 10;
	}
	if (IsPlayerLiberatedHolyCity(ePlayer))
	{
		iChance += 5;
	}
	if (IsPlayerReturnedCapital(ePlayer))
	{
		iChance += 5;
	}
	if (IsPlayerReturnedHolyCity(ePlayer))
	{
		iChance += 3;
	}

	iChance += GetNumCitiesLiberatedBy(ePlayer) * 2;

	// Ongoing coop war?
	if (GetGlobalCoopWarWithState(ePlayer) >= COOP_WAR_STATE_PREPARING)
	{
		iChance += 5;
	}

	// Warmonger?
	if (GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
	{
		iChance -= GetWarmongerHate();
	}

	// Broken/ignored promises? Each one adds negative weight.
	bool bBold = GetBoldness() > 7;
	bBold |= IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DOMINATION;
	bBold |= GetPlayer()->GetPlayerTraits()->IsWarmonger();

	PromiseStates ePromiseState = GetPlayerExpansionPromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bBold ? 10 : 5;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bBold ? 10 : 2;
	}

	ePromiseState = GetPlayerBorderPromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bBold ? 10 : 5;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bBold ? 10 : 2;
	}

	bool bDiplomatic = IsDiplomat();
	bDiplomatic |= IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC;
	bDiplomatic |= GetPlayer()->GetPlayerTraits()->IsDiplomat();

	ePromiseState = GetPlayerBullyCityStatePromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bDiplomatic ? 10 : 5;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bDiplomatic ? 5 : 2;
	}

	ePromiseState = GetPlayerAttackCityStatePromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		return true;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bDiplomatic ? 10 : 5;
	}

	bool bScientific = IsScientist();
	bScientific |= IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_SCIENCE;
	bScientific |= GetPlayer()->GetPlayerTraits()->IsNerd();

	ePromiseState = GetPlayerSpyPromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bScientific ? 20 : 10;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bScientific ? 10 : 5;
	}

	int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));
	bool bReligious = iFlavorReligion > 6;
	bReligious |= GetPlayer()->GetPlayerTraits()->IsReligious();

	ePromiseState = GetPlayerNoConvertPromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bReligious ? 20 : 10;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bReligious ? 10 : 5;
	}

	int iFlavorCulture = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));
	bool bCultural = iFlavorCulture > 6;
	bCultural |= IsCultural();
	bCultural |= IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_CULTURE;
	bCultural = GetPlayer()->GetPlayerTraits()->IsTourism();

	ePromiseState = GetPlayerNoDiggingPromiseState(ePlayer);
	if (ePromiseState == PROMISE_STATE_BROKEN)
	{
		iChance -= bCultural ? 20 : 10;
	}
	else if (ePromiseState == PROMISE_STATE_IGNORED)
	{
		iChance -= bCultural ? 10 : 5;
	}

	// Disputes?
	if (IsCompetingForVictory())
	{
		if (IsEndgameAggressiveTo(ePlayer))
		{
			iChance -= GetVictoryCompetitiveness();
		}
		if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			iChance -= GetVictoryCompetitiveness();
		}
		if (GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		{
			iChance -= GetVictoryCompetitiveness();
		}
	}

	if (GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iChance -= GetBoldness();
	}
	if (GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iChance -= GetWonderCompetitiveness();
	}
	if (GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iChance -= GetMinorCivCompetitiveness();
	}

	if (WasEverBackstabbedBy(ePlayer))
	{
		iChance -= 10;
	}

	// Less likely to break things off if we've been friends for a while.
	switch (GetDoFType(ePlayer))
	{
	case DOF_TYPE_FRIENDS:
		iChance += 2;
		break;
	case DOF_TYPE_ALLIES:
		iChance += 5;
		break;
	case DOF_TYPE_BATTLE_BROTHERS:
		iChance += 10;
		break;
	}

	iChance += GetCoopWarScore(ePlayer);

	if (iChance <= 0)
		return true;

	return false;
}

/// AI won't agree to a DoF until they've known a player for at least a few turns
bool CvDiplomacyAI::IsTooEarlyForDoF(PlayerTypes ePlayer)
{
	int iDoFBuffer = /*50*/ GC.getDOF_TURN_BUFFER();
	int iEra = GetPlayer()->GetCurrentEra();

	if (iEra > 0)
	{
		iDoFBuffer += min(0, (iEra * /*-5*/ GC.getDOF_TURN_BUFFER_REDUCTION_PER_ERA()));
	}

	if (iDoFBuffer < /*10*/ GC.getJUST_MET_TURN_BUFFER())
	{
		iDoFBuffer = GC.getJUST_MET_TURN_BUFFER();
	}

	if (GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < iDoFBuffer)
		return true;

	return false;
}

/// How many Research Agreements do we currently have with other players?
int CvDiplomacyAI::GetNumRA()
{
	int iRtnValue = 0;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && IsHasResearchAgreement(eLoopPlayer))
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

/// How many Defensive Pacts do we currently have with other players?
int CvDiplomacyAI::GetNumDefensePacts()
{
	int iRtnValue = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer) && IsHasDefensivePact(eLoopPlayer))
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

/// Do we have similar or divergent Social Policies?
int CvDiplomacyAI::GetNumSamePolicies(PlayerTypes ePlayer)
{
	int iNumSame = 0;
	int iNumDifferent = 0;
	int iNumWeHave = 0;
	int iNumTheyHave = 0;

	for (int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyBranchInfos(); iPolicyLoop++)
	{
		PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes)iPolicyLoop;
		if (ePolicyBranch != NO_POLICY_BRANCH_TYPE)
		{
			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);
			if (pkPolicyBranchInfo == NULL)
			{
				continue;
			}
			//No ideologies.
			if (pkPolicyBranchInfo->IsPurchaseByLevel())
			{
				continue;
			}

			//We have it and they don't?
			if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && !GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumDifferent++;
				iNumWeHave++;
			}
			//They have it and we don't?
			else if (!GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumDifferent++;
				iNumTheyHave++;
			}
			//We both have it?
			else if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumSame++;
				iNumWeHave++;
				iNumTheyHave++;
			}
		}
	}

	// If one of us has only one branch unlocked and the other has none, count it as 0.
	if (iNumWeHave == 1 && iNumTheyHave == 0)
	{
		return 0;
	}
	else if (iNumTheyHave == 1 && iNumWeHave == 0)
	{
		return 0;
	}

	return (iNumSame - iNumDifferent);
}

/// Are we done with ePlayer, and now want to Denounce him?
bool CvDiplomacyAI::IsDenounceFriendAcceptable(PlayerTypes ePlayer)
{
	// We have to be really treacherous to consider doing this, otherwise we'll just break up our friendships.
	if (!IsBackstabber() && !IsUntrustworthy(ePlayer) && !WasEverBackstabbedBy(ePlayer) && GetMeanness() < 8 && GetDenounceWillingness() < 9 && GetLoyalty() > 3)
		return false;

	if (IsMaster(ePlayer) || GetPlayer()->IsVassalOfSomeone())
		return false;

	if (GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		return false;

	// We've been on more than one coop war together?
	if (GetCoopWarScore(ePlayer) > 1)
		return false;

	// Liberator?
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
		return false;

	// Don't sabotage our teammates' friendships...
	vector<PlayerTypes> vOurTeam = GET_TEAM(GetTeam()).getPlayers();
	for (size_t i=0; i<vOurTeam.size(); i++)
	{
		if (!IsPlayerValid(vOurTeam[i], true))
			continue;

		if (GET_PLAYER(vOurTeam[i]).GetID() == GetID())
			continue;

		if (GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->IsDoFAccepted(ePlayer))
		{
			if (GET_PLAYER(vOurTeam[i]).isHuman())
				return false;

			if (!GET_PLAYER(vOurTeam[i]).GetDiplomacyAI()->IsWantsToEndDoFWithPlayer(ePlayer))
				return false;
		}
	}

	if (IsUntrustworthy(ePlayer))
		return true;

	// Avoid denouncing friends if we're going for diplo victory!
	if (!WasEverBackstabbedBy(ePlayer) && IsCompetingForVictory() && GetVictoryFocus() == VICTORY_FOCUS_DIPLOMATIC)
		return false;

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
	if (eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return false;

	if (eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return true;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	if (eOpinion <= MAJOR_CIV_OPINION_ENEMY)
		return true;

	if (eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
		return false;

	int iChance = 10 + GetLoyalty();

	if (eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
	{
		iChance -= GetDiploBalance();
	}

	if (GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
	{
		iChance -= GetWarmongerHate();
	}

	if (IsCompetingForVictory())
	{
		if (IsEndgameAggressiveTo(ePlayer))
		{
			iChance -= GetVictoryCompetitiveness();
		}

		if (GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		{
			iChance -= GetVictoryCompetitiveness();
		}

		if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			iChance -= GetVictoryCompetitiveness();
		}

		// Going for conquest, and they're weak and close
		if (GetVictoryFocus() == VICTORY_FOCUS_DOMINATION && GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE)
		{
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_POOR && GetPlayerTargetValue(ePlayer) >= TARGET_VALUE_AVERAGE && GetMilitaryThreat(ePlayer) <= THREAT_MAJOR)
			{
				iChance -= GetMeanness();
			}
		}
	}

	if (WasEverBackstabbedBy(ePlayer))
	{
		iChance -= 10;
	}

	if (GetDoFType(ePlayer) == DOF_TYPE_ALLIES)
	{
		iChance += 5;
	}
	else if (GetDoFType(ePlayer) == DOF_TYPE_FRIENDS)
	{
		iChance += 2;
	}

	if (GetCoopWarScore(ePlayer) == 1)
	{
		iChance += 2;
	}
	else if (GetCoopWarScore(ePlayer) < 0)
	{
		iChance += GetCoopWarScore(ePlayer);
	}

	if (IsPlayerReturnedCapital(ePlayer))
	{
		iChance += 10;
	}
	if (IsPlayerReturnedHolyCity(ePlayer))
	{
		iChance += 5;
	}

	iChance += GetNumCitiesLiberatedBy(ePlayer) * 3;

	if (iChance <= 0)
		return true;

	return false;
}

/// Does ePlayer have a DoF with anyone we have a DoF with?
bool CvDiplomacyAI::IsPlayerDoFWithAnyFriend(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
			continue;

		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (IsDoFAccepted(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
			return true;
	}

	return false;
}

/// Does ePlayer have a DoF with any of our enemies?
bool CvDiplomacyAI::IsPlayerDoFWithAnyEnemy(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
			continue;

		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
		{
			if (IsDenouncedPlayer(eLoopPlayer) || IsAtWar(eLoopPlayer))
				return true;
		}
	}

	return false;
}

/// Does ePlayer have a Defensive Pact with anyone we also have a DP with?
bool CvDiplomacyAI::IsPlayerDPWithAnyFriend(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (IsHasDefensivePact(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer))
			return true;
	}
	
	return false;
}

/// Does ePlayer have a Defensive Pact with any of our enemies?
bool CvDiplomacyAI::IsPlayerDPWithAnyEnemy(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;
		
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer))
		{
			if (IsDenouncedPlayer(eLoopPlayer) || IsAtWar(eLoopPlayer))
				return true;
		}
	}
	
	return false;
}

///////////////////////////////
// Religion
///////////////////////////////

/// Does ePlayer have similar religious beliefs as we do?
bool CvDiplomacyAI::IsPlayerSameReligion(PlayerTypes ePlayer) const
{
	ReligionTypes eOurReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false) != NO_RELIGION ? GetPlayer()->GetReligions()->GetCurrentReligion(false) : GetPlayer()->GetReligions()->GetReligionInMostCities();
	ReligionTypes eTheirReligion = (GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) != NO_RELIGION && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false), ePlayer)) ? GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) : GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();

	if (eOurReligion == NO_RELIGION || eTheirReligion == NO_RELIGION)
		return false;
	
	if (eOurReligion == eTheirReligion)
		return true;
	
	return false;
}

/// Does ePlayer have a religion that opposes ours?
bool CvDiplomacyAI::IsPlayerOpposingReligion(PlayerTypes ePlayer) const
{
	ReligionTypes eOurReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false) != NO_RELIGION ? GetPlayer()->GetReligions()->GetCurrentReligion(false) : GetPlayer()->GetReligions()->GetReligionInMostCities();
	ReligionTypes eTheirReligion = (GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) != NO_RELIGION && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false), ePlayer)) ? GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) : GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();

	if (eOurReligion == NO_RELIGION || eTheirReligion == NO_RELIGION)
		return false;
	
	if (eOurReligion != eTheirReligion)
		return true;
	
	return false;
}

///////////////////////////////
// Ideology
///////////////////////////////

/// Does ePlayer have the same ideology that we do?
bool CvDiplomacyAI::IsPlayerSameIdeology(PlayerTypes ePlayer) const
{
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();

	if (eMyBranch == NO_POLICY_BRANCH_TYPE || eTheirBranch == NO_POLICY_BRANCH_TYPE)
		return false;

	if (eMyBranch == eTheirBranch)
		return true;
	
	return false;
}

/// Does ePlayer have an ideology that opposes ours?
bool CvDiplomacyAI::IsPlayerOpposingIdeology(PlayerTypes ePlayer) const
{
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();

	if (eMyBranch == NO_POLICY_BRANCH_TYPE || eTheirBranch == NO_POLICY_BRANCH_TYPE)
		return false;

	if (eMyBranch != eTheirBranch)
		return true;
	
	return false;
}


///////////////////////////////
// Denounce Player
///////////////////////////////

/// Denounces a player
void CvDiplomacyAI::DoDenouncePlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PlayerTypes eMyPlayer = GetID();
	TeamTypes eMyTeam = GetTeam();
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();

	SetDenouncedPlayer(ePlayer, true);

	// close both embassies
	GET_TEAM(eMyTeam).CloseEmbassyAtTeam(eTheirTeam);
	GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(eMyTeam);
	
	// End all coop war agreements with this player
	GET_PLAYER(ePlayer).GetDiplomacyAI()->CancelCoopWarsWithPlayer(eMyPlayer, true);

	bool bBackstabTimer = (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFBroken(eMyPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetTurnsSinceDoFBroken(eMyPlayer) < /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER());

	// WAS working with this player
	if (IsDoFAccepted(ePlayer) || bBackstabTimer)
	{
		SetDoFAccepted(ePlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);

		SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetID(), DOF_TYPE_UNTRUSTWORTHY);

		// They now view us as a traitor!
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetFriendDenouncedUs(eMyPlayer, true);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);

		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFBroken(eMyPlayer, true, true);

		GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(ePlayer).getTeam(), false);
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);
	}
	
	// Update opinions and approaches
	vector<PlayerTypes> v;
	v.push_back(GetID());
	DoReevaluatePlayers(v);
	
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer) > MAJOR_CIV_APPROACH_GUARDED)
	{
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMajorCivApproach(eMyPlayer, MAJOR_CIV_APPROACH_GUARDED);
	}

	vector<PlayerTypes> v2;
	v2.push_back(ePlayer);
	DoReevaluatePlayers(v2);
	
	// Other players' reactions
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (IsPlayerValid(eLoopPlayer, true) && !GET_PLAYER(eLoopPlayer).isHuman() && eLoopPlayer != ePlayer && eLoopPlayer != eMyPlayer)
		{
			// Our teammates
			if (IsTeammate(eLoopPlayer))
			{
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(ePlayer))
				{
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -300);
				}
			}
			else if (GET_PLAYER(eLoopPlayer).getTeam() != GET_PLAYER(ePlayer).getTeam())
			{
				// Player might apply a diplo bonus if they don't hate us
				if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && !IsDenouncedPlayer(eLoopPlayer) &&
					!GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eMyPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(eMyPlayer) &&
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(eMyPlayer) != MAJOR_CIV_OPINION_UNFORGIVABLE)
				{
					// Large diplo bonus for denouncing a backstabber
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsUntrustworthy(ePlayer))
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -150);
					}
					// Bonus for denouncing a player they're at war with
					else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -75);
						
						// Extra bonus if they're doing badly in the war
						if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarState(ePlayer) == WAR_STATE_DEFENSIVE)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -35);
						}
						else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -75);
						}
					}
					// Bonus for denouncing a player who denounced them
					else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, -75);
					}
					// Penalty for denouncing a friend, DP or ally
					else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(ePlayer) || 
							GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) ||
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
					{
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 75);
					}						
				}
				// Penalty for denouncing a friend, DP or ally (they hate us)
				else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(ePlayer) || 
						GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) ||
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
				{
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 150);
				}
			}
			// Their teammates
			else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsTeammate(ePlayer))
			{
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
			}
		}
	}
		

	Localization::String someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE");
#if defined(MOD_BALANCE_CORE)
	int iMessage = GetDenounceMessage(ePlayer);
	if (iMessage > 0 && iMessage <= 7)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_IDEOLOGY");
	}
	else if(iMessage == 8)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_WARMONGER");
	}
	else if(iMessage == 9)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_MINORS");
	}
	else if(iMessage == 10)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_MINORS");
	}
	else if(iMessage == 11)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_NUKED");
	}
	else if(iMessage == 12)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_SPIES");
	}
	else if(iMessage == 13)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_LAND");
	}
	else if(iMessage == 14)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DOF");
	}
	else if(iMessage == 15)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DOGPILE");
	}
	else if(iMessage == 16)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_UNTRUSTWORTHY");
	}
	else if(iMessage == 17)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_UNFORGIVEABLE");
	}
	else if(iMessage == 18)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_FAITH");
	}
	else if(iMessage == 19)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DIGGING");
	}
	else if(iMessage == 20)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_WONDERS");
	}
	else if(iMessage == 21)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_VICTORY");
	}
	else if(iMessage == 22)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_VICTORY");
	}
	else
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE");
	}
#endif
	Localization::String someoneDenounceSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_S");
	Localization::String youDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_DENOUNCE");
	Localization::String youDenounceSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_DENOUNCE_S");
	Localization::String denounceYouInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_YOU");
	Localization::String denounceYouSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCED_YOU_S");
	for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
		PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
		CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
		CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
		if(pNotifications)
		{
			const char* strThisPlayerName;
			const char* strOtherPlayerName;

			CvTeam* pNotifyTeam = &GET_TEAM(kCurPlayer.getTeam());

			bool bFromMe = GetTeam() == kCurPlayer.getTeam();
			bool bAtMe = GET_PLAYER(ePlayer).getTeam() == kCurPlayer.getTeam();

			// Have we met these guys yet?
			if(!bFromMe)
			{
				if(pNotifyTeam->isHasMet(GetTeam()) || kCurPlayer.isObserver())
					strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
				else
					strThisPlayerName = "TXT_KEY_UNMET_PLAYER";
			}

			if(!bAtMe)
			{
				if(pNotifyTeam->isHasMet(GET_PLAYER(ePlayer).getTeam()) || kCurPlayer.isObserver())
					strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
				else
					strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";
			}

			Localization::String strText;
			Localization::String strSummary;

			if(bFromMe)
			{
				strText = youDenounceInfo;
				strText << strOtherPlayerName;
				strSummary = youDenounceSummary;
				strSummary << strOtherPlayerName;
			}
			else if(bAtMe)
			{
				strText = denounceYouInfo;
				strText << strThisPlayerName;
				strSummary = denounceYouSummary;
				strSummary << strThisPlayerName;
			}
			else
			{
				bool bHasMetThisTeam = pNotifyTeam->isHasMet(GetTeam()) || kCurPlayer.isObserver();
				bool bHasMetOtherTeam = pNotifyTeam->isHasMet(GET_PLAYER(ePlayer).getTeam()) || kCurPlayer.isObserver();

				//Only display notification if we've met both teams.
				if (bHasMetThisTeam && bHasMetOtherTeam)
				{
					strText = someoneDenounceInfo;
					strText << strThisPlayerName << strOtherPlayerName;
					strSummary = someoneDenounceSummary;
					strSummary << strThisPlayerName << strOtherPlayerName;
				}
				else
				{
					continue;
				}
			}

			pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText.toUTF8(), strSummary.toUTF8(), -1, -1, GetID(), ePlayer);
		}
	}
}

/// Does this player feel it's time to denounce ePlayer?
bool CvDiplomacyAI::IsDenounceAcceptable(PlayerTypes ePlayer, bool bBias)
{
	// Can't denounce if always at war
	if (IsAlwaysAtWar(ePlayer))
		return false;

	// Don't denounce if we're at war and want peace
	if (IsAtWar(ePlayer))
	{
		if (GetWarGoal(ePlayer) == WAR_GOAL_PEACE)
			return false;

		if (IsWantsPeaceWithPlayer(ePlayer))
			return false;
	}

	// If we've already denounced, it's no good
	if (IsDenouncedPlayer(ePlayer))
		return false;

	// If we're friends, return false - this is handled in IsDenounceFriendAcceptable
	if (IsDoFAccepted(ePlayer))
		return false;

	// Don't denounce players we've just met.
	if (GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < 10)
		return false;

	// If we ended a DoF recently and the 10-turn timer is in effect, let's wait it out.
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFBroken(GetID()) && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetTurnsSinceDoFBroken(GetID()) < /*10*/ GC.getDOF_BROKEN_BACKSTAB_TIMER())
		return false;

	int iWeight = GetDenounceWeight(ePlayer, bBias);

	if (iWeight > 25)
		return true;

	return false;
}

/// Returns the weight this AI has for denouncing ePlayer
int CvDiplomacyAI::GetDenounceWeight(PlayerTypes ePlayer, bool bBias)
{
	int iWeight = 0;

	// Base Personality value; ranges from 1 to 10
	iWeight += GetDenounceWillingness();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Vassal treatment view
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// This guy is our vassal - never denounce!
		if (IsMaster(ePlayer))
		{
			return 0;
		}
		// This guy is our master
		else if (IsVassal(ePlayer))
		{
			// Voluntary vassals have a huge weight against denouncing
			if (IsVoluntaryVassalage(ePlayer))
			{
				iWeight -= 50;
			}

			switch (GetVassalTreatmentLevel(ePlayer))
			{
			// Content vassals have a huge weight against denouncing
			case VASSAL_TREATMENT_CONTENT:
				iWeight -= 50;
				break;
			// Disagree? Let's not upset things...
			case VASSAL_TREATMENT_DISAGREE:
				iWeight -= 15;
				break;
			// Mistreated: Small bonus
			case VASSAL_TREATMENT_MISTREATED:
				iWeight += 2;
				break;
			// Unhappy: Medium bonus
			case VASSAL_TREATMENT_UNHAPPY:
				iWeight += 5;
				break;
			// Enslaved: Big bonus
			case VASSAL_TREATMENT_ENSLAVED:
				iWeight += 10;
				break;
			}
		}
		// If this guy is a vassal of someone else, reduce the weight to make us less likely to denounce them
		else if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
		{
			iWeight -= 8;
		}
	}
#endif

	switch (GetMajorCivApproach(ePlayer))
	{
	// Hostile: Bonus
	case MAJOR_CIV_APPROACH_HOSTILE:
		iWeight += 6;
		break;
	// Afraid: Penalty
	case MAJOR_CIV_APPROACH_AFRAID:
		iWeight -= 10;
		break;
	// Let's not upset things
	case MAJOR_CIV_APPROACH_NEUTRAL:
		iWeight -= 8;
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		iWeight -= 15;
		break;
	// Slight bump if guarded
	case MAJOR_CIV_APPROACH_GUARDED:
		iWeight++;
		break;
	// Do NOT reveal if deceptive
	case MAJOR_CIV_APPROACH_DECEPTIVE:
		iWeight -= 25;
		break;
	// War - depends on surface approach
	case MAJOR_CIV_APPROACH_WAR:
		if (IsAtWar(ePlayer))
		{
			iWeight += 8;
		}
		else
		{
			switch (GetSurfaceApproach(ePlayer))
			{
			// Higher bump than true HOSTILE
			case MAJOR_CIV_APPROACH_HOSTILE:
				iWeight += 8;
				break;
			// Slightly higher bump than true GUARDED
			case MAJOR_CIV_APPROACH_GUARDED:
				iWeight += 2;
				break;
			// Avoid upsetting things, but lower weight than true NEUTRAL
			case MAJOR_CIV_APPROACH_NEUTRAL:
				iWeight -= 4;
				break;
			// Do NOT reveal if pretending to be FRIENDLY
			case MAJOR_CIV_APPROACH_FRIENDLY:
				iWeight -= 25;
				break;
			}
		}
		break;
	}

	switch (GetMajorCivOpinion(ePlayer))
	{
	// Unforgivable: Big Bonus
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
		iWeight += 10;
		break;
	// Enemy: Bonus
	case MAJOR_CIV_OPINION_ENEMY:
		iWeight += 5;
		break;
	// Competitor: Small Bonus
	case MAJOR_CIV_OPINION_COMPETITOR:
		iWeight += 2;
		break;
	// Let's not upset things
	case MAJOR_CIV_OPINION_NEUTRAL:
		iWeight -= 2;
		break;
	// Good Relations: Penalty
	case MAJOR_CIV_OPINION_FAVORABLE:
		iWeight -= 10;
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		iWeight -= 25;
		break;
	case MAJOR_CIV_OPINION_ALLY:
		iWeight -= 50;
		break;
	}

	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iWeight += 4;
	}
	if (GetVictoryBlockLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iWeight += 4;
	}
	if (GetLandDisputeLevel(ePlayer) == DISPUTE_LEVEL_STRONG)
	{
		iWeight += 2;
	}
	else if (GetLandDisputeLevel(ePlayer) == DISPUTE_LEVEL_FIERCE)
	{
		iWeight += 5;
	}
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts() > 0)
	{
		iWeight -= (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts()*2);
	}
	if (GetBiggestCompetitor() == ePlayer)
	{
		iWeight += 10;
	}
	else if (IsMajorCompetitor(ePlayer))
	{
		iWeight += 2;
	}

	// Backstabber: Huge bonus!
	if (IsUntrustworthy(ePlayer))
	{
		iWeight += 25;
	}
	// Close to victory: Bonus based on difficulty level
	if (IsEndgameAggressiveTo(ePlayer))
	{
		iWeight += (GC.getGame().getHandicapInfo().getAIDeclareWarProb() / 20);
	}

	// Resurrected us: Huge penalty!
	if (WasResurrectedBy(ePlayer))
	{
		iWeight -= 25;
	}
	// Defensive Pact: Big penalty
	if (IsHasDefensivePact(ePlayer))
	{
		iWeight -= 10;
	}
	// Liberated our capital: Big penalty
	if (IsPlayerLiberatedCapital(ePlayer))
	{
		iWeight -= 10;
	}
	// Liberated cities: Penalty
	if (GetNumCitiesLiberatedBy(ePlayer) > 0)
	{
		iWeight -= 5;
	}
	// Resurrected them: Penalty
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetID()))
	{
		iWeight -= 5;
	}

	// Look for other players we like or are strong, and modify our willingness to denounce based on this
	PlayerTypes eThirdParty;
	CvDiplomacyAI* pThirdPartyDiplo;
	for (int iThirdParty = 0; iThirdParty < MAX_MAJOR_CIVS; iThirdParty++)
	{
		eThirdParty = (PlayerTypes) iThirdParty;
		pThirdPartyDiplo = GET_PLAYER(eThirdParty).GetDiplomacyAI();

		// Third party has strong positive or negative relations with this player
		if (pThirdPartyDiplo->IsDoFAccepted(ePlayer) || pThirdPartyDiplo->IsHasDefensivePact(ePlayer) || pThirdPartyDiplo->IsTeammate(ePlayer) ||
			pThirdPartyDiplo->IsDenouncedPlayer(ePlayer) || pThirdPartyDiplo->IsAtWar(ePlayer))
		{
			// Teammate?
			if (IsTeammate(eThirdParty))
			{
				// Big bonus to denouncing a non-friend if a teammate denounced them
				if (pThirdPartyDiplo->IsDenouncedPlayer(ePlayer))
				{
					iWeight += 10;
				}
				// Never denounce our teammates' friends or DPs
				else
				{
					return 0;
				}
			}
	
			// Ignore if we hate the third party
			if (GetMajorCivOpinion(eThirdParty) <= MAJOR_CIV_OPINION_ENEMY)
				continue;
			if (GetMajorCivApproach(eThirdParty) <= MAJOR_CIV_APPROACH_HOSTILE)
				continue;
			if (IsUntrustworthy(eThirdParty))
				continue;

			// Third party is close to victory? Don't be a pawn.
			if (IsEndgameAggressiveTo(ePlayer))
				continue;

			int iMod = 0;

			// We're close to this guy who's at war - want to gain favor
			if (GetPlayer()->GetProximityToPlayer(eThirdParty) == PLAYER_PROXIMITY_NEIGHBORS)
				iMod++;

			// Do we like this guy?
			iMod += (GetMajorCivOpinion(eThirdParty) - MAJOR_CIV_OPINION_NEUTRAL); // Ex: if opinion is Ally, this will add 3 to the weight; if Competitor, will subtract 1

			// Are they strong?
			if (GetPlayerMilitaryStrengthComparedToUs(eThirdParty) > STRENGTH_AVERAGE)
				iMod += (GetPlayerMilitaryStrengthComparedToUs(eThirdParty) - STRENGTH_AVERAGE); // Ex: if they're immense, this will add 3 to the weight

			// Are we friends with them?
			if (IsDoFAccepted(eThirdParty))
				iMod += 4;

			// Do we have a DP with them?
			if (IsHasDefensivePact(eThirdParty))
				iMod += 2;

			if (pThirdPartyDiplo->IsDenouncedPlayer(ePlayer) || pThirdPartyDiplo->IsAtWar(ePlayer))
			{
				iWeight += iMod;
			}
			else
			{
				iWeight -= iMod;
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	// Are there any quests that should influence our decision? Ignore if we're already close to a non-domination victory, we shouldn't be making additional enemies over City-States.
	if (!IsCloseToSSVictory() && !IsCloseToCultureVictory() && !IsCloseToDiploVictory())
	{
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
			if (IsPlayerValid(eMinor) && GET_PLAYER(eMinor).isMinorCiv() && !IsAtWar(eMinor) && GetMinorCivApproach(eMinor) != MINOR_CIV_APPROACH_BULLY && GetMinorCivApproach(eMinor) != MINOR_CIV_APPROACH_CONQUEST)
			{
				CvPlayer* pMinor = &GET_PLAYER(eMinor);
				CvMinorCivAI* pMinorCivAI = pMinor->GetMinorCivAI();
				if (pMinor && pMinorCivAI)
				{
					if (pMinorCivAI->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_DENOUNCE_MAJOR) && pMinorCivAI->GetQuestData1(GetID(), MINOR_CIV_QUEST_DENOUNCE_MAJOR) == ePlayer)
					{
						iWeight += 2;

						if (IsGoingForDiploVictory() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
							iWeight += 3;
						else if (IsDiplomat())
							iWeight += 2;
					}
				}
			}
		}
	}
#endif

	// Used when friends are asking us to denounce someone
	if (bBias)
		iWeight += 3;

	return iWeight;
}

/// Has this player denounced someone we have a DoF with?
bool CvDiplomacyAI::IsPlayerDenouncedFriend(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
			continue;

		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (IsDoFAccepted(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
			return true;
	}

	return false;
}

/// Has this player denounced someone we've also denounced?
bool CvDiplomacyAI::IsPlayerDenouncedEnemy(PlayerTypes ePlayer) const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GetPlayer()->isHuman() && GET_PLAYER(eLoopPlayer).isHuman())
			continue;
		
		if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv())
			continue;

		if (IsDenouncedPlayer(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
			return true;
	}

	return false;
}



///////////////////////////////
// Requests of Friends
///////////////////////////////


/// Does this AI want to request that ePlayer denounce someone?
PlayerTypes CvDiplomacyAI::GetRequestFriendToDenounce(PlayerTypes ePlayer, bool& bRandFailed)
{
	bRandFailed = false;

	// Must be friends with ePlayer
	if(!IsDoFAccepted(ePlayer))
		return NO_PLAYER;

	PlayerTypes eTarget = NO_PLAYER;
	int iBestWeight = -1;

	CvDiplomacyAI* pTheirAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
	CvTeam* pTheirTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pLoopPlayer = &GET_PLAYER(eLoopPlayer);
		TeamTypes eLoopTeam = pLoopPlayer->getTeam();

		// Must be alive
		if(!pLoopPlayer->isAlive())
			continue;

		// Can't be either of us
		if(eLoopPlayer == GetID() || eLoopPlayer == ePlayer)
			continue;

		// Don't pick someone they haven't met
		if(!pTheirTeam->isHasMet(eLoopTeam))
			continue;

		// Don't pick someone they're at war with
		if(pTheirTeam->isAtWar(eLoopTeam))
			continue;

		// Don't pick someone they've already denounced
		if(pTheirAI->IsDenouncedPlayer(eLoopPlayer))
			continue;

		// Only look at players we've denounced, or at war with
		if(!IsAtWar(eLoopPlayer) && !IsDenouncedPlayer(eLoopPlayer))
			continue;

		// Rand roll
		int iWeight = GetDenounceWeight(ePlayer, /*bBias*/ false);

		iWeight += GetNeediness();		// Generally ranges from 3 to 7

		if(iWeight >= 23 && iWeight > iBestWeight)
		{
			iBestWeight = iWeight;

			eTarget = eLoopPlayer;
			bRandFailed = false;		// Set this here as well, because we could have failed a roll on another player, and then succeeded on a later one
		}
		else
			bRandFailed = true;
	}

	return eTarget;
}

/// Are we upset that our friend ePlayer refused our request to denounce eAgainstPlayer?
bool CvDiplomacyAI::IsFriendDenounceRefusalUnacceptable(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer)
{
	ePlayer;
	eAgainstPlayer;

	// Rand roll
	int iDesire = GetDenounceWeight(eAgainstPlayer, /*bBias*/ false);
	iDesire += GetNeediness();		// Generally ranges from 3 to 7
	iDesire -= GetForgiveness();	// Generally ranges from 3 to 7

	if(iDesire >= 23)	//  Note: 23 is required to even ask (see function above this one)
		return true;

	return false;
}


/////////////////////////////////////////////////////////
// A Player's adherence to this AI's statements
/////////////////////////////////////////////////////////


/// Will this AI agree to stop sending missionaries and prophets to ePlayer's cities?
bool CvDiplomacyAI::IsStopSpreadingReligionAcceptable(PlayerTypes ePlayer)
{
	// Debug mode
	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsAIMustAcceptHumanDiscussRequests())
		return true;

	// Always acceptable for teammates
	if (IsTeammate(ePlayer))
		return true;
	
	// Always acceptable if they resurrected or liberated us
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
		return true;

	// Must accept if they're our master
	if (IsVassal(ePlayer))
		return true;
	
	// If we control 33%+ of other players' original capitals, don't make a promise unless we like them
	if (GetPlayer()->GetFractionOriginalCapitalsUnderControl() >= 33)
	{
		if (GetMajorCivApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY || GetMajorCivOpinion(ePlayer) < MAJOR_CIV_OPINION_FRIEND)
		{
			if (!IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer) && GetCoopWarScore(ePlayer) <= 0)
			{
				return false;
			}
		}
	}
	
	// Refuse all promises if close to world conquest and they still have their original capital
	if (IsCloseToDominationVictory() && GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
		return false;

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

	// If player is Afraid, always say yes
	if (eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;
	
	// If player is Hostile or planning War, always say no
	if (eApproach <= MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	// If player is plotting against us, always say no
	if (GetNumTimesTheyPlottedAgainstUs(ePlayer) > 0)
		return false;
	
	// Never acceptable if they've converted our cities (unless a promise was made, and not broken)
	if (HasEverConvertedCity(ePlayer) && !IsPlayerMadeNoConvertPromise(ePlayer))
		return false;
	
	if (IsPlayerBrokenNoConvertPromise(ePlayer) || IsPlayerIgnoredNoConvertPromise(ePlayer))
		return false;
	
	// Never acceptable if they're an Enemy or Unforgivable
	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return false;
	
	// Backstabber? Never acceptable.
	if (IsUntrustworthy(ePlayer))
		return false;

	// Acceptable if we're friends
	if ((IsDoFAccepted(ePlayer) && !IsWantsToEndDoFWithPlayer(ePlayer)) || (IsHasDefensivePact(ePlayer) && !IsWantsToEndDefensivePactWithPlayer(ePlayer)))
		return true;
	else if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES || GetMostValuableFriend() == ePlayer || GetMostValuableAlly() == ePlayer || GetCoopWarScore(ePlayer) > 0 || GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
			return true;
	}

	// If we're fiercely competitive, always say no
	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG || GetBiggestCompetitor() == ePlayer || GetPrimeLeagueCompetitor() == ePlayer || IsEndgameAggressiveTo(ePlayer))
		return false;
	
	int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));

	if (iFlavorReligion > 4 && GetPlayer()->GetPlayerTraits()->IsReligious())
	{
		return false;
	}

	if (iFlavorReligion < 7)
	{
		return true;
	}

	return false;
}

/// Will this AI agree to stop digging up ePlayer's artifacts?
bool CvDiplomacyAI::IsStopDiggingAcceptable(PlayerTypes ePlayer) const
{
	// Debug mode
	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsAIMustAcceptHumanDiscussRequests())
		return true;
	
	// Always acceptable if they resurrected or liberated us
	if (WasResurrectedBy(ePlayer) || IsPlayerLiberatedCapital(ePlayer) || IsPlayerLiberatedHolyCity(ePlayer))
		return true;
	
	// If we control 33%+ of other players' original capitals, don't make a promise unless we like them
	if (GetPlayer()->GetFractionOriginalCapitalsUnderControl() >= 33)
	{
		if (GetMajorCivApproach(ePlayer) != MAJOR_CIV_APPROACH_FRIENDLY || GetMajorCivOpinion(ePlayer) < MAJOR_CIV_OPINION_FRIEND)
		{
			if (!IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer) && GetCoopWarScore(ePlayer) <= 0)
			{
				return false;
			}
		}
	}
	
	// Refuse all promises if close to world conquest and they still have their original capital
	if (IsCloseToDominationVictory() && GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
		return false;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
	
	// If player is Afraid, always say yes
	if (eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;
	
	// If player is Hostile or planning War, always say no
	if (eApproach <= MAJOR_CIV_APPROACH_HOSTILE)
		return false;
	
	// Never acceptable if they've dug up our artifacts (unless a promise was made, and not broken)
	if (GetNumArtifactsEverDugUp(ePlayer) > 0 && !IsPlayerMadeNoDiggingPromise(ePlayer))
		return false;
	
	if (IsPlayerBrokenNoDiggingPromise(ePlayer) || IsPlayerIgnoredNoDiggingPromise(ePlayer))
		return false;
	
	// Never acceptable if they're an Enemy or Unforgivable
	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	// If player is plotting against us, always say no
	if (GetNumTimesTheyPlottedAgainstUs(ePlayer) > 0)
		return false;
	
	// Backstabber? Never acceptable.
	if (IsUntrustworthy(ePlayer))
		return false;

	// Acceptable if we're friends
	if ((IsDoFAccepted(ePlayer) && !IsWantsToEndDoFWithPlayer(ePlayer)) || (IsHasDefensivePact(ePlayer) && !IsWantsToEndDefensivePactWithPlayer(ePlayer)))
		return true;
	else if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES || GetMostValuableFriend() == ePlayer || GetMostValuableAlly() == ePlayer || GetCoopWarScore(ePlayer) > 0 || GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
			return true;
	}

	// If we're fiercely competitive, always say no
	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG || GetBiggestCompetitor() == ePlayer || GetPrimeLeagueCompetitor() == ePlayer || IsEndgameAggressiveTo(ePlayer))
		return false;
	
	// Going for or close to culture victory?
	if (IsGoingForCultureVictory() || IsCloseToCultureVictory())
		return false;
	
	int iFlavorCulture = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));

	if (iFlavorCulture > 4 && GetPlayer()->GetPlayerTraits()->IsTourism())
	{
		return false;
	}
	
	if (iFlavorCulture < 7)
	{
		return true;
	}

	return false;
}

/////////////////////////////////////////////////////////
// Opinion modifiers
/////////////////////////////////////////////////////////

/// Adjusts the duration of a temporary opinion modifier based on flavors and game speed
int CvDiplomacyAI::AdjustModifierDuration(bool bGood, int iDuration, int iFlavorValue, bool bGamespeed)
{
	if (iDuration <= 0)
		return 0;

	int iTurns = iDuration;
	int iTurnMod = 0;

	if (iFlavorValue != 0)
	{
		iTurnMod = iFlavorValue - 5;
	}
	else
	{
		if (bGood)
		{
			iTurnMod = (GetLoyalty() > GetDoFWillingness()) ? (GetLoyalty() - 5) : (GetDoFWillingness() - 5);
		}
		else
		{
			iTurnMod = (GetMeanness() > GetForgiveness()) ? (GetMeanness() - 5) : (-GetForgiveness() + 5);
		}
	}

	if (iTurns < 50)
	{
		iTurns += iTurnMod;
	}
	else if (iTurns == 50)
	{
		iTurns += (iTurnMod * 2);
	}
	else if (iTurns > 50)
	{
		iTurns += (iTurnMod * 3);
	}

	if (bGamespeed)
	{
		iTurns *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iTurns /= 100;
	}

	return max(1, iTurns);
}

/// Adjusts the value of a temporary opinion modifier based on modifier type and how many turns have passed
int CvDiplomacyAI::AdjustModifierValue(int iValue, int iDuration, int iTurn, ModifierTypes eModifierType, int iStacks, int iFirstStackValue)
{
	// Some error checking in case a bad value gets in
	if (iValue == 0)
		return 0;

	if (iTurn < 0)
		return iValue;

	if (iDuration <= 0)
		return iValue;

	if (eModifierType < 0 || eModifierType > NUM_MODIFIER_TYPES)
		return iValue;

	if (eModifierType == MODIFIER_TYPE_DIMINISHING)
	{
		if (iValue == iFirstStackValue)
		{
			if (iStacks > 1)
			{
				return iValue;
			}
		}
		else if (iValue > 0)
		{
			if (iFirstStackValue < 0 || iFirstStackValue > iValue)
			{
				return iValue;
			}
		}
		else
		{
			if (iFirstStackValue > 0 || iFirstStackValue < iValue)
			{
				return iValue;
			}
		}
	}

	int iTurnsPassed = GC.getGame().getGameTurn() - iTurn;
	int iDurationPercent = iTurnsPassed * 100 / iDuration;
	int iPercentageLeft = 100 - iDurationPercent;
	bool bGood = iValue < 0;

	if (iTurnsPassed <= 0)
		return iValue;

	if (iTurnsPassed >= iDuration)
		return 0;

	if (iPercentageLeft <= 0)
		return 0;

	if (eModifierType == MODIFIER_TYPE_NORMAL) // just the modifier
	{
		if (bGood)
			return min(-1, (iValue * iPercentageLeft / 100));
		else
			return max(1, (iValue * iPercentageLeft / 100));
	}

	if (eModifierType == MODIFIER_TYPE_STACKED || iFirstStackValue == 0) // modifier value * # of occurrences
	{
		if (iStacks <= 1)
		{
			if (bGood)
				return min(-1, (iValue * iPercentageLeft / 100));
			else
				return max(1, (iValue * iPercentageLeft / 100));
		}

		int iValuePerStack = iValue / iStacks; // # of stacks
		int iStacksToReduceTo = iStacks / 2; // # of stacks after the next reduction
		int iValueToReduceTo = iStacksToReduceTo * iValuePerStack; // after the next reduction

		int iDifference = iValue - iValueToReduceTo;
		int iAmountToReduceBy = iDifference * iDurationPercent / 100;

		if (bGood)
			return min(-1, (iValue - iAmountToReduceBy));
		else
			return max(1, (iValue - iAmountToReduceBy));
	}

	if (eModifierType == MODIFIER_TYPE_DIMINISHING) // modifier value increases with # of occurrences, but subsequent worth less than first
	{
		if (iStacks <= 1)
		{
			if (bGood)
				return min(-1, (iValue * iPercentageLeft / 100));
			else
				return max(1, (iValue * iPercentageLeft / 100));
		}

		int iRemainingValue = iValue - iFirstStackValue;
		int iRemainingStacks = iStacks - 1;
		int iStacksToReduceTo = iStacks / 2;

		if (iRemainingStacks == 1 || iStacksToReduceTo == 1)
		{
			int iAmountToReduceBy = iRemainingValue * iDurationPercent / 100;

			if (bGood)
				return min(-1, (iValue - iAmountToReduceBy));
			else
				return max(1, (iValue - iAmountToReduceBy));
		}

		// If we got here, iRemainingStacks > 1 and iStacksToReduceTo > 1
		int iValuePerStack = iRemainingValue / iRemainingStacks;
		int iValueToReduceTo = iStacksToReduceTo - 1;
		iValueToReduceTo *= iValuePerStack;
		iValueToReduceTo += iFirstStackValue;

		int iDifference = iValue - iValueToReduceTo;
		int iAmountToReduceBy = iDifference * iDurationPercent / 100;

		if (bGood)
			return min(-1, (iValue - iAmountToReduceBy));
		else
			return max(1, (iValue - iAmountToReduceBy));
	}

	return iValue;
}

/// Clear any expired opinion modifiers prior to updating Opinion for the turn
void CvDiplomacyAI::DoTestOpinionModifiers()
{
	int iTurn = GC.getGame().getGameTurn();
	int iTurnDifference;
	int iDuration;
	int iStacks;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		// Civilians returned?
		iStacks = GetNumCiviliansReturnedToMe(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetCiviliansReturnedToMeTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, 50);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumCiviliansReturnedToMe(ePlayer, iStacks);
			}
		}

		// Landmarks built?
		iStacks = GetNumLandmarksBuiltForMe(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetLandmarksBuiltForMeTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, 50);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumLandmarksBuiltForMe(ePlayer, iStacks);
			}
		}

		// Cities liberated?
		iStacks = GetNumCitiesLiberatedBy(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetLiberatedCitiesTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, 75);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumCitiesLiberatedBy(ePlayer, iStacks);
			}
		}

		// Forgave for spying?
		if (IsPlayerForgaveForSpying(ePlayer))
		{
			iTurnDifference = iTurn - GetForgaveForSpyingTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, 30);

			if (iTurnDifference >= iDuration)
			{
				SetPlayerForgaveForSpying(ePlayer, false);
			}
		}

		// Trade demands?
		iStacks = GetNumDemandEverMade(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetDemandMadeTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, 50);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumDemandEverMade(ePlayer, iStacks);
			}

			if (IsVassal(ePlayer))
			{
				iStacks = GetNumTimesDemandedWhileVassal(ePlayer);
				if (iTurnDifference >= iDuration)
				{
					iStacks /= 2;
					SetNumTimesDemandedWhileVassal(ePlayer, iStacks);
				}
			}
		}

		// Converted our cities?
		iStacks = GetNegativeReligiousConversionPoints(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetReligiousConversionTurn(ePlayer);
			int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));
			iDuration = AdjustModifierDuration(false, 50, iFlavorReligion);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNegativeReligiousConversionPoints(ePlayer, iStacks);
			}
		}

		// Robbed us?
		iStacks = GetNumTimesRobbedBy(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetRobbedTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, 50);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumTimesRobbedBy(ePlayer, iStacks);
			}
		}

		// Plundered our trade routes?
		iStacks = GetNumTradeRoutesPlundered(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetPlunderedTradeRouteTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, 25);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumTradeRoutesPlundered(ePlayer, iStacks);
			}
		}

		// Plotted against us?
		iStacks = GetNumTimesTheyPlottedAgainstUs(ePlayer);
		if (iStacks > 0)
		{
			// Scale modifier duration based on military strength
			int iDurationMod = (int)GetPlayerMilitaryStrengthComparedToUs(ePlayer); // between 0 and 7, inclusive
			iDurationMod += ((int)GET_PLAYER(ePlayer).GetProximityToPlayer(GetID()) * 2); // between 0 and 6, inclusive
			iDurationMod *= 2;

			iTurnDifference = iTurn - GetPlottedAgainstUsTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, 19, iDurationMod, false); // returns between 14 and 40 turns, inclusive, not scaling with gamespeed

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumTimesTheyPlottedAgainstUs(ePlayer, iStacks);
			}
		}

		// Stole our City-State allies?
		iStacks = GetNumTimesPerformedCoupAgainstUs(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetPerformedCoupTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, 50, GetMinorCivCompetitiveness());

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumTimesPerformedCoupAgainstUs(ePlayer, iStacks);
			}
		}

		// Shared intrigue with us?
		iStacks = GetNumTimesIntrigueSharedBy(ePlayer);
		if (iStacks > 0)
		{
			iTurnDifference = iTurn - GetIntrigueSharedTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, 50);

			if (iTurnDifference >= iDuration)
			{
				iStacks /= 2;
				SetNumTimesIntrigueSharedBy(ePlayer, iStacks);
			}
		}

		// Sided with their protected minor?
		if (GetOtherPlayerSidedWithProtectedMinorTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetOtherPlayerSidedWithProtectedMinorTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, /*10*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FORGIVEN());

			if (iTurnDifference >= iDuration)
			{
				SetOtherPlayerSidedWithProtectedMinorTurn(ePlayer, -1);
			}
		}

		// Attacked our protected minor?
		if (GetOtherPlayerAttackedProtectedMinorTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetOtherPlayerAttackedProtectedMinorTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, /*30*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN(), GetPersonalityMinorCivApproachBias(MINOR_CIV_APPROACH_PROTECTIVE));

			if (iTurnDifference >= iDuration)
			{
				SetOtherPlayerProtectedMinorAttacked(ePlayer, NO_PLAYER);
				SetOtherPlayerAttackedProtectedMinorTurn(ePlayer, -1);
			}
		}

		// Killed our protected minor?
		if (GetOtherPlayerKilledProtectedMinorTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetOtherPlayerKilledProtectedMinorTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, /*50*/ GC.getOPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN(), GetPersonalityMinorCivApproachBias(MINOR_CIV_APPROACH_PROTECTIVE));

			if (iTurnDifference >= iDuration)
			{
				SetOtherPlayerProtectedMinorKilled(ePlayer, NO_PLAYER);
				SetOtherPlayerKilledProtectedMinorTurn(ePlayer, -1);
			}
		}

		// Liked their WC proposal?
		if (GetWeLikedTheirProposalTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetWeLikedTheirProposalTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			if (iTurnDifference >= iDuration)
			{
				SetWeLikedTheirProposalTurn(ePlayer, -1);
				SetLikedTheirProposalValue(ePlayer, 0);
			}
		}

		// Disliked their WC proposal?
		if (GetWeDislikedTheirProposalTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetWeDislikedTheirProposalTurn(ePlayer);
			iDuration = AdjustModifierDuration(false, /*50*/ GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			if (iTurnDifference >= iDuration)
			{
				SetWeDislikedTheirProposalTurn(ePlayer, -1);
				SetLikedTheirProposalValue(ePlayer, 0);
			}
		}

		int iSupportValue = GetSupportedOurProposalValue(ePlayer);

		// They foiled our proposals! 
		if (iSupportValue > 0)
		{
			int iProposalTurn;
			iDuration = AdjustModifierDuration(false, /*50*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			if (IsFoiledOurProposalAndThenSupportedUs(ePlayer))
			{
				iProposalTurn = GetTheySupportedOurProposalTurn(ePlayer);

				// The more recent action should carry higher value if Forgiveness is higher
				int iDurationMod = (GetForgiveness() - 5) * 2;
				iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
				iDurationMod /= 100;
				if (iDurationMod > 0)
				{
					iDuration -= iDurationMod;
				}
			}
			else
			{
				iProposalTurn = GetTheyFoiledOurProposalTurn(ePlayer);
			}

			iTurnDifference = iTurn - iProposalTurn;

			if (iTurnDifference >= iDuration)
			{
				SetTheySupportedOurProposalTurn(ePlayer, -1);
				SetTheyFoiledOurProposalTurn(ePlayer, -1);
				SetSupportedOurProposalValue(ePlayer, 0);
			}
		}
		// They supported our proposals!
		else if (iSupportValue < 0)
		{
			int iProposalTurn;
			iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

			if (IsSupportedOurProposalAndThenFoiledUs(ePlayer))
			{
				iProposalTurn = GetTheyFoiledOurProposalTurn(ePlayer);

				// The more recent action should carry higher value if Boldness is higher
				int iDurationMod = (GetBoldness() - 5) * 2;
				iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
				iDurationMod /= 100;
				if (iDurationMod > 0)
				{
					iDuration -= iDurationMod;
				}
			}
			else
			{
				iProposalTurn = GetTheySupportedOurProposalTurn(ePlayer);
			}

			iTurnDifference = iTurn - iProposalTurn;

			if (iTurnDifference >= iDuration)
			{
				SetTheySupportedOurProposalTurn(ePlayer, -1);
				SetTheyFoiledOurProposalTurn(ePlayer, -1);
				SetSupportedOurProposalValue(ePlayer, 0);
			}
		}

		// Supported our hosting?
		if (GetTheySupportedOurHostingTurn(ePlayer) > -1)
		{
			iTurnDifference = iTurn - GetTheySupportedOurHostingTurn(ePlayer);
			iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS(), GetDiploBalance());

			if (iTurnDifference >= iDuration)
			{
				SetTheySupportedOurHostingTurn(ePlayer, -1);
			}
		}
	}
}

int CvDiplomacyAI::GetBaseOpinionScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// Modder bonus/penalty to opinion
	if (GET_PLAYER(ePlayer).isHuman())
	{
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_BASE_HUMAN();

		// Bonus or penalty from difficulty level?
		if (MOD_BALANCE_CORE_DIFFICULTY)
		{
			iOpinionWeight += GET_PLAYER(ePlayer).getHandicapInfo().getAttitudeChange();
		}
	}
	else
	{
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_BASE_AI();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLandDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	switch (GetLandDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_LAND_FIERCE();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*25*/ GC.getOPINION_WEIGHT_LAND_STRONG();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_LAND_WEAK();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_LAND_NONE();
		break;
	}
	
	// AI will care more about land if they're a warmonger or it's the early game.
	if (iOpinionWeight > 0)
	{
		if (IsConqueror())
		{
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_LAND_WARMONGER();
		}
		if (GetPlayer()->GetCurrentEra() == 0)
		{
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_LAND_ANCIENT_ERA();
		}
		else if (GetPlayer()->GetCurrentEra() == 1)
		{
			iOpinionWeight += /*5*/ GC.getOPINION_WEIGHT_LAND_CLASSICAL_ERA();
		}
	}
	else if (iOpinionWeight < 0)
	{
		if (IsConqueror())
		{
			iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_LAND_NONE_WARMONGER();
		}
		if (GetPlayer()->GetCurrentEra() <= 1)
		{
			iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_LAND_NONE_EARLY_GAME();
		}
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetWonderDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	switch (GetWonderDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_WONDER_FIERCE();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_WONDER_STRONG();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_WONDER_WEAK();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_WONDER_NONE();
		break;
	}

	if (IsCultural())
	{
		if (iOpinionWeight > 0)
		{
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_WONDER_CULTURAL();
		}
		else if (!IsPlayerWonderSpammer(ePlayer))
		{
			iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_WONDER_NONE_CULTURAL();
		}
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetMinorCivDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	if (GetPlayer()->HasMetValidMinorCiv())
	{
		switch (GetMinorCivDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_MINOR_CIV_FIERCE();
			break;
		case DISPUTE_LEVEL_STRONG:
			iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_MINOR_CIV_STRONG();
			break;
		case DISPUTE_LEVEL_WEAK:
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_MINOR_CIV_WEAK();
			break;
		case DISPUTE_LEVEL_NONE:
			iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_MINOR_CIV_NONE();
			break;
		}

		if (IsDiplomat())
		{
			if (iOpinionWeight > 0)
			{
				iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_MINOR_CIV_DIPLOMAT();
			}
			else if (!IsMinorCivTroublemaker(ePlayer, true))
			{
				iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_MINOR_CIV_NONE_DIPLOMAT();
			}
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTechBlockLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (!IsScientist())
		return 0;
	
	switch (GetTechBlockLevel(ePlayer))
	{
	case BLOCK_LEVEL_FIERCE:
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_TECH_FIERCE();
		break;
	case BLOCK_LEVEL_STRONG:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_TECH_STRONG();
		break;
	case BLOCK_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_TECH_WEAK();
		break;
	case BLOCK_LEVEL_NONE:
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_TECH_NONE();
		break;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetPolicyBlockLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (!IsCultural())
		return 0;
	
	switch (GetPolicyBlockLevel(ePlayer))
	{
	case BLOCK_LEVEL_FIERCE:
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_POLICY_FIERCE();
		break;
	case BLOCK_LEVEL_STRONG:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_POLICY_STRONG();
		break;
	case BLOCK_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_POLICY_WEAK();
		break;
	case BLOCK_LEVEL_NONE:
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_POLICY_NONE();
		break;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetVictoryDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	switch (GetVictoryDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_VICTORY_FIERCE();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*3*/ GC.getOPINION_WEIGHT_VICTORY_PER_ERA());
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_VICTORY_STRONG();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*3*/ GC.getOPINION_WEIGHT_VICTORY_PER_ERA());
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_VICTORY_WEAK();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*3*/ GC.getOPINION_WEIGHT_VICTORY_PER_ERA());
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight = /*0*/ GC.getOPINION_WEIGHT_VICTORY_NONE();
		break;
	}

	iOpinionWeight *= GetVictoryCompetitiveness();
	iOpinionWeight /= 5;

	if (IsEndgameAggressiveTo(ePlayer))
	{
		iOpinionWeight *= GC.getGame().getHandicapInfo().getAIDeclareWarProb();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVictoryBlockLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	switch (GetVictoryBlockLevel(ePlayer))
	{
	case BLOCK_LEVEL_FIERCE:
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_FIERCE();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*4*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_PER_ERA());
		break;
	case BLOCK_LEVEL_STRONG:
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_STRONG();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*4*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_PER_ERA());
		break;
	case BLOCK_LEVEL_WEAK:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_WEAK();
		iOpinionWeight += (GET_PLAYER(ePlayer).GetCurrentEra() * /*4*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_PER_ERA());
		break;
	case BLOCK_LEVEL_NONE:
		iOpinionWeight = /*0*/ GC.getOPINION_WEIGHT_VICTORY_BLOCK_NONE();
		break;
	}

	iOpinionWeight *= GetVictoryCompetitiveness();
	iOpinionWeight /= 10;

	if (IsEndgameAggressiveTo(ePlayer))
	{
		iOpinionWeight *= GC.getGame().getHandicapInfo().getAIDeclareWarProb();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetWarmongerThreatScore(PlayerTypes ePlayer)
{
	if (IsAlwaysAtWar(ePlayer))
		return 0;

	return GetOtherPlayerWarmongerScore(ePlayer);
}

int CvDiplomacyAI::GetCiviliansReturnedToMeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumCivs = GetNumCiviliansReturnedToMe(ePlayer);

	if (iNumCivs > 0)
	{
		// Full credit for first one
		iOpinionWeight = /*-10*/ GC.getOPINION_WEIGHT_RETURNED_CIVILIAN();
		
		// Partial credit for any after first
		if (iNumCivs > 1)
		{
			iOpinionWeight += ((GC.getOPINION_WEIGHT_RETURNED_CIVILIAN() / 2) * (iNumCivs - 1));
		}

		int iDuration = AdjustModifierDuration(true, 50);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetCiviliansReturnedToMeTurn(ePlayer), MODIFIER_TYPE_DIMINISHING, iNumCivs, GC.getOPINION_WEIGHT_RETURNED_CIVILIAN());
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLandmarksBuiltForMeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumLandmarks = GetNumLandmarksBuiltForMe(ePlayer);

	if (iNumLandmarks > 0)
	{
		// Full credit for first one
		iOpinionWeight = /*-20*/ GC.getOPINION_WEIGHT_BUILT_LANDMARK();

		// Partial credit for any after first
		if (iNumLandmarks > 1)
		{
			iOpinionWeight += ((GC.getOPINION_WEIGHT_BUILT_LANDMARK() / 3) * (iNumLandmarks - 1));
		}

		int iDuration = AdjustModifierDuration(true, 50);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetLandmarksBuiltForMeTurn(ePlayer), MODIFIER_TYPE_DIMINISHING, iNumLandmarks, GC.getOPINION_WEIGHT_BUILT_LANDMARK());
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetResurrectedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (WasResurrectedBy(ePlayer))
	{
		iOpinionWeight = /*-200*/ GC.getOPINION_WEIGHT_RESURRECTED();
	}

	// Halve the weight if they captured our capital
	if (IsCapitalCapturedBy(ePlayer, false, true, true))
	{
		iOpinionWeight /= 2;
	}

	// Halve the weight if they captured our Holy City.
	if (IsHolyCityCapturedBy(ePlayer, false, true, true))
	{
		iOpinionWeight /= 2;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLiberatedCapitalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerLiberatedCapital(ePlayer))
	{
		iOpinionWeight = /*-120*/ GC.getOPINION_WEIGHT_LIBERATED_CAPITAL();
	}

	// Increase the weight if we're someone's vassal
	if (GetPlayer()->IsVassalOfSomeone())
	{
		iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_LIBERATED_CAPITAL_VASSAL_MULTIPLIER();
		iOpinionWeight /= 100;
	}

	// Halve the weight if they captured our Holy City.
	if (IsHolyCityCapturedBy(ePlayer, false, true, true))
	{
		iOpinionWeight /= 2;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLiberatedHolyCityScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerLiberatedHolyCity(ePlayer))
	{
		iOpinionWeight = /*-80*/ GC.getOPINION_WEIGHT_LIBERATED_HOLY_CITY();
	}

	// Increase the weight if we're someone's vassal
	if (GetPlayer()->IsVassalOfSomeone())
	{
		iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_LIBERATED_HOLY_CITY_VASSAL_MULTIPLIER();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLiberatedCitiesScore(PlayerTypes ePlayer)
{
	// No bonus if they captured our capital
	if (IsCapitalCapturedBy(ePlayer, false, true, true))
		return 0;
	
	int iOpinionWeight = 0;
	int iNumCitiesLiberated = GetNumCitiesLiberatedBy(ePlayer);

	// Capital/Holy City liberation bonus doesn't stack
	if (IsPlayerLiberatedCapital(ePlayer))
		iNumCitiesLiberated--;

	if (IsPlayerLiberatedHolyCity(ePlayer))
		iNumCitiesLiberated--;

	if (iNumCitiesLiberated > 0)
	{
		int iLiberationValue = /*-30*/ GC.getOPINION_WEIGHT_LIBERATED_CITY() * iNumCitiesLiberated;
		int iDuration = AdjustModifierDuration(true, 75);
		iOpinionWeight = AdjustModifierValue(iLiberationValue, iDuration, GetLiberatedCitiesTurn(ePlayer), MODIFIER_TYPE_STACKED, iNumCitiesLiberated);

		// Double the weight if we're someone's vassal
		if (GetPlayer()->IsVassalOfSomeone())
		{
			iOpinionWeight *= /*200*/ GC.getOPINION_WEIGHT_LIBERATED_CITY_VASSAL_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		// Halve the weight if they captured our Holy City.
		if (IsHolyCityCapturedBy(ePlayer, false, true, true))
		{
			iOpinionWeight /= 2;
		}

		// Reduce the weight if they've been capturing more of our cities than they've been liberating
		int iDivisor = max(1, (GetNumCitiesCapturedBy(ePlayer) - iNumCitiesLiberated + 1));
		iOpinionWeight /= iDivisor;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetReturnedCapitalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerReturnedCapital(ePlayer))
	{
		iOpinionWeight = /*-60*/ GC.getOPINION_WEIGHT_RETURNED_CAPITAL();
	}

	// Increase the weight if we're someone's vassal
	if (GetPlayer()->IsVassalOfSomeone())
	{
		iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_RETURNED_CAPITAL_VASSAL_MULTIPLIER();
		iOpinionWeight /= 100;
	}

	// Halve the weight if they captured our Holy City.
	if (IsHolyCityCapturedBy(ePlayer, false, true, true))
	{
		iOpinionWeight /= 2;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetReturnedHolyCityScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerLiberatedHolyCity(ePlayer))
	{
		iOpinionWeight = /*-40*/ GC.getOPINION_WEIGHT_RETURNED_CAPITAL();
	}

	// Increase the weight if we're someone's vassal
	if (GetPlayer()->IsVassalOfSomeone())
	{
		iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_RETURNED_HOLY_CITY_VASSAL_MULTIPLIER();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetEmbassyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsHasEmbassy(ePlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasEmbassy(GetID()))
	{
		iOpinionWeight = /*-3*/ GC.getOPINION_WEIGHT_EMBASSY_MUTUAL();
	}
	else if (IsHasEmbassy(ePlayer))
	{
		iOpinionWeight = /*-2*/ GC.getOPINION_WEIGHT_EMBASSY();
	}
	else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasEmbassy(GetID()))
	{
		iOpinionWeight = /*-1*/ GC.getOPINION_WEIGHT_EMBASSY_THEM();
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDiplomatScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They have a Spy as a Diplomat in our Capital
	// Smaller bonus if it's from vassalage
	bool bVassalReduction = (IsVassal(ePlayer) && !IsVoluntaryVassalage(ePlayer));

	if (IsVassal(ePlayer) || GetPlayer()->GetEspionage()->IsOtherDiplomatVisitingMe(ePlayer))
	{
		iOpinionWeight = bVassalReduction ? /*-10*/ GC.getOPINION_WEIGHT_DIPLOMAT_CAPITULATED_VASSAL() : /*-15*/ GC.getOPINION_WEIGHT_DIPLOMAT();

		if (!bVassalReduction && IsDiplomat())
		{
			iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_DIPLOMAT_MOD();
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetForgaveForSpyingScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerForgaveForSpying(ePlayer))
	{
		iOpinionWeight = /*-10*/ GC.getOPINION_WEIGHT_FORGAVE_FOR_SPYING();

		int iDuration = AdjustModifierDuration(true, 30);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetForgaveForSpyingTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetNoSettleRequestScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerExpansionPromiseState(GetID()) >= PROMISE_STATE_IGNORED)
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_ASKED_NO_SETTLE();

		int iDuration = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerExpansionPromiseState(GetID()) == PROMISE_STATE_IGNORED ? /*30*/ GC.getEXPANSION_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() : /*50*/ GC.getEXPANSION_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerExpansionPromiseTurn(GetID()), MODIFIER_TYPE_NORMAL); 
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetStopSpyingRequestScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerSpyPromiseState(GetID()) >= PROMISE_STATE_IGNORED)
	{
		iOpinionWeight = /*10*/ GC.getOPINION_WEIGHT_ASKED_STOP_SPYING();

		int iDuration = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerSpyPromiseState(GetID()) == PROMISE_STATE_IGNORED ? /*30*/ GC.getSPY_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN() : /*50*/ GC.getSPY_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerSpyPromiseTurn(GetID()), MODIFIER_TYPE_NORMAL);
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDemandEverMadeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumDemands = GetNumDemandEverMade(ePlayer);

	if (iNumDemands > 0)
	{
		// Full penalty for first one
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_MADE_DEMAND_OF_US();

		// Half penalty for every subsequent demand
		if (iNumDemands > 1)
		{
			iOpinionWeight += (iNumDemands - 1) * (GC.getOPINION_WEIGHT_MADE_DEMAND_OF_US() / 2);
		}

		int iDuration = AdjustModifierDuration(false, 50);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetDemandMadeTurn(ePlayer), MODIFIER_TYPE_DIMINISHING, iNumDemands, GC.getOPINION_WEIGHT_MADE_DEMAND_OF_US());
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesCultureBombedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (GetNumTimesCultureBombed(ePlayer) > 0)
		iOpinionWeight += (GetNumTimesCultureBombed(ePlayer) * /*10*/ GC.getOPINION_WEIGHT_CULTURE_BOMBED());
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetReligiousConversionPointsScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iPoints = GetNegativeReligiousConversionPoints(ePlayer);

	if (iPoints > 0)
	{
		iOpinionWeight = (GetNegativeReligiousConversionPoints(ePlayer) * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion() * /*2*/ GC.getOPINION_WEIGHT_PER_NEGATIVE_CONVERSION());

		int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));
		int iDuration = AdjustModifierDuration(false, 50, iFlavorReligion);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetReligiousConversionTurn(ePlayer), MODIFIER_TYPE_STACKED, iPoints);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetReligionScore(PlayerTypes ePlayer)
{
	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)) return 0;
	if (IsVassal(ePlayer)) return 0; // Vassals have their own function for this

	int iOpinionWeight = 0;

	ReligionTypes eOurStateReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);
	ReligionTypes eOurMajorityReligion = GetPlayer()->GetReligions()->GetReligionInMostCities();
	ReligionTypes eTheirStateReligion = GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false);
	ReligionTypes eTheirMajorityReligion = GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();

	int iFlavorReligion = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION"));
	int iEraMod = GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();

	// Weight increases or decreases based on flavors
	if (iFlavorReligion < 5)
	{
		iEraMod = max(0, iEraMod - 1);
	}
	else if (iFlavorReligion > 7)
	{
		iEraMod++;
	}

	iEraMod += GetPlayer()->GetPlayerTraits()->IsReligious() ? 1 : 0;

	// We didn't found or conquer, but have a majority religion
	if (eOurStateReligion == NO_RELIGION && eOurMajorityReligion != NO_RELIGION)
	{
		if (GetNegativeReligiousConversionPoints(ePlayer) <= 0 && !IsHolyCityCapturedBy(ePlayer))
		{
			if (eOurMajorityReligion == eTheirStateReligion)
			{
				// They must have at least one of their own cities following their state religion to get a bonus
				if (GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eTheirStateReligion, ePlayer))
				{
					iOpinionWeight += /*-4*/ GC.getOPINION_WEIGHT_ADOPTING_HIS_RELIGION() * iEraMod;

					// If it's the World Religion and they're its controller, support them since we get extra League votes from it
					if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(ePlayer, eTheirStateReligion) > 0)
					{
						iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_RELIGION_MODIFIER();
						iOpinionWeight /= 100;
					}
				}
			}
			// Same majority religions?
			else if (eOurMajorityReligion == eTheirMajorityReligion)
			{
				iOpinionWeight += /*-2*/ GC.getOPINION_WEIGHT_SAME_MAJORITY_RELIGIONS() * iEraMod;
			}
		}
		// Different majority religions?
		if (eOurMajorityReligion != eTheirStateReligion && eOurMajorityReligion != eTheirMajorityReligion && eTheirMajorityReligion != NO_RELIGION)
		{
			iOpinionWeight += /*2*/ GC.getOPINION_WEIGHT_DIFFERENT_MAJORITY_RELIGIONS() * iEraMod;
		}
	}
	// We founded or conquered
	else if (eOurStateReligion != NO_RELIGION)
	{
		// Do they also have a state religion? We don't like that!
		if (eTheirStateReligion != NO_RELIGION && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eTheirStateReligion, ePlayer))
		{
			iOpinionWeight += /*5*/ GC.getOPINION_WEIGHT_DIFFERENT_STATE_RELIGIONS() * iEraMod;

			// If it's the World Religion and they control its Holy City, we should work against them
			if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(ePlayer, eTheirStateReligion) > 0)
			{
				iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_RELIGION_MODIFIER();
				iOpinionWeight /= 100;
			}
		}
		// No? Well, do they have a majority religion?
		else if (eTheirMajorityReligion != NO_RELIGION)
		{
			// Ours?
			if (eTheirMajorityReligion == eOurStateReligion)
			{
				iOpinionWeight += /*-8*/ GC.getOPINION_WEIGHT_ADOPTING_MY_RELIGION() * iEraMod;

				// If it's the World Religion and we control its Holy City, we should work together
				if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(GetID(), eOurStateReligion) > 0)
				{
					iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_RELIGION_MODIFIER();
					iOpinionWeight /= 100;
				}
			}
			// Someone else's?
			else
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eTheirMajorityReligion, NO_PLAYER);

				// If the religion's founder is our teammate, don't apply a penalty if that teammate is still alive.
				if (IsTeammate((PlayerTypes)pReligion->m_eFounder) && GET_PLAYER((PlayerTypes)pReligion->m_eFounder).getNumCities() > 0)
					return 0;

				// If the religion's founder is THEIR teammate, treat it like a state religion.
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsTeammate((PlayerTypes)pReligion->m_eFounder) && GET_PLAYER((PlayerTypes)pReligion->m_eFounder).getNumCities() > 0)
				{
					iOpinionWeight += /*5*/ GC.getOPINION_WEIGHT_DIFFERENT_STATE_RELIGIONS() * iEraMod;

					// If it's the World Religion and their teammate controls its Holy City, we should work against them
					if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier((PlayerTypes)pReligion->m_eFounder, eTheirMajorityReligion) > 0)
					{
						iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_RELIGION_MODIFIER();
						iOpinionWeight /= 100;
					}
				}
				// Otherwise, apply a penalty for different majority religions.
				else
				{
					iOpinionWeight += /*2*/ GC.getOPINION_WEIGHT_DIFFERENT_MAJORITY_RELIGIONS() * iEraMod;
				}
			}
		}
	}

	if (iOpinionWeight > 0 && IsIgnoreReligionDifferences(ePlayer))
		return 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIdeologyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	if (eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE)
	{
		int iFlavorCulture = m_pPlayer->GetFlavorManager()->GetPersonalityFlavorForDiplomacy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));
		int iEraMod = GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisLatePolicies();

		// Weight increases or decreases based on flavors
		if (iFlavorCulture < 5)
		{
			iEraMod = max(0, iEraMod - 1);
		}
		else if (iFlavorCulture > 7)
		{
			iEraMod++;
		}

		iEraMod += (GetPlayer()->GetPlayerTraits()->IsTourism() || IsCultural()) ? 1 : 0;
		iEraMod += IsCloseToCultureVictory() ? 1 : 0;

		if (eMyBranch == eTheirBranch)
		{
			iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_SAME_LATE_POLICIES() * iEraMod;

			// World Ideology modifier?
			if (pLeague != NULL && pLeague->GetPressureForIdeology(eMyBranch) > 0)
			{
				iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_IDEOLOGY_MODIFIER();
				iOpinionWeight /= 100;
			}
		}
		else if (eMyBranch != eTheirBranch)
		{
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_DIFFERENT_LATE_POLICIES() * iEraMod;

			// World Ideology modifier?
			if (pLeague != NULL && (pLeague->GetPressureForIdeology(eMyBranch) > 0 || pLeague->GetPressureForIdeology(eTheirBranch) > 0))
			{
				iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_WORLD_IDEOLOGY_MODIFIER();
				iOpinionWeight /= 100;
			}
		}
	}

	if (iOpinionWeight > 0 && IsIgnoreIdeologyDifferences(ePlayer))
		return 0;

	// Vassals care less, since they're forced to adopt the master's ideology
	if (IsVassal(ePlayer) && !IsVoluntaryVassalage(ePlayer))
	{
		iOpinionWeight /= 2;
	}
	else if (!IsVassal(ePlayer) && GetPlayer()->IsVassalOfSomeone())
	{
		iOpinionWeight /= 2;
	}
	// Care less about vassals' ideologies, for the same reason
	else if (GET_PLAYER(ePlayer).IsVassalOfSomeone())
	{
		iOpinionWeight /= 2;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesRobbedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iTimesRobbed = GetNumTimesRobbedBy(ePlayer);

	if (iTimesRobbed > 0)
	{
		iOpinionWeight = (iTimesRobbed * /*20*/ GC.getOPINION_WEIGHT_ROBBED_BY());

		int iDuration = AdjustModifierDuration(false, 50);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetRobbedTurn(ePlayer), MODIFIER_TYPE_STACKED, iTimesRobbed);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTradeRoutesPlunderedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iRoutesPlundered = GetNumTradeRoutesPlundered(ePlayer);

	if (iRoutesPlundered > 0)
	{
		iOpinionWeight = (iRoutesPlundered * /*5*/ GC.getOPINION_WEIGHT_PLUNDERED_TRADE_ROUTE());

		int iDuration = AdjustModifierDuration(false, 25);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlunderedTradeRouteTurn(ePlayer), MODIFIER_TYPE_STACKED, iRoutesPlundered);
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesPlottedAgainstUsScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumPlots = GetNumTimesTheyPlottedAgainstUs(ePlayer);

	if (iNumPlots > 0)
	{
		// Full penalty for first time
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_PLOTTED_AGAINST_US();

		// Half penalty for subsequent times
		if (iNumPlots > 1)
		{
			iOpinionWeight += ((iNumPlots - 1) * (GC.getOPINION_WEIGHT_PLOTTED_AGAINST_US() / 2));
		}

		// Scale modifier duration based on military strength
		int iDurationMod = (int)GetPlayerMilitaryStrengthComparedToUs(ePlayer); // between 0 and 7, inclusive
		iDurationMod += ((int)GET_PLAYER(ePlayer).GetProximityToPlayer(GetID()) * 2); // between 0 and 6, inclusive
		iDurationMod *= 2;
		int iDuration = AdjustModifierDuration(false, 19, iDurationMod, false); // returns between 14 and 40 turns, inclusive, not scaling with gamespeed

		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlottedAgainstUsTurn(ePlayer), MODIFIER_TYPE_DIMINISHING, iNumPlots, GC.getOPINION_WEIGHT_PLOTTED_AGAINST_US());
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesPerformedCoupScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumCoups = GetNumTimesPerformedCoupAgainstUs(ePlayer);

	if (iNumCoups > 0)
	{
		iOpinionWeight = (iNumCoups * /*30*/ GC.getOPINION_WEIGHT_PERFORMED_COUP());

		int iDuration = AdjustModifierDuration(false, 50, GetMinorCivCompetitiveness());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPerformedCoupTurn(ePlayer), MODIFIER_TYPE_STACKED, iNumCoups);
	}

	return iOpinionWeight;
}

// todo
int CvDiplomacyAI::GetDugUpMyYardScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNegativePoints = GetNegativeArchaeologyPoints(ePlayer);
	
	if (iNegativePoints > 100)
	{
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_EXCAVATED_THREE_ARTIFACTS();
	}
	else if (iNegativePoints > 50)
	{
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_EXCAVATED_TWO_ARTIFACTS();
	}
	else if (iNegativePoints > 0)
	{
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_EXCAVATED_ONE_ARTIFACT();
	}
	
	if (iOpinionWeight > 0 && IsPlayerMadeNoDiggingPromise(ePlayer))
	{
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_MADE_NO_DIGGING_PROMISE_REDUCTION();
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesIntrigueSharedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumIntrigue = GetNumTimesIntrigueSharedBy(ePlayer);

	if (iNumIntrigue > 0)
	{
		// Full credit for first one
		iOpinionWeight = /*-10*/ GC.getOPINION_WEIGHT_INTRIGUE_SHARED_BY();

		// Partial credit for any after first
		if (iNumIntrigue > 1)
		{
			iOpinionWeight = ((iNumIntrigue - 1) * (GC.getOPINION_WEIGHT_INTRIGUE_SHARED_BY() / 2));
		}

		int iDuration = AdjustModifierDuration(true, 50);
		return AdjustModifierValue(iOpinionWeight, iDuration, GetIntrigueSharedTurn(ePlayer), MODIFIER_TYPE_DIMINISHING, iNumIntrigue, GC.getOPINION_WEIGHT_INTRIGUE_SHARED_BY());
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenMilitaryPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// No scaling for backstabbing penalties!
	if (IsPlayerBrokenMilitaryPromise(ePlayer))
	{
		iOpinionWeight = /*40*/ GC.getOPINION_WEIGHT_BROKEN_MILITARY_PROMISE();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenMilitaryPromiseWithAnybodyScore(PlayerTypes ePlayer)
{
	if (IsFriendOrAlly(ePlayer) && !IsUntrustworthy(ePlayer) && !WasEverBackstabbedBy(ePlayer))
		return 0;

	int iOpinionWeight = 0;

	// Don't add this if they broke a military promise with US
	if (!IsPlayerBrokenMilitaryPromise(ePlayer))
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			
			if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != ePlayer && eLoopPlayer != GetID())
			{
				// If this guy is untrustworthy or we hate him, he doesn't count.
				if (!IsUntrustworthy(eLoopPlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !IsAtWar(eLoopPlayer))
				{
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerBrokenMilitaryPromise(ePlayer))
					{
						iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD();
						break;
					}
				}
			}
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredMilitaryPromiseScore (PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredMilitaryPromise(ePlayer))
	{
		iOpinionWeight = /*0*/ GC.getOPINION_WEIGHT_IGNORED_MILITARY_PROMISE();

		int iDuration = /*40*/ GC.getMILITARY_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerMilitaryPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenExpansionPromiseScore (PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenExpansionPromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX();

		int iDuration = /*50*/ GC.getEXPANSION_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerExpansionPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredExpansionPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredExpansionPromise(ePlayer))
	{
		iOpinionWeight = /*15*/ GC.getOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX();

		int iDuration = /*30*/ GC.getEXPANSION_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerExpansionPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenBorderPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenBorderPromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX();

		int iDuration = /*50*/ GC.getBORDER_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerBorderPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredBorderPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenBorderPromise(ePlayer))
	{
		iOpinionWeight = /*15*/ GC.getOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX();

		int iDuration = /*30*/ GC.getBORDER_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerBorderPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenAttackCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// No scaling for backstabbing penalties!
	if (IsPlayerBrokenAttackCityStatePromise(ePlayer))
	{
		iOpinionWeight = /*40*/ GC.getOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenAttackCityStatePromiseWithAnybodyScore(PlayerTypes ePlayer)
{
	if (IsFriendOrAlly(ePlayer) && !IsUntrustworthy(ePlayer) && !WasEverBackstabbedBy(ePlayer))
		return 0;
	
	int iOpinionWeight = 0;

	// Don't add this if they broke a City-State attack promise with US
	if (!IsPlayerBrokenAttackCityStatePromise(ePlayer))
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			
			if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != ePlayer && eLoopPlayer != GetID())
			{
				// If this guy is untrustworthy or we hate him, he doesn't count
				if (!IsUntrustworthy(eLoopPlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !IsAtWar(eLoopPlayer))
				{
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerBrokenAttackCityStatePromise(ePlayer))
					{
						iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD();
						break;
					}
				}
			}
		}
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredAttackCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredAttackCityStatePromise(ePlayer))
	{
		iOpinionWeight = /*15*/ GC.getOPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE();

		int iDuration = /*40*/ GC.getATTACK_CS_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerAttackCityStatePromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenBullyCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenBullyCityStatePromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_BROKEN_BULLY_CITY_STATE_PROMISE();

		int iDuration = /*30*/ GC.getBULLY_CS_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerBullyCityStatePromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredBullyCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredBullyCityStatePromise(ePlayer))
	{
		iOpinionWeight = /*10*/ GC.getOPINION_WEIGHT_IGNORED_BULLY_CITY_STATE_PROMISE();

		int iDuration = /*50*/ GC.getBULLY_CS_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerBullyCityStatePromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenNoConvertPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenNoConvertPromise(ePlayer))
	{
		iOpinionWeight = /*8*/ GC.getOPINION_WEIGHT_BROKEN_NO_CONVERT_PROMISE() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();

		int iDuration = /*60*/ GC.getCONVERT_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerNoConvertPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredNoConvertPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredNoConvertPromise(ePlayer))
	{
		iOpinionWeight = /*4*/ GC.getOPINION_WEIGHT_IGNORED_NO_CONVERT_PROMISE() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();

		int iDuration = /*40*/ GC.getCONVERT_PROMISE_IGNORED_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerNoConvertPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenNoDiggingPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenNoDiggingPromise(ePlayer))
	{
		iOpinionWeight = /*30*/ GC.getOPINION_WEIGHT_BROKEN_NO_DIG_PROMISE();

		int iDuration = /*60*/ GC.getDIGGING_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerNoDiggingPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredNoDiggingPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredNoDiggingPromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_IGNORED_NO_DIG_PROMISE();

		int iDuration = /*40*/ GC.getDIGGING_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerNoDiggingPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}


int CvDiplomacyAI::GetBrokenSpyPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenSpyPromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_BROKEN_SPY_PROMISE();

		int iDuration = /*50*/ GC.getSPY_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerSpyPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredSpyPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerIgnoredSpyPromise(ePlayer))
	{
		iOpinionWeight = /*10*/ GC.getOPINION_WEIGHT_IGNORED_SPY_PROMISE();

		int iDuration = /*30*/ GC.getSPY_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		iDuration *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
		iDuration /= 100;
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerSpyPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}


int CvDiplomacyAI::GetBrokenCoopWarPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerBrokenCoopWarPromise(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_BROKEN_COOP_WAR_PROMISE();

		int iDuration = /*60*/ GC.getCOOP_WAR_PROMISE_BROKEN_TURNS_UNTIL_FORGIVEN();
		return AdjustModifierValue(iOpinionWeight, iDuration, GetPlayerSpyPromiseTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorKilledScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
	{
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_KILLED_PROTECTED_MINOR();
		if (GetOtherPlayerNumProtectedMinorsKilled(ePlayer) > 1)
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_KILLED_MANY_PROTECTED_MINORS();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorAttackedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsAngryAboutProtectedMinorAttacked(ePlayer))
	{
		iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY();
		if (GetOtherPlayerNumProtectedMinorsAttacked(ePlayer) > 1)
			iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_ATTACKED_MANY_PROTECTED_MINORS();

		int iDuration = AdjustModifierDuration(false, /*30*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN(), GetPersonalityMinorCivApproachBias(MINOR_CIV_APPROACH_PROTECTIVE));
		return AdjustModifierValue(iOpinionWeight, iDuration, GetOtherPlayerAttackedProtectedMinorTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorBulliedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsAngryAboutProtectedMinorBullied(ePlayer))
	{
		iOpinionWeight = /*15*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY();
		if (GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 1)					
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_BULLIED_MANY_PROTECTED_MINORS();

		int iDuration = AdjustModifierDuration(false, /*30*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN(), GetPersonalityMinorCivApproachBias(MINOR_CIV_APPROACH_PROTECTIVE));
		return AdjustModifierValue(iOpinionWeight, iDuration, GetOtherPlayerBulliedProtectedMinorTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutSidedWithProtectedMinorScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsAngryAboutSidedWithProtectedMinor(ePlayer))
	{
		iOpinionWeight = /*10*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR();

		if (!IsDoFAccepted(ePlayer))
		{
			if (GetBoldness() > 7 || GetMeanness() > 7)
				iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_AGGRESSIVE_MOD();

			else if (MOD_BALANCE_CORE)
			{
				if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 ||
					GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0 ||
					GetPlayer()->GetPlayerTraits()->GetCityStateCombatModifier() != 0 ||
					GetPlayer()->GetPlayerTraits()->IsBullyAnnex() || GetPlayer()->GetPlayerTraits()->IgnoreBullyPenalties() ||
					GetPlayer()->IsCanBullyFriendlyCS())
				{
					iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_AGGRESSIVE_MOD();
				}
			}
		}

		int iDuration = AdjustModifierDuration(false, /*10*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FORGIVEN());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetOtherPlayerSidedWithProtectedMinorTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetResearchAgreementScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsHasResearchAgreement(ePlayer))
	{
		iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_RA();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPAcceptedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// We have made a Defensive Pact
	if (IsHasDefensivePact(ePlayer))
	{
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_DP();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPWithAnyFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They have a DP with at least one other player we have a DP with
	if (IsPlayerDPWithAnyFriend(ePlayer))
	{
		iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_DP_WITH_FRIEND();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPWithAnyEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They have a DP with at least one enemy we have denounced
	if (IsPlayerDPWithAnyEnemy(ePlayer))
	{
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_DP_WITH_ENEMY();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetOpenBordersScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	bool bTheyAllow = IsHasOpenBorders(ePlayer);
	bool bWeAllow = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsHasOpenBorders(GetID());

	if (bWeAllow && bTheyAllow)
	{
		iOpinionWeight += /*-12*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_MUTUAL();
	}
	else if (bTheyAllow)
	{
		iOpinionWeight += /*-8*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_US();
	}
	else if (bWeAllow)
	{
		iOpinionWeight += /*-4*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_THEM();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDOFAcceptedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsDoFAccepted(ePlayer))
	{
		iOpinionWeight += /*-30*/ GC.getOPINION_WEIGHT_DOF();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDOFWithAnyFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They have a DoF with at least one other player we have a DoF with
	if (IsPlayerDoFWithAnyFriend(ePlayer))
	{
		iOpinionWeight += /*-18*/ GC.getOPINION_WEIGHT_DOF_WITH_FRIEND();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDOFWithAnyEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They have a DoF with at least one other player we have DENOUNCED
	if (IsPlayerDoFWithAnyEnemy(ePlayer))
	{
		iOpinionWeight += /*18*/ GC.getOPINION_WEIGHT_DOF_WITH_ENEMY();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetFriendDenouncementScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	
	// If we don't view them as untrustworthy, disregard this
	if (!IsUntrustworthy(ePlayer))
		return 0;
	
	// How many of their friends have denounced them?
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != GetID() && eLoopPlayer != ePlayer && IsHasMet(eLoopPlayer, true) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsFriendDenouncedUs(eLoopPlayer))
		{
			// If this guy is untrustworthy or we hate him, he doesn't count
			if (!IsUntrustworthy(eLoopPlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()) && !IsAtWar(eLoopPlayer) && !IsDenouncedPlayer(eLoopPlayer) && !IsDenouncedByPlayer(eLoopPlayer))
			{
				// Do we like this player who denounced them more than the player we're evaluating?
				if (GetMajorCivOpinion(eLoopPlayer) > GetMajorCivOpinion(ePlayer))
				{
					iTraitorOpinion += /*20*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH();
				}
				else
				{
					iTraitorOpinion += /*10*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_DONT_LIKE();
				}
			}
		}
	}
	
	return iTraitorOpinion;
}

int CvDiplomacyAI::GetWeDenouncedFriendScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	
	// If we don't view them as untrustworthy, disregard this
	if (!IsUntrustworthy(ePlayer))
		return 0;
	
	int iWeight = /*30*/ GC.getOPINION_WEIGHT_DENOUNCED_FRIEND_EACH();
	
	// How many of their friends have they denounced?
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != GetID() && eLoopPlayer != ePlayer && IsHasMet(eLoopPlayer, true) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDenouncedUs(ePlayer))
		{
			// If this guy is untrustworthy, he doesn't count
			if (!IsUntrustworthy(eLoopPlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()))
			{
				// Someone important to us?
				if (IsFriendOrAlly(eLoopPlayer))
				{
					iTraitorOpinion += (iWeight * 2);
				}
				else
				{
					iTraitorOpinion += iWeight;
				}
			}
		}
	}

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetFriendDenouncedUsScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;

	if (IsFriendDenouncedUs(ePlayer))
	{
		iTraitorOpinion = /*45*/ GC.getOPINION_WEIGHT_DENOUNCED_ME_FRIENDS();
	}

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetWeDeclaredWarOnFriendScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;

	// If we don't view them as untrustworthy, disregard this
	if (!IsUntrustworthy(ePlayer))
		return 0;
	
	int iWeight = /*50*/ GC.getOPINION_WEIGHT_WAR_FRIEND_EACH();
	
	// How many of their friends have they declared war on?
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != GetID() && eLoopPlayer != ePlayer && IsHasMet(eLoopPlayer, true) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDeclaredWarOnUs(ePlayer))
		{
			// If this guy is untrustworthy, he doesn't count
			if (!IsUntrustworthy(eLoopPlayer) && !WasEverBackstabbedBy(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->WasEverBackstabbedBy(GetID()))
			{
				// Someone important to us?
				if (IsFriendOrAlly(eLoopPlayer))
				{
					iTraitorOpinion += (iWeight * 2);
				}
				else
				{
					iTraitorOpinion += iWeight;
				}
			}
		}
	}

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetFriendDeclaredWarOnUsScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;

	if (IsFriendDeclaredWarOnUs(ePlayer))
	{
		iTraitorOpinion = /*100*/ GC.getOPINION_WEIGHT_WAR_ME_FRIENDS();
	}

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetMutualDenouncementScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// We denounced each other!
	if (IsDenouncedPlayer(ePlayer) && IsDenouncedByPlayer(ePlayer))
	{
		iOpinionWeight += /*50*/ GC.getOPINION_WEIGHT_MUTUAL_DENOUNCEMENT();
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedUsScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They denounced us!
	if (IsDenouncedByPlayer(ePlayer) && !IsDenouncedPlayer(ePlayer))
	{
		iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_ME();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedThemScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// We denounced them!
	if (IsDenouncedPlayer(ePlayer) && !IsDenouncedByPlayer(ePlayer))
	{
		iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_THEM();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They've denounced someone we have a DoF with
	if (IsPlayerDenouncedFriend(ePlayer))
	{
		iOpinionWeight += /*18*/ GC.getOPINION_WEIGHT_DENOUNCED_FRIEND();
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// They've denounced someone we've denounced
	if (IsPlayerDenouncedEnemy(ePlayer))
	{
		iOpinionWeight += /*-18*/ GC.getOPINION_WEIGHT_DENOUNCED_ENEMY();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetRecklessExpanderScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerRecklessExpander(ePlayer))
	{
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_RECKLESS_EXPANDER();

		int iMedianCities = GC.getGame().CalculateMedianNumCities();
		int iMedianPlots = GC.getGame().CalculateMedianNumPlots();
		int iNumCities = GET_PLAYER(ePlayer).getNumCities();
		int iNumPlots = GET_PLAYER(ePlayer).getTotalLand();

		int iCivCityDifference = iNumCities - GetPlayer()->getNumCities();
		int iCivPlotDifference = iNumPlots - GetPlayer()->getTotalLand();
		int iMedianCityDifference = (((iNumCities*100) - (iMedianCities * /*200*/ GC.getRECKLESS_EXPANDER_CITIES_THRESHOLD())) / 100);
		int iMedianPlotDifference = (((iNumPlots*100) - (iMedianPlots * /*250*/ GC.getRECKLESS_EXPANDER_LAND_THRESHOLD())) / 100);

		// For scaling, go with whichever value is smaller
		int iCityWeight = 0;
		int iCityDifference = min(iCivCityDifference, iMedianCityDifference);

		if (iCityDifference > 1)
		{
			iCityWeight += ((iCityDifference-1) * /*10*/ GC.getOPINION_WEIGHT_RECKLESS_EXPANDER_PER_CITY());
		}

		// Since land can be a factor, also factor in tile count (scale by whichever value is smaller)
		int iPlotWeight = 0;
		int iPlotDifference = min(iCivPlotDifference, iMedianPlotDifference);

		if (iPlotDifference > 1)
		{
			iPlotWeight += ((iPlotDifference-1) * /*1*/ GC.getOPINION_WEIGHT_RECKLESS_EXPANDER_PER_TILE());
		}

		// Apply the highest of the two scaling weights to Opinion
		iOpinionWeight += max(iCityWeight, iPlotWeight);

		if (IsConqueror())
		{
			iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_RECKLESS_EXPANDER_STRATEGIC_MOD();
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetWonderSpammerScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsPlayerWonderSpammer(ePlayer))
	{
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_WONDER_SPAMMER();

		int iCivDifference = GET_PLAYER(ePlayer).GetWondersConstructed() - GetPlayer()->GetWondersConstructed();
		int iMedianDifference = GET_PLAYER(ePlayer).GetWondersConstructed() - GC.getGame().CalculateMedianNumWondersConstructed();

		// For scaling, go with whichever value is smaller
		int iWonderDifference = min(iCivDifference, iMedianDifference);

		if (iWonderDifference > /*4*/ (GC.getWONDER_SPAMMER_THRESHOLD() + 1))
		{
			iOpinionWeight += ((iWonderDifference - /*4*/ (GC.getWONDER_SPAMMER_THRESHOLD() + 1)) * /*5*/ GC.getOPINION_WEIGHT_WONDER_SPAMMER_PER_WONDER());

			if (iOpinionWeight > /*60*/ GC.getOPINION_WEIGHT_WONDER_SPAMMER_CAP())
			{
				iOpinionWeight = /*60*/ GC.getOPINION_WEIGHT_WONDER_SPAMMER_CAP();
			}
		}
		if (IsCultural() || IsConqueror())
		{
			iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_WONDER_SPAMMER_STRATEGIC_MOD();
		}
	}

	return iOpinionWeight;
}

//todo
int CvDiplomacyAI::GetRecentTradeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (GetRecentTradeValue(ePlayer) > 0)
	{
		int iWeightChange = -1 * GetRecentTradeValue(ePlayer) / GC.getDEAL_VALUE_PER_OPINION_WEIGHT();
		if(iWeightChange < /*-40*/ GC.getOPINION_WEIGHT_TRADE_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_TRADE_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}

	if (IsStrategicTradePartner(ePlayer))
	{
		iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_STRATEGIC_TRADE_PARTNER_MULTIPLIER();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

//todo
int CvDiplomacyAI::GetCommonFoeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetCommonFoeValue(ePlayer) > 0)
	{
		int iWeightChange = -1 * GetCommonFoeValue(ePlayer) / GC.getCOMMON_FOE_VALUE_PER_OPINION_WEIGHT();
		if(iWeightChange < /*-50*/ GC.getOPINION_WEIGHT_COMMON_FOE_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_COMMON_FOE_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}	
	return iOpinionWeight;
}

//todo
int CvDiplomacyAI::GetRecentAssistScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetRecentAssistValue(ePlayer) != 0)
	{
		int iWeightChange = GetRecentAssistValue(ePlayer) / GC.getASSIST_VALUE_PER_OPINION_WEIGHT();
		if (iWeightChange < /*-30*/ -GC.getOPINION_WEIGHT_ASSIST_MAX())
		{
			iWeightChange = -GC.getOPINION_WEIGHT_ASSIST_MAX();
		}
		else if (iWeightChange > /*30*/ GC.getOPINION_WEIGHT_ASSIST_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_ASSIST_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetNukedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if(IsNukedBy(ePlayer))
	{
		iOpinionWeight += /*50*/ GC.getOPINION_WEIGHT_NUKED_MAX();
	}

	return iOpinionWeight;
}

//todo
int CvDiplomacyAI::GetCitiesRazedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (GetNumTimesRazed(ePlayer) > 0)
	{
		iOpinionWeight += (min(GetNumTimesRazed(ePlayer), /*50*/ GC.getOPINION_WEIGHT_CIVILIAN_KILLER_MAX()) * /*1*/ GC.getOPINION_WEIGHT_PER_CIVILIAN_KILLER_VALUE());
	}

	return iOpinionWeight;
}

//todo
int CvDiplomacyAI::GetCitiesRazedGlobalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_NEUTRAL && !IsDoFAccepted(ePlayer) && !IsHasDefensivePact(ePlayer))
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != GetID() && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTimesRazed(ePlayer) >= 50)
			{
				MajorCivApproachTypes eApproach = GetMajorCivApproach(eLoopPlayer);
				bool bDontCare = (WasEverBackstabbedBy(eLoopPlayer) || IsAtWar(eLoopPlayer) || IsDenouncedPlayer(eLoopPlayer) || IsDenouncedByPlayer(eLoopPlayer) || IsUntrustworthy(eLoopPlayer) || eApproach == MAJOR_CIV_APPROACH_AFRAID || eApproach <= MAJOR_CIV_APPROACH_DECEPTIVE || GetMajorCivOpinion(eLoopPlayer) <= MAJOR_CIV_OPINION_ENEMY);

				if (!bDontCare)
				{
					iOpinionWeight = /*20*/ GC.getOPINION_WEIGHT_CIVILIAN_KILLER_WORLD();
					break;
				}
			}
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetPolicyScore(PlayerTypes ePlayer)
{
	if (GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
		return 0;

	int iOpinionWeight = 0;
	int iNumPolicies = GetNumSamePolicies(ePlayer);
	
	if (iNumPolicies < 0)
	{
		iOpinionWeight = max(/*10*/ GC.getOPINION_WEIGHT_DIVERGENT_POLICIES(), iNumPolicies * /*5*/ -GC.getOPINION_WEIGHT_PER_DIVERGENT_POLICY());
	}
	else if (iNumPolicies > 0)
	{
		iOpinionWeight = min(/*-10*/ GC.getOPINION_WEIGHT_SIMILAR_POLICIES(), iNumPolicies * /*-5*/ GC.getOPINION_WEIGHT_PER_SIMILAR_POLICY());
	}
	
	if (GetNeediness() >= /*8*/ GC.getPOLICY_SCORE_NEEDY_THRESHOLD())
	{
		if (iOpinionWeight > 0)
		{
			iOpinionWeight += /*5*/ GC.getPOLICY_SCORE_NEEDY_BONUS();
		}
		else if (iOpinionWeight < 0)
		{
			iOpinionWeight += /*-5*/ -GC.getPOLICY_SCORE_NEEDY_BONUS();
		}
	}

	if (iOpinionWeight > 0 && IsIgnorePolicyDifferences(ePlayer))
		return 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetPtPSameCSScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iSamePtP = 0;

	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eMinorLoopPlayer = (PlayerTypes) iPlayerLoop;
		if (eMinorLoopPlayer == NO_PLAYER)
			continue;
		
		if (GET_PLAYER(eMinorLoopPlayer).isMinorCiv())
		{
			if (GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(ePlayer) && GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(GetID()))
			{
				iSamePtP++;
			}
		}
	}
	// Diplomatic civs apply a larger bonus for this if they're not being competed with.
	if (IsDiplomat() && !IsMinorCivTroublemaker(ePlayer))
	{
		iSamePtP *= 2;
	}
	if (iSamePtP > 0)
	{
		iOpinionWeight += min(/*-12*/ GC.getOPINION_WEIGHT_PTP_SAME_MINOR_MIN(), (iSamePtP * /*-3*/ GC.getOPINION_WEIGHT_PTP_SAME_MINOR_EACH()));
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetCapitalCapturedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	if (IsCapitalCapturedBy(ePlayer))
	{
		iOpinionWeight += /*160*/ GC.getOPINION_WEIGHT_CAPTURED_CAPITAL();
	}

	// Halve the weight if they willingly returned our capital.
	if (IsPlayerReturnedCapital(ePlayer, true))
	{
		iOpinionWeight /= 2;
	}

	// If a capitulated vassal, halve the weight.
	if (MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(ePlayer) && !IsVoluntaryVassalage(ePlayer))
	{
		iOpinionWeight *= 100;
		iOpinionWeight /= max(1, /*200*/ GC.getOPINION_WEIGHT_CAPTURED_KEY_CITY_CAPITULATION_DIVISOR());
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetHolyCityCapturedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	if (IsHolyCityCapturedBy(ePlayer))
	{
		iOpinionWeight += /*80*/ GC.getOPINION_WEIGHT_CAPTURED_HOLY_CITY();
	}

	// Halve the weight if they willingly returned our Holy City.
	if (IsPlayerReturnedHolyCity(ePlayer, true))
	{
		iOpinionWeight /= 2;
	}

	// If a capitulated vassal, halve the weight.
	if (MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(ePlayer) && !IsVoluntaryVassalage(ePlayer))
	{
		iOpinionWeight *= 100;
		iOpinionWeight /= max(1, /*200*/ GC.getOPINION_WEIGHT_CAPTURED_KEY_CITY_CAPITULATION_DIVISOR());
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetLeagueAlignmentScore(PlayerTypes ePlayer)
{
	if (!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;

	int iOpinionWeight = 0;
	bool bDiplomat = IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat();

	if (GetPrimeLeagueCompetitor() == ePlayer)
	{
		iOpinionWeight = bDiplomat ? /*50*/ GC.getOPINION_WEIGHT_PRIME_LEAGUE_COMPETITOR_DIPLOMAT() : /*25*/ GC.getOPINION_WEIGHT_PRIME_LEAGUE_COMPETITOR();
	}
	else
	{
		CvLeagueAI::AlignmentLevels eAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(ePlayer, /*bIgnoreWar*/ true);
		switch (eAlignment)
		{
		case CvLeagueAI::ALIGNMENT_ENEMY:
			iOpinionWeight = bDiplomat ? /*40*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_ENEMY_DIPLOMAT() : /*20*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_ENEMY();
			break;
		case CvLeagueAI::ALIGNMENT_HATRED:
			iOpinionWeight = bDiplomat ? /*30*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_HATRED_DIPLOMAT() : /*15*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_HATRED();
			break;
		case CvLeagueAI::ALIGNMENT_RIVAL:
			iOpinionWeight = bDiplomat ? /*20*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_RIVAL_DIPLOMAT() : /*10*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_RIVAL();
			break;
		case CvLeagueAI::ALIGNMENT_FRIEND:
			iOpinionWeight = bDiplomat ? /*-20*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_FRIEND_DIPLOMAT() : /*-10*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_FRIEND();
			break;
		case CvLeagueAI::ALIGNMENT_CONFIDANT:
			iOpinionWeight = bDiplomat ? /*-30*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_CONFIDANT_DIPLOMAT() : /*-15*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_CONFIDANT();
			break;
		case CvLeagueAI::ALIGNMENT_ALLY:
			iOpinionWeight = bDiplomat ? /*-40*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_ALLY_DIPLOMAT() : /*-20*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_ALLY();
			break;
		case CvLeagueAI::ALIGNMENT_LIBERATOR:
			iOpinionWeight = bDiplomat ? /*-50*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_LIBERATOR_DIPLOMAT() : /*-25*/ GC.getOPINION_WEIGHT_LEAGUE_ALIGNMENT_LIBERATOR();
			break;
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetLikedTheirProposalScore(PlayerTypes ePlayer)
{
	if (!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;

	int iOpinionWeight = 0;

	if (GetWeLikedTheirProposalTurn(ePlayer) > -1)
	{
		iOpinionWeight = GetLikedTheirProposalValue(ePlayer);

		if (IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			iOpinionWeight *= /*134*/ GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_DIPLOMAT_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		int iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS(), GetDiploBalance());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetWeLikedTheirProposalTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDislikedTheirProposalScore(PlayerTypes ePlayer)
{
	if (!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;

	int iOpinionWeight = 0;

	if (GetWeDislikedTheirProposalTurn(ePlayer) > -1)
	{
		iOpinionWeight = GetLikedTheirProposalValue(ePlayer);

		if (IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			iOpinionWeight *= /*134*/ GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_DIPLOMAT_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		int iDuration = AdjustModifierDuration(false, /*50*/ GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS(), GetDiploBalance());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetWeDislikedTheirProposalTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetSupportedOurProposalScore(PlayerTypes ePlayer)
{
	if (!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;

	int iOpinionWeight = 0;
	int iSupportValue = GetSupportedOurProposalValue(ePlayer);

	// Foiled our proposals!
	if (iSupportValue > 0)
	{
		int iTurn = 0;
		int iDuration = AdjustModifierDuration(false, /*50*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

		if (IsFoiledOurProposalAndThenSupportedUs(ePlayer))
		{
			iTurn = GetTheySupportedOurProposalTurn(ePlayer);

			// The more recent action should carry higher value if Forgiveness is higher
			int iDurationMod = (GetForgiveness() - 5) * 2;
			iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
			iDurationMod /= 100;
			if (iDurationMod > 0)
			{
				iDuration -= iDurationMod;
			}
		}
		else
		{
			iTurn = GetTheyFoiledOurProposalTurn(ePlayer);
		}

		int iMinOpinionWeight = max(0, /*10*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL());
		int iMaxOpinionWeight = max(0, /*60*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_MAX());
		int iDifference = iMaxOpinionWeight - iMinOpinionWeight;
		int iAwardPercentage = min(100, (iSupportValue * max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT()))); // 2% of the penalty for each 1% of the vote they contributed, up to 100%

		iOpinionWeight = iMinOpinionWeight;
		iOpinionWeight += (iDifference * iAwardPercentage / 100);

		if (IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			iOpinionWeight *= /*167*/ GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_DIPLOMAT_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		return AdjustModifierValue(iOpinionWeight, iDuration, iTurn, MODIFIER_TYPE_NORMAL);
	}
	// Supported our proposals!
	else if (iSupportValue < 0)
	{
		int iTurn = 0;
		int iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS(), GetDiploBalance());

		if (IsSupportedOurProposalAndThenFoiledUs(ePlayer))
		{
			iTurn = GetTheyFoiledOurProposalTurn(ePlayer);

			// The more recent action should carry higher value if Boldness is higher
			int iDurationMod = (GetBoldness() - 5) * 2;
			iDurationMod *= GC.getGame().getGameSpeedInfo().getOpinionDurationPercent();
			iDurationMod /= 100;
			if (iDurationMod > 0)
			{
				iDuration -= iDurationMod;
			}
		}
		else
		{
			iTurn = GetTheySupportedOurProposalTurn(ePlayer);
		}

		int iMinOpinionWeight = min(0, /*-10*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL());
		int iMaxOpinionWeight = min(0, /*-60*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_MAX());
		int iDifference = iMaxOpinionWeight - iMinOpinionWeight;
		int iAwardPercentage = min(100, (-iSupportValue * max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT()))); // 2% of the bonus for each 1% of the vote they contributed, up to 100%

		iOpinionWeight = iMinOpinionWeight;
		iOpinionWeight += (iDifference * iAwardPercentage / 100);

		if (IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			iOpinionWeight *= /*167*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_DIPLOMAT_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		return AdjustModifierValue(iOpinionWeight, iDuration, iTurn, MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetSupportedMyHostingScore(PlayerTypes ePlayer)
{
	if (!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;

	int iOpinionWeight = 0;

	if (GetTheySupportedOurHostingTurn(ePlayer) > -1)
	{
		int iMinOpinionWeight = min(0, /*-20*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING());
		int iMaxOpinionWeight = min(0, /*-70*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_MAX());
		int iDifference = iMaxOpinionWeight - iMinOpinionWeight;
		int iAwardPercentage = min(100, (GetSupportedOurHostingValue(ePlayer) * max(1, /*2*/ GC.getOPINION_WEIGHT_PER_VOTE_PERCENT()))); // 2% of the bonus for each 1% of the vote they contributed, up to 100%

		iOpinionWeight = iMinOpinionWeight;
		iOpinionWeight += (iDifference * iAwardPercentage / 100);

		if (IsDiplomat() || GetPlayer()->GetPlayerTraits()->IsDiplomat())
		{
			iOpinionWeight *= /*150*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_DIPLOMAT_MULTIPLIER();
			iOpinionWeight /= 100;
		}

		int iDuration = AdjustModifierDuration(true, /*50*/ GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS(), GetDiploBalance());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetTheySupportedOurHostingTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

#if defined(MOD_EVENTS_DIPLO_MODIFIERS)
int CvDiplomacyAI::GetDiploModifiers(PlayerTypes eToPlayer, std::vector<Opinion>& aOpinions)
{
	int iValue = 0;
	int iModifier;

	iModifier = GetScenarioModifier1(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_1");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}
	
	iModifier = GetScenarioModifier2(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_2");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}

	iModifier = GetScenarioModifier3(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_3");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}
	
	if (MOD_EVENTS_DIPLO_MODIFIERS)
	{
		PlayerTypes eFromPlayer = m_pPlayer->GetID();
		CivilizationTypes eFromCiv = m_pPlayer->getCivilizationType();
		
		CvPlayer* pToPlayer = &GET_PLAYER(eToPlayer);
		CivilizationTypes eToCiv = pToPlayer->getCivilizationType();
		
		
		for (int iI = 0; iI < GC.getNumDiploModifierInfos(); iI++) {
			CvDiploModifierInfo* pDiploModifierInfo = GC.getDiploModifierInfo((DiploModifierTypes) iI);
			
			if (pDiploModifierInfo && pDiploModifierInfo->isForFromCiv(eFromCiv) && pDiploModifierInfo->isForToCiv(eToCiv)) {
				iModifier = 0;
				
				if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_GetDiploModifier, pDiploModifierInfo->GetID(), eFromPlayer, eToPlayer) == GAMEEVENTRETURN_VALUE) {
					if (iModifier != 0) {
						iValue += iModifier;
		
						Opinion kOpinion;
						kOpinion.m_iValue = iModifier;
						Localization::String strOpinion = Localization::Lookup(pDiploModifierInfo->GetDescriptionKey());
						strOpinion << iModifier;
						strOpinion << m_pPlayer->getName();
						strOpinion << m_pPlayer->getCivilizationDescription();
						strOpinion << pToPlayer->getName();
						strOpinion << pToPlayer->getCivilizationDescription();

						kOpinion.m_str = strOpinion.toUTF8();
						aOpinions.push_back(kOpinion);
					}
				}
			}
		}
	}
	
	return iValue;
}
#endif

int CvDiplomacyAI::GetScenarioModifier1(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier1", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;
}

int CvDiplomacyAI::GetScenarioModifier2(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier2", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;
}

int CvDiplomacyAI::GetScenarioModifier3(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier3", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;

}

/////////////////////////////////////////////////////////
// Miscellaneous
/////////////////////////////////////////////////////////

/// Will this player liberate a Minor's City that it now owns?
bool CvDiplomacyAI::DoPossibleMinorLiberation(PlayerTypes eMinor, int iCityID)
{
	bool bLiberate = false;

	if (GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_PROTECTIVE || IsGoingForDiploVictory() || IsCloseToDiploVictory())
	{
		bLiberate = true;
	}
	
#if defined(MOD_BALANCE_CORE)
	if(GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
	{
		bLiberate = false;
	}
#endif

	if (GetPlayer()->IsEmpireVeryUnhappy())
	{
		bLiberate = true;
	}

	if (bLiberate)
	{
		GetPlayer()->DoLiberatePlayer(eMinor, iCityID);
	}

	return bLiberate;
}

/// Will this player liberate a Major's City that it now owns?
bool CvDiplomacyAI::DoPossibleMajorLiberation(PlayerTypes eMajor, PlayerTypes eOldOwner, CvCity* pCity)
{
	if (pCity == NULL)
		return false;

	// Received from a teammate?
	if (IsTeammate(eOldOwner))
		return false;

	// Originally owned by a teammate?
	if (IsTeammate(eMajor))
		return true;

	bool bLiberate = false;
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(eMajor);
	MajorCivApproachTypes eApproach = GetMajorCivApproach(eMajor);

	// If we're going for world conquest, never liberate an original major capital!
	if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
	{
		if (pCity->IsOriginalMajorCapital())
			return false;
	}

	// Never liberate a rival Holy City...
	if (GetPlayer()->GetReligions()->GetCurrentReligion(false) != NO_RELIGION)
	{
		if (pCity->GetCityReligions()->IsHolyCityAnyReligion() && !pCity->GetCityReligions()->IsHolyCityForReligion(GetPlayer()->GetReligions()->GetCurrentReligion(false)))
			return false;
	}

	// If we're planning to attack them, liberating their cities would be foolish!
	if (IsWantsSneakAttack(eMajor) || IsArmyInPlaceForAttack(eMajor) || GetGlobalCoopWarAgainstState(eMajor) >= COOP_WAR_STATE_PREPARING)
		return false;

	// Hate them? Don't consider liberating!
	if (eOpinion <= MAJOR_CIV_OPINION_ENEMY || IsUntrustworthy(eMajor))
		return false;
	if (eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_GUARDED)
		return false;

	// Empire unhappy?
	if (GetPlayer()->IsEmpireUnhappy() && !IsAtWar(eMajor) && !IsAtWar(eOldOwner))
	{
		if (eOpinion >= MAJOR_CIV_OPINION_FRIEND)
		{
			bLiberate = true;
		}
		else if (eOpinion >= MAJOR_CIV_OPINION_NEUTRAL)
		{
			if (GetMajorCivOpinion(eOldOwner) <= MAJOR_CIV_OPINION_ENEMY)
			{
				bLiberate = true;
			}
			// Very unhappy and war weary? Liberating a city will help.
			else if (GetPlayer()->IsEmpireVeryUnhappy() && GetPlayer()->GetCulture()->GetWarWeariness() > 0)
			{
				bLiberate = true;
			}
		}
	}

	if (!bLiberate)
	{
		bool bBadWarDecision = GetWarState(eOldOwner) <= WAR_STATE_DEFENSIVE && (!GET_PLAYER(eMajor).isAlive() || GET_PLAYER(eMajor).IsAtWarWith(eOldOwner));

		// Player we'd be liberating is alive
		if (GET_PLAYER(eMajor).isAlive())
		{
			// DP, and we're both at war with the old owner?
			if (IsHasDefensivePact(eMajor) && IsAtWar(eOldOwner) && GET_PLAYER(eMajor).IsAtWarWith(eOldOwner))
			{
				bLiberate = true;
			}
			// Coop war against the old owner?
			else if (GetCoopWarState(eMajor, eOldOwner) >= COOP_WAR_STATE_PREPARING)
			{
				bLiberate = true;
			}
			// They liberated us previously?
			else if (WasResurrectedBy(eMajor) || IsPlayerLiberatedCapital(eMajor) || IsPlayerLiberatedHolyCity(eMajor))
			{
				bLiberate = true;
			}
			// We liberated them previously?
			else if (GET_PLAYER(eMajor).GetDiplomacyAI()->WasResurrectedBy(GetID()) || GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerLiberatedCapital(GetID()) || GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerLiberatedHolyCity(GetID()))
			{
				bLiberate = true;
			}
			// Do we really like them?
			else if (eOpinion == MAJOR_CIV_OPINION_ALLY || GetDoFType(eMajor) >= DOF_TYPE_ALLIES || GetCoopWarScore(eMajor) > 1)
			{
				bLiberate = true;
			}
			// They liberated some of our cities before or vice versa, and at least Favorable?
			else if ((GetNumCitiesLiberatedBy(eMajor) > 0 || GET_PLAYER(eMajor).GetDiplomacyAI()->GetNumCitiesLiberatedBy(GetID()) > 0) && eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
			{
				bLiberate = !bBadWarDecision;
			}

			if (!bLiberate)
			{
				// Friends?
				if ((IsDoFAccepted(eMajor) && !IsWantsToEndDoFWithPlayer(eMajor)) || IsWantsDoFWithPlayer(eMajor) || IsHasDefensivePact(eMajor) || eOpinion >= MAJOR_CIV_OPINION_FRIEND || eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
				{
					// Going for diplo victory?
					if (IsGoingForDiploVictory() || IsCloseToDiploVictory())
					{
						bLiberate = true;
					}
					// Do we really like them?
					else if (eOpinion >= MAJOR_CIV_OPINION_FRIEND && eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
					{
						bLiberate = !bBadWarDecision;
					}
					// Going for culture victory, and we're okay for influence/victory against this guy?
					else if (GetVictoryFocus() == VICTORY_FOCUS_CULTURE)
					{
						bLiberate = !bBadWarDecision && GetVictoryDisputeLevel(eMajor) < DISPUTE_LEVEL_STRONG && GetVictoryBlockLevel(eMajor) < BLOCK_LEVEL_FIERCE && !IsEndgameAggressiveTo(eMajor);

						if (bLiberate && IsCloseToCultureVictory())
						{
							if (GetPlayer()->GetCulture()->GetInfluenceLevel(eMajor) < INFLUENCE_LEVEL_INFLUENTIAL)
							{
								if (GetPlayer()->GetCulture()->GetInfluenceLevel(eMajor) < INFLUENCE_LEVEL_POPULAR)
								{
									bLiberate = false;
								}
								else if (GetPlayer()->GetCulture()->GetInfluenceTrend(eMajor) != INFLUENCE_TREND_RISING)
								{
									bLiberate = false;
								}
							}
						}
					}
				}
			}
		}
		// Player we'd be liberating is dead (resurrection!)
		else if (!GET_PLAYER(eMajor).isHuman())
		{
			// Going for diplo victory? Resurrect for super diplo bonuses!
			if (IsGoingForDiploVictory() || IsCloseToDiploVictory())
			{
				bLiberate = true;
			}
			// They liberated us previously?
			else if (WasResurrectedBy(eMajor) || IsPlayerLiberatedCapital(eMajor) || IsPlayerLiberatedHolyCity(eMajor))
			{
				bLiberate = true;
			}
			// We liberated them previously?
			else if (GET_PLAYER(eMajor).GetDiplomacyAI()->WasResurrectedBy(GetID()) || GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerLiberatedCapital(GetID()) || GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerLiberatedHolyCity(GetID()))
			{
				bLiberate = true;
			}
			// We had good relations?
			else if (GetDoFType(eMajor) >= DOF_TYPE_ALLIES || GetCoopWarScore(eMajor) > 0)
			{
				bLiberate = true;
			}
			else
			{
				// Going for culture victory?
				if (IsGoingForCultureVictory())
				{
					bLiberate = !bBadWarDecision;
				}
				// Previous liberation?
				else if (GetNumCitiesLiberatedBy(eMajor) > 0 || GET_PLAYER(eMajor).GetDiplomacyAI()->GetNumCitiesLiberatedBy(GetID()) > 0)
				{
					bLiberate = !bBadWarDecision;
				}
				// Are we really willing to make friends?
				else if (GetDoFWillingness() >= 8 || GetLoyalty() >= 8)
				{
					bLiberate = !bBadWarDecision;
				}

				if (bLiberate && IsCloseToCultureVictory())
				{
					if (GetPlayer()->GetCulture()->GetInfluenceLevel(eMajor) < INFLUENCE_LEVEL_INFLUENTIAL)
					{
						bLiberate = false;
					}
				}
			}
		}
	}

	if (bLiberate)
	{
		GetPlayer()->DoLiberatePlayer(eMajor, pCity->GetID());
	}

	return bLiberate;
}

/// Is this a bad target to steal from?
bool CvDiplomacyAI::IsPlayerBadTheftTarget(PlayerTypes ePlayer, TheftTypes eTheftType, const CvPlot* pPlot /* = NULL */)
{
	// Failsafe
	if (pPlot == NULL)
	{
		if (eTheftType == THEFT_TYPE_TRADE_ROUTE || eTheftType == THEFT_TYPE_PLOT)
			return true;
	}

	if (ePlayer == NO_PLAYER || ePlayer == BARBARIAN_PLAYER || ePlayer == GetID() || !GET_PLAYER(ePlayer).isAlive())
		return false;

	if (IsAtWar(ePlayer))
		return false;

	// Handle minors here (only citadels and plots are applicable)
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		switch (eTheftType)
		{
		case THEFT_TYPE_CULTURE_BOMB:
			if (GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == GetID())
			{
				return true;
			}
			break;
		case THEFT_TYPE_PLOT: // America UA
			// Steal Natural Wonders and other teams' embassies, the City-State's feelings be damned!
			if (pPlot->IsNaturalWonder())
			{
				return false;
			}
			if (pPlot->IsImprovementEmbassy() && GET_PLAYER(pPlot->GetPlayerThatBuiltImprovement()).getTeam() != GetTeam())
			{
				return false;
			}
			if (GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == GetID())
			{
				return true;
			}
			break;
		}

		return false;
	}

	// Exception for religious conversion: Never a bad target if they haven't created a religion.
	if (eTheftType == THEFT_TYPE_CONVERSION && !GET_PLAYER(ePlayer).GetReligions()->HasCreatedReligion())
		return false;

	// If any of the below conditions are true, never steal from this player
	if (IsTeammate(ePlayer))
		return true;

	if (IsDoFAccepted(ePlayer))
		return true;

	if (GetNumCitiesLiberatedBy(ePlayer) > 0)
		return true;

	if (IsHasDefensivePact(ePlayer))
		return true;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	MajorCivApproachTypes eTrueApproach = GetMajorCivApproach(ePlayer);
	MajorCivApproachTypes eSurfaceApproach = GetSurfaceApproach(ePlayer);

	if (eOpinion == MAJOR_CIV_OPINION_ALLY)
		return true;

	if (eTrueApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	if (eOpinion >= MAJOR_CIV_OPINION_FRIEND && eTrueApproach >= MAJOR_CIV_APPROACH_FRIENDLY)
		return true;

	// Morocco can plunder trade routes with no diplo penalty if the plot is not visible to the other team, so use this
	// We want to know whether they can still see the plot *after* we plunder the caravan, so check for > 1
	bool bPlotIsVisibleToOtherTeam = false;
	if (eTheftType == THEFT_TYPE_TRADE_ROUTE)
	{
		bPlotIsVisibleToOtherTeam = (pPlot->getVisibilityCount(GET_PLAYER(ePlayer).getTeam()) > 1);
	}

	// Additional conditions depend on the type of theft we'd be doing
	switch (eTheftType)
	{
	case THEFT_TYPE_CULTURE_BOMB:
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(GetID()))
			return true;
		
		if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
			return true;

		if (IsVassal(ePlayer))
			return true;

		// Only steal if we're hostile or covet their lands
		if (eSurfaceApproach <= MAJOR_CIV_APPROACH_GUARDED || GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			return false;
		}
		
		return true;
		break;

	case THEFT_TYPE_CONVERSION:
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoConvertPromise(GetID()))
			return true;

		if (IsVassal(ePlayer))
			return true;

		return false;
		break;

	case THEFT_TYPE_ARTIFACT:
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeNoDiggingPromise(GetID()))
			return true;

		if (IsVassal(ePlayer))
			return true;

		return false;
		break;

	case THEFT_TYPE_SPY:
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeSpyPromise(GetID()))
			return true;

		if (IsVassal(ePlayer) && GetVassalTreatmentLevel(ePlayer) == VASSAL_TREATMENT_CONTENT)
			return true;
		
		return false;
		break;

	case THEFT_TYPE_TRADE_ROUTE: // Morocco UA
		if (eTrueApproach == MAJOR_CIV_APPROACH_FRIENDLY)
			return true;
		
		if (eTrueApproach == MAJOR_CIV_APPROACH_NEUTRAL && eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
			return true;

		if (IsVassal(ePlayer) && GetVassalTreatmentLevel(ePlayer) == VASSAL_TREATMENT_CONTENT)
			return true;

		if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
			return true;

		if (eSurfaceApproach == MAJOR_CIV_APPROACH_FRIENDLY && bPlotIsVisibleToOtherTeam)
			return true;

		if (eSurfaceApproach == MAJOR_CIV_APPROACH_NEUTRAL && eOpinion >= MAJOR_CIV_OPINION_FAVORABLE && bPlotIsVisibleToOtherTeam)
			return true;

		return false;
		break;

	case THEFT_TYPE_PLOT: // America UA
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeExpansionPromise(GetID()))
			return true;
		
		if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
			return true;

		if (IsVassal(ePlayer))
			return true;

		return false;
		break;
	}

	return false;
}

/// How many players that we're Competitive or more with is ePlayer at war with?
int CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith(PlayerTypes ePlayer)
{
	int iAtWarCount = 0;
	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

		if (IsPlayerValid(eLoopPlayer))
		{
			if (IsAtWar(eLoopPlayer))
			{
				if (GET_TEAM(eTeam).isAtWar(eLoopTeam))
				{
					iAtWarCount++;
				}
			}
		}
	}

	return iAtWarCount;
}

/// Does this player want to conquer the world?
bool CvDiplomacyAI::IsGoingForWorldConquest() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	if (eGrandStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
	{
		return true;
	}

	return false;
}

/// Does this player want to win by diplomacy?
bool CvDiplomacyAI::IsGoingForDiploVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");

	if (eGrandStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
	{
		return true;
	}

	return false;
}

/// Does this player want to win by culture?
bool CvDiplomacyAI::IsGoingForCultureVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	if (eGrandStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
	{
		return true;
	}

	return false;
}

/// Does this player want to win by science?
bool CvDiplomacyAI::IsGoingForSpaceshipVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	if (eGrandStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
	{
		return true;
	}

	return false;
}

/// Is this player close to ANY victory condition?
bool CvDiplomacyAI::IsCloseToAnyVictoryCondition() const
{
	if (IsCloseToDominationVictory() || IsCloseToSSVictory() || IsCloseToCultureVictory() || IsCloseToDiploVictory())
	{
		return true;
	}

	return false;
}

/// Is this player close to a science victory?
bool CvDiplomacyAI::IsCloseToSSVictory() const
{
	VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	
	if (!GC.getGame().isVictoryValid(eSpaceshipVictory))
	{
		return false;
	}
	
	if (GC.getGame().IsGameWon())
	{
		return false;
	}
	
	if (eSpaceshipVictory != NO_VICTORY)
	{
		int iProjectCount = GET_TEAM(GetTeam()).GetSSProjectCount();
		if (iProjectCount > 0)
		{
			return true;
		}

		int iTotalTechs = GC.getNumTechInfos();
		int iOurTechs = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();
		int iTechPercent = (iOurTechs * 100) / max(1, iTotalTechs);
		
		if (iTechPercent > 85)
		{
			int iNumCivsAheadScience = 0;
			int iNumCivsBehindScience = 0;
			int iNumCivsAlive = 0;

			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
				CvPlayer &kPlayer = GET_PLAYER(eLoopPlayer);

				if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian() && iPlayerLoop != GetID())
				{
					if (iOurTechs > GET_TEAM(kPlayer.getTeam()).GetTeamTechs()->GetNumTechsKnown())
					{
						iNumCivsAheadScience++;
					}
					else
					{
						iNumCivsBehindScience++;
					}
					iNumCivsAlive++;
				}
			}
			if (iNumCivsAlive > 0 && iNumCivsAheadScience > iNumCivsBehindScience)
			{
				return true;
			}
		}
	}	

	return false;
}

/// Is this player close to a domination victory?
bool CvDiplomacyAI::IsCloseToDominationVictory() const
{
	// Not close to victory if player cannot attempt Domination Victory.
	if (!GC.getGame().CanPlayerAttemptDominationVictory(GetID()))
		return false;

	if (GetPlayer()->GetFractionOriginalCapitalsUnderControl() >= 75)
		return true;

	return false;
}

/// Is this player close to a cultural victory?
bool CvDiplomacyAI::IsCloseToCultureVictory() const
{
	VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	
	if (!GC.getGame().isVictoryValid(eCulturalVictory))
	{
		return false;
	}
	
	if (GC.getGame().IsGameWon())
	{
		return false;
	}

	ProjectTypes eUtopia = (ProjectTypes)GC.getInfoTypeForString("PROJECT_UTOPIA_PROJECT", true);
	if (eUtopia != NO_PROJECT && GET_TEAM(GetTeam()).getProjectMaking(eUtopia) > 0)
	{
		return true;
	}
	
	// % of influenced civs isn't important if we're not at least in the Modern Era
	if (GetPlayer()->GetCurrentEra() < 5)
	{
		return false;
	}
	
	int iNumCivsInfluential = GetPlayer()->GetCulture()->GetNumCivsInfluentialOn();
	if (iNumCivsInfluential > 0)
	{
		int iNumCivsAlive = GetPlayer()->GetCulture()->GetNumCivsToBeInfluentialOn();

		if (iNumCivsInfluential == iNumCivsAlive)
			return true;

		int iPercentToGo = iNumCivsInfluential * 100 / max(1,iNumCivsAlive);
		int iPercentToCheck = 0;
		if (iNumCivsAlive >= 4)
			iPercentToCheck = 50;
		else if (iNumCivsAlive == 3)
			iPercentToCheck = 25;
		else
			iPercentToCheck = 0;

		if (iPercentToGo >= iPercentToCheck)
		{
			PlayerTypes eFinalPlayer = GetPlayer()->GetCulture()->GetCivLowestInfluence(false);
			if (eFinalPlayer != NO_PLAYER && GetPlayer()->GetCulture()->GetTurnsToInfluential(eFinalPlayer) <= 75)
			{
				return true;
			}
		}
	}

	return false;
}

/// Is this player close to a diplomatic victory?
bool CvDiplomacyAI::IsCloseToDiploVictory() const
{
	VictoryTypes eDiplomaticVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);
	
	if (!GC.getGame().isVictoryValid(eDiplomaticVictory))
	{
		return false;
	}
	
	if (GC.getGame().IsGameWon())
	{
		return false;
	}
	
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (pLeague != NULL)
	{
		int iVotes = GC.getGame().GetGameLeagues()->GetActiveLeague()->CalculateStartingVotesForMember(GetID());
		int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();
		iVotesNeededToWin *= 75;
		iVotesNeededToWin /= 100;
		if (iVotes >= iVotesNeededToWin)
		{
			return true;
		}
	}

	return false;
}

/// AI is doing something with a Minor civ
void CvDiplomacyAI::LogMinorCivGiftTile(PlayerTypes eMinor)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gift amount
		strTemp.Format("Tile Improvement");
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
	}
}
void CvDiplomacyAI::LogMinorCivGiftGold(PlayerTypes eMinor, int iOldFriendship, int iGold, bool bSaving, bool bWantQuickBoost, PlayerTypes ePlayerTryingToPass)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gift amount
		strTemp.Format("Gold Gift: %d", iGold);
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendship, GET_PLAYER(eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetID()));
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Saving Gold for Gift
		if(bSaving)
			strOutBuf += ", (SAVING) ";

		// Wants a quick boost
		if(bWantQuickBoost)
			strOutBuf += ", Boost! ";

		// Trying to pass up a player!
		if(ePlayerTryingToPass != NO_PLAYER)
		{
			strOutBuf += ", Passing ";
			strOutBuf += GET_PLAYER(ePlayerTryingToPass).getCivilizationShortDescription();
		}

		pLog->Msg(strOutBuf);
	}
}

/// AI is doing something with a Minor civ
void CvDiplomacyAI::LogMinorCivBullyGold(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, int iGold, bool bSuccess, int iBullyMetricScore)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gold tribute
		strTemp.Format("Gold Bully: %d", iGold);
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Did it work?
		if(bSuccess)
		{
			strOutBuf += ", ";
			strOutBuf += "Success!";
		}
		else
		{
			strOutBuf += ", ";
			strOutBuf += "Failure";
		}

		// Append the bully metric score
		strTemp.Format("Bully Score: %d", iBullyMetricScore);
		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);
	}
}

void CvDiplomacyAI::LogMinorCivBullyHeavy(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, YieldTypes eYield, int iValue, bool bSuccess, int iBullyMetricScore)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Heavy tribute
		strTemp.Format("Heavy Tribute Bully: %d %s", iValue, GC.getYieldInfo(eYield)->GetDescription());
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Did it work?
		if (bSuccess)
		{
			strOutBuf += ", ";
			strOutBuf += "Success!";
		}
		else
		{
			strOutBuf += ", ";
			strOutBuf += "Failure";
		}

		// Append the bully metric score
		strTemp.Format("Bully Score: %d", iBullyMetricScore);
		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);
	}
}

void CvDiplomacyAI::LogMinorCivBullyUnit(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, UnitTypes eUnit, bool bSuccess, int iBullyMetricScore)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Unit tribute
		strTemp.Format("Unit Bully: %s", eUnit == (UnitTypes) GC.getInfoTypeForString("UNIT_WORKER") ? "Worker" : "Other unit");
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Did it work?
		if(bSuccess)
		{
			strOutBuf += ", ";
			strOutBuf += "Success!";
		}
		else
		{
			strOutBuf += ", ";
			strOutBuf += "Failure";
		}

		// Append the bully metric score
		strTemp.Format("Bully Score: %d", iBullyMetricScore);
		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);
	}
}

/// A quest was given to us, so log it
void CvDiplomacyAI::LogMinorCivQuestReceived(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "RECEIVED QUEST";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
	}
}

/// We finished a quest! Now log it
void CvDiplomacyAI::LogMinorCivQuestFinished(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "FINISHED QUEST";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
	}
}

/// A quest became obsolete and was cancelled, so log it
void CvDiplomacyAI::LogMinorCivQuestCancelled(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "cancelled";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
	}
}

/// A minor civ was bought, and possession changed
void CvDiplomacyAI::LogMinorCivBuyout(PlayerTypes eMinor, int iGoldPaid, bool bSaving)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		strTemp.Format("BUYOUT: %d", iGoldPaid);
		strOutBuf += ", " + strTemp;

		// Spacing
		strOutBuf += ", , ";

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Saving Gold for Gift
		if(bSaving)
			strOutBuf += ", (SAVING) ";

		pLog->Msg(strOutBuf);
	}
}

/// Deal to renew
CvDeal* CvDiplomacyAI::GetDealToRenew(PlayerTypes eOtherPlayer)
{
	if (GetPlayer()->isHuman())
		return NULL;

	CvDeal* pTargetDeal = NULL;
	CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();

	int iNumDeals = kGameDeals.GetRenewableDealsWithPlayer(m_pPlayer->GetID(), eOtherPlayer);

	for(int iDeal = 0; iDeal < iNumDeals; iDeal++)
	{
		 CvDeal* pCurrentDeal = kGameDeals.GetRenewableDealWithPlayer(m_pPlayer->GetID(), eOtherPlayer, iDeal);

		if (pCurrentDeal->m_bConsideringForRenewal)
		{
			return pCurrentDeal;
		}
	}

	return pTargetDeal;
}

void CvDiplomacyAI::CleanupRenewDeals(PlayerTypes eOtherPlayer)
{
	if (GetPlayer()->isHuman())
		return;

	CvDeal* pTargetDeal = NULL;
	CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();

	int iNumDeals = kGameDeals.GetRenewableDealsWithPlayer(m_pPlayer->GetID(), eOtherPlayer);

	for (int iDeal = 0; iDeal < iNumDeals; iDeal++)
	{
		CvDeal* pCurrentDeal = kGameDeals.GetRenewableDealWithPlayer(m_pPlayer->GetID(), eOtherPlayer, iDeal);
		if (pCurrentDeal->m_bConsideringForRenewal)
		{
			pTargetDeal = pCurrentDeal;
			continue;
		}
		//we only want one deal per player.
		if (pTargetDeal != NULL)
			pCurrentDeal->m_bConsideringForRenewal = false;
	}
}

/// Deal to renew
void CvDiplomacyAI::CancelRenewDeal(PlayerTypes eOtherPlayer, RenewalReason eReason, bool bJustLogging)
{
	if (GetPlayer()->isHuman())
		return;

	CvDeal* pRenewalDeal = GetDealToRenew(eOtherPlayer);

	if (!pRenewalDeal)
		return;

	if (!bJustLogging)
	{
		TradedItemList::iterator itemIter;
		for (itemIter = pRenewalDeal->m_TradedItems.begin(); itemIter != pRenewalDeal->m_TradedItems.end(); ++itemIter)
		{
			//OutputDebugString("Cleared item from expired renewal deal \n");
			//If we checked for renewal, we don't need to remove items, as we already did it.
			GC.getGame().GetGameDeals().DoEndTradedItem(&*itemIter, pRenewalDeal->GetOtherPlayer(itemIter->m_eFromPlayer), false, pRenewalDeal->m_bCheckedForRenewal);
		}
	}
	pRenewalDeal->m_bConsideringForRenewal = false;

	//log it for me bby
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_TradeAgreements_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_TradeAgreements_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(eOtherPlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ", * TRADE RENEWAL CANCELED*, " + otherPlayerName;

		TradedItemList::iterator itemIter;
		for (itemIter = pRenewalDeal->m_TradedItems.begin(); itemIter != pRenewalDeal->m_TradedItems.end(); ++itemIter)
		{
			CvString strItems;
			strItems.Format(",ItemType: %d, ", (int)itemIter->m_eItemType);
			strOutBuf += strItems;
		}

		CvString strReason;
		switch (eReason)
		{
		case NO_REASON:
			strReason.Format(",REASON: No Reason Given");
			strOutBuf += strReason;
			break;
		case REASON_NO_GPT:
			strReason.Format(",REASON: Invalid Items");
			strOutBuf += strReason;
			break;
		case REASON_NO_DEAL:
			strReason.Format(",REASON: No Deal Found");
			strOutBuf += strReason;
			break;
		case REASON_CANNOT_COMPROMISE:
			strReason.Format(",REASON: Cannot Re-negotiate with AI");
			strOutBuf += strReason;
			break;
		case REASON_HUMAN_REJECTION:
			strReason.Format(",REASON: Human Rejection");
			strOutBuf += strReason;
			break;
		}
		pLog->Msg(strOutBuf);
	}
}


// When someone dies, clear out data
void CvDiplomacyAI::KilledPlayerCleanup (PlayerTypes eKilledPlayer)
{
	// clear out coop war agreements
	CancelCoopWarsAgainstPlayer(eKilledPlayer);

	// reset locked war turns
	if (GET_PLAYER(eKilledPlayer).getTeam() != GetTeam())
	{
		GET_TEAM(GetTeam()).SetNumTurnsLockedIntoWar(GET_PLAYER(eKilledPlayer).getTeam(), 0);
		GET_TEAM(GET_PLAYER(eKilledPlayer).getTeam()).SetNumTurnsLockedIntoWar(GetTeam(), 0);
	}

	// clear out planning exchanges, attack operations
	SetWantsDoFWithPlayer(eKilledPlayer, false);
	SetWantsDefensivePactWithPlayer(eKilledPlayer, false);
	SetWantsResearchAgreementWithPlayer(eKilledPlayer, false);
	SetArmyInPlaceForAttack(eKilledPlayer, false);
	SetWantsSneakAttack(eKilledPlayer, false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetWantsDoFWithPlayer(GetID(), false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetWantsDefensivePactWithPlayer(GetID(), false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetWantsResearchAgreementWithPlayer(GetID(), false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetArmyInPlaceForAttack(GetID(), false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetWantsSneakAttack(GetID(), false);
	
	// Clear certain promise values
	SetPlayerExpansionPromiseState(eKilledPlayer, NO_PROMISE_STATE);
	SetPlayerBorderPromiseState(eKilledPlayer, NO_PROMISE_STATE);
	SetPlayerMilitaryPromiseState(eKilledPlayer, NO_PROMISE_STATE);
	SetPlayerBullyCityStatePromiseState(eKilledPlayer, NO_PROMISE_STATE);
	SetPlayerAttackCityStatePromiseState(eKilledPlayer, NO_PROMISE_STATE);
	SetPlayerAskedNotToConvert(eKilledPlayer, false);
	SetPlayerAskedNotToDig(eKilledPlayer, false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerExpansionPromiseState(GetID(), NO_PROMISE_STATE);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerBorderPromiseState(GetID(), NO_PROMISE_STATE);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState(GetID(), NO_PROMISE_STATE);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerBullyCityStatePromiseState(GetID(), NO_PROMISE_STATE);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerAttackCityStatePromiseState(GetID(), NO_PROMISE_STATE);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerAskedNotToConvert(GetID(), false);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetPlayerAskedNotToDig(GetID(), false);

	SetVassalProtectValue(eKilledPlayer, 0);
	SetVassalFailedProtectValue(eKilledPlayer, 0);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetVassalProtectValue(GetID(), 0);
	GET_PLAYER(eKilledPlayer).GetDiplomacyAI()->SetVassalFailedProtectValue(GetID(), 0);

	SetWarmongerThreat(eKilledPlayer, THREAT_NONE);
	SetOtherPlayerWarmongerAmountTimes100(eKilledPlayer, 0);
}


// ************************************
// LOGGING (PRIVATE FUNCTIONS)
// ************************************

/// Helper function to return this player's ID more conveniently
PlayerTypes CvDiplomacyAI::GetID() const
{
	return m_pPlayer->GetID();
}

//	-----------------------------------------------------------------------------------------------

// ////////////////////////////////////
// Estimations of other players' tendencies
// ////////////////////////////////////

// Recursive: Because of how Firaxis programmed the diplomacy flavors, a separate estimation function is necessary for each of them, plus one for other flavors
// For Diplo Personality Type, just grab the other leader's personality instead of estimating ...
// ... humans can learn this by studying opinion modifiers whenever the AI's approach isn't FRIENDLY (or with Transparent Diplomacy enabled)

/// How much do we estimate this other leader gets angry when another player is competing for Victory?
int CvDiplomacyAI::GetEstimatePlayerVictoryCompetitiveness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetVictoryCompetitiveness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetVictoryCompetitiveness(), 10));
}

/// How much do we estimate this other leader gets angry when they're beaten to a World Wonder?
int CvDiplomacyAI::GetEstimatePlayerWonderCompetitiveness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWonderCompetitiveness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetWonderCompetitiveness(), 10));
}

/// How much do we estimate this other leader gets angry when another player is befriending "their" minor civs?
int CvDiplomacyAI::GetEstimatePlayerMinorCivCompetitiveness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivCompetitiveness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetMinorCivCompetitiveness(), 10));
}

/// What is this other leader's estimated likelihood to take risks / go for World Conquest?
int CvDiplomacyAI::GetEstimatePlayerBoldness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetBoldness(), 10));
}

/// How much do we estimate this other leader wants to maintain a balance of power in the world?
int CvDiplomacyAI::GetEstimatePlayerDiploBalance(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDiploBalance();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetDiploBalance(), 10));
}

/// How much does this other leader gets angry when someone's being a warmonger?
int CvDiplomacyAI::GetEstimatePlayerWarmongerHate(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarmongerHate();
	}

	int iRtnValue = /*5*/ GC.getGame().GetDefaultFlavorValue();

	// Human or Random Personalities? Assume the default flavor value.
	if (!GET_PLAYER(ePlayer).isHuman())
	{
		if (!GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
		{
			// AI? Use the other player's base XML value.
			iRtnValue = GET_PLAYER(ePlayer).getLeaderInfo().GetWarmongerHate();
		}

		// Special: If we currently have warmongering penalties with this player, we have a better idea of their flavor...
		// This uses the warmonger hate thresholds from the opinion table in LuaPlayer
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarmongerThreatScore(GetID()) > 0)
		{
			int iActualValue = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarmongerHate();
			if (iActualValue >= 7 && iRtnValue < 7)
			{
				iRtnValue = 7;
			}
			else if (iActualValue <= 4 && iRtnValue > 4)
			{
				iRtnValue = 4;
			}
			else if (iActualValue == 5 || iActualValue == 6)
			{
				if (iRtnValue < 5)
				{
					iRtnValue = 5;
				}
				else if (iRtnValue > 6)
				{
					iRtnValue = 6;
				}
			}
		}
	}

	return max(1, min(iRtnValue, 10));
}

/// What is this other leader's estimated likelihood to work with someone AGAINST another player?
int CvDiplomacyAI::GetEstimatePlayerDenounceWillingness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDenounceWillingness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetDenounceWillingness(), 10));
}

/// What is this other leader's estimated likelihood to befriend other players?
int CvDiplomacyAI::GetEstimatePlayerDoFWillingness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDoFWillingness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetDoFWillingness(), 10));
}

/// What is this other leader's estimated likelihood to refrain from backstabbing their friends?
int CvDiplomacyAI::GetEstimatePlayerLoyalty(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetLoyalty();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetLoyalty(), 10));
}

/// How much do we estimate this other leader wants the support of its friends in rough times?
int CvDiplomacyAI::GetEstimatePlayerNeediness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNeediness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetNeediness(), 10));
}

/// How much do we estimate this other leader is willing to forgive transgressions against them?
int CvDiplomacyAI::GetEstimatePlayerForgiveness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetForgiveness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetForgiveness(), 10));
}

/// How much do we estimate this other leader likes to pop up and talk?
int CvDiplomacyAI::GetEstimatePlayerChattiness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetChattiness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetChattiness(), 10));
}

/// How much do we estimate this other leader likes to talk smack / bully others?
int CvDiplomacyAI::GetEstimatePlayerMeanness(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMeanness();
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetMeanness(), 10));
}

/// What is our estimate of another leader's bias for a particular Major Civ Approach?
int CvDiplomacyAI::GetEstimatePlayerMajorCivApproachBias(PlayerTypes ePlayer, MajorCivApproachTypes eApproach) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	if (eApproach < 0 || eApproach >= NUM_MAJOR_CIV_APPROACHES) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPersonalityMajorCivApproachBias(eApproach);
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetMajorCivApproachBias((int)eApproach), 10));
}

/// What is our estimate of another leader's bias for a particular Minor Civ Approach?
int CvDiplomacyAI::GetEstimatePlayerMinorCivApproachBias(PlayerTypes ePlayer, MinorCivApproachTypes eApproach) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	if (eApproach < 0 || eApproach >= NUM_MINOR_CIV_APPROACHES) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPersonalityMinorCivApproachBias(eApproach);
	}

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return /*5*/ GC.getGame().GetDefaultFlavorValue();
	}

	// AI? Use the other player's base XML value.
	return max(1, min(GET_PLAYER(ePlayer).getLeaderInfo().GetMinorCivApproachBias((int)eApproach), 10));
}

/// What is our estimate of another leader's value for a personality flavor?
int CvDiplomacyAI::GetEstimatePlayerFlavorValue(PlayerTypes ePlayer, FlavorTypes eFlavor) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;
	if (eFlavor < 0 || eFlavor >= GC.getNumFlavorTypes()) return 0;

	// We always know our team's flavors
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return GET_PLAYER(ePlayer).GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);
	}

	int iRtnValue = /*5*/ GC.getGame().GetDefaultFlavorValue();

	// Human or Random Personalities? Assume the default flavor value.
	if (GET_PLAYER(ePlayer).isHuman() || GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
	{
		return iRtnValue;
	}

	// AI? Use the other player's base XML value.
	LeaderHeadTypes leader = GET_PLAYER(ePlayer).getPersonalityType();
	if (leader != NO_LEADER)
	{
		CvLeaderHeadInfo* pkLeaderHeadInfo = GC.getLeaderHeadInfo(leader);
		if (pkLeaderHeadInfo)
		{
			iRtnValue = pkLeaderHeadInfo->getFlavorValue((int)eFlavor);
		}
	}

	return max(1, min(iRtnValue, 20));
}

/// What is the difference between a player's personality flavor value and the default (average) flavor value?
int CvDiplomacyAI::GetDifferenceFromAverageFlavorValue(int iValue) const
{
	int iDefaultFlavorValue = /*5*/ GC.getGame().GetDefaultFlavorValue();
	return iValue - iDefaultFlavorValue;
}

//	-----------------------------------------------------------------------------------------------

/// Log public declaration made by this AI
void CvDiplomacyAI::LogPublicDeclaration(PublicDeclarationTypes eDeclaration, int iData1, PlayerTypes eForSpecificPlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		// JON: Disabling some logspam
		if(eForSpecificPlayer != NO_PLAYER)
			return;

		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		strOutBuf = strBaseString;

		// Is this declaration for a specific player (one we met after we made the declaration?)
		if(eForSpecificPlayer != NO_PLAYER)
		{
			otherPlayerName = GET_PLAYER(eForSpecificPlayer).getCivilizationShortDescription();
			strTemp = "To " + otherPlayerName;
			strOutBuf += ", " + strTemp;
		}

		PlayerTypes eMinorCiv;

		bool bMinorMessage = false;

		switch(eDeclaration)
		{
		case PUBLIC_DECLARATION_PROTECT_MINOR:
			eMinorCiv = (PlayerTypes) iData1;
			otherPlayerName = GET_PLAYER(eMinorCiv).getCivilizationShortDescription();
			strTemp = "We're now protecting " + otherPlayerName + "!";
			bMinorMessage = true;
			break;
		case PUBLIC_DECLARATION_ABANDON_MINOR:
			eMinorCiv = (PlayerTypes) iData1;
			otherPlayerName = GET_PLAYER(eMinorCiv).getCivilizationShortDescription();
			strTemp = "We've abandoned " + otherPlayerName + "!";
			bMinorMessage = true;
			break;
		default:
			strTemp.Format("Unknown Declaration!!!");
			break;
		}

		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);

		// Also send message to Minor Civ log if applicable
		if(bMinorMessage)
		{
			// Open the log file
			if(GC.getPlayerAndCityAILogSplit())
				strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
			else
				strLogName = "DiplomacyAI_MinorCiv_Log.csv";

			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}
	}
}

/// Log war declaration
void CvDiplomacyAI::LogWarDeclaration(PlayerTypes ePlayer, int iTotalWarWeight)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ", ***** WAR DECLARATION! *****, " + otherPlayerName;

		if(iTotalWarWeight >= 0)
		{
			CvString strWarWeight;
			strWarWeight.Format(", %d, ", iTotalWarWeight);
			strOutBuf += strWarWeight;
		}

		pLog->Msg(strOutBuf);

		// Want this in DiploMessage Log
//		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			if(GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Messages_Log.csv";
			}
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}

		// Log it to military AI too
		m_pPlayer->GetMilitaryAI()->LogDeclarationOfWar(ePlayer);
	}
}


/// Log war declaration
void CvDiplomacyAI::LogPeaceMade(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ", ***** PEACE MADE! *****, " + otherPlayerName;

		pLog->Msg(strOutBuf);

		// Want this in DiploMessage Log
//		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			if(GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Messages_Log.csv";
			}
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}

		// Log it to military AI too
		m_pPlayer->GetMilitaryAI()->LogPeace(ePlayer);
	}
}


/// Log working with a player
void CvDiplomacyAI::LogDoF(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

		CvString strRank; 
		strRank.Format("Rank: %03d, ", (int)GetDoFType(ePlayer));
		strOutBuf = strBaseString + ",***** NOW FRIENDS " + otherPlayerName + strRank + "! *****";

		pLog->Msg(strOutBuf);
	}
}

/// Log DoF Broken with a player
void CvDiplomacyAI::LogBrokenDoF(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** NO LONGER FRIENDS " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);
	}
}

/// Log working with a player
void CvDiplomacyAI::LogDenounce(PlayerTypes ePlayer, bool bBackstab, bool bRefusal)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		//CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		if(bBackstab)
			strOutBuf = strBaseString + ",***** BACKSTABBED " + otherPlayerName + "! *****";
		else if(bRefusal)
			strOutBuf = strBaseString + ",***** REFUSED TO FORGIVE " + otherPlayerName + "! *****";
		else
#if defined(MOD_BALANCE_CORE)
		{
			strOutBuf = strBaseString + ",***** DENOUNCED GENERIC " + otherPlayerName + "! *****";
			int iMessage = GetDenounceMessage(ePlayer);
			if(iMessage != 0 && iMessage <= 7)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF IDEOLOGY " + otherPlayerName + "! *****";
			}
			else if(iMessage == 8)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF WARMONGER " + otherPlayerName + "! *****";
			}
			else if(iMessage == 9)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF MINORS " + otherPlayerName + "! *****";
			}
			else if(iMessage == 10)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF BULLYING" + otherPlayerName + "! *****";
			}
			else if(iMessage == 11)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF NUKES " + otherPlayerName + "! *****";
			}
			else if(iMessage == 12)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF SPYING " + otherPlayerName + "! *****";
			}
			else if(iMessage == 13)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF LAND " + otherPlayerName + "! *****";
			}
			else if(iMessage == 14)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE IS ENEMY OF FRIEND " + otherPlayerName + "! *****";
			}
			else if(iMessage == 15)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE DOGPILE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 16)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE UNTRUSTWORTHY " + otherPlayerName + "! *****";
			}
			else if(iMessage == 17)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE UNFORGIVEABLE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 18)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF RELIGION " + otherPlayerName + "! *****";
			}
			else if(iMessage == 19)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF DIGGING " + otherPlayerName + "! *****";
			}		
			else if(iMessage == 20)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF WONDERS " + otherPlayerName + "! *****";
			}
			else if(iMessage == 21)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF VICTORY DISPUTE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 22)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF VICTORY BLOCK " + otherPlayerName + "! *****";
			}
		}
#else
			strOutBuf = strBaseString + ",***** DENOUNCED " + otherPlayerName + "! *****";
#endif

		pLog->Msg(strOutBuf);
	}
}

/// Log friend asks another to denounce someone
void CvDiplomacyAI::LogFriendRequestDenounce(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, bool bAgreed)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		// Did they actually agree?
		if(bAgreed)
			strOutBuf = strBaseString + ",***** CONVINCED " + otherPlayerName + " TO DENOUNCE " + againstPlayerName + "! *****";
		else
			strOutBuf = strBaseString + ", ASKED " + otherPlayerName + " TO DENOUNCE " + againstPlayerName + "!";

		pLog->Msg(strOutBuf);
	}
}


/// Log coop war state change update
void CvDiplomacyAI::LogCoopWar(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, CoopWarStates eState)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString withPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		switch (eState)
		{
		case NO_COOP_WAR_STATE:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: Coop war state with player " + withPlayerName + " against " + againstPlayerName + " has been reset (NO COOP WAR STATE).";
			break;
		case COOP_WAR_STATE_WARNED_TARGET:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: We warned " + againstPlayerName + " about " + withPlayerName + "'s coop war plans (WARNED TARGET).";
			break;
		case COOP_WAR_STATE_REJECTED:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: We rejected " + withPlayerName + "'s request to go to war against " + againstPlayerName + " (REJECTED).";
			break;
		case COOP_WAR_STATE_PREPARING:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: We are preparing to go to war with " + withPlayerName + " against " + againstPlayerName + " (PREPARING).";
			break;
		case COOP_WAR_STATE_READY:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: We are ready to go to war with " + withPlayerName + " against " + againstPlayerName + " (READY).";
			break;
		case COOP_WAR_STATE_ONGOING:
			strOutBuf = strBaseString + ",***** COOP WAR STATE CHANGE: We are now in a coop war with " + withPlayerName + " against " + againstPlayerName + " (ONGOING).";
			break;
		default:
			strOutBuf = strBaseString + ", ERROR! Invalid coop war state for " + withPlayerName + " against " + againstPlayerName + ".";
		}

		pLog->Msg(strOutBuf);
	}
}

/// Log player wanting a RA
void CvDiplomacyAI::LogWantRA(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + otherPlayerName + ", Wants Research Agreement!";

		pLog->Msg(strOutBuf);
	}
}

/// Log player wanting a DP
void CvDiplomacyAI::LogWantDP(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + otherPlayerName + ", Wants Defensive Pact!";

		pLog->Msg(strOutBuf);
	}
}

/// Log Major Civ Opinion Update
void CvDiplomacyAI::LogOpinionUpdate(PlayerTypes ePlayer, std::vector<int>& viOpinionValues)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strTemp.Format("OPINION");
		strOutBuf += ", " + strTemp;

		MajorCivOpinionTypes eMajorCivOpinion;
		//		MinorCivOpinionTypes eMinorCivOpinion;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// Current Opinion
			switch(GetMajorCivOpinion(ePlayer))
			{
			case MAJOR_CIV_OPINION_ALLY:
				strTemp.Format("** ALLY **");
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				strTemp.Format("FRIEND");
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				strTemp.Format("Favorable");
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				strTemp.Format("N");
				break;
			case MAJOR_CIV_OPINION_COMPETITOR:
				strTemp.Format("Competitor");
				break;
			case MAJOR_CIV_OPINION_ENEMY:
				strTemp.Format("ENEMY");
				break;
			case MAJOR_CIV_OPINION_UNFORGIVABLE:
				strTemp.Format("**UNFORGIVABLE**");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf += ", " + strTemp;

			for(int iMajorCivOpinionLoop = 0; iMajorCivOpinionLoop < NUM_MAJOR_CIV_OPINIONS; iMajorCivOpinionLoop++)
			{
				eMajorCivOpinion = (MajorCivOpinionTypes) iMajorCivOpinionLoop;

				switch(eMajorCivOpinion)
				{
				case MAJOR_CIV_OPINION_ALLY:
					strTemp.Format("Ally");
					break;
				case MAJOR_CIV_OPINION_FRIEND:
					strTemp.Format("Friend");
					break;
				case MAJOR_CIV_OPINION_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				case MAJOR_CIV_OPINION_COMPETITOR:
					strTemp.Format("Competitor");
					break;
				case MAJOR_CIV_OPINION_ENEMY:
					strTemp.Format("Enemy");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", viOpinionValues[eMajorCivOpinion]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}
#if defined(MOD_BALANCE_CORE)
/// Log Major Civ Approach Update
void CvDiplomacyAI::LogApproachValueDeltas(PlayerTypes ePlayer, const int* aiApproachValues, const int* aiScratchValues)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Deltas_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Deltas_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		MajorCivApproachTypes eMajorCivApproach;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			strTemp.Format("Opinion: %d", GetMajorCivOpinionWeight(ePlayer));
			strOutBuf += ", " + strTemp;

			// Weights for each possible Approach
			for(int iMajorCivApproachLoop = 0; iMajorCivApproachLoop < NUM_MAJOR_CIV_APPROACHES; iMajorCivApproachLoop++)
			{
				eMajorCivApproach = (MajorCivApproachTypes) iMajorCivApproachLoop;

				switch(eMajorCivApproach)
				{
				case MAJOR_CIV_APPROACH_WAR:
					strTemp.Format("War");
					break;
				case MAJOR_CIV_APPROACH_HOSTILE:
					strTemp.Format("Hostile");
					break;
				case MAJOR_CIV_APPROACH_DECEPTIVE:
					strTemp.Format("Deceptive");
					break;
				case MAJOR_CIV_APPROACH_GUARDED:
					strTemp.Format("Guarded");
					break;
				case MAJOR_CIV_APPROACH_AFRAID:
					strTemp.Format("Afraid");
					break;
				case MAJOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MAJOR_CIV_APPROACH_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}

				strOutBuf += ", " + strTemp;

				strTemp.Format("Value: %d", aiApproachValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;

				strTemp.Format("Scratch: %d", aiScratchValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;

				int iDelta = 0;
				if(aiApproachValues[eMajorCivApproach] >= aiScratchValues[eMajorCivApproach])
				{
					iDelta = (aiApproachValues[eMajorCivApproach] - aiScratchValues[eMajorCivApproach]);
					strTemp.Format("Delta: +%d", iDelta);
					strOutBuf += ", " + strTemp;
				}
				else
				{
					iDelta = (aiScratchValues[eMajorCivApproach] - aiApproachValues[eMajorCivApproach]);
					strTemp.Format("Delta: -%d", iDelta);
					strOutBuf += ", " + strTemp;
				}
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}
#endif

/// Log Major Civ Warmonger Threat update
void CvDiplomacyAI::LogMajorCivWarmongerUpdate(PlayerTypes ePlayer, int iValue, bool bUpdateLogsSpecial)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_WarmongerStatus_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_WarmongerStatus_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		// Don't fill out this field for Minors, as it just makes the log harder to read
		if (GET_PLAYER(ePlayer).isMinorCiv())
		{
			strTemp.Format(",");
		}
		else
		{
			int iResistance = m_pPlayer->GetDominationResistance(ePlayer);

			if (bUpdateLogsSpecial)
			{
				switch (GetWarmongerThreat(ePlayer))
				{
				case THREAT_CRITICAL:
					strTemp.Format(" -- NEW STATUS -- W_THT CRIT, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_SEVERE:
					strTemp.Format(" -- NEW STATUS -- W_THT SEVR, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_MAJOR:
					strTemp.Format(" -- NEW STATUS -- W_THT MAJR, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_MINOR:
					strTemp.Format(" -- NEW STATUS -- W_THT MINR, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_NONE:
					strTemp.Format(" -- NEW STATUS -- W_THT NONE, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				default:
					strTemp.Format(" -- NEW STATUS -- W_THT XXXX, %d/%d, Decay: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				}
			}
			else
			{
				strTemp.Format(" -- %d/%d, Decay: %d, Resistance : %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
			}
		}

		strOutBuf = strBaseString + strTemp;
		pLog->Msg(strOutBuf);
	}
}

/// Log Major Civ Approach Update
void CvDiplomacyAI::LogMajorCivApproachUpdate(PlayerTypes ePlayer, const int* aiApproachValues, MajorCivApproachTypes eNewMajorCivApproach, MajorCivApproachTypes eOldApproach, MajorCivApproachTypes eSurfaceApproach)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		MajorCivApproachTypes eMajorCivApproach;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			LogMajorCivApproach(strOutBuf, eNewMajorCivApproach, eSurfaceApproach);

			if(eNewMajorCivApproach != eOldApproach)
			{
				LogMajorCivApproach(strOutBuf, eOldApproach, eSurfaceApproach);
			}
			else
			{
				strTemp.Format("---");
				strOutBuf += ", " + strTemp;
			}

			LogOpinion(strOutBuf, ePlayer);

			LogWarmongerThreat(strOutBuf, ePlayer);

			LogMilitaryThreat(strOutBuf, ePlayer);

			LogTargetValue(strOutBuf, ePlayer);

			LogWarGoal(strOutBuf, ePlayer);

			LogMilitaryAggressivePosture(strOutBuf, ePlayer);

			LogProximity(strOutBuf, ePlayer);

			LogLandDispute(strOutBuf, ePlayer);

			LogVictoryDispute(strOutBuf, ePlayer);

			LogVictoryBlock(strOutBuf, ePlayer);

			LogWonderDispute(strOutBuf, ePlayer);

			LogMinorCivDispute(strOutBuf, ePlayer);

			strTemp.Format("---");
			strOutBuf += ", " + strTemp;

			// Weights for each possible Approach
			for(int iMajorCivApproachLoop = 0; iMajorCivApproachLoop < NUM_MAJOR_CIV_APPROACHES; iMajorCivApproachLoop++)
			{
				eMajorCivApproach = (MajorCivApproachTypes) iMajorCivApproachLoop;

				switch(eMajorCivApproach)
				{
				case MAJOR_CIV_APPROACH_WAR:
					strTemp.Format("War");
					break;
				case MAJOR_CIV_APPROACH_HOSTILE:
					strTemp.Format("Hostile");
					break;
				case MAJOR_CIV_APPROACH_DECEPTIVE:
					strTemp.Format("Deceptive");
					break;
				case MAJOR_CIV_APPROACH_GUARDED:
					strTemp.Format("Guarded");
					break;
				case MAJOR_CIV_APPROACH_AFRAID:
					strTemp.Format("Afraid");
					break;
				case MAJOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MAJOR_CIV_APPROACH_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", aiApproachValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}


/// Log Minor Civ Approach Update
void CvDiplomacyAI::LogMinorCivApproachUpdate(PlayerTypes ePlayer, const int* aiApproachValues, MinorCivApproachTypes eNewMinorCivApproach, MinorCivApproachTypes eOldApproach)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Name
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", --- " + otherPlayerName;

		MinorCivApproachTypes eMinorCivApproach;

		// Minor Civs only
		if(GET_PLAYER(ePlayer).isMinorCiv())
		{
			LogMinorCivApproach(strOutBuf, eNewMinorCivApproach);

			if(eNewMinorCivApproach != eOldApproach)
			{
				LogMinorCivApproach(strOutBuf, eOldApproach);
			}
			else
			{
				strTemp.Format("---");
				strOutBuf += ", " + strTemp;
			}

			//LogOpinion(strOutBuf, ePlayer);
			strOutBuf += ", ";

			//LogWarmongerThreat(strOutBuf, ePlayer);
			strOutBuf += ", ";

			//LogMilitaryThreat(strOutBuf, ePlayer);
			strOutBuf += ", ";

			LogTargetValue(strOutBuf, ePlayer);

			LogWarGoal(strOutBuf, ePlayer);

			LogMilitaryAggressivePosture(strOutBuf, ePlayer);

			LogProximity(strOutBuf, ePlayer);

			LogLandDispute(strOutBuf, ePlayer);

			//LogVictoryDispute(strOutBuf, ePlayer);
			strOutBuf += ", ";

			strOutBuf += ", ---";

			// Weights for each possible Approach
			for(int iMinorCivApproachLoop = 0; iMinorCivApproachLoop < NUM_MINOR_CIV_APPROACHES; iMinorCivApproachLoop++)
			{
				eMinorCivApproach = (MinorCivApproachTypes) iMinorCivApproachLoop;

				switch(eMinorCivApproach)
				{
				case MINOR_CIV_APPROACH_IGNORE:
					strTemp.Format("Ignore");
					break;
				case MINOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MINOR_CIV_APPROACH_PROTECTIVE:
					strTemp.Format("Protective");
					break;
				case MINOR_CIV_APPROACH_CONQUEST:
					strTemp.Format("Conquest");
					break;
				case MINOR_CIV_APPROACH_BULLY:
					strTemp.Format("Bully");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", aiApproachValues[eMinorCivApproach]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}

/// Log the Personality of this player (Flavors & Personality Traits)
void CvDiplomacyAI::LogPersonality()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "AI_Personality_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "AI_Personality_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, PERSONALITY, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		// Loop through all Flavors
		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
		{
			strTemp.Format("%s, %d", GC.getFlavorTypes((FlavorTypes) iFlavorLoop).GetCString(), GetPlayer()->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes) iFlavorLoop));
			strOutBuf = strBaseString + ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		MajorCivApproachTypes eMajorCivApproach;

		// Loop through all Approaches to see what this player's bias is
		for(int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			eMajorCivApproach = (MajorCivApproachTypes) iApproachLoop;

			switch(eMajorCivApproach)
			{
			case MAJOR_CIV_APPROACH_WAR:
				strTemp.Format("War");
				break;
			case MAJOR_CIV_APPROACH_HOSTILE:
				strTemp.Format("Hostile");
				break;
			case MAJOR_CIV_APPROACH_DECEPTIVE:
				strTemp.Format("Deceptive");
				break;
			case MAJOR_CIV_APPROACH_GUARDED:
				strTemp.Format("Guarded");
				break;
			case MAJOR_CIV_APPROACH_AFRAID:
				strTemp.Format("Afraid");
				break;
			case MAJOR_CIV_APPROACH_FRIENDLY:
				strTemp.Format("Friendly");
				break;
			case MAJOR_CIV_APPROACH_NEUTRAL:
				strTemp.Format("Neutral");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf = strBaseString + ", " + strTemp;

			strTemp.Format("%d", GetPersonalityMajorCivApproachBias(eMajorCivApproach));
			strOutBuf += ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		MinorCivApproachTypes eMinorCivApproach;

		// Loop through all Approaches to see what this player's bias is
		for(int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			eMinorCivApproach = (MinorCivApproachTypes) iApproachLoop;

			switch(eMinorCivApproach)
			{
			case MINOR_CIV_APPROACH_IGNORE:
				strTemp.Format("Ignore");
				break;
			case MINOR_CIV_APPROACH_FRIENDLY:
				strTemp.Format("Friendly");
				break;
			case MINOR_CIV_APPROACH_PROTECTIVE:
				strTemp.Format("Protective");
				break;
			case MINOR_CIV_APPROACH_CONQUEST:
				strTemp.Format("Conquest");
				break;
			case MINOR_CIV_APPROACH_BULLY:
				strTemp.Format("Bully");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf = strBaseString + ", " + strTemp;

			strTemp.Format("%d", GetPersonalityMinorCivApproachBias(eMinorCivApproach));
			strOutBuf += ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		strTemp.Format("VICTORY COMPETITIVENESS, %d", GetVictoryCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("WONDER COMPETITIVENESS, %d", GetWonderCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("MINOR CIV COMPETITIVENESS, %d", GetMinorCivCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("BOLDNESS, %d", GetBoldness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DIPLO BALANCE, %d", GetDiploBalance());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("WARMONGER HATE, %d", GetWarmongerHate());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DENOUNCE, %d", GetDenounceWillingness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DoF, %d", GetDoFWillingness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("LOYALTY, %d", GetLoyalty());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("NEEDINESS, %d", GetNeediness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("FORGIVENESS, %d", GetForgiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("CHATTINESS, %d", GetChattiness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("MEANNESS, %d", GetMeanness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);
	}
}

/// Log diplomatic status with other Players
void CvDiplomacyAI::LogStatus()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				strOutBuf = strBaseString;

				LogGrandStrategy(strOutBuf);

				// Name
				if(GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					strMinorString = "--- ";
				}

				otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
				strOutBuf += ", " + strMinorString + otherPlayerName;

				// Major Civ
				if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					if(IsDoFAccepted(eLoopPlayer))
						strOutBuf += ", WW";
					else
						strOutBuf += ", ";

					if(IsDenouncedPlayer(eLoopPlayer))
						strOutBuf += ", DEN";
					else
						strOutBuf += ", ";
#if defined(MOD_BALANCE_CORE)
					if(IsAtWar(eLoopPlayer))
						strOutBuf += ", AT WAR";
					else
						strOutBuf += ", ";
#endif
					CoopWarStates eCoopWarState = GetGlobalCoopWarAgainstState(eLoopPlayer);

					if (eCoopWarState == COOP_WAR_STATE_ONGOING)
						strOutBuf += ", CW";
					else if (eCoopWarState == COOP_WAR_STATE_PREPARING || eCoopWarState == COOP_WAR_STATE_READY)
						strOutBuf += ", CWS";
					else
						strOutBuf += ", ";

					LogMajorCivApproach(strOutBuf, GetMajorCivApproach(eLoopPlayer), GetSurfaceApproach(eLoopPlayer));
					LogOpinion(strOutBuf, eLoopPlayer);
				}
				// Minor Civ
				else
				{
					strOutBuf += ", ";		// Working With
					strOutBuf += ", ";		// Working Against
					strOutBuf += ", ";		// Coop War

					LogMinorCivApproach(strOutBuf, GetMinorCivApproach(eLoopPlayer));
					strOutBuf += ", ";		// Opinion
				}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				//if (MOD_DIPLOMACY_CIV4_FEATURES) {
				//	LogGlobalState(strOutBuf, eLoopPlayer);
				//}
#endif

				LogProximity(strOutBuf, eLoopPlayer);

				LogWarState(strOutBuf, eLoopPlayer);

				LogEconomicStrength(strOutBuf, eLoopPlayer);

				LogMilitaryStrength(strOutBuf, eLoopPlayer);
				LogTargetValue(strOutBuf, eLoopPlayer);
				LogWarProjection(strOutBuf, eLoopPlayer);
				LogMilitaryAggressivePosture(strOutBuf, eLoopPlayer);
				LogWarmongerThreat(strOutBuf, eLoopPlayer);
				LogMilitaryThreat(strOutBuf, eLoopPlayer);

				LogExpansionAggressivePosture(strOutBuf, eLoopPlayer);
				LogPlotBuyingAggressivePosture(strOutBuf, eLoopPlayer);
				LogLandDispute(strOutBuf, eLoopPlayer);
				LogVictoryDispute(strOutBuf, eLoopPlayer);
				LogWonderDispute(strOutBuf, eLoopPlayer);
				LogMinorCivDispute(strOutBuf, eLoopPlayer);

				// Other Player's Estimated Grand Strategy
				if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					AIGrandStrategyTypes eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer);

					CvAIGrandStrategyXMLEntry* pEntry = eGrandStrategy != NO_AIGRANDSTRATEGY ? GC.getAIGrandStrategyInfo(eGrandStrategy) : NULL;
					if(pEntry != NULL)
					{
						strTemp.Format("GSS %s", pEntry->GetType());
						strOutBuf += ", " + strTemp;

						// Confidence in our guess
						switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
						{
						case GUESS_CONFIDENCE_POSITIVE:
							strTemp.Format("POSITIVE");
							break;
						case GUESS_CONFIDENCE_LIKELY:
							strTemp.Format("Likely");
							break;
						case GUESS_CONFIDENCE_UNSURE:
							strTemp.Format("Unsure");
							break;
						default:
							strTemp.Format("XXX");
							break;
						}
					}
					else
					{
						strTemp.Format("No GS Guess, ");
					}
				}
				else
				{
					strTemp.Format(", ");
				}
				strOutBuf += ", " + strTemp;

				pLog->Msg(strOutBuf);
			}
		}
	}
}


/// Log Diplomatic War status with other Players
void CvDiplomacyAI::LogWarStatus()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_War_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_War_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		bool bLogPlayer;

		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				if(IsAtWar(eLoopPlayer))
				{
					bLogPlayer = true;
				}
				else if(GetWarState(eLoopPlayer) != NO_WAR_STATE_TYPE)
				{
					bLogPlayer = true;
				}
				else if(GetWarGoal(eLoopPlayer) != NO_WAR_GOAL_TYPE)
				{
					bLogPlayer = true;
				}
				else
				{
					bLogPlayer = false;
				}

				// Should we actually record a log entry for this player?
				if(bLogPlayer)
				{
					strOutBuf = strBaseString;

					// Name
					if(GET_PLAYER(eLoopPlayer).isMinorCiv())
					{
						strMinorString = "--- ";
					}

					otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
					strOutBuf += ", " + strMinorString + otherPlayerName;

					// Approach
					if(GET_PLAYER(eLoopPlayer).isMinorCiv())
					{
						if(GetMinorCivApproach(eLoopPlayer) == MINOR_CIV_APPROACH_CONQUEST)
						{
							strOutBuf += ", APP: CONQUEST";
						}
						else
						{
							strOutBuf += ", APP: o";
						}
					}
					else
					{
						if(GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_WAR)
						{
							strOutBuf += ", APP: WAR";
						}
						else
						{
							strOutBuf += ", APP: o";
						}
					}

					// Wants to conquer the world?
					if(IsGoingForWorldConquest())
					{
						strOutBuf += ", WC";
					}
					else
					{
						strOutBuf += ", ";
					}

					// Wants peace with eLoopPlayer?
					if(!GET_PLAYER(eLoopPlayer).isMinorCiv() && IsWantsPeaceWithPlayer(eLoopPlayer))
					{
						strOutBuf += ", Wants Peace!!!";
					}
					else
					{
						strOutBuf += ", ";
					}

					LogWarGoal(strOutBuf, eLoopPlayer);
					LogWarState(strOutBuf, eLoopPlayer);
					LogWarProjection(strOutBuf, eLoopPlayer);

					LogWarPeaceWillingToOffer(strOutBuf, eLoopPlayer);
					LogWarPeaceWillingToAccept(strOutBuf, eLoopPlayer);

					// # of turns at War
					if(GetPlayerNumTurnsAtWar(eLoopPlayer) > 0)
					{
						strTemp.Format("%d", GetPlayerNumTurnsAtWar(eLoopPlayer));
						strOutBuf += ", " + strTemp;
					}
					else
					{
						strOutBuf += ", ";
					}

					LogWarDamage(strOutBuf, eLoopPlayer);

					LogMilitaryThreat(strOutBuf, eLoopPlayer);

					LogProximity(strOutBuf, eLoopPlayer);
					LogTargetValue(strOutBuf, eLoopPlayer);

					LogMilitaryStrength(strOutBuf, eLoopPlayer);
					LogEconomicStrength(strOutBuf, eLoopPlayer);

#if defined(MOD_BALANCE_CORE)
					if(!GET_PLAYER(eLoopPlayer).isMinorCiv() && IsAtWar(eLoopPlayer))
					{
						strTemp.Format("   !!!!WAR SCORE: %d !!!! ", GetWarScore(eLoopPlayer));
						strOutBuf += ", " + strTemp;
					}

					strTemp.Format(" ---  War Weariness: %d, Supply: %d", m_pPlayer->GetCulture()->GetWarWeariness(), m_pPlayer->GetNumUnitsSupplied());
					strOutBuf += ", " + strTemp;
#endif
					pLog->Msg(strOutBuf);
				}
			}
		}
	}
}


/// Log Statements, to make sure our record is solid
void CvDiplomacyAI::LogStatements()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Statement_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Statement_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		CvString strStatementLine;

		int iItem;
		DiploStatementTypes eStatement;
		int iTurn;

		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();

				// Diplo Statement Log Counter
				for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
				{
					eStatement = GetDiploLogStatementTypeForIndex(eLoopPlayer, iItem);

					if(eStatement != NO_DIPLO_STATEMENT_TYPE)
					{
						iTurn = GetDiploLogStatementTurnForIndex(eLoopPlayer, iItem);

						strStatementLine.Format(", Statement: %d, Index: %d, Turn %d", eStatement, iItem, iTurn);

						strOutBuf = strBaseString;

						strOutBuf += ", " + otherPlayerName;
						strOutBuf += strStatementLine;

						pLog->Msg(strOutBuf);
					}
				}
			}
		}
	}
}

/// Log Grand Strategy
void CvDiplomacyAI::LogGrandStrategy(CvString& strString)
{
	CvString strTemp;

	AIGrandStrategyTypes eGrandStrategy =GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();

	if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))
	{
		strTemp.Format("Conquest");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))
	{
		strTemp.Format("Spaceship");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))
	{
		strTemp.Format("Diplomacy");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))
	{
		strTemp.Format("Culture");
	}

	strString += ", " + strTemp;
}

/// Log Current Approach towards Major
void CvDiplomacyAI::LogMajorCivApproach(CvString& strString, MajorCivApproachTypes eNewMajorCivApproach, MajorCivApproachTypes eSurfaceApproach)
{
	CvString strTemp;

	switch(eNewMajorCivApproach)
	{
	case MAJOR_CIV_APPROACH_WAR:
		switch(eSurfaceApproach)
		{
		case MAJOR_CIV_APPROACH_HOSTILE:
			strTemp.Format("**WAR_HOSTILE**");
			break;
		case MAJOR_CIV_APPROACH_NEUTRAL:
			strTemp.Format("**WAR_NEUTRAL**");
			break;
		case MAJOR_CIV_APPROACH_FRIENDLY:
			strTemp.Format("**WAR_FRIENDLY**");
			break;
		case MAJOR_CIV_APPROACH_GUARDED:
			strTemp.Format("**WAR_GUARDED**");
			break;
		default:
			strTemp.Format("**WAR**");
			break;
		}
		break;
	case MAJOR_CIV_APPROACH_HOSTILE:
		strTemp.Format("HOSTILE");
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
		strTemp.Format("DECEPTIVE");
		break;
	case MAJOR_CIV_APPROACH_GUARDED:
		strTemp.Format("GUARDED");
		break;
	case MAJOR_CIV_APPROACH_AFRAID:
		strTemp.Format("AFRAID");
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		strTemp.Format("FRIENDLY");
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		strTemp.Format("N");
		break;
	default:
		strTemp.Format("ApproachUnknown");
		break;
	}
	strString += ", " + strTemp;
}


/// Log Current Approach towards Minor
void CvDiplomacyAI::LogMinorCivApproach(CvString& strString, MinorCivApproachTypes eNewMinorCivApproach)
{
	CvString strTemp;

	switch(eNewMinorCivApproach)
	{
	case MINOR_CIV_APPROACH_IGNORE:
		strTemp.Format("IG");
		break;
	case MINOR_CIV_APPROACH_FRIENDLY:
		strTemp.Format("FRIENDLY");
		break;
	case MINOR_CIV_APPROACH_PROTECTIVE:
		strTemp.Format("PROTECTIVE");
		break;
	case MINOR_CIV_APPROACH_CONQUEST:
		strTemp.Format("**CONQUEST**");
		break;
	case MINOR_CIV_APPROACH_BULLY:
		strTemp.Format("BULLY");
		break;
	default:
		strTemp.Format("ApproachUnknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log a quest from a Minor
void CvDiplomacyAI::LogMinorCivQuestType(CvString& strString, MinorCivQuestTypes eQuestType)
{
	CvString strTemp;

	switch(eQuestType)
	{
	case MINOR_CIV_QUEST_ROUTE:
		strTemp.Format("Route");
		break;
	case MINOR_CIV_QUEST_KILL_CAMP:
		strTemp.Format("Kill Camp");
		break;
	case MINOR_CIV_QUEST_CONNECT_RESOURCE:
		strTemp.Format("Connect Resource");
		break;
	case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
		strTemp.Format("Construct Wonder");
		break;
	case MINOR_CIV_QUEST_GREAT_PERSON:
		strTemp.Format("Great Person");
		break;
	case MINOR_CIV_QUEST_KILL_CITY_STATE:
		strTemp.Format("Kill City State");
		break;
	case MINOR_CIV_QUEST_FIND_PLAYER:
		strTemp.Format("Find Player");
		break;
	case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
		strTemp.Format("Find Natural Wonder");
		break;
	case MINOR_CIV_QUEST_GIVE_GOLD:
		strTemp.Format("Give Gold");
		break;
	case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
		strTemp.Format("Pledge to Protect");
		break;
	case MINOR_CIV_QUEST_CONTEST_CULTURE:
		strTemp.Format("Contest Culture");
		break;
	case MINOR_CIV_QUEST_CONTEST_FAITH:
		strTemp.Format("Contest Faith");
		break;
	case MINOR_CIV_QUEST_CONTEST_TECHS:
		strTemp.Format("Contest Techs");
		break;
	case MINOR_CIV_QUEST_INVEST:
		strTemp.Format("Invest");
		break;
	case MINOR_CIV_QUEST_BULLY_CITY_STATE:
		strTemp.Format("Bully City-State");
		break;
	case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
		strTemp.Format("Denounce Major");
		break;
	case MINOR_CIV_QUEST_SPREAD_RELIGION:
		strTemp.Format("Spread Religion");
		break;
	case MINOR_CIV_QUEST_TRADE_ROUTE:
		strTemp.Format("Trade Route");
		break;
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
	case MINOR_CIV_QUEST_WAR:
		strTemp.Format("Declare War on Major");
		break;
	case MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER:
		strTemp.Format("Construct National Wonder");
		break;
	case MINOR_CIV_QUEST_FIND_CITY_STATE:
		strTemp.Format("Find City State");
		break;
	case MINOR_CIV_QUEST_INFLUENCE:
		strTemp.Format("Influence");
		break;
	case MINOR_CIV_QUEST_CONTEST_TOURISM:
		strTemp.Format("Contest Tourism");
		break;
	case MINOR_CIV_QUEST_ARCHAEOLOGY:
		strTemp.Format("Archaeology");
		break;
	case MINOR_CIV_QUEST_CIRCUMNAVIGATION:
		strTemp.Format("Circumnavigation");
		break;
	case MINOR_CIV_QUEST_LIBERATION:
		strTemp.Format("Liberation");
		break;
	case MINOR_CIV_QUEST_HORDE:
		strTemp.Format("Horde");
		break;
	case MINOR_CIV_QUEST_REBELLION:
		strTemp.Format("Rebellion");
		break;
	case MINOR_CIV_QUEST_DISCOVER_PLOT:
		strTemp.Format("Discover a Plot");
		break;
	case MINOR_CIV_QUEST_BUILD_X_BUILDINGS:
		strTemp.Format("Build X Buildings");
		break;
	case MINOR_CIV_QUEST_UNIT_STEAL_FROM:
		strTemp.Format("Steal From");
		break;
	case MINOR_CIV_QUEST_UNIT_COUP_CITY:
		strTemp.Format("Coup City");
		break;
	case MINOR_CIV_QUEST_UNIT_GET_CITY:
		strTemp.Format("Conquer a City");
		break;
#endif
	default:
		strTemp.Format("Quest_Unknown");
		break;
	}

	strString += ", " + strTemp;
}

/// Log Current Opinion of Major
void CvDiplomacyAI::LogOpinion(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Opinion
	switch(GetMajorCivOpinion(ePlayer))
	{
	case MAJOR_CIV_OPINION_ALLY:
		strTemp.Format("OPN **ALLY**");
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		strTemp.Format("OPN FRIEND");
		break;
	case MAJOR_CIV_OPINION_FAVORABLE:
		strTemp.Format("OPN Favorable");
		break;
	case MAJOR_CIV_OPINION_NEUTRAL:
		strTemp.Format("OPN N");
		break;
	case MAJOR_CIV_OPINION_COMPETITOR:
		strTemp.Format("OPN Competitor");
		break;
	case MAJOR_CIV_OPINION_ENEMY:
		strTemp.Format("OPN ENEMY");
		break;
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
		strTemp.Format("OPN **UNFORGIVABLE**");
		break;
	default:
		strTemp.Format("OPN Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Warmonger Threat
void CvDiplomacyAI::LogWarmongerThreat(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format(",");
	}
	else
	{
		switch(GetWarmongerThreat(ePlayer))
		{
		case THREAT_CRITICAL:
			strTemp.Format("W_THT CRIT, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_SEVERE:
			strTemp.Format("W_THT SEVR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_MAJOR:
			strTemp.Format("W_THT MAJR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_MINOR:
			strTemp.Format("W_THT MINR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_NONE:
			strTemp.Format("W_THT NONE, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		default:
			strTemp.Format("W_THT XXXX, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Military Threat
void CvDiplomacyAI::LogMilitaryThreat(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		switch(GetMilitaryThreat(ePlayer))
		{
		case THREAT_CRITICAL:
			strTemp.Format("M_THT **CRITICAL**");
			break;
		case THREAT_SEVERE:
			strTemp.Format("M_THT SEVERE");
			break;
		case THREAT_MAJOR:
			strTemp.Format("M_THT Major");
			break;
		case THREAT_MINOR:
			strTemp.Format("M_THT mnr");
			break;
		case THREAT_NONE:
			strTemp.Format("M_THT N");
			break;
		default:
			strTemp.Format("M_THT Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Military Strength
void CvDiplomacyAI::LogMilitaryStrength(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Military Strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
		strTemp.Format("MSTR **IMMENSE**");
		break;
	case STRENGTH_POWERFUL:
		strTemp.Format("MSTR POWERFUL");
		break;
	case STRENGTH_STRONG:
		strTemp.Format("MSTR Strong");
		break;
	case STRENGTH_AVERAGE:
		strTemp.Format("MSTR A");
		break;
	case STRENGTH_POOR:
		strTemp.Format("MSTR Poor");
		break;
	case STRENGTH_WEAK:
		strTemp.Format("MSTR WEAK");
		break;
	case STRENGTH_PATHETIC:
		strTemp.Format("MSTR **PATHETIC**");
		break;
	default:
		strTemp.Format("MSTR Unknown");
		break;
	}
	strString += ", " + strTemp;

}

/// Log Economic Strength
void CvDiplomacyAI::LogEconomicStrength(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Economic Strength
	switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
		strTemp.Format("ESTR **IMMENSE**");
		break;
	case STRENGTH_POWERFUL:
		strTemp.Format("ESTR POWERFUL");
		break;
	case STRENGTH_STRONG:
		strTemp.Format("ESTR Strong");
		break;
	case STRENGTH_AVERAGE:
		strTemp.Format("ESTR Avg");
		break;
	case STRENGTH_POOR:
		strTemp.Format("ESTR Poor");
		break;
	case STRENGTH_WEAK:
		strTemp.Format("ESTR Weak");
		break;
	case STRENGTH_PATHETIC:
		strTemp.Format("ESTR Pathetic");
		break;
	default:
		strTemp.Format("ESTR Unknown");
		break;
	}
	strString += ", " + strTemp;

}

/// Log Target Value
void CvDiplomacyAI::LogTargetValue(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Target Value
	switch (GetPlayerTargetValue(ePlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
		strTemp.Format("TGT Impossible");
		break;
	case TARGET_VALUE_BAD:
		strTemp.Format("TGT Bad");
		break;
	case TARGET_VALUE_AVERAGE:
		strTemp.Format("TGT Avg");
		break;
	case TARGET_VALUE_FAVORABLE:
		strTemp.Format("TGT Favorable");
		break;
	case TARGET_VALUE_SOFT:
		strTemp.Format("TGT Soft");
		break;
	default:
		strTemp.Format("TGT Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log War Goal
void CvDiplomacyAI::LogWarGoal(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Goal
	switch(GetWarGoal(ePlayer))
	{
	case WAR_GOAL_DEMAND:
		strTemp.Format("WGL Demand");
		break;
	case WAR_GOAL_PREPARE:
		strTemp.Format("WGL Preparing");
		break;
	case WAR_GOAL_CONQUEST:
		strTemp.Format("WGL Conquest");
		break;
	case WAR_GOAL_DAMAGE:
		strTemp.Format("WGL Damage");
		break;
	case WAR_GOAL_PEACE:
		strTemp.Format("WGL PEACE");
		break;
	default:
		if(IsAtWar(ePlayer))
		{
			strTemp.Format("WGL Unknown");
		}
		else
		{
			strTemp.Format("WGL None");
		}
		break;
	}
	strString += ", " + strTemp;
}

/// Log Peace Treaty Willing to Offer
void CvDiplomacyAI::LogWarPeaceWillingToOffer(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// No Minor Civs
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// War Goal
		switch(GetTreatyWillingToOffer(ePlayer))
		{
		case NO_PEACE_TREATY_TYPE:
			strTemp.Format("");
			break;
		case PEACE_TREATY_WHITE_PEACE:
			strTemp.Format("PeaceOff WhitePeace(0)");
			break;
		case PEACE_TREATY_ARMISTICE:
			strTemp.Format("PeaceOff Armistice(1)");
			break;
		case PEACE_TREATY_SETTLEMENT:
			strTemp.Format("PeaceOff Settlement(2)");
			break;
		case PEACE_TREATY_BACKDOWN:
			strTemp.Format("PeaceOff Backdown(3)");
			break;
		case PEACE_TREATY_SUBMISSION:
			strTemp.Format("PeaceOff Submission(4)");
			break;
		case PEACE_TREATY_SURRENDER:
			strTemp.Format("PeaceOff Surrender(5)");
			break;
		case PEACE_TREATY_CESSION:
			strTemp.Format("PeaceOff Cession(6)");
			break;
		case PEACE_TREATY_CAPITULATION:
			strTemp.Format("PeaceOff CAPITULATION(7)");
			break;
		case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
			strTemp.Format("PeaceOff **SURRENDER(8)**");
			break;
		default:
			strTemp.Format("PeaceOff Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Peace Treaty Willing to Accept
void CvDiplomacyAI::LogWarPeaceWillingToAccept(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// No Minor Civs
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// War Goal
		switch(GetTreatyWillingToAccept(ePlayer))
		{
		case NO_PEACE_TREATY_TYPE:
			strTemp.Format("");
			break;
		case PEACE_TREATY_WHITE_PEACE:
			strTemp.Format("PeaceAcc WhitePeace(0)");
			break;
		case PEACE_TREATY_ARMISTICE:
			strTemp.Format("PeaceAcc Armistice(1)");
			break;
		case PEACE_TREATY_SETTLEMENT:
			strTemp.Format("PeaceAcc Settlement(2)");
			break;
		case PEACE_TREATY_BACKDOWN:
			strTemp.Format("PeaceAcc Backdown(3)");
			break;
		case PEACE_TREATY_SUBMISSION:
			strTemp.Format("PeaceAcc Submission(4)");
			break;
		case PEACE_TREATY_SURRENDER:
			strTemp.Format("PeaceAcc Surrender(5)");
			break;
		case PEACE_TREATY_CESSION:
			strTemp.Format("PeaceAcc Cession(6)");
			break;
		case PEACE_TREATY_CAPITULATION:
			strTemp.Format("PeaceAcc CAPITULATION(7)");
			break;
		case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
			strTemp.Format("PeaceAcc **SURRENDER(8)**");
			break;
		default:
			strTemp.Format("PeaceAcc Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}


/// Log War State
void CvDiplomacyAI::LogWarState(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	bool bShowOperationProgress = false;

	// Log progress towards Sneak Attack Operation launch if we're not yet at war
	if(GetWarGoal(ePlayer) == WAR_GOAL_PREPARE)
	{
		CvAIOperation* pOperation = GetPlayer()->getFirstOffensiveAIOperation(ePlayer);

		if(pOperation)
		{
			bShowOperationProgress = true;
			int iOperationPercentMustered = pOperation->PercentFromMusterPointToTarget();

			if(iOperationPercentMustered > 0)
			{
				strTemp.Format("PREP PRGS %2d", iOperationPercentMustered);
			}
			else
			{
				strTemp.Format("PREP Gathering");
			}
		}
	}
	// Preparing a demand?
	if(GetWarGoal(ePlayer) == WAR_GOAL_DEMAND)
	{
		CvAIOperation* pOperation = GetPlayer()->getFirstOffensiveAIOperation(ePlayer);

		if(pOperation)
		{
			bShowOperationProgress = true;
			int iOperationPercentMustered = pOperation->PercentFromMusterPointToTarget();

			if(iOperationPercentMustered > 0)
			{
				strTemp.Format("DMND PRGS %2d", iOperationPercentMustered);
			}
			else
			{
				strTemp.Format("DMND Gathering");
			}
		}
	}

	if(!bShowOperationProgress)
	{
		// War State
		switch(GetWarState(ePlayer))
		{
		case WAR_STATE_CALM:
			strTemp.Format("WST Calm");
			break;
		case WAR_STATE_NEARLY_WON:
			strTemp.Format("WST Nearly Won");
			break;
		case WAR_STATE_OFFENSIVE:
			strTemp.Format("WST Offensive");
			break;
		case WAR_STATE_STALEMATE:
			strTemp.Format("WST Stalemate");
			break;
		case WAR_STATE_DEFENSIVE:
			strTemp.Format("WST DEFENSIVE");
			break;
		case WAR_STATE_NEARLY_DEFEATED:
			strTemp.Format("WST **NEARLY DEFEATED**");
			break;
		default:
			if(IsAtWar(ePlayer))
			{
				strTemp.Format("WST Unknown");
			}
			else
			{
				strTemp.Format("WST None");
			}
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log War Projection
void CvDiplomacyAI::LogWarProjection(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Projection
	switch(GetWarProjection(ePlayer))
	{
	case WAR_PROJECTION_DESTRUCTION:
		strTemp.Format("W_PRJ **DESTRUCTION**");
		break;
	case WAR_PROJECTION_DEFEAT:
		strTemp.Format("W_PRJ DEFEAT");
		break;
	case WAR_PROJECTION_STALEMATE:
		strTemp.Format("W_PRJ Stalemate");
		break;
	case WAR_PROJECTION_UNKNOWN:
		strTemp.Format("W_PRJ U");
		break;
	case WAR_PROJECTION_GOOD:
		strTemp.Format("W_PRJ GOOD");
		break;
	case WAR_PROJECTION_VERY_GOOD:
		strTemp.Format("W_PRJ ** VERY GOOD **");
		break;
	default:
		strTemp.Format("W_PRJ Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log War Damage
void CvDiplomacyAI::LogWarDamage(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Damage
	switch(GetWarDamageLevel(ePlayer))
	{
	case WAR_DAMAGE_LEVEL_CRIPPLED:
		strTemp.Format("W_DMG **CRIPPLED**");
		break;
	case WAR_DAMAGE_LEVEL_SERIOUS:
		strTemp.Format("W_DMG SERIOUS");
		break;
	case WAR_DAMAGE_LEVEL_MAJOR:
		strTemp.Format("W_DMG Major");
		break;
	case WAR_DAMAGE_LEVEL_MINOR:
		strTemp.Format("W_DMG mnr");
		break;
	case WAR_DAMAGE_LEVEL_NONE:
		strTemp.Format("W_DMG None");
		break;
	default:
		strTemp.Format("W_DMG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Military Aggressive Posture
void CvDiplomacyAI::LogMilitaryAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Military Aggressive Posture
	switch(GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("MAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("MAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("MAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("MAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("MAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("MAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Expansion Aggressive Posture
void CvDiplomacyAI::LogExpansionAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Expansion Aggressive Posture
	switch(GetExpansionAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("EAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("EAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("EAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("EAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("EAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("EAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Plot Buying Aggressive Posture
void CvDiplomacyAI::LogPlotBuyingAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Plot Buying Aggressive Posture
	switch(GetPlotBuyingAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("BAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("BAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("BAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("BAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("BAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("BAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Land Dispute
void CvDiplomacyAI::LogLandDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		switch(GetLandDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("LND **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("LND STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("LND Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("LND N");
			break;
		default:
			strTemp.Format("LND Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Victory Dispute
void CvDiplomacyAI::LogVictoryDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetVictoryDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("VCT **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("VCT STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("VCT Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("VCT N");
			break;
		default:
			strTemp.Format("VCT Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Victory Block
void CvDiplomacyAI::LogVictoryBlock(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetVictoryBlockLevel(ePlayer))
		{
		case BLOCK_LEVEL_FIERCE:
			strTemp.Format("VBlock **FIERCE**");
			break;
		case BLOCK_LEVEL_STRONG:
			strTemp.Format("VBlock STRONG");
			break;
		case BLOCK_LEVEL_WEAK:
			strTemp.Format("VBlock Weak");
			break;
		case BLOCK_LEVEL_NONE:
			strTemp.Format("VBlock N");
			break;
		default:
			strTemp.Format("VBlock Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Wonder Dispute
void CvDiplomacyAI::LogWonderDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetWonderDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("WND **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("WND STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("WND Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("WND N");
			break;
		default:
			strTemp.Format("WND Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Minor Civ Dispute
void CvDiplomacyAI::LogMinorCivDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetMinorCivDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("MCF **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("MCF STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("MCF Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("MCF N");
			break;
		default:
			strTemp.Format("MCF Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Proximity
void CvDiplomacyAI::LogProximity(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_NEIGHBORS:
		strTemp.Format("PRX Neighbors");
		break;
	case PLAYER_PROXIMITY_CLOSE:
		strTemp.Format("PRX Close");
		break;
	case PLAYER_PROXIMITY_FAR:
		strTemp.Format("PRX Far");
		break;
	case PLAYER_PROXIMITY_DISTANT:
		strTemp.Format("PRX Distant");
		break;
	default:
		strTemp.Format("PRX Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// AI sent a message to someone... what is it?!?!? :o
void CvDiplomacyAI::LogStatementToPlayer(PlayerTypes ePlayer, DiploStatementTypes eMessage)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);

		bool bMinorMessage = false;

		switch(eMessage)
		{
		case DIPLO_STATEMENT_REQUEST_PEACE:
			strTemp.Format("We request peace!!!");
			break;
		case DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING:
			strTemp.Format("Your Military is stationed aggressively!");
			break;
		case DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE:
			strTemp.Format("You Killed a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE:
			strTemp.Format("You Attacked a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE:
			strTemp.Format("You Bullied a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_EXPANSION_SERIOUS_WARNING:
			strTemp.Format("Expansion SERIOUS Warning!");
			break;
		case DIPLO_STATEMENT_EXPANSION_WARNING:
			strTemp.Format("Expansion Warning!");
			break;
		case DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE:
			strTemp.Format("Expansion Broken Promise!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_SERIOUS_WARNING:
			strTemp.Format("Plot Buying SERIOUS Warning!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_WARNING:
			strTemp.Format("Plot Buying Warning!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE:
			strTemp.Format("Plot Buying Broken Promise!");
			break;
		case DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR:
			strTemp.Format("Haha! We attacked your Minor!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR:
			strTemp.Format("Haha! We bullied your Minor!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_WORK_WITH_US:
			strTemp.Format("Wanna team up?");
			break;
		case DIPLO_STATEMENT_END_WORK_WITH_US:
			strTemp.Format("***** We're done working with you. *****");
			break;
		case DIPLO_STATEMENT_DENOUNCE:
			strTemp.Format("Denounce!");
			break;
		case DIPLO_STATEMENT_DENOUNCE_RANDFAILED:
			strTemp.Format("Denounce RANDFAILED");
			break;
		case DIPLO_STATEMENT_END_WORK_AGAINST_SOMEONE:
			strTemp.Format("***** We're done working against someone with you. *****");
			break;
		case DIPLO_STATEMENT_COOP_WAR_REQUEST:
			strTemp.Format("Wanna coop war against someone?");
			break;
		case DIPLO_STATEMENT_COOP_WAR_TIME:
			strTemp.Format("It's time to coop war against someone!");
			break;
		case DIPLO_STATEMENT_NOW_UNFORGIVABLE:
			strTemp.Format("***** You are Unforgivable! *****");
			break;
		case DIPLO_STATEMENT_NOW_ENEMY:
			strTemp.Format("***** You are an Enemy! *****");
			break;
		case DIPLO_STATEMENT_DEMAND:
			strTemp.Format("***** Give in to my demands or else! *****");
			break;
		case DIPLO_STATEMENT_REQUEST:
			strTemp.Format("***** Can you spare something for a friend? *****");
			break;
		case DIPLO_STATEMENT_REQUEST_RANDFAILED:
			strTemp.Format("***** Request RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_LUXURY_TRADE:
			strTemp.Format("***** You have a Luxury I would like *****");
			break;
		case DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE:
			strTemp.Format("Open Borders Exchange");
			break;
		case DIPLO_STATEMENT_OPEN_BORDERS_OFFER:
			strTemp.Format("Open Borders Offer");
			break;
		case DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER:
			strTemp.Format("Research Agreement Offer");
			break;
		case DIPLO_STATEMENT_RENEW_DEAL:
			strTemp.Format("Renew Deal");
			break;
		case DIPLO_STATEMENT_INSULT:
			strTemp.Format("Insult");
			break;
		case DIPLO_STATEMENT_COMPLIMENT:
			if(eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
			{
				strTemp.Format("DECEPTIVE Compliment");
			}
			else
			{
				strTemp.Format("Compliment");
			}
			break;
		case DIPLO_STATEMENT_BOOT_KISSING:
			strTemp.Format("Boot Kissing");
			break;
		case DIPLO_STATEMENT_WARMONGER:
			strTemp.Format("Warmonger!");
			break;
		case DIPLO_STATEMENT_DENOUNCE_FRIEND:
			strTemp.Format("***** DENOUNCING A FRIEND *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE:
			strTemp.Format("***** DENOUNCE SOMEONE FOR ME? *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE_RANDFAILED:
			strTemp.Format("***** Denounce someone for me? RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_WAR:
			strTemp.Format("***** DECLARE WAR ON SOMEONE FOR ME? *****");
			break;
		case DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY:
			strTemp.Format("***** YOU BEFRIENDED AN ENEMY OF MINE! *****");
			break;
		case DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED:
			strTemp.Format("***** You befriended an enemy of mine! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND:
			strTemp.Format("***** YOU DENOUNCED A FRIEND OF MINE! *****");
			break;
		case DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED:
			strTemp.Format("***** You denounced a friend of mine! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY:
			strTemp.Format("***** YAY - YOU DENOUNCED AN ENEMY! *****");
			break;
		case DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED:
			strTemp.Format("***** Yay - you denounced an enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND:
			strTemp.Format("***** YAY - YOU BEFRIENDED A FRIEND! *****");
			break;
		case DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED:
			strTemp.Format("***** Yay - you befriended a friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY:
			strTemp.Format("***** JUST FYI - I BEFRIENDED YOUR ENEMY! *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED:
			strTemp.Format("***** Just FYI - I befriended your enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND:
			strTemp.Format("***** JUST FYI - I DENOUNCED YOUR FRIEND! *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED:
			strTemp.Format("***** Just FYI - I denounced your friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY:
			strTemp.Format("***** JUST FYI - I DENOUNCED YOUR ENEMY! *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED:
			strTemp.Format("***** Just FYI - I denounced your enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND:
			strTemp.Format("***** JUST FYI - I BEFRIENDED YOUR FRIEND! *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED:
			strTemp.Format("***** Just FYI - I befriended your friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY:
		case DIPLO_STATEMENT_SAME_POLICIES_FREEDOM:
		case DIPLO_STATEMENT_SAME_POLICIES_ORDER:
			strTemp.Format("***** Yay! We like the same late game social policy tree *****");
			break;
		case DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL:
			strTemp.Format("***** We liked their World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL:
			strTemp.Format("***** We disliked their World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL:
			strTemp.Format("***** They supported our World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL:
			strTemp.Format("***** They foiled our World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING:
			strTemp.Format("***** They supported our World Congress hosting *****");
			break;
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
			strTemp.Format("***** Your ideology is causing civil unrest in our civ *****");
			break;
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
			strTemp.Format("***** Taunt - our ideology is causing unrest in your civ *****");
			break;
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM:
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER:
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY:
			strTemp.Format("***** Yay! They switched to our ideology *****");
			break;
		case DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL:
			strTemp.Format("***** Your culture is now influential over us *****");
			break;
		case DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL:
			strTemp.Format("***** Taunt - Our culture is now influential over you *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST:
			strTemp.Format("***** Taunt - We are coming for you with guns! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS:
			strTemp.Format("***** Taunt - We will rule the world through politics! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE:
			strTemp.Format("***** Taunt - Our culture is becoming unstoppable! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP:
			strTemp.Format("***** Taunt - Our spaceship will be the first to launch! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED:
			strTemp.Format("***** Taunt - We don't know what you're doing, but we are grumpy! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST:
			strTemp.Format("***** Taunt - We don't want you to win war! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS:
			strTemp.Format("***** Taunt - We don't want you to win WC! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE:
			strTemp.Format("***** Taunt - We don't want you to win culture! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP:
			strTemp.Format("***** Taunt - We don't want you to win spaceship! *****");
			break;
		case DIPLO_STATEMENT_DOF_BB:
			strTemp.Format("DOF offer - Battle Brothers");
			break;
		case DIPLO_STATEMENT_DOF_ALLIES:
			strTemp.Format("DOF offer - Allies");
			break;
		case DIPLO_STATEMENT_DOF_FRIENDS:
			strTemp.Format("DOF offer - Friends");
			break;
		case DIPLO_STATEMENT_DOF_UNTRUSTWORTHY:
			strTemp.Format("DOF offer - Untrustworthy");
			break;

		case DIPLO_STATEMENT_STRATEGIC_TRADE:
			strTemp.Format("Strategic Resource Trade");
			break;

		case DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST:
			strTemp.Format("Defensive Pact Offer");
			break;

		case DIPLO_STATEMENT_TRADE_CITIES_REQUEST:
			strTemp.Format("Trade Cities Offer");
			break;

		case DIPLO_STATEMENT_EXCHANGE_CITIES:
			strTemp.Format("Exchange Cities Offer");
			break;

		case DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST:
			strTemp.Format("3rd Party PEACE Offer");
			break;

		case DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST:
			strTemp.Format("3rd Party WAR Offer");
			break;

		case DIPLO_STATEMENT_VOTE_REQUEST:
			strTemp.Format("Vote Buy Offer");
			break;

		case DIPLO_STATEMENT_EMBASSY_EXCHANGE:
			strTemp.Format("***** Embassy Exchange *****");
			break;

		case DIPLO_STATEMENT_EMBASSY_OFFER:
			strTemp.Format("***** Embassy Offer *****");
			break;
		
		case DIPLO_STATEMENT_MINOR_CIV_COMPETITION:
			strTemp.Format("***** MINOR CIV COMPETITION *****");
			break;

		case DIPLO_STATEMENT_SHARE_INTRIGUE:
			strTemp.Format("***** Share Intrigue *****");
			break;

		case DIPLO_STATEMENT_CAUGHT_YOUR_SPY:
			strTemp.Format("***** SPY CAUGHT *****");
			break;

		case DIPLO_STATEMENT_KILLED_YOUR_SPY:
			strTemp.Format("***** KILLED YOUR SPY *****");
			break;

		case DIPLO_STATEMENT_KILLED_MY_SPY:
			strTemp.Format("***** KILLED MY SPY *****");
			break;

		case DIPLO_STATEMENT_STOP_DIGGING:
			strTemp.Format("***** STOP DIGGING WARNING *****");
			break;
		case DIPLO_STATEMENT_STOP_CONVERSIONS:
			strTemp.Format("***** STOP CONVERSIONS! *****");
			break;
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		case DIPLO_STATEMENT_GENEROUS_OFFER:
			strTemp.Format("***** We would like to offer you a gift. *****");
			break;
		case DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED:
			strTemp.Format("***** Generous Offer RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_MAPS_OFFER:
			strTemp.Format("*****Maps Offer*****");
			break;
		case DIPLO_STATEMENT_TECH_EXCHANGE:
			strTemp.Format("*****Technology Exchange*****");
			break;
		case DIPLO_STATEMENT_TECH_OFFER:
			strTemp.Format("*****You have a technology I would like*****");
			break;
		case DIPLO_STATEMENT_BECOME_MY_VASSAL:
			strTemp.Format("***** BECOME MY VASSAL *****");
			break;
		case DIPLO_STATEMENT_ACCEPT_VASSALAGE:
			strTemp.Format("***** BECOME YOUR VASSAL *****");
			break;
		case DIPLO_STATEMENT_REVOKE_VASSALAGE:
			strTemp.Format("***** REVOKING VASSALAGE *****");
			break;
		case DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY:
			strTemp.Format("***** REVOKING VASSALAGE VIA TRADE *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER:
			strTemp.Format("***** HUMAN RAISED MY TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER:
			strTemp.Format("***** I RAISED HUMAN'S TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER:
			strTemp.Format("***** HUMAN RAISED MY TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER:
			strTemp.Format("***** I LOWERED HUMAN'S TAXES! *****");
			break;
		case DIPLO_STATEMENT_LIBERATE_VASSAL:
			strTemp.Format("***** LIBERATED VASSAL! *****");
			break;
#endif
		default:
			strTemp.Format("Unknown message!!! %d", eMessage);
			break;
		}

		strOutBuf += ", " + strTemp;

		// Don't log these messages for now - they have their own function
		if(eMessage != DIPLO_STATEMENT_DENOUNCE &&
		        eMessage != DIPLO_STATEMENT_COOP_WAR_REQUEST)
			pLog->Msg(strOutBuf);

		// Also send message to Minor Civ log if applicable
		if(bMinorMessage)
		{
			// Open the log file
			if(GC.getPlayerAndCityAILogSplit())
				strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
			else
				strLogName = "DiplomacyAI_MinorCiv_Log.csv";

			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}
	}
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::TestUIDiploStatement(PlayerTypes eToPlayer, DiploStatementTypes eStatement, int iArg1)
{
	m_eTestToPlayer = eToPlayer;
	m_eTestStatement = eStatement;
	m_iTestStatementArg1 = iArg1;
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::LogOpenEmbassy(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** OPENED EMBASSY @ " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);
	}
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::LogCloseEmbassy(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** CLOSED EMBASSY @ " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);
	}
}
//	-------------------------------------------------------------------------------------
//	Returns true if the target is valid to show a UI to immediately.
//	This will return true if the source and destination are both AI.
bool CvDiplomacyAI::IsValidUIDiplomacyTarget(PlayerTypes eTargetPlayer)
{
	if(eTargetPlayer != NO_PLAYER)
	{
		CvPlayer& kTarget = GET_PLAYER(eTargetPlayer);
		if (m_eDiploMode == DIPLO_ALL_PLAYERS || 
			(m_eDiploMode == DIPLO_SPECIFIC_PLAYER && m_eTargetPlayer == eTargetPlayer) || 
			(m_eDiploMode == DIPLO_AI_PLAYERS && !kTarget.isHuman()) || 
			(m_eDiploMode == DIPLO_HUMAN_PLAYERS && kTarget.isHuman()))
			return true;
	}

	return false;
}

FDataStream& operator<<(FDataStream& saveTo, const DiploLogData& readFrom)
{
	saveTo << readFrom.m_eDiploLogStatement;
	saveTo << readFrom.m_iTurn;
	return saveTo;
}

FDataStream& operator>>(FDataStream& loadFrom, DiploLogData& writeTo)
{
	loadFrom >> writeTo.m_eDiploLogStatement;
	loadFrom >> writeTo.m_iTurn;
	return loadFrom;
}

FDataStream& operator<<(FDataStream& saveTo, const DeclarationLogData& readFrom)
{
	saveTo << readFrom.m_eDeclaration;
	saveTo << readFrom.m_iData1;
	saveTo << readFrom.m_iData2;
	saveTo << readFrom.m_eMustHaveMetPlayer;
	saveTo << readFrom.m_bActive;
	saveTo << readFrom.m_iTurn;
	return saveTo;
}

FDataStream& operator>>(FDataStream& loadFrom, DeclarationLogData& writeTo)
{
	loadFrom >> writeTo.m_eDeclaration;
	loadFrom >> writeTo.m_iData1;
	loadFrom >> writeTo.m_iData2;
	loadFrom >> writeTo.m_eMustHaveMetPlayer;
	loadFrom >> writeTo.m_bActive;
	loadFrom >> writeTo.m_iTurn;
	return loadFrom;
}

// AI HELPER ROUTINES

int CvDiplomacyAIHelpers::GetWarmongerOffset(CvCity* pCity, PlayerTypes eWarmonger, PlayerTypes ePlayer, WarmongerTriggerTypes eWarmongerTrigger)
{
	switch (eWarmongerTrigger)
	{
		case WARMONGER_MAJOR_ATTACKED:
		{
			int iWarmongerValue = /*10*/ GC.getWARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT();

			if (iWarmongerValue <= 0)
				return 0;

			int iWarmongerModifier = 100 + (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetOtherPlayerNumMajorsAttacked(eWarmonger) * 10);

			// INCREASE if he's big and nasty, less so if he's not.
			switch (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eWarmonger))
			{
			case STRENGTH_IMMENSE:
			case STRENGTH_POWERFUL:
			case STRENGTH_STRONG:
				iWarmongerModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
				break;
			case STRENGTH_AVERAGE:
			case STRENGTH_WEAK:
			case STRENGTH_POOR:
			case STRENGTH_PATHETIC:
				iWarmongerModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
				break;
			default:
				break;
			}

			iWarmongerValue *= iWarmongerModifier;
			iWarmongerValue /= 100;

			iWarmongerValue *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
			iWarmongerValue /= 100;

			return iWarmongerValue;
		}
		case WARMONGER_MINOR_ATTACKED:
		{
			int iWarmongerValue = /*5*/ GC.getWARMONGER_THREAT_MINOR_ATTACKED_WEIGHT();

			if (iWarmongerValue <= 0)
				return 0;

			int iWarmongerModifier = 100 + (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetOtherPlayerNumMinorsAttacked(eWarmonger) * 10);

			// INCREASE if he's big and nasty, less so if he's not.
			switch (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eWarmonger))
			{
			case STRENGTH_IMMENSE:
			case STRENGTH_POWERFUL:
			case STRENGTH_STRONG:
				iWarmongerModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
				break;
			case STRENGTH_AVERAGE:
			case STRENGTH_WEAK:
			case STRENGTH_POOR:
			case STRENGTH_PATHETIC:
				iWarmongerModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
				break;
			default:
				break;
			}

			iWarmongerValue *= iWarmongerModifier;
			iWarmongerValue /= 100;

			iWarmongerValue *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
			iWarmongerValue /= 100;

			return iWarmongerValue;
		}
		case WARMONGER_NUKED_PLAYER:
		{
			int iWarmongerValue = /*20*/ GC.getWARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT() * 2;

			if (iWarmongerValue <= 0)
				return 0;

			int iWarmongerModifier = 100 + (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumTimesNuked(eWarmonger) * 25);

			// INCREASE if he's big and nasty, less so if he's not.
			switch (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eWarmonger))
			{
			case STRENGTH_IMMENSE:
			case STRENGTH_POWERFUL:
			case STRENGTH_STRONG:
				iWarmongerModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
				break;
			case STRENGTH_AVERAGE:
			case STRENGTH_WEAK:
			case STRENGTH_POOR:
			case STRENGTH_PATHETIC:
				iWarmongerModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
				break;
			default:
				break;
			}

			iWarmongerValue *= iWarmongerModifier;
			iWarmongerValue /= 100;

			iWarmongerValue *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
			iWarmongerValue /= 100;

			return iWarmongerValue;
		}
	}

	// If we got this far, a city was captured (or liberated)
	if (pCity == NULL)
		return 0;

	int iWarmongerWeight = 0;

	int iHighestEconomicPower = GC.getGame().getHighestEconomicValue();
	int iLocalEconomicPower = pCity->getEconomicValue(pCity->getOwner());
	//cities rated on a 0-100 scale, where 0 = worthless, and 100 = most valuable in the world.
	iWarmongerWeight = (iLocalEconomicPower * 100) / max(1, iHighestEconomicPower);

	if (pCity->IsOriginalCapitalForPlayer(ePlayer))
	{
		iWarmongerWeight *= /*125*/ GC.getWARMONGER_THREAT_CAPITAL_CITY_PERCENT();
		iWarmongerWeight /= 100;
	}

	//we reduce value significantly if we've owned before.
	if (eWarmonger != NO_PLAYER)
	{
		int iNumTimesOwned(pCity->GetNumTimesOwned(eWarmonger));
		if (iNumTimesOwned > 1)
		{
			iWarmongerWeight -= (iNumTimesOwned * 10);
		}
	}

	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	if ((pLeague != NULL && pLeague->IsTradeEmbargoed(eWarmonger, ePlayer)) || GC.getGame().GetGameLeagues()->IsWorldWar(ePlayer) > 0)
	{
		iWarmongerWeight *= GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_WAR();
		iWarmongerWeight /= 100;
	}
	else if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(ePlayer) > 0)
	{
		iWarmongerWeight *= GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_PEACE();
		iWarmongerWeight /= 100;
	}

	if (iWarmongerWeight <= 0)
		iWarmongerWeight = 1;

	CUSTOMLOG("GetWarmongerOffset = %i for %s, Turn %i", iWarmongerWeight, pCity->getNameKey(), GC.getGame().getGameTurn());
	return iWarmongerWeight;
}

CvString CvDiplomacyAIHelpers::GetWarmongerPreviewString(PlayerTypes eCurrentOwner, CvCity* pCity, PlayerTypes eActivePlayer)
{
	CvString szRtnValue = "";

	if (eActivePlayer == NO_PLAYER)
		eActivePlayer = GC.getGame().getActivePlayer();

	if (pCity != NULL && eActivePlayer != NO_PLAYER && eCurrentOwner != NO_PLAYER)
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_HEADER").toUTF8();
		CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veWarmongerWeights;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			// Ignore minors
			if (!GET_PLAYER((PlayerTypes)iPlayerLoop).isMinorCiv() && GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && (PlayerTypes)iPlayerLoop != eActivePlayer)
			{
				// Ignore unmet players
				if (!GET_TEAM(GET_PLAYER(eActivePlayer).getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iPlayerLoop).getTeam()))
					continue;

				// Ignore humans
				if (GET_PLAYER((PlayerTypes)iPlayerLoop).isHuman())
					continue;

				int iWarmongerCare = CvDiplomacyAIHelpers::GetPlayerCaresValue(eActivePlayer, eCurrentOwner, pCity, (PlayerTypes)iPlayerLoop);

				if (iWarmongerCare > 0)
				{
					veWarmongerWeights.push_back((PlayerTypes)iPlayerLoop, iWarmongerCare);
				}
			}
		}
		if (veWarmongerWeights.size() > 0)
		{
			veWarmongerWeights.SortItems();

			int iHighestVal = veWarmongerWeights.GetWeight(0);

			int iCap = 0;
			int iMax = 8;
			for (int iWarmongerCivs = 0; iWarmongerCivs < (int) veWarmongerWeights.size(); iWarmongerCivs++)
			{
				if (iCap >= iMax)
				{
					break;
				}

				PlayerTypes eLoopPlayer = (PlayerTypes) veWarmongerWeights.GetElement(iWarmongerCivs);
				if (eLoopPlayer == NO_PLAYER)
					continue;

				int iWarmongerCare = veWarmongerWeights.GetWeight(iWarmongerCivs);
				int iPercentOfMax = (iWarmongerCare * 100) / iHighestVal;
				if (eLoopPlayer != NO_PLAYER)
				{
					if (iPercentOfMax >= 75)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_1000", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iPercentOfMax >= 60)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_800", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iPercentOfMax >= 45)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_600", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iPercentOfMax >= 30)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_400", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iPercentOfMax >= 15)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_200", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else 
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_NIL", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
				}
			}
		}
		else
		{
			szRtnValue = "";
		}
		return szRtnValue;
	}
	else
	{
		int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(pCity, eActivePlayer, eActivePlayer);

		if (iWarmongerOffset <= 30)
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MINOR").toUTF8();
		}
		else if (iWarmongerOffset <= 60)
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MAJOR").toUTF8();
		}
		else
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_EXTREME").toUTF8();
		}
	}

	return szRtnValue;
}

CvString CvDiplomacyAIHelpers::GetLiberationPreviewString(PlayerTypes eOriginalOwner, CvCity* pCity, PlayerTypes eActivePlayer)
{
	CvString szRtnValue = "";

	if (eActivePlayer == NO_PLAYER)
		eActivePlayer = GC.getGame().getActivePlayer();

	if (pCity != NULL && eActivePlayer != NO_PLAYER && eOriginalOwner != NO_PLAYER)
	{
		szRtnValue = Localization::Lookup("TXT_KEY_LIBERATOR_PREVIEW_HEADER").toUTF8();
		CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veWarmongerWeights;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			// Ignore minors
			if (!GET_PLAYER((PlayerTypes)iPlayerLoop).isMinorCiv() && GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && (PlayerTypes)iPlayerLoop != eActivePlayer)
			{
				if (!GET_TEAM(GET_PLAYER(eActivePlayer).getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iPlayerLoop).getTeam()))
					continue;
				
				// Ignore humans
				if (GET_PLAYER((PlayerTypes)iPlayerLoop).isHuman())
					continue;
				
				int iWarmongerCare = CvDiplomacyAIHelpers::GetPlayerCaresValue(eActivePlayer, eOriginalOwner, pCity, (PlayerTypes)iPlayerLoop, true);

				if (iWarmongerCare > 0)
				{
					veWarmongerWeights.push_back((PlayerTypes)iPlayerLoop, iWarmongerCare);
				}
			}
		}
		if (veWarmongerWeights.size() > 0)
		{
			veWarmongerWeights.SortItems();
			int iHighestVal = veWarmongerWeights.GetWeight(0);
			int iCap = 0;
			int iMax = 8;
			for (int iWarmongerCivs = 0; iWarmongerCivs < (int) veWarmongerWeights.size(); iWarmongerCivs++)
			{
				if (iCap >= iMax)
				{
					break;
				}

				PlayerTypes eLoopPlayer = (PlayerTypes)veWarmongerWeights.GetElement(iWarmongerCivs);
				if (eLoopPlayer == NO_PLAYER)
					continue;

				int iWarmongerCare = veWarmongerWeights.GetWeight(iWarmongerCivs);
				int iPercentOfMax = (iWarmongerCare * 100) / iHighestVal;
				
				if (iPercentOfMax >= 75)
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_1000", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				else if (iPercentOfMax >= 60)
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_800", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				else if (iPercentOfMax >= 45)
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_600", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				else if (iPercentOfMax >= 30)
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_400", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				else if (iPercentOfMax >= 15)
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_200", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				else 
				{
					szRtnValue += "[NEWLINE]";
					szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_NIL", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
				}
				iCap++;
			}
		}
		else
		{
			szRtnValue = "";
		}
		return szRtnValue;
	}
	else
	{
		int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(pCity, eActivePlayer, eActivePlayer);
		if (iWarmongerOffset <= 30)
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MINOR").toUTF8();
		}
		else if (iWarmongerOffset <= 60)
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MAJOR").toUTF8();
		}
		else
		{
			szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_EXTREME").toUTF8();
		}
	}

	return szRtnValue;
}

void CvDiplomacyAIHelpers::ApplyWarmongerPenalties(PlayerTypes eConqueror, PlayerTypes eConquered, CvCity* pCity)
{
	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
	{
		PlayerTypes eMajor = (PlayerTypes)iMajorLoop;
		if (GET_PLAYER(eMajor).getTeam() != GET_PLAYER(eConqueror).getTeam() && GET_PLAYER(eMajor).isAlive() && GET_PLAYER(eMajor).isMajorCiv())
		{
			int iWarmonger = GetPlayerCaresValue(eConqueror, eConquered, pCity, eMajor);
			if (iWarmonger > 0)
			{
				iWarmonger *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
				iWarmonger /= 100;

				CUSTOMLOG("WarmongerTimes100: Total=%i", iWarmonger);
				GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(eConqueror, iWarmonger * 100);
			}
		}
	}
}

int CvDiplomacyAIHelpers::GetPlayerCaresValue(PlayerTypes eConqueror, PlayerTypes eConquered, CvCity* pCity, PlayerTypes eMajor, bool bLiberation)
{
	CvPlayer &kConqueringPlayer = GET_PLAYER(eConqueror);
	CvPlayer &kConqueredPlayer = GET_PLAYER(eConquered);
	
	//Don't consider ourselves, teammates or dead dudes.
	if (GET_PLAYER(eMajor).getTeam() != GET_PLAYER(eConqueror).getTeam() && GET_PLAYER(eMajor).isAlive() && GET_PLAYER(eMajor).isMajorCiv())
	{
		CvTeam &kAffectedTeam = GET_TEAM(GET_PLAYER(eMajor).getTeam());
		
		// Don't apply warmongering or liberation if we haven't met the conqueror (otherwise that's cheating)
		if(!kAffectedTeam.isHasMet(kConqueringPlayer.getTeam()))
			return 0;
		
		// Am I at war with the owner of the conquered/liberated city? How's the war going?
		if (kAffectedTeam.isAtWar(kConqueredPlayer.getTeam()))
		{
			// If our warscore with the owner is negative, ignore warmongering AND liberation.
			if (GET_PLAYER(eMajor).GetDiplomacyAI()->GetWarScore(eConquered) < 0)
			{
				return 0;
			}
			
			// Loop through all other players on our team and perform the same check
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
				
				if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != eMajor && GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eMajor).getTeam())
				{
					if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarScore(eConquered) < 0)
					{
						return 0;
					}
				}
			}
		}

		int iWarmongerModifier = 100;
		PlayerTypes eFormerOwner = pCity->getPreviousOwner();

		if (eMajor == eConquered && !bLiberation)
		{
			// The conquered city owner ALWAYS gets the full warmonger value
		}
		//Our city? Only we should care.
		else if (eConqueror == eConquered && bLiberation)
		{
			return 0;
		}
		else if (bLiberation && eFormerOwner == eMajor && GET_TEAM(GET_PLAYER(eMajor).getTeam()).isAtWar(kConqueringPlayer.getTeam()))
		{
			return 0;
		}
		//At war with the civ that formerly owned the city? No liberation bonuses for this.
		else if (kConqueredPlayer.isAlive() && bLiberation && GET_TEAM(kConqueredPlayer.getTeam()).isAtWar(GET_PLAYER(eConqueror).getTeam()))
		{
			return 0;
		}
		//At war with the civ that owns the city now? No liberation bonus for this.
		else if (bLiberation && eMajor == pCity->getOwner() && GET_TEAM(kConqueringPlayer.getTeam()).isAtWar(pCity->getTeam()))
		{
			return 0;
		}
		//At war with the conquering civ? No liberation bonus for this.
		else if (bLiberation && GET_TEAM(kConqueredPlayer.getTeam()).isAtWar(pCity->getTeam()))
		{
			return 0;
		}

		else
		{
			if (MOD_DIPLOMACY_CIV4_FEATURES && !bLiberation)
			{
				// Our master?
				if (kAffectedTeam.IsVassal(kConqueringPlayer.getTeam()))
				{
					return 0;
				}
				// Vassals receive no warmongering penalties, they have no rights.
				if (kConqueringPlayer.IsVassalOfSomeone())
				{
					return 0;
				}
				if (kAffectedTeam.IsVassal(GET_PLAYER(eConquered).getTeam()))
				{
					iWarmongerModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
				}
				else if (GET_TEAM(kConqueredPlayer.getTeam()).IsVassal(GET_PLAYER(eMajor).getTeam()))
				{
					iWarmongerModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
				}
			}

			int iWarmongerCoopWarPercent = /*10*/ GC.getWARMONGER_THREAT_COOP_WAR_PERCENT();
			bool bCoopWarWithAttacker = (GET_PLAYER(eMajor).GetDiplomacyAI()->GetCoopWarState(eConqueror, eConquered) == COOP_WAR_STATE_ONGOING);

			// The affected player is in a co-op war with the attacker against the defender - this trumps everything!
			if (bCoopWarWithAttacker)
			{
				iWarmongerModifier = iWarmongerCoopWarPercent;
			}
			// Do we not know the defender?
			else if (!kAffectedTeam.isHasMet(kConqueredPlayer.getTeam()))
			{
				iWarmongerModifier *= /*50*/ GC.getWARMONGER_THREAT_KNOWS_ATTACKER_PERCENT();
				iWarmongerModifier /= 100;
			}
		}

		int iWarmongerApproachModifier = 0;
		if (!bLiberation)
		{
			if (eMajor == eConquered || GET_PLAYER(eMajor).getTeam() == GET_PLAYER(eConquered).getTeam() || kAffectedTeam.IsHasDefensivePact(kConqueredPlayer.getTeam()))
			{
				iWarmongerApproachModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
			}
			else
			{
				// INCREASE if he's big and nasty, less so if he's not.
				switch (GET_PLAYER(eMajor).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eConqueror))
				{
					case STRENGTH_IMMENSE:
					case STRENGTH_POWERFUL:
						iWarmongerApproachModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
						break;
					case STRENGTH_STRONG:
					case STRENGTH_AVERAGE:
						iWarmongerApproachModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						break;
					case STRENGTH_WEAK:
					case STRENGTH_POOR:
					case STRENGTH_PATHETIC:
						iWarmongerApproachModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
						break;
					default:
						break;
				}

				// DECREASE if opponent is big and nasty, less so if he's not.
				switch (GET_PLAYER(eMajor).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eConquered))
				{
				case STRENGTH_IMMENSE:
				case STRENGTH_POWERFUL:
				case STRENGTH_STRONG:
					iWarmongerApproachModifier += /*-50*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
					break;
				case STRENGTH_AVERAGE:
				case STRENGTH_WEAK:
				case STRENGTH_POOR:
				case STRENGTH_PATHETIC:
					iWarmongerApproachModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
					break;
				default:
					break;
				}
			}
		}

		int iWarmongerStatusModifier = 0;
		
		if (eMajor == eConquered)
		{
			iWarmongerStatusModifier += /*150*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 2;
		}

		if (eMajor != eConquered)
		{
			//penalty if I'm also at war with conquered civ
			if (kAffectedTeam.isAtWar(GET_PLAYER(eConquered).getTeam()))
			{
				iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
			}

			if (!bLiberation)
			{
				//Minor
				if (kConqueredPlayer.isMinorCiv())
				{
					if (kConqueredPlayer.GetMinorCivAI()->IsAllies(eMajor))
					{
						iWarmongerStatusModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}
					else if (kConqueredPlayer.GetMinorCivAI()->IsFriends(eMajor))
					{
						iWarmongerStatusModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
					}
					else
					{
						iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
					}

					if (kConqueredPlayer.GetMinorCivAI()->IsProtectedByMajor(eMajor))
					{
						iWarmongerStatusModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}
					else
					{
						iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
					}
				}

				//RELIGION

				//Religious brothers/sisters should turn a blind eye to war conducted on different faiths.
				if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerSameReligion(eConqueror))
				{
					//Reduced penalties for religious friends.
					iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();

					//We don't mind when you war on enemies of the faith.
					if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerOpposingReligion(eConquered) && !GET_PLAYER(eMajor).GetDiplomacyAI()->IsIgnoreReligionDifferences(eConquered))
					{
						//If everything is true, halve the standard warmonger amount for this player.
						iWarmongerStatusModifier += /*-50*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
					}
				}
				//Religious enemies will not be allowed to expand!
				else if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerOpposingReligion(eConqueror) && !GET_PLAYER(eMajor).GetDiplomacyAI()->IsIgnoreReligionDifferences(eConqueror))
				{
					//Increased penalties for religious enemies.
					iWarmongerStatusModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();

					//We don't like it when you war on brothers of the faith.
					if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerSameReligion(eConquered))
					{
						//If everything is true, double the standard warmonger amount for this player.
						iWarmongerStatusModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
					}
				}

				//IDEOLOGY

				//Are the conqueror and I of the same ideology? We overlook war on our ideological opponents.
				if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerSameIdeology(eConqueror))
				{
					//Reduced penalties for ideological companions.
					iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
					//We overlook war on our ideological opponents!
					if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerOpposingIdeology(eConquered) && !GET_PLAYER(eMajor).GetDiplomacyAI()->IsIgnoreIdeologyDifferences(eConquered))
					{
						//If everything is true, halve the standard warmonger amount for this player.
						iWarmongerStatusModifier += /*-50*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
					}
				}
				//Are the conqueror and I of different ideologies? We shall not overlook this (especially if they're fighting an ideological ally)!
				else if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerOpposingIdeology(eConqueror) && !GET_PLAYER(eMajor).GetDiplomacyAI()->IsIgnoreIdeologyDifferences(eConqueror))
				{
					//Increased penalties for ideological enemies.
					iWarmongerStatusModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();

					if (GET_PLAYER(eMajor).GetDiplomacyAI()->IsPlayerSameIdeology(eConquered))
					{
						//If the conquered player and I are of the same ideology, this will really irritate us.
						iWarmongerStatusModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
					}
				}

				//SANCTIONED

				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

				//Is the conquered player embargoed (i.e. sanctioned)? If so, half warmonger penalties against this civ.
				if (pLeague != NULL && pLeague->IsTradeEmbargoed(eMajor, eConquered))
				{
					iWarmongerStatusModifier -= /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
				}

				// Is the Casus Belli resolution enabled? If so, greatly reduce warmonger penalties.
				if (MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->IsWorldWar(eMajor) > 0)
				{
					iWarmongerStatusModifier -= /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
				}

				// Is the Global Peace Accords resolution enabled? If so, greatly increase warmonger penalties.
				if (MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(eMajor) > 0)
				{
					iWarmongerStatusModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
				}

				// Personality should also matter
				if (!GET_PLAYER(eMajor).isHuman())
				{
					int iPersonality = GET_PLAYER(eMajor).GetDiplomacyAI()->GetDiploBalance() * GET_PLAYER(eMajor).GetDiplomacyAI()->GetWarmongerHate();
					iWarmongerStatusModifier *= (100 + iPersonality);
					iWarmongerStatusModifier /= 100;
				}
				// Humans we assume average.
				else
				{
					iWarmongerStatusModifier *= 136;
					iWarmongerStatusModifier /= 100;
				}
			}
			// Liberation bonuses/penalties
			else
			{
				//If the conqueror is at war, liberating cities matters way less to them.
				if (GET_TEAM(kConqueringPlayer.getTeam()).isAtWar(GET_PLAYER(eMajor).getTeam()))
				{
					iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
				}
				//Is this a city for me? Yay!
				if (eMajor == eConquered)
				{
					iWarmongerStatusModifier += /*150*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 2;
				}

				//Minor
				if (kConqueredPlayer.isMinorCiv())
				{
					if (kConqueredPlayer.GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eMajor) >= GC.getFRIENDSHIP_THRESHOLD_ALLIES())
					{
						iWarmongerStatusModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}
					else if (kConqueredPlayer.GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eMajor) >= GC.getFRIENDSHIP_THRESHOLD_FRIENDS())
					{
						iWarmongerStatusModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
					}
					else
					{
						iWarmongerStatusModifier -= /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
					}
				}
			}
			//Proximity should matter.
			if (GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_DISTANT)
			{
				iWarmongerStatusModifier += /*-25*/ GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
			}
			else if (GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_FAR)
			{
				iWarmongerStatusModifier += /*25*/ GC.getWARMONGER_THREAT_MODIFIER_SMALL();
			}
			else if (GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_CLOSE)
			{
				iWarmongerStatusModifier += /*50*/ GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
			}
			else if (GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_NEIGHBORS)
			{
				iWarmongerStatusModifier += /*75*/ GC.getWARMONGER_THREAT_MODIFIER_LARGE();
			}
		}

		int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(pCity, eConqueror, eMajor);

		//this is the big one - geopolitics etc.
		iWarmongerOffset *= 100 + max(-75, iWarmongerStatusModifier);
		iWarmongerOffset /= 100;

		//this one mainly deals with relative power
		iWarmongerOffset *= 100 + iWarmongerApproachModifier;
		iWarmongerOffset /= 100;

		//this one mainly deals with defensive pacts and vassalage
		iWarmongerOffset *= max(1, iWarmongerModifier);
		iWarmongerOffset /= 100;

		return iWarmongerOffset;
	}
	return 0;
}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
/// Possible Contact Statement - AI only
void CvDiplomacyAI::DoMakeVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	// note: we check to see if it's possible in IsMakeOfferForVassalage()

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can we make an offer for vassalage?
		if(GetPlayer()->GetDealAI()->IsMakeOfferForVassalage(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BECOME_MY_VASSAL;
			int iTurnsBetweenStatement = 50;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
			{
				// Send the statement
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - AI only
void CvDiplomacyAI::DoBecomeVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (IsAvoidDeals())
		return;

	if (GET_PLAYER(ePlayer).isHuman() && GC.getGame().IsTradeOffersDisabled())
		return;

	// note: we check to see if it's possible in IsMakeOfferForVassalage()

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can we make an offer for vassalage?
		if (GetPlayer()->GetDealAI()->IsMakeOfferToBecomeVassal(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ACCEPT_VASSALAGE;
			int iTurnsBetweenStatement = 50;

			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
			{
				// Send the statement
				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Vassal taxes have been raised
void CvDiplomacyAI::DoVassalTaxesRaisedStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Which player is actually the vassal?
		PlayerTypes eVassal = NO_PLAYER;
		if(IsVassal(ePlayer))
			eVassal = GetID();
		else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetID()))
			eVassal = ePlayer;

		if(eVassal != NO_PLAYER)
		{
			// We are ePlayer's vassal
			if(eVassal == GetID())
			{
				if(IsVassalTaxRaised(ePlayer))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER;
					SetVassalTaxRaised(ePlayer, false);
				}
			}
			// ePlayer is our vassal
			else if(eVassal == ePlayer)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassalTaxRaised(GetID()))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER;
					
					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						// Modify player view to all AI teammates
						if (GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
						{
							eLoopPlayer = (PlayerTypes) iPlayerLoop;
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetVassalTaxRaised(eLoopPlayer, false);
						}
					}
				}
			}
		}
	}
}
/// Possible Contact Statement - Vassal taxes have been lowered
void CvDiplomacyAI::DoVassalTaxesLoweredStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Which player is actually the vassal?
		PlayerTypes eVassal = NO_PLAYER;
		if(IsVassal(ePlayer))
			eVassal = GetID();
		else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetID()))
			eVassal = ePlayer;

		if(eVassal != NO_PLAYER)
		{
			// We are ePlayer's vassal
			if(eVassal == GetID())
			{
				if(IsVassalTaxLowered(ePlayer))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER;
					SetVassalTaxLowered(ePlayer, false);
				}
			}
			// ePlayer is our vassal
			else if(eVassal == ePlayer)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassalTaxLowered(GetID()))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER;
					
					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						// Modify player view to all AI teammates
						if (GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
						{
							eLoopPlayer = (PlayerTypes) iPlayerLoop;
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetVassalTaxLowered(eLoopPlayer, false);
						}
					}
				}
			}

		}
	}
}
/// Possible Contact Statement - Vassal has been liberated
void CvDiplomacyAI::DoLiberateMyVassalStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Has to be my vassal
		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetID()))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_LIBERATE_VASSAL;
			int iTurnsBetweenStatement = 25;

			if(IsWantToLiberateVassal(ePlayer))
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Do we want to liberate ePlayer's team?
bool CvDiplomacyAI::IsWantToLiberateVassal(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	TeamTypes eMyTeam = m_pPlayer->getTeam();
	CvTeam& kMyTeam = GET_TEAM(eMyTeam);

	TeamTypes eVassalTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kVassalTeam = GET_TEAM(eVassalTeam);

	// Can't liberate? Abort!
	if(!kMyTeam.CanLiberateVassal(eVassalTeam))
		return false;

	// Shadow AI can't make this decision for teammate
	if(kMyTeam.isHuman() && !m_pPlayer->isHuman())
		return false;

	//World conqueror and this guy lost his capital? He's a perma-vassal.
	if (m_pPlayer->GetDiplomacyAI()->IsGoingForWorldConquest() && GET_PLAYER(ePlayer).IsHasLostCapital())
		return false;

	std::vector<CvPlayerAI*> m_Masters;
	std::vector<CvPlayerAI*> m_Vassals;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if(GET_PLAYER(eLoopPlayer).getTeam() == eMyTeam)
				m_Masters.push_back(&GET_PLAYER(eLoopPlayer));
			if(GET_PLAYER(eLoopPlayer).getTeam() == eVassalTeam)
				m_Vassals.push_back(&GET_PLAYER(eLoopPlayer));
		}
	}

	CvAssertMsg(m_Masters.size() > 0, "master team expected to be greater than size 0");
	CvAssertMsg(m_Vassals.size() > 0, "vassal team expected to be greater than size 0");

	MajorCivApproachTypes eMasterApproach = NO_MAJOR_CIV_APPROACH;
	MajorCivOpinionTypes eMasterOpinion = NO_MAJOR_CIV_OPINION;
	StrengthTypes eVassalStrength = NO_STRENGTH_VALUE;
	StrengthTypes eVassalEcoStrength = NO_STRENGTH_VALUE;

	int iTotalGPTTimes100 = 0;
	int iApproachScore = 0;
	int iOpinionScore = 0;
	int iStrengthScore = 0;
	int iEcoStrengthScore = 0;

	InfluenceLevelTypes eMasterInfluence = NO_INFLUENCE_LEVEL;
	InfluenceLevelTypes eVassalInfluence = NO_INFLUENCE_LEVEL;

	// Calculate averages for master
	for(std::vector<CvPlayerAI*>::iterator it = m_Masters.begin(); it != m_Masters.end(); it++)
	{
		CvPlayer* pMaster = (*it);

		iTotalGPTTimes100 += pMaster->calculateGoldRateTimes100();

		// How does one master see each vassal?
		int iAverageApproachForOneMaster = 0;
		int iAverageOpinionForOneMaster = 0;
		int iAverageStrengthScoreForOneMaster = 0;
		int iAverageEcoStrengthScoreForOneMaster = 0;

		for(std::vector<CvPlayerAI*>::iterator vIt = m_Vassals.begin(); vIt != m_Vassals.end(); vIt++)
		{
			CvPlayer* pVassal = (*vIt);

			// Did they denounce us?
			if(pVassal->GetDiplomacyAI()->IsDenouncedPlayer(pMaster->GetID()))
				return false;

			// Did we denounce them?
			if(pMaster->GetDiplomacyAI()->IsDenouncedPlayer(pVassal->GetID()))
				return false;

			iAverageApproachForOneMaster += (int) pMaster->GetDiplomacyAI()->GetMajorCivApproach(pVassal->GetID());
			iAverageOpinionForOneMaster += (int) pMaster->GetDiplomacyAI()->GetMajorCivOpinion(pVassal->GetID());
			iAverageStrengthScoreForOneMaster += (int) pMaster->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(pVassal->GetID());
			iAverageEcoStrengthScoreForOneMaster += (int) pMaster->GetDiplomacyAI()->GetPlayerEconomicStrengthComparedToUs(pVassal->GetID());
			
			// Only care about the highest
			InfluenceLevelTypes eMasterInfluenceOverVassal = pMaster->GetCulture()->GetInfluenceLevel(pVassal->GetID());
			if(eMasterInfluenceOverVassal > eMasterInfluence)
				eMasterInfluence = eMasterInfluenceOverVassal;

			// Only care about the highest
			InfluenceLevelTypes eVassalInfluenceOverMaster = pVassal->GetCulture()->GetInfluenceLevel(pMaster->GetID());
			if(eVassalInfluenceOverMaster > eVassalInfluence)
				eVassalInfluence = eVassalInfluenceOverMaster;
		}

		iApproachScore += iAverageApproachForOneMaster;
		iApproachScore /= m_Vassals.size();

		iOpinionScore += iAverageOpinionForOneMaster;
		iOpinionScore /= m_Vassals.size();

		iStrengthScore += iAverageStrengthScoreForOneMaster;
		iStrengthScore /= m_Vassals.size();

		iEcoStrengthScore += iAverageEcoStrengthScoreForOneMaster;
		iEcoStrengthScore /= m_Vassals.size();
	}

	iApproachScore /= m_Masters.size();
	iOpinionScore /= m_Masters.size();
	iStrengthScore /= m_Masters.size();
	iEcoStrengthScore /= m_Masters.size();

	eMasterApproach = (MajorCivApproachTypes) iApproachScore;
	eMasterOpinion = (MajorCivOpinionTypes) iOpinionScore;
	eVassalStrength = (StrengthTypes) iStrengthScore;
	eVassalEcoStrength = (StrengthTypes) iEcoStrengthScore;

	CvAssertMsg(eMasterApproach >= NO_MAJOR_CIV_APPROACH && eMasterApproach < NUM_MAJOR_CIV_APPROACHES, "Something went wrong with the evaluation for approaches.");
	CvAssertMsg(eMasterOpinion >= NO_MAJOR_CIV_OPINION && eMasterOpinion < NUM_MAJOR_CIV_OPINIONS, "Something went wrong with the evaluation for opinions.");
	CvAssertMsg(eVassalStrength >= NO_STRENGTH_VALUE && eMasterOpinion < NUM_STRENGTH_VALUES, "Something went wrong with the evaluation for strengths.");
	CvAssertMsg(eMasterInfluence >= NO_INFLUENCE_LEVEL && eMasterInfluence < /* hard-coded */ 6, "Something went wrong with the evaluation for opinions.");
	CvAssertMsg(eVassalInfluence >= NO_INFLUENCE_LEVEL && eMasterInfluence < /* hard-coded */ 6, "Something went wrong with the evaluation for opinions.");

	// Note, could use a "less than "MAJOR_CIV_APPROACH_AFRAID" check, but this is more explicit :)
	// If team doesn't like them, don't consider it.
	if(eMasterApproach == MAJOR_CIV_APPROACH_WAR ||
		eMasterApproach == MAJOR_CIV_APPROACH_HOSTILE ||
		eMasterApproach == MAJOR_CIV_APPROACH_DECEPTIVE ||
		eMasterApproach == MAJOR_CIV_APPROACH_GUARDED)
	{
		return false;
	}

	// Opinion also bad?
	if(eMasterOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE ||
		eMasterOpinion == MAJOR_CIV_OPINION_ENEMY ||
		eMasterOpinion == MAJOR_CIV_OPINION_COMPETITOR)
	{
		return false;
	}

	int iScoreForLiberate = 0;
		
	// Initial score based on remaining approach
	switch(eMasterApproach)
	{
	case MAJOR_CIV_APPROACH_AFRAID:
		iScoreForLiberate = 100;
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		iScoreForLiberate = 50;
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		iScoreForLiberate = 20;
		break;
	default:
		CvAssertMsg(false, "IsWantToLiberateVassal(): Something went terribly wrong");
	}

	// mod based on opinion
	switch(eMasterOpinion)
	{
		case MAJOR_CIV_OPINION_NEUTRAL:
			iScoreForLiberate += 0;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iScoreForLiberate += 10;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			iScoreForLiberate += 15;
			break;
		case MAJOR_CIV_OPINION_ALLY:
			iScoreForLiberate += 25;
			break;
		default:
			CvAssertMsg(false, "IsWantToLiberateVassal(): Something went terribly wrong");
	}

	int iGoldFromTaxesTimes100 = 0;
	// Good source of revenue for us - not so likely to break off
	for(std::vector<CvPlayerAI*>::iterator it = m_Vassals.begin(); it != m_Vassals.end(); it++)
	{
		iGoldFromTaxesTimes100 += (*it)->GetTreasury()->GetExpensePerTurnFromVassalTaxesTimes100();
	}

	// more than 20 percent of our net GPT - less likely
	if(iGoldFromTaxesTimes100 * 100 > iTotalGPTTimes100 * 20)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// don't liberate a strong vassal - he could be a threat
	if(eVassalStrength > STRENGTH_AVERAGE ||
		eVassalEcoStrength > STRENGTH_AVERAGE)
		return false;

	switch(eVassalStrength)
	{
		case STRENGTH_PATHETIC:
			iScoreForLiberate *= 125;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_WEAK:
			iScoreForLiberate *= 115;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_POOR:
			iScoreForLiberate *= 100;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_AVERAGE:
			iScoreForLiberate *= 90;
			iScoreForLiberate /= 100;
			break;
	}

	switch(eVassalEcoStrength)
	{
		case STRENGTH_PATHETIC:
			iScoreForLiberate *= 125;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_WEAK:
			iScoreForLiberate *= 115;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_POOR:
			iScoreForLiberate *= 100;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_AVERAGE:
			iScoreForLiberate *= 90;
			iScoreForLiberate /= 100;
			break;
	}

	// Mod based on proximity
	switch(m_pPlayer->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_DISTANT:
		iScoreForLiberate *= 125;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_FAR:
		iScoreForLiberate *= 110;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_CLOSE:
		iScoreForLiberate *= 100;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_NEIGHBORS:
		iScoreForLiberate *= 75;
		iScoreForLiberate /= 100;
		break;
	}

	// City comparison modifier
	int iNumPop = kMyTeam.getTotalPopulation();
	int iNumVassalPop = kVassalTeam.getTotalPopulation();

	if(iNumVassalPop >= iNumPop)
		return false;

	if(iNumVassalPop * 100 > iNumPop * 75)
	{
		iScoreForLiberate *= 75;
		iScoreForLiberate /= 100;
	}
	else if(iNumVassalPop * 100 > iNumPop * 50)
	{
		iScoreForLiberate *= 100;
		iScoreForLiberate /= 100;
	}
	else if(iNumVassalPop * 100 > iNumPop * 33)
	{
		iScoreForLiberate *= 125;
		iScoreForLiberate /= 100;
	}
	else
	{
		iScoreForLiberate *= 150;	// not a threat at all to us
		iScoreForLiberate /= 100;
	}

	int iDominanceOverVassal = eMasterInfluence - eVassalInfluence;

	// someone is pretty dominant over vassal (not too much of a modifier, but helps our chances of liberation)
	if(iDominanceOverVassal > 0)
	{
		iScoreForLiberate *= 120;
		iScoreForLiberate /= 100;
	}
	else if(iDominanceOverVassal < 0)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// Someone influential over one of our vassals
	if(eMasterInfluence >= INFLUENCE_LEVEL_INFLUENTIAL)
	{
		iScoreForLiberate *= 150;
		iScoreForLiberate /= 100;
	}

	// A vassal is influential over us!!! Them being a vassal will be good for us
	if(eVassalInfluence >= INFLUENCE_LEVEL_INFLUENTIAL)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// The longer they've been our vassal, give a very small boost toward liberation
	iScoreForLiberate += 3 * (kVassalTeam.GetNumTurnsIsVassal() / 50);	// 3% per 50 turns

	return (iScoreForLiberate > 100);
}

/// Possible Contact Statement - Third-party offer for ePlayer to liberate their vassals
void CvDiplomacyAI::DoRevokeVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// note: we check to see if it's possible in IsMakeOfferForVassalage()

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can we make an offer for vassalage?
		if(GetPlayer()->GetDealAI()->IsMakeOfferForRevokeVassalage(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY;
			int iTurnsBetweenStatement = 50;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
			{
				// Send the statement
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}
///	Do we want to capitulate to ePlayer? (bWar: is this a wartime assessment?)
bool CvDiplomacyAI::IsVassalageAcceptable(PlayerTypes ePlayer, bool bWar)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We can't become ePlayer's vassal
	if(!GET_TEAM(GetTeam()).canBecomeVassal(GET_PLAYER(ePlayer).getTeam()))
		return false;

	// Human teams can capitulate, but the AI can't do it for him and he must accept on the trade screen
	if(GET_TEAM(GetTeam()).isHuman() || GetPlayer()->IsAITeammateOfHuman())
		return false;

	// Split this function into two evaluations, capitulation (war) and voluntary (peace)
	if(bWar)
	{
		return IsCapitulationAcceptable(ePlayer);
	}
	else
	{
		return IsVoluntaryVassalageAcceptable(ePlayer);
	}
}

/// Do we want to capitulate to ePlayer due to war?
bool CvDiplomacyAI::IsCapitulationAcceptable(PlayerTypes ePlayer)
{
	TeamTypes eOurTeam = GetTeam();
	CvTeam& kOurTeam = GET_TEAM(eOurTeam);
	
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kTheirTeam = GET_TEAM(eTheirTeam);

	if(!kOurTeam.isAtWar(eTheirTeam))
		return false;

	// Check war score
	if (GetWarScore(ePlayer) == -100)
		return true;

	// How's the war going?
	WarStateTypes eWarState = GetWarState(ePlayer);
	if(eWarState >= WAR_STATE_STALEMATE ||
		eWarState == NO_WAR_STATE_TYPE)
		return false;

	// We have vassals
	if(GET_TEAM(GetTeam()).GetNumVassals() > 0)
	{
		return false;
	}

	int iWantVassalageScore = 0;

	int iWarScore = GetWarScore(ePlayer);

	// Check war score
	if (GetWarScore(ePlayer) > -80)
		return false;
	
	if(iWarScore < -80)
		iWantVassalageScore = 75;
	else
		iWantVassalageScore = 100;

	// Mod based on distance
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_DISTANT:
			iWantVassalageScore *= 33;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_FAR:
			iWantVassalageScore *= 66;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWantVassalageScore *= 100;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWantVassalageScore *= 150;
			iWantVassalageScore /= 100;
			break;
	}

	// Factor in this guy's military strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
		case STRENGTH_IMMENSE:
			iWantVassalageScore *= 250;
			iWantVassalageScore /= 100;
			break;
		case STRENGTH_POWERFUL:
			iWantVassalageScore *= 150;
			iWantVassalageScore /= 100;
			break;
		case STRENGTH_STRONG:
			iWantVassalageScore *= 125;
			iWantVassalageScore /= 100;
			break;
		default:
			return false;
			break;
	}

	// We're going for conquest...
	if(IsGoingForWorldConquest())
	{
		iWantVassalageScore *= 50;
		iWantVassalageScore /= 100;
	}

	// Lost our capital?
	if(GetPlayer()->IsHasLostCapital())
	{
		iWantVassalageScore *= 150;
		iWantVassalageScore /= 100;

		// to this player?
		CvPlot* pOriginalCapitalPlot = GC.getMap().plot(GET_PLAYER(ePlayer).GetOriginalCapitalX(), GET_PLAYER(ePlayer).GetOriginalCapitalY());
		if(pOriginalCapitalPlot != NULL)
		{
			if(pOriginalCapitalPlot->isCity())
			{
				if(GET_PLAYER(pOriginalCapitalPlot->getOwner()).getTeam() == GET_PLAYER(ePlayer).getTeam())
				{
					iWantVassalageScore *= 150;
					iWantVassalageScore /= 100;
				}
			}
		}
	}

	//// They have more civs than us!
	if(kOurTeam.getAliveCount() < kTheirTeam.getAliveCount())
	{
		iWantVassalageScore *= 200;
		iWantVassalageScore /= 100;
	}
	else if (kOurTeam.getAliveCount() > kTheirTeam.getAliveCount())
	{
		iWantVassalageScore *= 50;
		iWantVassalageScore /= 100;
	}

	int iThreshold = /*100*/ GC.getVASSALAGE_CAPITULATE_BASE_THRESHOLD();
	return (iWantVassalageScore > iThreshold);
}

/// Do we want to voluntarily become ePlayer's vassal?
bool CvDiplomacyAI::IsVoluntaryVassalageAcceptable(PlayerTypes ePlayer)
{
	TeamTypes eOurTeam = GetTeam();
	CvTeam& kOurTeam = GET_TEAM(eOurTeam);

	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kTheirTeam = GET_TEAM(eTheirTeam);

	// No cities
	if(kTheirTeam.getNumCities() == 0)
		return false;

	// We have more members - no
	if(kOurTeam.getAliveCount() > kTheirTeam.getAliveCount())
		return false;

	// Vassalage never acceptable if I have vassals already
	if(GET_TEAM(GetTeam()).GetNumVassals() > 0)
		return false;

	//cannot voluntary become a vassal if at war.
	if (GetPlayer()->IsAtWar())
		return false;
	
	// Don't become vassal if we're going for diplo victory and UN is available
	if (!GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
		{
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				if (pLeague->IsUnitedNations())
				{
					if(IsGoingForDiploVictory())
						return false;
				}
			}
		}
	}

	std::vector<PlayerTypes> aOurTeam;
	std::vector<PlayerTypes> aTheirTeam;
	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iI;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			if(GET_PLAYER(eLoopPlayer).getTeam() == eOurTeam)
				aOurTeam.push_back(eLoopPlayer);
			if(GET_PLAYER(eLoopPlayer).getTeam() == eTheirTeam)
				aTheirTeam.push_back(eLoopPlayer);
		}
	}

	int iAverageOpinionScore = 0;
	int iOurCapitals = 0;
	int iTheirCapitals = 0;
	for(std::vector<PlayerTypes>::iterator it = aOurTeam.begin(); it != aOurTeam.end(); it++)
	{
		iOurCapitals += GET_PLAYER(*it).GetNumCapitalCities();
		iAverageOpinionScore += (int) GET_PLAYER(*it).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer);
		if (GET_PLAYER(*it).IsHasLostCapital())
			iOurCapitals--;
	}
	for(std::vector<PlayerTypes>::iterator it = aTheirTeam.begin(); it != aTheirTeam.end(); it++)
	{
		iTheirCapitals += GET_PLAYER(*it).GetNumCapitalCities();
		if (GET_PLAYER(*it).IsHasLostCapital())
			iTheirCapitals--;
	}
	iAverageOpinionScore /= std::max(1, (int)aOurTeam.size());
	MajorCivOpinionTypes eOpinion = (MajorCivOpinionTypes) iAverageOpinionScore;

	// We possess more capitals than them AND we have more than one city
	if(iOurCapitals >= iTheirCapitals && GetPlayer()->getNumCities() > 1)
		return false;

	// We're going for world conquest?
	if(IsGoingForWorldConquest())
	{
		if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_STRONG)
			return false;
	}

	// If this guy is a backstabber, don't want to be his voluntary vassal
	if (IsUntrustworthy(ePlayer))
		return false;

	// if we're hostile with this player, don't want to be his voluntary vassal
	if (GetMajorCivApproach(ePlayer) <= MAJOR_CIV_APPROACH_GUARDED)
		return false;

	//Denouncement in either direction?
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
		return false;

	// Don't accept vassalage from players too far away
	if(GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
		return false;

	// Player is not a threat
	if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) < STRENGTH_AVERAGE)
		return false;

	// Player is not a threat
	if (GetPlayerEconomicStrengthComparedToUs(ePlayer) < STRENGTH_AVERAGE)
		return false;

	// Player is significantly weaker than we are
	if (IsEasyTarget(ePlayer))
		return false;

	// Are we dominating them in some way?
	InfluenceLevelTypes eInfluence = GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);
	if(eInfluence >= INFLUENCE_LEVEL_POPULAR)
		return false;

	// No voluntary capitulation if there's less than 50% of the players ever alive
	if(GC.getGame().countMajorCivsAlive() < (GC.getGame().countMajorCivsEverAlive() / 2 ))
		return false;

	// Has this player a military promise against us?
	if(IsPlayerBrokenMilitaryPromise(ePlayer))
		return false;

	// Differing ideologies?
	if(GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE &&
		GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE &&
		GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
		return false;

	// If we got down here, then vassalage is possible - let's evaluate
	int iWantVassalageScore = -10;

	// Small bonus for voluntary vassalage depending on opinion
	if (eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
		iWantVassalageScore += -50;
	else if(eOpinion == MAJOR_CIV_OPINION_NEUTRAL)
		iWantVassalageScore += -10;
	else if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
		iWantVassalageScore += 10;
	else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
		iWantVassalageScore += 15;
	else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
		iWantVassalageScore += 25;
	else
		iWantVassalageScore += -25;

	// If they are economically strong, consider vassalage
	StrengthTypes eEconomyStrength = GetPlayerEconomicStrengthComparedToUs(ePlayer);
	if(eEconomyStrength == STRENGTH_IMMENSE)
		iWantVassalageScore += 50;
	else if(eEconomyStrength == STRENGTH_POWERFUL)
		iWantVassalageScore += 25;
	else if(eEconomyStrength == STRENGTH_STRONG)
		iWantVassalageScore += 10;
	else if(eEconomyStrength == STRENGTH_AVERAGE)
		iWantVassalageScore += 0;
	else if(eEconomyStrength == STRENGTH_POOR)
		iWantVassalageScore += -15;
	else if(eEconomyStrength == STRENGTH_WEAK)
		iWantVassalageScore += -30;
	else
		iWantVassalageScore += -100;

	// If they are militarily strong, consider vassalage
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_IMMENSE)
		iWantVassalageScore += 50;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iWantVassalageScore += 30;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iWantVassalageScore += 10;
	else if (eMilitaryStrength == STRENGTH_AVERAGE)
		iWantVassalageScore += 5;
	else
		iWantVassalageScore += -100;

	// Small bonus for being a threat to us
	ThreatTypes eMilitaryThreat = GetMilitaryThreat(ePlayer);
	if(eMilitaryThreat == THREAT_CRITICAL)
		iWantVassalageScore += 40;
	else if(eMilitaryThreat == THREAT_SEVERE)
		iWantVassalageScore += 30;
	else if(eMilitaryThreat == THREAT_MAJOR)
		iWantVassalageScore += 20;
	else if(eMilitaryThreat <= THREAT_MINOR)
		iWantVassalageScore += 10;
	else
		iWantVassalageScore += -10;

	int iOurTechs = kOurTeam.GetTeamTechs()->GetNumTechsKnown();
	int iTheirTechs = kTheirTeam.GetTeamTechs()->GetNumTechsKnown();
	int iTechPercent = 0;
	if(iTheirTechs == 0)
		iTechPercent = INT_MAX;
	else
		iTechPercent = iOurTechs * 100 / iTheirTechs;

	// We are at a similar tech level!
	if (iTechPercent > 95)
		iWantVassalageScore -= 10;

	// Lagging behind
	if(iTechPercent >= 85)
		iWantVassalageScore += 10;
	else if(iTechPercent >= 75)
		iWantVassalageScore += 20;
	// Really far behind!
	else if(iTechPercent >= 65)
		iWantVassalageScore += 30;
	else
		iWantVassalageScore += 40;

	int iVal = MOD_BALANCE_CORE_HAPPINESS ? 50 : 0;
	// Small mod based on happiness
	if (GetPlayer()->GetExcessHappiness() < iVal)
		iWantVassalageScore += 10;

	// Account for this player's flavors
	
	// If the player has deleted the EXPANSION Flavor we have to account for that
	int iDefaultFlavorValue = /*5*/ GC.getGame().GetDefaultFlavorValue();
	int iExpansionFlavor = iDefaultFlavorValue;
	int iOffenseFlavor = iDefaultFlavorValue;
	int iMilitaryTrainingFlavor = iDefaultFlavorValue;
	int iDefenseFlavor = iDefaultFlavorValue;
	int iCultureFlavor = iDefaultFlavorValue;
	int iWonderFlavor = iDefaultFlavorValue;

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")			iExpansionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_OFFENSE")			iOffenseFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")	iMilitaryTrainingFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_DEFENSE")			iDefenseFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_CULTURE")			iCultureFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_WONDER")				iWonderFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
	}

	// Adjust score based on civ flavors
	iWantVassalageScore += (iExpansionFlavor - iDefaultFlavorValue) * -3;	// expansionist civs don't like vassalage too much
	iWantVassalageScore += (iOffenseFlavor - iDefaultFlavorValue) * -3;	// offensive civs don't like vassalage too much
	iWantVassalageScore += (iMilitaryTrainingFlavor - iDefaultFlavorValue)	* -3;	// offensive civs don't like vassalage too much
	iWantVassalageScore += (iDefenseFlavor - iDefaultFlavorValue);	// defensive civs like vassalage a lot
	iWantVassalageScore += (iCultureFlavor - iDefaultFlavorValue);	// cultural civs prefer vassalage
	iWantVassalageScore += (iWonderFlavor - iDefaultFlavorValue);	// wonder civs don't mind vassalage

	// Modifier based on proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWantVassalageScore *= 125;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWantVassalageScore *= 105;
			iWantVassalageScore /= 100;
			break;
		default:
			return false;
	}

	// Are they threatening us with military?
	AggressivePostureTypes eAggressivePosture = GetMilitaryAggressivePosture(ePlayer);
	if(eAggressivePosture == AGGRESSIVE_POSTURE_INCREDIBLE)
	{
		iWantVassalageScore *= 125;
		iWantVassalageScore /= 100;
	}
	else if(eAggressivePosture == AGGRESSIVE_POSTURE_HIGH)
	{
		iWantVassalageScore *= 110;
		iWantVassalageScore /= 100;
	}
	else if(eAggressivePosture == AGGRESSIVE_POSTURE_MEDIUM)
	{
		iWantVassalageScore *= 100;
		iWantVassalageScore /= 100;
	}

	// We're bigger than him? Bail!
	if (GET_PLAYER(ePlayer).getTotalPopulation() < GET_PLAYER(GetID()).getTotalPopulation())
	{
		iWantVassalageScore *= 75;
		iWantVassalageScore /= 100;
	}

	// Modifier based on culture
	int iCulturalDominanceOverUs = GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);

	iWantVassalageScore *= (100 + 10 * iCulturalDominanceOverUs);
	iWantVassalageScore /= 100;

	// Reduce score based on at war count
	iWantVassalageScore -= 10 * kTheirTeam.getAtWarCount(true);

	// Reduce score based on number of his vassals
	iWantVassalageScore -= 15 * kTheirTeam.GetNumVassals();

	int iThreshold = /*100*/ GC.getVASSALAGE_CAPITULATE_BASE_THRESHOLD();

	return (iWantVassalageScore >= iThreshold);
}

/// Are we done being ePlayer's vassal, and now want to end it?
bool CvDiplomacyAI::IsEndVassalageAcceptable(PlayerTypes ePlayer)
{
	CvAssertMsg(IsVassal(ePlayer), "Diplomacy AI: Testing whether we should End Vassalage with someone, but we aren't right now. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	// If we actually can't end Vassalage with ePlayer (conditions not satisfied) then abort
	if(!GET_TEAM(GetTeam()).canEndVassal(GET_PLAYER(ePlayer).getTeam()))
		return false;
	
	// Shadow AI does not make decisions for human!
	if(GetPlayer()->IsAITeammateOfHuman())
		return false;

	// don't do this in anarchy
	if(m_pPlayer->IsAnarchy())
		return false;

	if (!IsVoluntaryVassalage(ePlayer) && GET_PLAYER(ePlayer).IsVassalsNoRebel())
		return false;

	// If UN is in session, end vassalage ASAP if going for diplo victory
	if (!GC.getGame().isOption(GAMEOPTION_NO_LEAGUES) && !WasResurrectedBy(ePlayer))
	{
		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
		{
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				if (pLeague->IsUnitedNations())
				{
					if(IsGoingForDiploVictory())
						return true;
				}
			}
		}
	}

	int iChance = WasResurrectedBy(ePlayer) ? -100 : 0;

	// How are we being treated?
	VassalTreatmentTypes eVassalTreatment = GetVassalTreatmentLevel(ePlayer);
	if(eVassalTreatment == VASSAL_TREATMENT_ENSLAVED)
		iChance += 80;
	else if(eVassalTreatment == VASSAL_TREATMENT_UNHAPPY)
		iChance += 60;
	else if(eVassalTreatment == VASSAL_TREATMENT_MISTREATED)
		iChance += 40;
	else if(eVassalTreatment == VASSAL_TREATMENT_DISAGREE)
		iChance += 20;
	else
		iChance += 0;

	// More likely to break vassals off with distant players than close neighbors
	PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
	if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChance += 30;
	else if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChance += 15;

	// if the current approach is a dangerous approach
	if (GetMajorCivApproach(ePlayer) <= MAJOR_CIV_APPROACH_GUARDED)
	{
		iChance += 25;
	}
	else if (GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_AFRAID)
	{
		iChance -= 25;
	}

	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_PATHETIC)
		iChance += 100;
	else if(eMilitaryStrength == STRENGTH_WEAK)
		iChance += 60;
	else if(eMilitaryStrength == STRENGTH_POOR)
		iChance += 40;
	else if(eMilitaryStrength == STRENGTH_AVERAGE)
		iChance += 10;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iChance += -40;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iChance += -60;
	else
		iChance += -40;

	// How will a war against ePlayer go?
	WarProjectionTypes eWarProjection = GetWarProjection(ePlayer);
	if(eWarProjection == WAR_PROJECTION_VERY_GOOD)
		iChance += 40;
	else if(eWarProjection == WAR_PROJECTION_GOOD)
		iChance += 30;
	if(eWarProjection == WAR_PROJECTION_STALEMATE)
		iChance += 5;
	else if(eWarProjection == WAR_PROJECTION_DEFEAT)
		iChance += -20;
	else if(eWarProjection == WAR_PROJECTION_DESTRUCTION)
		iChance += -50;
	else
		iChance += 0;

	// Are we culturally dominant over hem?
	int iCulturalDominanceOverUs = GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);
	if(iCulturalDominanceOverUs <= 0)
	{
		iChance *= 150;
		iChance /= 100;
	}

	// Modifier based on number of wars currently fighting
	iChance *= (100 + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getAtWarCount(true) * 20);
	iChance /= 100;

	// Master is losing all of our wars at the moment - not protecting us
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		iChance *= 500;
		iChance /= 100;
	}

	// We're bigger than him? Bail!
	if (GET_PLAYER(ePlayer).getTotalPopulation() < GET_PLAYER(GetID()).getTotalPopulation())
	{
		iChance *= 500;
		iChance /= 100;
	}

	// Master is aggressive against us
	if(GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM)
	{
		iChance *= 80;
		iChance /= 100;
	}

	// if we're a warmonger
	if(IsGoingForWorldConquest())
	{
		iChance *= 500;
		iChance /= 100;
	}

	// Master in anarchy?
	if(GET_PLAYER(ePlayer).IsAnarchy())
	{
		iChance *= 500;
		iChance /= 100;
	}

	return (iChance >= 100); // todo: global define
}

/// Player ended vassalage with us, is that acceptable?
bool CvDiplomacyAI::IsEndVassalageRequestAcceptable(PlayerTypes ePlayer)
{
//	CvAssertMsg(GET_PLAYER(eHuman).GetDiplomacy()->IsVassal(GetID()), "CvDiplomacyAI: Human ending vassalage with us, but he's not our vassal.");

	int iChanceToGiveIn = 0;

	MajorCivApproachTypes eTrueApproach = (GetMajorCivApproach(ePlayer));
	MajorCivOpinionTypes eOpinion = (GetMajorCivOpinion(ePlayer));

	// We hate him - war!
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE ||
		eOpinion == MAJOR_CIV_OPINION_ENEMY)
		return false;

	// We hate him - war!
	if(eTrueApproach == MAJOR_CIV_APPROACH_WAR ||
		eTrueApproach == MAJOR_CIV_APPROACH_DECEPTIVE ||
		eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	// We're afraid - give in 
	if(eTrueApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// Do we like him?
	if(eOpinion == MAJOR_CIV_OPINION_ALLY)
		iChanceToGiveIn += 25;
	else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
		iChanceToGiveIn += 15;
	else if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
		iChanceToGiveIn += 8;
	else if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
		iChanceToGiveIn += -20;		

	// How will a war against eHuman go?
	WarProjectionTypes eWarProjection = GetWarProjection(ePlayer);
	if(eWarProjection == WAR_PROJECTION_DESTRUCTION)
		iChanceToGiveIn += 33;
	else if(eWarProjection == WAR_PROJECTION_DEFEAT)
		iChanceToGiveIn += 18;
	else if(eWarProjection == WAR_PROJECTION_STALEMATE)
		iChanceToGiveIn += 0;
	else if(eWarProjection == WAR_PROJECTION_GOOD)
		iChanceToGiveIn += -18;
	else if(eWarProjection == WAR_PROJECTION_VERY_GOOD)
		iChanceToGiveIn += -33;
	else 
		iChanceToGiveIn += 0;

	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_IMMENSE)
		iChanceToGiveIn += 50;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iChanceToGiveIn += 33;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iChanceToGiveIn += 18;
	else if(eMilitaryStrength == STRENGTH_AVERAGE)
		iChanceToGiveIn += 0;
	else if(eMilitaryStrength == STRENGTH_POOR)
		iChanceToGiveIn += -20;
	else if(eMilitaryStrength == STRENGTH_WEAK)
		iChanceToGiveIn += -40;
	else 
		iChanceToGiveIn += 0;

	// How much money are we making off this vassal and his team?
	int iTaxIncome = GET_PLAYER(ePlayer).GetTreasury()->GetExpensePerTurnFromVassalTaxesTimes100();
	int iOurGPT = m_pPlayer->calculateGoldRateTimes100();
	
	// Tax is 50% of our income, heavily reliant on it
	if(iTaxIncome * 50 > iOurGPT)
		iChanceToGiveIn += -25;
	else if(iTaxIncome * 20 > iOurGPT)
		iChanceToGiveIn += -10;
	else
		iChanceToGiveIn += 0;

	PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
	if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChanceToGiveIn *= 120;
	else if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChanceToGiveIn *= 110;
	else
		iChanceToGiveIn *= 100;

	iChanceToGiveIn /= 1000;

	if (iChanceToGiveIn <= 3)
	{
		iChanceToGiveIn = 3;
	}

	int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

	if(iRand < iChanceToGiveIn)
		return true;

	return false;
}

/// Possible Contact Statement - We're done being ePlayer's vassal
void CvDiplomacyAI::DoEndVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Must be vassal of ePlayer
		if(IsVassal(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REVOKE_VASSALAGE;
			int iTurnsBetweenStatement = 10;

			// Done being this player's vassal?
			if (IsEndVassalageAcceptable(ePlayer))
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - World Map
void CvDiplomacyAI::DoMapsOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	//problem: on larger maps evaluating the map value every turn for every player is significant performance overhead
	//solution: we could cache the value for the active player, saving half the effort, but it's simpler to just not even contemplate the offer every turn
	int iRandom = GC.getGame().getSmallFakeRandNum(3, (int)ePlayer) + 3; // either 3 or 4 or 5
	if (GC.getGame().getGameTurn() % iRandom != 0)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForMaps(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_MAPS_OFFER;
			int iTurnsBetweenStatements = 30;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Purchase technology
void CvDiplomacyAI::DoTechOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForTech(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_TECH_OFFER;
			int iTurnsBetweenStatements = 30;
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Generous Offer
void CvDiplomacyAI::DoGenerousOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_GENEROUS_OFFER;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
				GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED) >= 15 &&
				// Don't send a generous offer request if we recently sent a Request to this player
				GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST) >= 25)
		{
			bool bRandPassed = false;
			bool bMakeGenerousOffer = IsMakeGenerousOffer(ePlayer, pDeal, bRandPassed);

			if(bMakeGenerousOffer && pDeal->GetNumItems() > 0)
			{
				eStatement = eTempStatement;
				SetOfferingGift(ePlayer, true);
				bRandPassed = true;
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				pDeal->m_bIsGift = true;
#endif
			}
			else
			{
				pDeal->ClearItems();
			}
			
			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED);
		}
	}
}

/// Does this AI want to purchase a technology?
bool CvDiplomacyAI::IsTechRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	if (GetPlayer()->IsAITeammateOfHuman())
		return false;
	
	iWeightBias = 0;

	TechTypes eTechToAskFor = NO_TECH;

	int iTechLoop;

	int iNumTechsWeHave = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iNumTechsTheyHave = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
	
	if(iNumTechsTheyHave == 0)
		return false;

	int iNumTechsPercent = iNumTechsWeHave * 100 / iNumTechsTheyHave;

	if(iNumTechsPercent < 90)
		return false;

	// See if the other player has a Tech to trade
	for(iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);

		// Can they actually give us this item
		if(!pDeal->IsPossibleToTradeItem(ePlayer, GetID(), TRADE_ITEM_TECHS, eTech))
			continue;

		eTechToAskFor = eTech;
		break;
	}

	// Didn't find something they could give us?
	if(eTechToAskFor == NO_TECH)
		return false;

	// Add a little something extra since we're in dire straights
	if(iNumTechsPercent < 90)
		iWeightBias += 25;

	// Now seed the deal
	pDeal->AddTechTrade(ePlayer, eTechToAskFor);

	return true;
}

/// Do we want to trade world maps with eOtherPlayer? - this is only used for when to trigger an AI request, not whether or not the AI will accept a deal period
bool CvDiplomacyAI::WantsMapsFromPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (GetPlayer()->IsAITeammateOfHuman())
		return false;

	MajorCivApproachTypes eApproach = GetSurfaceApproach(ePlayer);
	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
	{
		return false;
	}

	// Physically see how much the deal will cost us. Only send request if it's in an acceptable range
	int iMapValue = GetPlayer()->GetDealAI()->GetMapValue(false, ePlayer);
	if(iMapValue > 750)
	{
		return true;
	}

	return false;
}

/// Do we want to make a generous offer to ePlayer?
bool CvDiplomacyAI::IsMakeGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal, bool& bRandPassed)
{
	bool bFriendly = GetMajorCivApproach(ePlayer) == MAJOR_CIV_APPROACH_FRIENDLY;

	if(bFriendly && IsDoFAccepted(ePlayer))
	{
		// Something we want to offer?
		bool bWantsToOfferSomething = false;

		// Gold Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsGoldGenerousOffer(ePlayer, pDeal);
		// Luxury Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsLuxuryGenerousOffer(ePlayer, pDeal);
		// Tech Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsTechGenerousOffer(ePlayer, pDeal);

		if(bWantsToOfferSomething)
		{
			// Random element
			int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			// modifier based on AI loyalty
			int iModifier = (GetLoyalty() - 5);	// +20 for 7 Loyalty, +0 for 5 Loyalty, -30 for 2 Loyalty, +50 for 10 Loyalty

			iRand += iModifier;

			if(iRand >= 6)
			{
				bRandPassed = true;
				return true;
			}
			else
			{
				bRandPassed = false;
				return false;
			}
		}
	}

	return false;
}

/// Do we want to make a gift of gold to ePlayer?
bool CvDiplomacyAI::IsGoldGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	int iOurGold = GetPlayer()->GetTreasury()->GetGold();
	int iOurGPT = GetPlayer()->calculateGoldRate();
	int iOurExpenses = GetPlayer()->GetTreasury()->CalculateInflatedCosts();
	int iOurGrossIncome = iOurGPT + iOurExpenses;

	// If we have no expenses, don't offer (and also don't crash)
	if(iOurExpenses == 0)
		return false;

	// If we don't have gold saved up, don't bother
	if(iOurGold < 100)
		return false;

	// If we're not making 35% more than we're spending then don't offer, we're not doing alright
	if(iOurGrossIncome * 100 / iOurExpenses < 135)
		return false;

	int iTheirGold = GET_PLAYER(ePlayer).GetTreasury()->GetGold();
	int iTheirGPT = GET_PLAYER(ePlayer).calculateGoldRate();
	int iTheirExpenses = GET_PLAYER(ePlayer).GetTreasury()->CalculateInflatedCosts();
	int iTheirGrossIncome = iTheirGPT + iTheirExpenses;

	// Don't divide by zero please
	if(iTheirExpenses != 0)
	{
		// If they're making more than 35% more than they're spending then don't offer, they're in good shape
		if(iTheirGrossIncome * 100 / iTheirExpenses > 135)
			return false;
	}
	else if(iTheirGPT >= iOurGPT)
	{
		return false;
	}

	// Let's not offer any gold if they have more than us
	if(iTheirGold > iOurGold)
	{
		return false;
	}

	// If we've made it this far we'd like to offer, so figure out how much we want to offer
	int iGoldToOffer = iOurGPT * GC.getGame().GetDealDuration() / 20;
	int iGPTToOffer = 0;

	// Let's not offer the player more than double the amount of gold they have
	/*if(iTheirGold != 0)
	{
		if(iGoldToOffer > iTheirGold * 2)
			iGoldToOffer = iTheirGold * 2;
	}*/

	if(iGoldToOffer > iOurGold)
	{
		iGoldToOffer = 0;
		iGPTToOffer = max(1, iOurGPT / 6);
	}

	// Now seed the deal
	if(iGoldToOffer > 0)
		pDeal->AddGoldTrade(GetID(), iGoldToOffer);
	else if(iGPTToOffer > 0)
		pDeal->AddGoldPerTurnTrade(GetID(), iGPTToOffer, GC.getGame().GetDealDuration());

	return true;
}

/// Do we want to gift a luxury to ePlayer?
bool CvDiplomacyAI::IsLuxuryGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	ResourceTypes eLuxuryToOffer = NO_RESOURCE;

	int iResourceLoop;

	// See if there's any Luxuries WE can trade
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			// Only look at Luxuries
			if(pkResource->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GetPlayer()->getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(GetID(), ePlayer, TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			eLuxuryToOffer = eResource;
			break;
		}
	}

	// Didn't find something we could give them?
	if(eLuxuryToOffer == NO_RESOURCE)
		return false;

	// See if the other player has a Resource to trade (because if there are then we shouldn't be offering hand outs)
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if(pkResourceInfo)
		{
			// Only look at Luxuries
			if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(ePlayer, GetID(), TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			// Found something we can trade to them, so abort
			return false;
		}
	}

	// Now seed the deal
	pDeal->AddResourceTrade(GetID(), eLuxuryToOffer, 1, GC.getGame().GetDealDuration());

	return true;
}

/// Do we want to gift a technology to ePlayer?
bool CvDiplomacyAI::IsTechGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	if (GetPlayer()->IsAITeammateOfHuman())
		return false;
	
	TechTypes eTechToOffer = NO_TECH;

	int iTechLoop;

	// See if the other player is lagging in science
	int iOurScience = GetPlayer()->GetScience();
	int iTheirScience = GetPlayer()->GetScience();

	if (iOurScience < iTheirScience)
		return false;

	// See if there's any Technologies WE can trade
	for(iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);

		// Can we actually give us this item
		if(!pDeal->IsPossibleToTradeItem(GetID(), ePlayer, TRADE_ITEM_TECHS, eTech, 1))
			continue;

		eTechToOffer = eTech;
		break;
	}

	// Didn't find something we could give them?
	if(eTechToOffer == NO_TECH)
		return false;

	// We made it this far, let's give them a tech.

	// Now seed the deal
	pDeal->AddTechTrade(GetID(), eTechToOffer);

	return true;
}

/// Are we willing to share our opinion of other players with ePlayer?
bool CvDiplomacyAI::IsShareOpinionAcceptable(PlayerTypes ePlayer)
{
	// Debug setting
	if (GC.getGame().IsDiploDebugModeEnabled() && GET_PLAYER(ePlayer).isHuman())
		return true;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer);
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// Have to share opinion to master
	if (IsVassal(ePlayer))
		return true;

    // Teammates
	if (IsTeammate(ePlayer))
		return true;
	
	// Resurrected us
	if (WasResurrectedBy(ePlayer))
		return true;

	// Backstabber?
	if (IsUntrustworthy(ePlayer))
		return false;

	// If we act hostile, it's not acceptable
	if(IsActHostileTowardsHuman(ePlayer))
		return false;

	// If we have a declaration of friendship, always yes
	if (IsDoFAccepted(ePlayer))
		return true;

	// Just in case we're not acting hostile (for some reason), but our approach is still something bad...
	if(eApproach == MAJOR_CIV_APPROACH_WAR ||
		eApproach == MAJOR_CIV_APPROACH_HOSTILE||
		eApproach == MAJOR_CIV_APPROACH_GUARDED)
	{
		return false;
	}

	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}

	// Haven't known this guy for long enough
	if(IsTooEarlyForShareOpinion(ePlayer))
		return false;
	
	// If player is unforgivable or an enemy, always say no
	if (eOpinion <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	// Has there been a denouncement in either direction?
	if(IsDenouncedPlayer(ePlayer))
		return false;
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetID()))
		return false;

	// If they're Friends or better, say yes
	if (eOpinion >= MAJOR_CIV_OPINION_FRIEND)
		return true;

	// If they're Favorable and our approach is Friendly, say yes
	if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY && eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
		return true;
		
	return false;
}

/// AI won't agree to share Opinions until they've known a player for at least a few turns.
bool CvDiplomacyAI::IsTooEarlyForShareOpinion(PlayerTypes ePlayer)
{
	int iShareOpinionBuffer = /*20*/ GC.getSHARE_OPINION_TURN_BUFFER();

	// Never too early for teammates to share opinion
	if (IsTeammate(ePlayer))
	{
		return false;
	}

	// Never too early for vassals to share opinion
	if (IsVassal(ePlayer))
	{
		return false;
	}

	// Never too early for friends to share opinion
	if (IsDoFAccepted(ePlayer))
	{
		return false;
	}

	if (GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < iShareOpinionBuffer)
		return true;

	return false;
}

void CvDiplomacyAI::DoHelpRequestMade(PlayerTypes ePlayer, DemandResponseTypes eResponse)
{
	if (eResponse == DEMAND_RESPONSE_GIFT_ACCEPT)
	{
		SetHelpRequestAcceptedTurn(ePlayer, GC.getGame().getGameTurn());

		// Decide how long it'll be before we might agree to another help request
		int iNumTurns = /*20*/ GC.getHELP_REQUEST_TURN_LIMIT_MIN();
		iNumTurns += GC.getGame().isReallyNetworkMultiPlayer() ? 5 : GC.getGame().getSmallFakeRandNum(/*10*/ GC.getHELP_REQUEST_TURN_LIMIT_RAND(), (int)GetID());
		SetHelpRequestTooSoonNumTurns(ePlayer, iNumTurns);
	}
}

int CvDiplomacyAI::GetMasterLiberatedMeFromVassalageScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if(IsMasterLiberatedMeFromVassalage(ePlayer))
	{
		iOpinionWeight += /*-50*/ GC.getOPINION_WEIGHT_MASTER_LIBERATED_ME_FROM_VASSALAGE();
	}

	return iOpinionWeight;
}

/// Opinion weight change based on being vassal
int CvDiplomacyAI::GetVassalScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	iOpinionWeight += bVoluntaryVassal ? GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VOLUNTARY_VASSAL() : GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VASSAL();

	return iOpinionWeight;
}

/// Get how we think ePlayer has treated us as our master
VassalTreatmentTypes CvDiplomacyAI::GetVassalTreatmentLevel(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer))
		return NO_VASSAL_TREATMENT;

	int iScore = GetVassalTreatedScore(ePlayer);

	if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_DISAGREE())
		return VASSAL_TREATMENT_CONTENT;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_MISTREATED())
		return VASSAL_TREATMENT_DISAGREE;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_UNHAPPY())
		return VASSAL_TREATMENT_MISTREATED;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_ENSLAVED())
		return VASSAL_TREATMENT_UNHAPPY;
	else
		return VASSAL_TREATMENT_ENSLAVED;
}

/// Tooltip for GetVassalTreatmentLevel()
CvString CvDiplomacyAI::GetVassalTreatmentToolTip(PlayerTypes ePlayer) const
{
	CvString szRtnValue = "";
	CvString szColor;

	int iScore = 0;
	
	int iTotalScore = GetVassalTreatedScore(ePlayer);

	if (iTotalScore == 0)
	{
		szRtnValue += GetLocalizedText("TXT_KEY_VO_TREATMENT_NOTHING", -iScore);
	}
	else
	{
		szRtnValue += GetLocalizedText("TXT_KEY_VO_TREATMENT_TT") + "[NEWLINE]";

		// Demands made of them
		iScore = GetVassalDemandScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_DEMAND", -iScore) + "[ENDCOLOR]";
		
		// Taxation policies
		iScore = GetVassalTaxScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TAX", -iScore) + "[ENDCOLOR]";
		
		// Protection of them
		iScore = GetVassalFailedProtectScore(ePlayer) + GetVassalProtectScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_PROTECT", -iScore) + "[ENDCOLOR]";
		
		// Trade routes made with them
		iScore = GetVassalTradeRouteScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TRADE_ROUTE", -iScore) + "[ENDCOLOR]";
		
		// Shared religion interests
		iScore = GetVassalReligionScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_RELIGION", -iScore) + "[ENDCOLOR]";

		// Total score
		szColor = ((iTotalScore == 0) ? "[COLOR_GREY]" : ((iTotalScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][NEWLINE][TAB]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TOTAL", -iTotalScore) + "[ENDCOLOR]";
	}

	return szRtnValue;
}

/// Opinion weight change based on how well we've been treated by our master
int CvDiplomacyAI::GetVassalTreatedScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	iOpinionWeight += GetVassalDemandScore(ePlayer);
	iOpinionWeight += GetVassalTaxScore(ePlayer);
	iOpinionWeight += GetVassalProtectScore(ePlayer);
	iOpinionWeight += GetVassalFailedProtectScore(ePlayer);
	iOpinionWeight += GetVassalTradeRouteScore(ePlayer);
	iOpinionWeight += GetVassalReligionScore(ePlayer);

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalDemandScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	iOpinionWeight = GetNumTimesDemandedWhileVassal(ePlayer) * GC.getOPINION_WEIGHT_DEMANDED_WHILE_VASSAL();
	
	if(bVoluntaryVassal)
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalTaxScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	int iGoldCollectedSinceVassalStarted = GetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer); 
	if (iGoldCollectedSinceVassalStarted == 0)
		return 0;
	int iGoldTaxedSinceVassalStarted = GetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer);
	int iPercentTaxed = iGoldTaxedSinceVassalStarted * 100 / iGoldCollectedSinceVassalStarted;

	// Opinion weight from how much % we've taxed them
	iOpinionWeight = ((int) pow((float)iPercentTaxed, GC.getOPINION_WEIGHT_VASSAL_TAX_EXPONENT())) / std::max(1, GC.getOPINION_WEIGHT_VASSAL_TAX_DIVISOR());
	// Opinion weight from current tax %
	iOpinionWeight += GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetVassalTax(m_pPlayer->GetID()) * GC.getOPINION_WEIGHT_VASSAL_CURRENT_TAX_MODIFIER() / 100;
	
	if (IsVoluntaryVassalage(ePlayer)) 
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalTradeRouteScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;
	
	bool bHaveTradeRouteWithUs = GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(ePlayer, m_pPlayer->GetID());
	if (bHaveTradeRouteWithUs)
	{
		iOpinionWeight += -15;
	}
	
	if (IsVoluntaryVassalage(ePlayer))
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalReligionScore(PlayerTypes ePlayer) const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)) return 0;
	if (!IsVassal(ePlayer)) return 0;

	int iOpinionWeight = 0;

	ReligionTypes eVassalStateReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);
	ReligionTypes eVassalMajorityReligion = GetPlayer()->GetReligions()->GetReligionInMostCities();
	ReligionTypes eMasterStateReligion = GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false);
	ReligionTypes eMasterMajorityReligion = GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();

	// No vassal religion - don't care
	if (eVassalStateReligion == NO_RELIGION && eVassalMajorityReligion == NO_RELIGION)
		return 0;

	// Vassal did not found or conquer
	if (eVassalStateReligion == NO_RELIGION)
	{
		// Master founded, and we have their religion
		if (eMasterStateReligion != NO_RELIGION && eMasterStateReligion == eVassalMajorityReligion && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eMasterStateReligion, ePlayer))
		{
			iOpinionWeight += -20;
		}
		// Same majority religions
		else if (eMasterMajorityReligion != NO_RELIGION && eMasterMajorityReligion == eVassalMajorityReligion)
		{
			iOpinionWeight += -10;
		}
	}
	// Vassal did found or conquer
	else
	{
		// Master also founded or conquered
		if (eMasterStateReligion != NO_RELIGION && GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eMasterStateReligion, ePlayer))
		{
			// ... and it's our majority religion
			if (eMasterStateReligion == eVassalMajorityReligion)
			{
				iOpinionWeight += 25;
			}
			// ... and they've converted some of our cities
			else if (GC.getGame().GetGameReligions()->HasAnyDomesticCityFollowing(eMasterStateReligion, GetID()))
			{
				iOpinionWeight += 10;
			}
		}
		// Master did not found or conquer, but does have a majority religion - ours
		else if (eMasterMajorityReligion != NO_RELIGION && eMasterMajorityReligion == eVassalStateReligion)
		{
			iOpinionWeight += -40;
		}
	}
	
	if (IsVoluntaryVassalage(ePlayer))
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	// No opinion bonuses if the Holy City was captured and we don't have it back yet
	if (iOpinionWeight < 0 && GetPlayer()->IsHasLostHolyCity() && IsPlayerCapturedHolyCity(ePlayer))
		return 0;

	// No opinion penalties if ignoring religious differences
	if (iOpinionWeight > 0 && GetPlayer()->GetDiplomacyAI()->IsIgnoreReligionDifferences(ePlayer))
		return 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetMasterScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if (IsMaster(ePlayer))
	{
		iOpinionWeight += /*-20*/ GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_MASTER();
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTooManyVassalsScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;
	int iNumVassals = 0;

	// Vassals, friends and teammates aren't too concerned
	if (IsVassal(ePlayer) || IsDoFAccepted(ePlayer) || IsTeammate(ePlayer))
	{
		return 0;
	}

	// Each vassal contributes +10 to score (each player on a team counts as 1 vassal)
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		// Only civs we have met
		if (GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iI).getTeam()))
		{
			if (GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
			{
				iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_VASSALAGE_TOO_MANY_VASSALS();
				iNumVassals++;
			}
		}
	}

	// First vassal worth nothing
	if (iNumVassals == 1)
		iOpinionWeight = 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetSameMasterScore(PlayerTypes ePlayer) const
{
	// Redundant for teammates
	if (IsTeammate(ePlayer))
		return 0;
	
	int iOpinionWeight = 0;
	
	if (GetPlayer()->IsVassalOfSomeone() && GET_PLAYER(ePlayer).IsVassalOfSomeone())
	{
		if (GET_TEAM(GetTeam()).GetMaster() == GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster())
		{
			iOpinionWeight += -30;
		}
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalProtectScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if (IsVassal(ePlayer))
	{
		int iWeightChange = -1 * GetVassalProtectValue(ePlayer) / std::max(1, GC.getVASSALAGE_PROTECT_VALUE_PER_OPINION_WEIGHT());
		if (iWeightChange < /*-50*/ GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalFailedProtectScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if (IsVassal(ePlayer))
	{
		int iWeightChange = GetVassalFailedProtectValue(ePlayer) / std::max(1, GC.getVASSALAGE_FAILED_PROTECT_VALUE_PER_OPINION_WEIGHT());
		if (iWeightChange > /*50*/ GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX();
		}
		iOpinionWeight += iWeightChange;
	}

	return iOpinionWeight;
}

/// Returns if we've peacefully revoked vassalage (and they agreed)
bool CvDiplomacyAI::IsHappyAboutPlayerVassalagePeacefullyRevoked(PlayerTypes ePlayer)
{
	int iTurn = GetVassalagePeacefullyRevokedTurn(ePlayer);

	if (iTurn < 0)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iTurn;
	int iDuration = AdjustModifierDuration(true, /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_PEACEFULLY_REVOKED_NUM_TURNS_UNTIL_FORGOTTEN(), GetLoyalty());

	if (iTurnDifference < iDuration)
	{
		return true;
	}

	return false;
}

int CvDiplomacyAI::GetHappyAboutVassalagePeacefullyRevokedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsHappyAboutPlayerVassalagePeacefullyRevoked(ePlayer))
	{
		iOpinionWeight = /*-40*/ GC.getOPINION_WEIGHT_VASSALAGE_THEY_PEACEFULLY_REVOKED();
		int iDuration = AdjustModifierDuration(true, /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_PEACEFULLY_REVOKED_NUM_TURNS_UNTIL_FORGOTTEN(), GetLoyalty());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetVassalagePeacefullyRevokedTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutVassalageForcefullyRevokedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if (IsAngryAboutPlayerVassalageForcefullyRevoked(ePlayer))
	{
		iOpinionWeight += /*50*/ GC.getOPINION_WEIGHT_VASSALAGE_THEY_FORCIBLY_REVOKED();
		int iDuration = AdjustModifierDuration(false, /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_FORCIBLY_REVOKED_NUM_TURNS_UNTIL_FORGIVEN(), GetBoldness());
		return AdjustModifierValue(iOpinionWeight, iDuration, GetVassalageForcefullyRevokedTurn(ePlayer), MODIFIER_TYPE_NORMAL);
	}

	return iOpinionWeight;
}

/// Returns if we've forcefully revoked vassalage
bool CvDiplomacyAI::IsAngryAboutPlayerVassalageForcefullyRevoked(PlayerTypes ePlayer)
{
	int iTurn = GetVassalageForcefullyRevokedTurn(ePlayer);

	if (iTurn < 0)
		return false;

	int iTurnDifference = GC.getGame().getGameTurn() - iTurn;
	int iDuration = AdjustModifierDuration(false, /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_FORCIBLY_REVOKED_NUM_TURNS_UNTIL_FORGIVEN(), GetBoldness());

	if (iTurnDifference < iDuration)
	{
		return true;
	}

	return false;
}

int CvDiplomacyAI::GetBrokenVassalAgreementScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	// Declared war on us while we were his vassal
	// No scaling for backstabbing penalties!
	if (IsPlayerBrokenVassalAgreement(ePlayer))
	{
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_VASSALAGE_BROKEN_VASSAL_AGREEMENT_OPINION_WEIGHT();
	}

	return iOpinionWeight;
}

/// eMasterTeam has changed our taxes
void CvDiplomacyAI::DoVassalTaxChanged(TeamTypes eMasterTeam, bool bTaxesLowered)
{
	if(!GET_TEAM(GetTeam()).IsVassal(eMasterTeam))
		return;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).getTeam() == eMasterTeam)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
			SetVassalTaxRaised(eLoopPlayer, !bTaxesLowered);
			SetVassalTaxLowered(eLoopPlayer, bTaxesLowered);
		}
	}
}

/// eMasterTeam became our master
void CvDiplomacyAI::DoWeMadeVassalageWithSomeone(TeamTypes eMasterTeam, bool bVoluntary)
{
	// Cancel all war plans
	CancelAllCoopWars();
	SetBackstabber(false);
	SetDemandTargetPlayer(NO_PLAYER);
	SetCSWarTargetPlayer(NO_PLAYER);
	SetCSBullyTargetPlayer(NO_PLAYER);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();
		if (eLoopTeam != GetTeam())
		{
			// All players reset warmongering penalty for the vassal
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetWarmongerThreat(GetID(), THREAT_NONE);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetOtherPlayerWarmongerAmountTimes100(GetID(), 0);

			// Kill any attack operations
			SetWantsSneakAttack(eLoopPlayer, false);
			SetArmyInPlaceForAttack(eLoopPlayer, false);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetWantsSneakAttack(GetID(), false);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetArmyInPlaceForAttack(GetID(), false);

			// Reset locked war turns
			GET_TEAM(GetTeam()).SetNumTurnsLockedIntoWar(eLoopTeam, 0);
			GET_TEAM(eLoopTeam).SetNumTurnsLockedIntoWar(GetTeam(), 0);

			// Clear this player's backstabbing penalties
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDoFBroken(GetID(), false, true);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetFriendDenouncedUs(GetID(), false);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetFriendDeclaredWarOnUs(GetID(), false);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetVassalageForcefullyRevokedTurn(GetID(), -1);
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerBrokenVassalAgreement(GetID(), false);

			if (!bVoluntary)
			{
				// Reset war-related penalties
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetNumTimesRazed(GetID(), 0);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetNumTradeRoutesPlundered(GetID(), 0);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetNumTimesNuked(GetID(), 0);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseState(GetID(), NO_PROMISE_STATE);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerAttackCityStatePromiseState(GetID(), NO_PROMISE_STATE);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerBrokenCoopWarPromise(GetID(), false);
			}
		}
	}

	for (int iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
	{
		PlayerTypes eOtherTeamPlayer = (PlayerTypes) iOtherPlayerLoop;
		
		// OtherPlayer is on eTeam
		if (GET_PLAYER(eOtherTeamPlayer).isMajorCiv() && GET_PLAYER(eOtherTeamPlayer).getTeam() == eMasterTeam && IsVassal(eOtherTeamPlayer))
		{
			// Reset master's warmongering penalty
			SetWarmongerThreat(eOtherTeamPlayer, THREAT_NONE);
			SetOtherPlayerWarmongerAmountTimes100(eOtherTeamPlayer, 0);

			// Reset memory of demands made
			SetNumDemandEverMade(eOtherTeamPlayer, 0);

			// Vassal thought they were a liberator, but Master had other plans...
			SetMasterLiberatedMeFromVassalage(eOtherTeamPlayer, false);
			SetVassalagePeacefullyRevokedTurn(eOtherTeamPlayer, -1);
			
			// During capitulation, reset almost all (negative) diplomatic scores. Rationale: When capitulating, AI tends to be very hostile.
			if (!bVoluntary)
			{
				SetLandDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
				SetWonderDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
				SetMinorCivDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
				SetVictoryDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
				SetVictoryBlockLevel(eOtherTeamPlayer, BLOCK_LEVEL_NONE);
				SetTechBlockLevel(eOtherTeamPlayer, BLOCK_LEVEL_NONE);
				SetPolicyBlockLevel(eOtherTeamPlayer, BLOCK_LEVEL_NONE);
				
				if (GetRecentAssistValue(eOtherTeamPlayer) > 0)
				{
					SetRecentAssistValue(eOtherTeamPlayer, 0);
				}
				
				SetNumTimesRazed(eOtherTeamPlayer, 0);
				SetNumTradeRoutesPlundered(eOtherTeamPlayer, 0);
				SetEverConvertedCity(eOtherTeamPlayer, false);
				
				SetNumTimesTheyPlottedAgainstUs(eOtherTeamPlayer, 0);
				SetNumTimesTheyLoweredOurInfluence(eOtherTeamPlayer, 0);
				SetNumTimesPerformedCoupAgainstUs(eOtherTeamPlayer, 0);
				SetNumTimesCultureBombed(eOtherTeamPlayer, 0);
				SetNegativeReligiousConversionPoints(eOtherTeamPlayer, 0);
				SetNegativeArchaeologyPoints(eOtherTeamPlayer, 0);
				SetNumTimesRobbedBy(eOtherTeamPlayer, 0);
				
				// Reset most promises
				if (!IsPlayerBrokenMilitaryPromise(eOtherTeamPlayer))
				{
					SetPlayerMilitaryPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				}
				if (!IsPlayerBrokenAttackCityStatePromise(eOtherTeamPlayer))
				{
					SetPlayerAttackCityStatePromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				}
				SetPlayerExpansionPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerBorderPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerBullyCityStatePromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerSpyPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerNoConvertPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerNoDiggingPromiseState(eOtherTeamPlayer, NO_PROMISE_STATE);
				SetPlayerBrokenCoopWarPromise(eOtherTeamPlayer, false);
				
				SetOtherPlayerNumProtectedMinorsKilled(eOtherTeamPlayer, 0);
				SetOtherPlayerNumProtectedMinorsAttacked(eOtherTeamPlayer, 0);
				SetOtherPlayerNumProtectedMinorsBullied(eOtherTeamPlayer, 0);
				SetOtherPlayerSidedWithProtectedMinorTurn(eOtherTeamPlayer, -1);

				SetDenouncedPlayer(eOtherTeamPlayer, false); // forget any denouncing
				GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetDenouncedPlayer(GetID(), false); // forget any denouncing

				// Forget broken DoF if they haven't backstabbed us
				if (IsDoFBroken(eOtherTeamPlayer) && !IsFriendDenouncedUs(eOtherTeamPlayer) && !IsFriendDeclaredWarOnUs(eOtherTeamPlayer))
				{
					SetDoFBroken(eOtherTeamPlayer, false, true);
				}
				
				SetNumTimesNuked(eOtherTeamPlayer, 0);
				SetWeDislikedTheirProposalTurn(eOtherTeamPlayer, -1);
				SetTheyFoiledOurProposalTurn(eOtherTeamPlayer, -1);

				if (GetLikedTheirProposalValue(eOtherTeamPlayer) > 0)
				{
					SetLikedTheirProposalValue(eOtherTeamPlayer, 0);
				}
				if (GetSupportedOurProposalValue(eOtherTeamPlayer) > 0)
				{
					SetSupportedOurProposalValue(eOtherTeamPlayer, 0);
				}
				
				// Reset common foe bonus
				SetCommonFoeValue(eOtherTeamPlayer, 0);
				SetCoopWarScore(eOtherTeamPlayer, 0);
				GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetCoopWarScore(GetID(), 0);
			}
		}
	}
}

/// ePlayer ended vassalage with someone, so figure out what that means
void CvDiplomacyAI::DoWeEndedVassalageWithSomeone(TeamTypes eTeam)
{
	// Loop through players on the former master's team
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		
		if (GET_PLAYER(ePlayer).getTeam() == eTeam)
		{
			// Set number of times demanded while vassal to be 0, since, y'know, we're not a vassal anymore...
			SetNumTimesDemandedWhileVassal(ePlayer, 0);

			// Reset our memory of GPT that was taxed from us
			SetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer, 0);
			SetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer, 0);

			SetVassalTaxRaised(ePlayer, false);
			SetVassalTaxLowered(ePlayer, false);
		}
	}
}

/// We are liberated by a master
void CvDiplomacyAI::DoLiberatedFromVassalage(TeamTypes eTeam)
{
	CvAssertMsg(eTeam >= 0, "DIPLOMACY AI: Invalid Team Index. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Only do this if we are a vassal
	if (!GET_TEAM(GetTeam()).IsVassal(eTeam))
		return;

	// Get players from Master's team
	for (int iMasterPlayer = 0; iMasterPlayer < MAX_MAJOR_CIVS; iMasterPlayer++)
	{
		PlayerTypes eMasterPlayer = (PlayerTypes) iMasterPlayer;
		if (GET_PLAYER(eMasterPlayer).getTeam() == eTeam)
		{
			SetMasterLiberatedMeFromVassalage(eMasterPlayer, true);
			ChangeRecentAssistValue(eMasterPlayer, -300);
			
			// Remove any previous penalty for refusing to give independence
			SetVassalageForcefullyRevokedTurn(eMasterPlayer, -1);

			PlayerTypes eThirdParty;
			
			// Friends of the vassal - bonus to recent assistance!
			for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
			{
				eThirdParty = (PlayerTypes) iThirdPartyLoop;
				
				if (eThirdParty == GetID() || eThirdParty == eMasterPlayer || GET_PLAYER(eThirdParty).getTeam() == GET_PLAYER(eMasterPlayer).getTeam())
					continue;
				
				if (IsPlayerValid(eThirdParty) && GET_PLAYER(eMasterPlayer).GetDiplomacyAI()->IsPlayerValid(eThirdParty) && IsDoFAccepted(eThirdParty))
				{
					GET_PLAYER(eThirdParty).GetDiplomacyAI()->ChangeRecentAssistValue(eMasterPlayer, -300);
				}
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (CvPreGame::isHuman(eMasterPlayer))
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
					CvDiplomacyRequests::SendRequest(GetID(), eMasterPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
			else
			{
				if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == eMasterPlayer)
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
					gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
#else
			if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == eMasterPlayer)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
				gDLL->GameplayDiplomacyAILeaderMessage(GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
#endif
		}
	}
}

/// How does ePlayer think the world is going?
//GlobalStateTypes CvDiplomacyAI::GetGlobalState(PlayerTypes ePlayer) const
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	return (GlobalStateTypes) m_paeGlobalState[ePlayer];
//}
//
//void CvDiplomacyAI::SetGlobalState(PlayerTypes ePlayer, GlobalStateTypes eGlobalState)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eGlobalState >= 0, "DIPLOMACY_AI: Invalid GlobalState in SetGlobalState.");
//	CvAssertMsg(eGlobalState < NUM_GLOBAL_STATES, "DIPLOMACY_AI: Invalid GlobalState.");
//
//	m_paeGlobalState[ePlayer] = eGlobalState;
//}

//void CvDiplomacyAI::DoUpdateGlobalStates()
//{
	/*
	int iNumPlayersProcessed = 0;
	int iGlobalScore = 0;
	GlobalStateTypes eGlobalState = NO_GLOBAL_STATE;
	// Update global comparisons for each player
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(IsPlayerValid(eLoopPlayer, true))
		{
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Don't process ourselves...
				if(eLoopPlayer != GetID())
				{
					DoUpdateGlobalStateForOnePlayer(eLoopPlayer);
					iNumPlayersProcessed++;

					switch(GetGlobalState(eLoopPlayer))
					{
						case GLOBAL_STATE_UNKNOWN:
							iGlobalScore += 0;
						break;
						case GLOBAL_STATE_VERY_BAD:
							iGlobalScore += -25;
						case GLOBAL_STATE_BAD:
							iGlobalScore += -10;
							break;
						case GLOBAL_STATE_AVERAGE:
							iGlobalScore += 0;
							break;
						case GLOBAL_STATE_GOOD:
							iGlobalScore += 10;
						case GLOBAL_STATE_VERY_GOOD:
							iGlobalScore += 25;
							break;
						default:
							iGlobalScore += 0;
							break;
					}
				}
			}
		}
	}

	// Set the global state for us (how we think we're doing in the world), also prevent a divide by zero
	if(iNumPlayersProcessed == 0)
	{
		SetGlobalState(GetID(), GLOBAL_STATE_UNKNOWN);
	}
	else
	{
		iGlobalScore /= iNumPlayersProcessed;

		if(iGlobalScore >= 25)
			eGlobalState = GLOBAL_STATE_VERY_GOOD;
		else if(iGlobalScore >= 10)
			eGlobalState = GLOBAL_STATE_GOOD;
		else if(iGlobalScore >= 0)
			eGlobalState = GLOBAL_STATE_AVERAGE;
		else if(iGlobalScore >= -10)
			eGlobalState = GLOBAL_STATE_BAD;
		else
			eGlobalState = GLOBAL_STATE_VERY_BAD;
	}

	// Do checks here to make sure AI is setting correct global state due to certain situations

	// We've lost our capital
	if(GetPlayer()->IsHasLostCapital())
	{
		// We're at war with our conqueror and we're winning against him, maybe things are looking up?
		if(IsAtWar(GetPlayer()->GetCapitalConqueror()) && GetWarState(GetPlayer()->GetCapitalConqueror()) >= WAR_STATE_OFFENSIVE)
		{
			// do nothing, use previous evaluation to determine global state
		}
		else
		{
			eGlobalState = GLOBAL_STATE_VERY_BAD;
		}
	}

	// Going for conquest and winning all of our wars, we must be doing something right
	if(GetStateAllWars() == STATE_ALL_WARS_WINNING && IsGoingForWorldConquest())
	{
		if(eGlobalState < GLOBAL_STATE_GOOD)
		{
			eGlobalState = GLOBAL_STATE_GOOD;
		}
	}

	// We're losing all of our wars
	if(GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		// If we're going for world conquest and losing all of our wars, we're in really bad shape
		if(IsGoingForWorldConquest())
		{
			eGlobalState = GLOBAL_STATE_VERY_BAD;
		}
		else
		{
			if(eGlobalState > GLOBAL_STATE_BAD)
			{
				eGlobalState = GLOBAL_STATE_BAD;
			}
		}
	}

	// We're badly unhappy
	if(GetPlayer()->GetExcessHappiness() <= GC.getVERY_UNHAPPY_THRESHOLD())
	{
		if(eGlobalState > GLOBAL_STATE_BAD)
		{
			eGlobalState = GLOBAL_STATE_BAD;
		}
	}
	
	SetGlobalState(GetID(), eGlobalState);
	*/
//}

/// What do we think of our situation with ePlayer?
//void CvDiplomacyAI::DoUpdateGlobalStateForOnePlayer(PlayerTypes ePlayer)
//{

	//GlobalStateTypes eGlobalState;
	//int iOneGlobalStateWeight = 0;
	//int iTempWeight = 0;

	//// Haven't known this guy to process how our situation with him is going (and we're not at war...)
	//if(GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < GC.getGLOBAL_STATE_MIN_TURNS_BEFORE_PROCESS_STATE()
	//	&& !IsAtWar(ePlayer))
	//{
	//	SetGlobalState(ePlayer, GLOBAL_STATE_UNKNOWN);
	//	return;
	//}

	//// Are we at war with this player? And if so, how is it going?
	//if(IsAtWar(ePlayer))
	//{
	//	switch(GetWarState(ePlayer))
	//	{
	//		case WAR_STATE_NEARLY_DEFEATED:
	//			iTempWeight += /*-20*/ GC.getGLOBAL_STATE_NEARLY_DEFEATED_WEIGHT();
	//			break;
	//		case WAR_STATE_DEFENSIVE:
	//			iTempWeight += /*-5*/ GC.getGLOBAL_STATE_DEFENSIVE_WEIGHT();
	//			break;
	//		case WAR_STATE_STALEMATE:
	//			iTempWeight += /*0*/ GC.getGLOBAL_STATE_STALEMATE_WEIGHT();
	//			break;
	//		case WAR_STATE_CALM:
	//			iTempWeight += /*0*/ GC.getGLOBAL_STATE_CALM_WEIGHT();
	//			break;
	//		case WAR_STATE_OFFENSIVE:
	//			iTempWeight += /*5*/ GC.getGLOBAL_STATE_OFFENSIVE_WEIGHT();
	//			break;
	//		case WAR_STATE_NEARLY_WON:
	//			iTempWeight += /*20*/ GC.getGLOBAL_STATE_NEARLY_WON_WEIGHT();
	//			break;
	//		default:
	//			iTempWeight += 0;
	//			break;
	//	}
	//	
	//	// We're going for conquest victory, this weight is very important
	//	if(IsGoingForWorldConquest())
	//	{
	//		iTempWeight *= 200;
	//		iTempWeight /= 100;
	//	}
	//}

	//// in any event, if we're not at war with ePlayer, Global weight starts at 0
	//iOneGlobalStateWeight = iTempWeight;
	//iTempWeight = 0;

	//// Compare strengths
	//switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	//{
	//	case STRENGTH_IMMENSE:
	//		iTempWeight += /*-20*/ GC.getGLOBAL_STATE_MIL_STRENGTH_IMMENSE_WEIGHT();
	//		break;
	//	case STRENGTH_POWERFUL:
	//		iTempWeight += /*-14*/ GC.getGLOBAL_STATE_MIL_STRENGTH_POWERFUL_WEIGHT();
	//		break;
	//	case STRENGTH_STRONG:
	//		iTempWeight += /*-8*/ GC.getGLOBAL_STATE_MIL_STRENGTH_STRONG_WEIGHT();
	//		break;
	//	case STRENGTH_AVERAGE:
	//		iTempWeight += /*0*/ GC.getGLOBAL_STATE_MIL_STRENGTH_AVERAGE_WEIGHT();
	//		break;
	//	case STRENGTH_WEAK:
	//		iTempWeight += /*8*/ GC.getGLOBAL_STATE_MIL_STRENGTH_WEAK_WEIGHT();
	//		break;
	//	case STRENGTH_POOR:
	//		iTempWeight += /*14*/ GC.getGLOBAL_STATE_MIL_STRENGTH_POOR_WEIGHT();
	//		break;
	//	case STRENGTH_PATHETIC:
	//		iTempWeight += /*20*/ GC.getGLOBAL_STATE_MIL_STRENGTH_PATHETIC_WEIGHT();
	//		break;
	//}

	//// military strength not as big a factor depending on distance
	//switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	//{
	//	case PLAYER_PROXIMITY_DISTANT:
	//		iTempWeight *= 50;
	//		break;
	//	case PLAYER_PROXIMITY_FAR:
	//		iTempWeight *= 75;
	//		break;
	//	case PLAYER_PROXIMITY_CLOSE:
	//		iTempWeight *= 100;
	//		break;
	//	case PLAYER_PROXIMITY_NEIGHBORS:
	//		iTempWeight *= 150;
	//		break;
	//}

	//iTempWeight /= 100;

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
	//{
	//	case STRENGTH_IMMENSE:
	//		iTempWeight += /*-12*/ GC.getGLOBAL_STATE_ECON_STRENGTH_IMMENSE_WEIGHT();
	//		break;
	//	case STRENGTH_POWERFUL:
	//		iTempWeight += /*-7*/ GC.getGLOBAL_STATE_ECON_STRENGTH_POWERFUL_WEIGHT();
	//		break;
	//	case STRENGTH_STRONG:
	//		iTempWeight += /*-3*/ GC.getGLOBAL_STATE_ECON_STRENGTH_STRONG_WEIGHT();
	//		break;
	//	case STRENGTH_AVERAGE:
	//		iTempWeight += /*0*/ GC.getGLOBAL_STATE_ECON_STRENGTH_AVERAGE_WEIGHT();
	//		break;
	//	case STRENGTH_WEAK:
	//		iTempWeight += /*3*/ GC.getGLOBAL_STATE_ECON_STRENGTH_WEAK_WEIGHT();
	//		break;
	//	case STRENGTH_POOR:
	//		iTempWeight += /*7*/ GC.getGLOBAL_STATE_ECON_STRENGTH_POOR_WEIGHT();
	//		break;
	//	case STRENGTH_PATHETIC:
	//		iTempWeight += /*12*/ GC.getGLOBAL_STATE_ECON_STRENGTH_PATHETIC_WEIGHT();
	//		break;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Compared number of vassals
	//int iOurVassals = GET_TEAM(GetTeam()).GetNumVassals();
	//int iTheirVassals = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetNumVassals();
	//int iVassalDifference = iOurVassals - iTheirVassals;

	//iOneGlobalStateWeight += (iVassalDifference * /*6*/ GC.getGLOBAL_STATE_NUM_VASSALS_MULTIPLIER());

	//// Compare Number of Techs
	//int iOurTechs = GET_TEAM(GetTeam()).GetTeamTechs()->GetNumTechsKnown();
	//int iTheirTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
	//		
	//iTempWeight = 0;

	//// don't crash if they haven't researched anything yet
	//if(iTheirTechs == 0)
	//	iTheirTechs = 1;
	//		
	//int iTechPercent = iOurTechs * 100/ iTheirTechs;

	//if(iTechPercent >= 115)
	//	iTempWeight += /*12*/ GC.getGLOBAL_STATE_TECH_PERCENT_VERY_GOOD_WEIGHT();
	//else if(iTechPercent >= 105)
	//	iTempWeight += /*6*/ GC.getGLOBAL_STATE_TECH_PERCENT_GOOD_WEIGHT();
	//else if(iTechPercent >= 90)
	//	iTempWeight += /*0*/ GC.getGLOBAL_STATE_TECH_PERCENT_AVERAGE_WEIGHT();
	//else if(iTechPercent >= 75)
	//	iTempWeight += /*-6*/ GC.getGLOBAL_STATE_TECH_PERCENT_BAD_WEIGHT();
	//else
	//	iTempWeight += /*-12*/ GC.getGLOBAL_STATE_TECH_PERCENT_VERY_BAD_WEIGHT();

	//// Increase the science weight if going for spaceship
	//if(IsGoingForSpaceshipVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Compare Number of Policies Unlocked
	//int iOurPolicies = GetPlayer()->GetNumPolicies();
	//int iTheirPolicies = GET_PLAYER(ePlayer).GetNumPolicies();
	//		
	//iTempWeight = (iOurPolicies - iTheirPolicies) * /*3*/ GC.getGLOBAL_STATE_PER_POLICY_WEIGHT();

	////Influential? Bring that in.

	//int iOurInfluence = GetPlayer()->GetCulture()->GetNumCivsInfluentialOn();
	//int iTheirInfluence = GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn();

	//iTempWeight += (iOurInfluence - iTheirInfluence) * 10;

	//// Increase weight if going for culture victory
	//if(IsGoingForCultureVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//int iOurAllies = 0, iTheirAllies = 0;

	//// Check this player's city-state allies
	//PlayerTypes eThirdPartyLoop;
	//for(int iThirdPartyLoop = MAX_MAJOR_CIVS; iThirdPartyLoop < MAX_MINOR_CIVS; iThirdPartyLoop++)
	//{
	//	eThirdPartyLoop = (PlayerTypes) iThirdPartyLoop;
	//	if(GET_PLAYER(eThirdPartyLoop).isMinorCiv())
	//	{
	//		// Minor civ ally of us
	//		if(GetPlayer()->GetMinorCivAI()->GetAlly())
	//		{
	//			iOurAllies++;
	//		}

	//		// Minor civ ally of this third party
	//		if(GET_PLAYER(eThirdPartyLoop).GetMinorCivAI()->GetAlly())
	//		{
	//			iTheirAllies++;
	//		}
	//	}
	//}

	//iTempWeight = (iOurAllies - iTheirAllies) * /*2*/ GC.getGLOBAL_STATE_PER_ALLY_WEIGHT();

	//// We're going for diplo victory, this metric is more important to us
	//if(IsGoingForDiploVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;
	//					
	//// Compare scores
	//int iOurScore = GetPlayer()->GetScore();
	//int iTheirScore = GET_PLAYER(ePlayer).GetScore();
	//if(iTheirScore == 0) iTheirScore = 1;
	//int iScorePercent = (iOurScore * 100/ iTheirScore);

	//if (iScorePercent > 200)
	//	iTempWeight += /*20*/ GC.getGLOBAL_STATE_SCORE_PERCENT_EXTREMELY_GOOD_WEIGHT();
	//else if(iScorePercent >= 150)
	//	iTempWeight += /*8*/ GC.getGLOBAL_STATE_SCORE_PERCENT_VERY_GOOD_WEIGHT();
	//else if(iScorePercent >= 100)
	//	iTempWeight += /*4*/ GC.getGLOBAL_STATE_SCORE_PERCENT_GOOD_WEIGHT();
	//else if(iScorePercent >= 75)
	//	iTempWeight += /*0*/ GC.getGLOBAL_STATE_SCORE_PERCENT_AVERAGE_WEIGHT();
	//else if(iScorePercent >= 50)
	//	iTempWeight += /*-4*/ GC.getGLOBAL_STATE_SCORE_PERCENT_BAD_WEIGHT();
	//else
	//	iTempWeight += /*-8*/ GC.getGLOBAL_STATE_SCORE_PERCENT_VERY_BAD_WEIGHT();

	//VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	//VictoryTypes eDominationVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DOMINATION", true);
	//VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	//VictoryTypes eDiplomaticVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);

	//// No victory condition is valid, we assume a Time Victory is left, our score is worth more
	//if(!GC.getGame().isVictoryValid(eSpaceshipVictory) &&
	//	!GC.getGame().isVictoryValid(eDominationVictory) &&
	//		!GC.getGame().isVictoryValid(eCulturalVictory)   &&
	//		!GC.getGame().isVictoryValid(eDiplomaticVictory))
	//{
	//	iTempWeight *= 150;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Do the final computation
	//if(iOneGlobalStateWeight >= 50)
	//	eGlobalState = GLOBAL_STATE_VERY_GOOD;
	//else if(iOneGlobalStateWeight >= 20)
	//	eGlobalState = GLOBAL_STATE_GOOD;
	//else if(iOneGlobalStateWeight  >= -5)
	//	eGlobalState = GLOBAL_STATE_AVERAGE;
	//else if(iOneGlobalStateWeight  >= -25)
	//	eGlobalState = GLOBAL_STATE_BAD;
	//else
	//	eGlobalState = GLOBAL_STATE_VERY_BAD;

	//// Set the global state for ePlayer
	//SetGlobalState(ePlayer, eGlobalState);
//}

/// Determine tax rates for all vassals, if we can
void CvDiplomacyAI::DoDetermineTaxRateForVassals()
{
	// Update global comparisons for each player
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(IsPlayerValid(eLoopPlayer, true))
		{
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Don't process ourselves...
				if(eLoopPlayer != GetID())
				{
					DoDetermineTaxRateForVassalOnePlayer(eLoopPlayer);
				}
			}
		}
	}
}

/// Determine how much we are going to tax this player, if we can
void CvDiplomacyAI::DoDetermineTaxRateForVassalOnePlayer(PlayerTypes ePlayer)
{
	// Must be able to set taxes for player
	if(!GET_TEAM(GetTeam()).CanSetVassalTax(ePlayer))
		return;

	TeamTypes eMyTeam = GetTeam();
	CvTeam& kMyTeam = GET_TEAM(eMyTeam);

	// Do not allow an AI teammate to do this for a human
	if(!GetPlayer()->isHuman() && kMyTeam.isHuman())
		return;

	// Current tax rate
	int iTaxRate = kMyTeam.GetVassalTax(ePlayer);

	// Make sure we can actually do that...
	bool bWantToLower = iTaxRate > GC.getVASSALAGE_VASSAL_TAX_PERCENT_MINIMUM();
	bool bWantToRaise = iTaxRate < GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM();

	// Because this function will involve lots of iteration over team members, let's store all alive team members in temporary vectors to improve the speed of this function
	std::vector<CvPlayerAI*> m_MasterTeam;
	std::vector<CvPlayerAI*> m_VassalTeam;

	for(int iI=0; iI < MAX_MAJOR_CIVS; iI++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iI;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			// Master team
			if(GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
			{
				m_MasterTeam.push_back(&GET_PLAYER(eLoopPlayer));
			}
			// Vassal team
			else if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
			{
				m_VassalTeam.push_back(&GET_PLAYER(eLoopPlayer));
			}
		}
	}
	
	MajorCivOpinionTypes eTeamOpinion = MAJOR_CIV_OPINION_NEUTRAL;
	int iMyCurrentGPT = 0, iMyCurrentGross = 0, iAverageMeanness = 0, iAverageLoyalty = 0, iAverageOpinionScore = 0;
	for(std::vector<CvPlayerAI*>::iterator it = m_MasterTeam.begin(); it != m_MasterTeam.end(); it++)
	{
		iMyCurrentGPT += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();
		iMyCurrentGross += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();

		iAverageMeanness += (*it)->GetDiplomacyAI()->GetMeanness();
		iAverageLoyalty += (*it)->GetDiplomacyAI()->GetLoyalty();

		iAverageOpinionScore += (*it)->GetDiplomacyAI()->GetMajorCivOpinion(ePlayer);
	}

	iAverageMeanness /= m_MasterTeam.size();
	iAverageLoyalty /= m_MasterTeam.size();
	iAverageOpinionScore /= m_MasterTeam.size();

	eTeamOpinion = (MajorCivOpinionTypes) iAverageOpinionScore;

	int iVassalCurrentGPT = 0, iVassalCurrentGross = 0;
	for(std::vector<CvPlayerAI*>::iterator it = m_VassalTeam.begin(); it != m_VassalTeam.end(); it++)
	{
		iVassalCurrentGPT += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();
		iVassalCurrentGross += (*it)->GetTreasury()->CalculateGrossGoldTimes100();
	}

	// Hate him? Don't consider lowering!
	if(eTeamOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		bWantToLower = false;

	
	// Like him? Don't consider raising!
	if(eTeamOpinion == MAJOR_CIV_OPINION_ALLY)
		bWantToRaise = false;

	// We have some choice in the direction taxes can go - pick a direction so we can start deciding
	if(bWantToLower && bWantToRaise)
	{
		// We're in dire straights
		if(iMyCurrentGPT <= 0)
		{
			bWantToLower = false;	// don't even consider lowering
			
			// Check to see if taxing the vassal the maximum would get us out of dire straights
			if(bWantToRaise)
			{
				// Wouldn't help us out at all
				if((iVassalCurrentGross * GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM() / 100 < 100))
				{
					bWantToRaise = false;
				}
				// Tax vassal the maximum to get us out of trouble - his feelings be damned
				else
				{
					kMyTeam.DoApplyVassalTax(ePlayer, GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM());
					return;
				}
			}
		}
		// Doing fine - have some choice
		else
		{	

			int iScoreForLower = 0;
			int iScoreForRaise = 0;

			// Starting values based on opinion
			switch(eTeamOpinion)
			{
			case MAJOR_CIV_OPINION_ENEMY:
				iScoreForLower = -25;
				iScoreForRaise = 25;
			case MAJOR_CIV_OPINION_COMPETITOR:
				iScoreForLower = -10;
				iScoreForRaise = 10;
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				iScoreForLower = 0;
				iScoreForRaise = 0;
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				iScoreForLower = 10;
				iScoreForRaise = -10;
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				iScoreForLower = 25;
				iScoreForRaise = -25;
				break;
			default:
				CvAssertMsg(false, "Should not have gotten here.");
			}

			// Still deciding what to be done?
			if(bWantToLower && bWantToRaise)
			{
				// Is our vassal doing better than us monetarily?
				if(iVassalCurrentGPT >= iMyCurrentGPT)
				{
					iScoreForLower *= 75;
					iScoreForLower /= 100;

					iScoreForRaise *= 125;
					iScoreForRaise /= 100;
				}
				// He is doing worse than 85% of our GPT
				else if(iVassalCurrentGPT * 85 <= iMyCurrentGPT * 100)
				{
					// Have to like the vassal
					if(eTeamOpinion > MAJOR_CIV_OPINION_NEUTRAL)
					{
						// Determine a percentage to lower
						int iThreshold = 3;

						// He is doing REALLY bad
						if(iVassalCurrentGPT * 150 < iMyCurrentGPT * 100)
							iThreshold = 7;

						int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));
						if(iRand < iThreshold)
						{
							iScoreForLower *= 150;
							iScoreForLower /= 100;
						}
					}
				}

				// Raise score for lowering based on loyalty
				iScoreForLower *= 100 + (iAverageLoyalty - 5) * 10;
				iScoreForLower /= 100;

				// Raise score for lowering based on meanness
				iScoreForRaise *= 100 + (iAverageMeanness - 5) * 10;
				iScoreForRaise /= 100;

				bWantToLower = (iScoreForLower > iScoreForRaise);
				bWantToRaise = (iScoreForLower < iScoreForRaise);
			}
		}
	}

	CvWeightedVector<int, 20, true> aPossibleValues;	// in case changed, 100 / 5  is a safe bet for number of possible elements
	
	// New tax value defaults to current tax rate
	int iNewTaxValue = iTaxRate;

	// Decided we're going to lower - figure out by how much
	if(bWantToLower)
	{
		int iCurrentIndex = 0;

		// Possible values are determined by increments of 5 starting from below the current tax line
		for(int i = (iTaxRate - 5); i >= GC.getVASSALAGE_VASSAL_TAX_PERCENT_MINIMUM(); i -= 5)
		{
			int iValue = i;
			int iWeight = (iAverageOpinionScore - 3) * iCurrentIndex + 100;
			
			// Determine if we will make at least one GPT profit off of this value, if not, then decentivize
			if(iVassalCurrentGross * iValue < 10000)
				iWeight /= 4;

			aPossibleValues.push_back(iValue, iWeight);
			iCurrentIndex++;
		}

		RandomNumberDelegate fcn;
		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);
		iNewTaxValue = aPossibleValues.ChooseByWeight(&fcn, "Choose the tax value to assign");
	}
	// Decided we're going to raise - figure out by how much
	else
	{
		int iCurrentIndex = 0;
		
		// Possible values are determined by increments of 5 starting from above the current tax line
		for(int i = (iTaxRate + 5); i <= GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM(); i += 5)
		{
			int iValue = i;
			int iWeight = (3 - iAverageOpinionScore) * iCurrentIndex + 100;
			
			// Determine if we will make at least one GPT profit off of this value, if not, then decentivize
			if(iVassalCurrentGross * iValue < 10000)
				iWeight /= 4;
			
			aPossibleValues.push_back(iValue, iWeight);
			iCurrentIndex++;
		}

		RandomNumberDelegate fcn;
		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);
		iNewTaxValue = aPossibleValues.ChooseByWeight(&fcn, "Choose the tax value to assign");
	}

	// Set the tax.
	kMyTeam.DoApplyVassalTax(ePlayer, iNewTaxValue);
}

/// Log Global State
//void CvDiplomacyAI::LogGlobalState(CvString& strString, PlayerTypes ePlayer)
//{
//	CvString strTemp;
//
//	switch(GetGlobalState(GetID()))
//	{
//		case NO_GLOBAL_STATE:
//			strTemp.Format("SELF: NO STATE!");
//			break;
//		case GLOBAL_STATE_UNKNOWN:
//			strTemp.Format("SELF: STATE UNKNOWN");
//			break;
//		case GLOBAL_STATE_ANNIHILATED:
//			strTemp.Format("SELF STATE ANNIH");
//			break;
//		case GLOBAL_STATE_VERY_BAD:
//			strTemp.Format("SELF STATE VERY BAD");
//			break;
//		case GLOBAL_STATE_BAD:
//			strTemp.Format("SELF STATE BAD");
//			break;
//		case GLOBAL_STATE_AVERAGE:
//			strTemp.Format("SELF STATE AVERAGE");
//			break;
//		case GLOBAL_STATE_GOOD:
//			strTemp.Format("SELF STATE GOOD");
//			break;
//		case GLOBAL_STATE_VERY_GOOD:
//			strTemp.Format("SELF STATE VERY GOOD");
//			break;
//		case GLOBAL_STATE_NEAR_VICTORY:
//			strTemp.Format("SELF STATE NEAR VICT");
//			break;
//		default:
//			strTemp.Format("SELF: XXX");
//			break;
//	}
//	strString += ", " + strTemp;
//
//	switch(GetGlobalState(ePlayer))
//	{
//		case NO_GLOBAL_STATE:
//			strTemp.Format("TheirGlbSt NONE");
//			break;
//		case GLOBAL_STATE_UNKNOWN:
//			strTemp.Format("TheirGlbSt UNKNOWN");
//			break;
//		case GLOBAL_STATE_VERY_BAD:
//			strTemp.Format("TheirGlbSt VERY BAD");
//			break;
//		case GLOBAL_STATE_BAD:
//			strTemp.Format("TheirGlbSt BAD");
//			break;
//		case GLOBAL_STATE_AVERAGE:
//			strTemp.Format("TheirGlbSt AVERAGE");
//			break;
//		case GLOBAL_STATE_GOOD:
//			strTemp.Format("TheirGlbSt GOOD");
//			break;
//		case GLOBAL_STATE_VERY_GOOD:
//			strTemp.Format("TheirGlbSt VERY GOOD");
//			break;
//		default:
//			strTemp.Format("XXX");
//			break;
//	}
//	strString += ", " + strTemp;
//}

// Version 9
/// Is moving our troops from ePlayer's lands acceptable?
MoveTroopsResponseTypes CvDiplomacyAI::GetMoveTroopsRequestResponse(PlayerTypes ePlayer, bool bJustChecking)
{
	if (IsTeammate(ePlayer) || IsVassal(ePlayer))
		return MOVE_TROOPS_RESPONSE_ACCEPT;

	// We have an operation en route to opponent, or we're planning war
	if (GetPlayer()->HasAnyOffensiveOperationsAgainstPlayer(ePlayer) || AvoidExchangesWithPlayer(ePlayer, /*bWarOnly*/ true))
	{
		return MOVE_TROOPS_RESPONSE_REFUSE;	// War!
	}

	MajorCivApproachTypes eTrueApproach = GetMajorCivApproach(ePlayer);
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	FStaticVector< int, 128, true, c_eCiv5GameplayDLL > viMoveTroopsWeights;

	// Push back values
	for (int i=0; i < NUM_MOVE_TROOPS_RESPONSES; i++)
	{
		viMoveTroopsWeights.push_back(0);
	}

	// Initialize our parallel arrays based on various approaches
	// i.e. more inclined to agree to leave if they like to be friendly toward civs
	viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_FRIENDLY);
	viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_NEUTRAL);
	viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);

	if(IsGoingForWorldConquest())
	{
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -3;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -3;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 5;
	}
	if (IsCloseToDominationVictory())
	{
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -10;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -10;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 10;
	}
	
	// If we hate the guy then add weight for attacking
	switch(eOpinion)
	{
		case MAJOR_CIV_OPINION_UNFORGIVABLE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -4;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 6;
			break;
		case MAJOR_CIV_OPINION_ENEMY:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -1;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 4;
			break;
		case MAJOR_CIV_OPINION_COMPETITOR:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 2;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 2;	// Slight weight for neutral as to not piss off neighbors
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 0;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 4;	// Just favorable? Weight being neutral higher.
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 0;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 4;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -8;
		case MAJOR_CIV_OPINION_ALLY:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 6;	// Allies want to leave their allies alone more
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 3;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -10;
			break;
	}

	// Add weight based on approach
	switch(eTrueApproach)
	{
		case MAJOR_CIV_APPROACH_HOSTILE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -1;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 4;
			break;
		case MAJOR_CIV_APPROACH_GUARDED:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -1;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 3;
			break;
		case MAJOR_CIV_APPROACH_NEUTRAL:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 0;
			break;
		case MAJOR_CIV_APPROACH_DECEPTIVE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 3;
			break;
		case MAJOR_CIV_APPROACH_FRIENDLY:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 5;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 5;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 0;
			break;
	}

	// The REAL meat of the strategy: military strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
		case STRENGTH_IMMENSE:		// if he's really strong let's pull out!
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 10;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 3;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -10;
			break;
		case STRENGTH_POWERFUL:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 7;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 5;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -6;
			break;
		case STRENGTH_STRONG:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 3;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 4;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -3;
			break;
		case STRENGTH_AVERAGE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 3;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 0;
			break;
		case STRENGTH_WEAK:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -2;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 0;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 3;
			break;
		case STRENGTH_POOR:	
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -6;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -4;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 6;
			break;
		case STRENGTH_PATHETIC:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += -10;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += -10;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += 10;
			break;
	}

	// If he's allowing open borders then maybe we want to move through them
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsAllowsOpenBordersToTeam(GetTeam()))
	{
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] *= 70;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] /= 100;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] *= 125;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] /= 100;
	}

	// Reduce weight if we're trading with them
	int iTradeRouteValue = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer);
	if (iTradeRouteValue > 0 || GC.getGame().GetGameDeals().IsReceivingItemsFromPlayer(GetID(), ePlayer, false))
	{
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] += 2;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] += 5;
		viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] += -3;
	}

	// Modifier for proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_DISTANT:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] *= 120;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] *= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] *= 40;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_FAR:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] *= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] *= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] *= 80;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] *= 85;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] *= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] *= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_NEIGHBORS:
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] *= 70;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_ACCEPT] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] *= 120;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_NEUTRAL] /= 100;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] *= 120;
			viMoveTroopsWeights[MOVE_TROOPS_RESPONSE_REFUSE] /= 100;
			break;
	}

	// And a random weight from 1-5 to each value
	int iRand;

	for(int i=0; i < NUM_MOVE_TROOPS_RESPONSES; i++)
	{
		iRand = GC.getGame().getSmallFakeRandNum(5, ePlayer);
		viMoveTroopsWeights[i] += iRand;
	}

	// This vector is what we'll use to sort
	CvWeightedVector< int, 128 > vMoveTroopsWeightsForSorting;
	vMoveTroopsWeightsForSorting.clear();

	// Transfer values over to the sorting vector
	for(int i = 0; i < NUM_MOVE_TROOPS_RESPONSES; i++)
	{
		vMoveTroopsWeightsForSorting.push_back(i, viMoveTroopsWeights[i]);
	}

	vMoveTroopsWeightsForSorting.SortItems();

	MoveTroopsResponseTypes eResponse = (MoveTroopsResponseTypes) vMoveTroopsWeightsForSorting.GetElement(0);

	// If we're planning on war or going for world conquest and guarded or worse then refuse
	if(eTrueApproach == MAJOR_CIV_APPROACH_WAR ||
		(IsGoingForWorldConquest() && eTrueApproach <= MAJOR_CIV_APPROACH_GUARDED))
	{
		eResponse = MOVE_TROOPS_RESPONSE_REFUSE;
	}

	// Sanity check: What do my teammates think?
	// Prevent human from abusing AI to declare war on a human
	if(!bJustChecking)
	{
		MoveTroopsResponseTypes eTeammateResponse;
		int iYes = 0;
		int iNeutral = 0;
		int iNo = 0;

		for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iMajorLoop;

			// Has to be on our team
			if(IsTeammate(eLoopPlayer))
			{
				// bJustChecking = true to prevent infinite loop
				eTeammateResponse = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetMoveTroopsRequestResponse(ePlayer, /*bJustChecking*/ true);

				switch (eTeammateResponse)
				{
					case MOVE_TROOPS_RESPONSE_ACCEPT:
						iYes++;
						break;
					case MOVE_TROOPS_RESPONSE_NEUTRAL:
						iNeutral++;
						break;
					case MOVE_TROOPS_RESPONSE_REFUSE:
						iNo++;
						break;
				}
			}
		}

		// Add in our vote
		switch(eResponse)
		{
			case MOVE_TROOPS_RESPONSE_ACCEPT:
				iYes++;
				break;
			case MOVE_TROOPS_RESPONSE_NEUTRAL:
				iNeutral++;
				break;
			case MOVE_TROOPS_RESPONSE_REFUSE:
				iNo++;
				break;
		}

		// Change eResponse to whatever is highest
		if (iYes >= iNeutral && iNeutral >= iNo)
		{
			eResponse = MOVE_TROOPS_RESPONSE_ACCEPT;
		}
		else if (iNeutral >= iYes && iYes >= iNo)
		{
			eResponse = MOVE_TROOPS_RESPONSE_NEUTRAL;
		}
		else
		{
			eResponse = MOVE_TROOPS_RESPONSE_REFUSE;
		}
	}

	// If we hate the guy then only neutral
	if(eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
	{
		if (eResponse == MOVE_TROOPS_RESPONSE_ACCEPT)
			eResponse = MOVE_TROOPS_RESPONSE_NEUTRAL;
	}

	// Final sanity check, if we're not planning war then don't go to war!
	if(GetWarGoal(ePlayer) == NO_WAR_GOAL_TYPE)
	{
		if (eResponse == MOVE_TROOPS_RESPONSE_REFUSE)
			eResponse = MOVE_TROOPS_RESPONSE_NEUTRAL;
	}

	return eResponse;
}
//--------------------------------------------------
#endif