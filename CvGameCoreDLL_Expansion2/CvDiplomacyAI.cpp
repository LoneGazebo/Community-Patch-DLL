/*	-------------------------------------------------------------------------------------------------------
	� 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "ICvDLLUserInterface.h"
#include "CvDiplomacyAI.h"
#include "CvGrandStrategyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvDealAI.h"
#include "CvGameCoreUtils.h"
#include "CvNotifications.h"
#include "CvDiplomacyRequests.h"

// must be included after all other headers
#include "LintFree.h"

#ifdef _MSC_VER
#	pragma warning ( disable : 4351 ) // default initialization of arrays
#endif

CvDiplomacyAI::DiplomacyAIData::DiplomacyAIData() :
	m_aDiploLogStatementTurnCountScratchPad()
	, m_aiMajorCivOpinion()
	, m_aeMajorCivApproach()
	, m_aeApproachScratchPad()
	, m_aeMinorCivApproach()
	, m_aeApproachTowardsUsGuess()
	, m_aeApproachTowardsUsGuessCounter()
	, m_aeWantPeaceCounter()
	, m_aePeaceTreatyWillingToOffer()
	, m_aePeaceTreatyWillingToAccept()
	, m_aiNumWondersBeatenTo()
	, m_abArmyInPlaceForAttack()
	, m_abWantsResearchAgreementWithPlayer()
	, m_abWantToRouteToMinor()
	, m_aeWarFace()
	, m_aeWarState()
	, m_aeWarProjection()
	, m_aeWarGoal()
	, m_aiPlayerNumTurnsAtWar()
	, m_aiNumWarsFought()
	, m_aePlayerMilitaryStrengthComparedToUs()
	, m_aePlayerEconomicStrengthComparedToUs()
	, m_aePlayerTargetValue()
	, m_aePlayerLandDisputeLevel()
	, m_aePlayerLastTurnLandDisputeLevel()
	, m_aePlayerVictoryDisputeLevel()
	, m_aePlayerWonderDisputeLevel()
	, m_aePlayerMinorCivDisputeLevel()
	, m_aeMilitaryAggressivePosture()
	, m_aeLastTurnMilitaryAggressivePosture()
	, m_aeExpansionAggressivePosture()
	, m_aePlotBuyingAggressivePosture()
	, m_aeMilitaryThreat()
	, m_aeWarDamageLevel()
	, m_aiWarValueLost()
	, m_aeWarmongerThreat()
	, m_aiPersonalityMajorCivApproachBiases()
	, m_aiPersonalityMinorCivApproachBiases()
	, m_aDeclarationsLog()
	, m_abPlayerNoSettleRequest()
	, m_aiPlayerNoSettleRequestCounter()
	, m_abPlayerStopSpyingRequest()
	, m_aiPlayerStopSpyingRequestCounter()
#if defined(MOD_BALANCE_CORE)
	, m_aiPlayerBackstabCounter()
	, m_aiDefensivePactValue()
	, m_aiDoFValue()
	, m_aiCompetitorValue()
#endif
	, m_aiDemandCounter()
	, m_aiDemandTooSoonNumTurns()
	, m_abDoFAccepted()
	, m_aiDoFCounter()
	, m_abDenouncedPlayer()
	, m_abFriendDenouncedUs()
	, m_abFriendDeclaredWarOnUs()
	, m_aiDenouncedPlayerCounter()
	, m_aiNumRequestsRefused()
	, m_aiNumCiviliansReturnedToMe()
	, m_aiNumLandmarksBuiltForMe()
	, m_aiResurrectedOnTurn()
	, m_aiNumTimesCultureBombed()
	, m_paiNegativeReligiousConversionPoints()
	, m_paiNegativeArchaeologyPoints()
	, m_aiNumTimesNuked()
	, m_aiNumTimesRobbedBy()
	, m_aiNumTimesIntrigueSharedBy()
	, m_abPlayerMadeMilitaryPromise()
	, m_abPlayerBrokenMilitaryPromise()
	, m_abPlayerIgnoredMilitaryPromise()
	, m_aiPlayerMilitaryPromiseCounter()
	, m_aiPlayerMadeExpansionPromiseTurn()
	, m_abPlayerBrokenExpansionPromise()
	, m_abPlayerIgnoredExpansionPromise()
	, m_aePlayerExpansionPromiseData()
	, m_aiPlayerMadeBorderPromiseTurn()
	, m_abPlayerBrokenBorderPromise()
	, m_abPlayerIgnoredBorderPromise()
	, m_aePlayerBorderPromiseData()
	, m_abPlayerMadeAttackCityStatePromise()
	, m_abPlayerBrokenAttackCityStatePromise()
	, m_abPlayerIgnoredAttackCityStatePromise()
	, m_abPlayerMadeBullyCityStatePromise()
	, m_abPlayerBrokenBullyCityStatePromise()
	, m_abPlayerIgnoredBullyCityStatePromise()
	, m_abPlayerMadeSpyPromise()
	, m_abPlayerBrokenSpyPromise()
	, m_abPlayerIgnoredSpyPromise()
	, m_abPlayerForgaveForSpying()
	, m_abPlayerMadeNoConvertPromise()
	, m_abPlayerBrokenNoConvertPromise()
	, m_abPlayerIgnoredNoConvertPromise()
	, m_abPlayerAskedNotToConvert()
	, m_abPlayerAgreedNotToConvert()
	, m_abPlayerMadeNoDiggingPromise()
	, m_abPlayerBrokenNoDiggingPromise()
	, m_abPlayerIgnoredNoDiggingPromise()
	, m_abPlayerAskedNotToDig()
	, m_abPlayerAgreedNotToDig()
	, m_abPlayerBrokenCoopWarPromise()
	, m_aiOtherPlayerTurnsSinceAttackedProtectedMinor()
	, m_aiOtherPlayerProtectedMinorAttacked()
	, m_aiOtherPlayerNumProtectedMinorsAttacked()
	, m_aiOtherPlayerTurnsSinceKilledProtectedMinor()
	, m_aiOtherPlayerProtectedMinorKilled()
	, m_aiOtherPlayerNumProtectedMinorsKilled()
	, m_aiOtherPlayerNumProtectedMinorsBullied()
	, m_aiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor()
	, m_aiOtherPlayerNumMinorsAttacked()
	, m_aiOtherPlayerNumMinorsConquered()
	, m_aiOtherPlayerNumMajorsAttacked()
	, m_aiOtherPlayerNumMajorsConquered()
	, m_apaeOtherPlayerMajorCivOpinion()
	, m_apaeOtherPlayerLandDisputeLevel()
	, m_apaeOtherPlayerVictoryDisputeLevel()
	, m_apaeOtherPlayerWonderDisputeLevel()
	, m_apaeOtherPlayerMinorCivDisputeLevel()
	, m_apaeOtherPlayerWarDamageLevel()
	, m_apaiOtherPlayerWarValueLost()
	, m_apaiOtherPlayerLastRoundWarValueLost()
	, m_apabSentAttackMessageToMinorCivProtector()
	, m_apaeOtherPlayerMilitaryThreat()
	, m_apaDiploStatementsLog()
	, m_apabWorkingAgainstPlayerAccepted()
	, m_apaiWorkingAgainstPlayerCounter()
	, m_apacCoopWarAcceptedState()
	, m_apaiCoopWarCounter()
	, m_aaeOtherPlayerMajorCivOpinion()
	, m_aaeOtherPlayerLandDisputeLevel()
	, m_aaeOtherPlayerVictoryDisputeLevel()
	, m_aaeOtherPlayerWarDamageLevel()
	, m_aaiOtherPlayerWarValueLost()
	, m_aaiOtherPlayerLastRoundWarValueLost()
	, m_aabSentAttackMessageToMinorCivProtector()
	, m_aaeOtherPlayerMilitaryThreat()
	, m_aaDiploStatementsLog()
	, m_aabWorkingAgainstPlayerAccepted()
	, m_aaiWorkingAgainstPlayerCounter()
	, m_aacCoopWarAcceptedState()
	, m_aaiCoopWarCounter()
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_abShareOpinionAccepted()
	, m_aiShareOpinionCounter()
	, m_aiHelpRequestCounter()
	, m_aiHelpRequestTooSoonNumTurns()
	, m_aiPlayerVassalageFailedProtectValue()
	, m_aiPlayerVassalageProtectValue()
	, m_abPlayerVassalagePeacefullyRevokedVassal()
	, m_abPlayerVassalageForcefullyRevokedVassal()
	, m_aiPlayerVassalageTurnsSincePeacefullyRevokedVassalage()
	, m_aiPlayerVassalageTurnsSinceForcefullyRevokedVassalage()
	, m_aiNumTimesDemandedWhenVassal()
	, m_abPlayerBrokenVassalAgreement()
	, m_abOfferingGift()
	, m_abOfferedGift()
	, m_abMasterLiberatedMeFromVassalage()
	, m_abVassalTaxRaised()
	, m_abVassalTaxLowered()
	, m_aiVassalGoldPerTurnTaxedSinceVassalStarted()
	, m_aiVassalGoldPerTurnCollectedSinceVassalStarted()
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
	, m_aiTheyPlottedAgainstUs()
	, m_aiTheyLoweredOurInfluence()
	, m_abWantsDefensivePactWithPlayer()
	, m_abWantsSneakAttack()
	, m_aiPlayerNumTurnsAtPeace()
	, m_aiPlayerNumTurnsSinceCityCapture()
	, m_aePlayerVictoryBlockLevel()
	, m_abCantMatchDeal()
	, m_aeDoFType()
	, m_aiNumTimesCoopWarDenied()
	, m_paNoExpansionPromise()
	, m_paLastTurnEmpireDistance()
	, m_abDoFBroken()
	, m_aiNumTimesRazed()
#endif
#if defined(MOD_API_EXTENSIONS)
	, m_aiOtherPlayerWarmongerAmountTimes100()
#endif
{
}

//=====================================
// CvDiplomacyAI
//=====================================
/// Constructor
CvDiplomacyAI::CvDiplomacyAI():
	m_pDiploData(NULL),
	m_paDiploLogStatementTurnCountScratchPad(NULL),
	m_paeMajorCivOpinion(NULL),
	m_ppaaeOtherPlayerMajorCivOpinion(NULL),
	m_paeMajorCivApproach(NULL),
	m_paeApproachScratchPad(NULL),
	m_paeMinorCivApproach(NULL),
	m_paeApproachTowardsUsGuess(NULL),
	m_paeApproachTowardsUsGuessCounter(NULL),
	m_paeWantPeaceCounter(NULL),
	m_paePeaceTreatyWillingToOffer(NULL),
	m_paePeaceTreatyWillingToAccept(NULL),
	m_paiNumWondersBeatenTo(NULL),
	m_pabArmyInPlaceForAttack(NULL),
	m_pabWantsResearchAgreementWithPlayer(NULL),
	m_pabWantToRouteToMinor(NULL),
	m_paeWarFace(NULL),
	m_paeWarState(NULL),
	m_paeWarProjection(NULL),
	m_paeLastWarProjection(NULL),
	m_paeWarGoal(NULL),
	m_paiPlayerNumTurnsAtWar(NULL),
	m_paiNumWarsFought(NULL),
	m_paePlayerMilitaryStrengthComparedToUs(NULL),
	m_paePlayerEconomicStrengthComparedToUs(NULL),
	m_paePlayerTargetValue(NULL),
	m_paePlayerLandDisputeLevel(NULL),
	m_paePlayerLastTurnLandDisputeLevel(NULL),
	m_paePlayerVictoryDisputeLevel(NULL),
	m_paePlayerWonderDisputeLevel(NULL),
	m_paePlayerMinorCivDisputeLevel(NULL),
	m_ppaaeOtherPlayerLandDisputeLevel(NULL),
	m_ppaaeOtherPlayerVictoryDisputeLevel(NULL),

	m_paeWarDamageLevel(NULL),
	m_paiWarValueLost(NULL),
	m_ppaaeOtherPlayerWarDamageLevel(NULL),
	m_ppaaiOtherPlayerWarValueLost(NULL),
	m_ppaaiOtherPlayerLastRoundWarValueLost(NULL),
	m_ppaabSentAttackMessageToMinorCivProtector(NULL),

	m_paeMilitaryAggressivePosture(NULL),
	m_paeLastTurnMilitaryAggressivePosture(NULL),
	m_paeExpansionAggressivePosture(NULL),
	m_paePlotBuyingAggressivePosture(NULL),

	m_paeMilitaryThreat(NULL),
	m_ppaaeOtherPlayerMilitaryThreat(NULL),

	m_paeWarmongerThreat(NULL),

	m_paiPersonalityMajorCivApproachBiases(NULL),
	m_paiPersonalityMinorCivApproachBiases(NULL),

	m_pabPlayerNoSettleRequestAccepted(NULL),
	m_paiPlayerNoSettleRequestCounter(NULL),

	m_pabPlayerStopSpyingRequestAccepted(NULL),
	m_paiPlayerStopSpyingRequestCounter(NULL),
#if defined(MOD_BALANCE_CORE)
	m_paiPlayerBackstabCounter(NULL),
	m_paiDefensivePactValue(NULL),
	m_paiDoFValue(NULL),
	m_paiCompetitorValue(NULL),
#endif

	m_paiDemandCounter(NULL),
	m_paiDemandTooSoonNumTurns(NULL),

	m_pabDoFAccepted(NULL),
	m_paiDoFCounter(NULL),

	m_pabDenouncedPlayer(NULL),
	m_pabFriendDenouncedUs(NULL),
	m_pabFriendDeclaredWarOnUs(NULL),
	m_paiDenouncedPlayerCounter(NULL),
	m_paiNumRequestsRefused(NULL),

	m_paiNumCiviliansReturnedToMe(NULL),
	m_paiNumLandmarksBuiltForMe(NULL),
	m_paiResurrectedOnTurn(NULL),
	m_paiNumTimesCultureBombed(NULL),

	m_paiNegativeReligiousConversionPoints(NULL),

	m_paiNegativeArchaeologyPoints(NULL),

	m_paiNumTimesNuked(NULL),
	m_paiNumTimesRobbedBy(NULL),
	m_paiNumTimesIntrigueSharedBy(NULL),

	m_paiBrokenExpansionPromiseValue(NULL),
	m_paiIgnoredExpansionPromiseValue(NULL),
	m_paiBrokenBorderPromiseValue(NULL),
	m_paiIgnoredBorderPromiseValue(NULL),
	m_paiDeclaredWarOnFriendValue(NULL),
	m_paiNumCitiesLiberated(NULL),
	m_paiTradeValue(NULL),
	m_paiCommonFoeValue(NULL),
	m_paiAssistValue(NULL),

	m_ppaabWorkingAgainstPlayerAccepted(NULL),
	m_ppaaiWorkingAgainstPlayerCounter(NULL),

	m_ppaacCoopWarAcceptedState(NULL),
	m_ppaaiCoopWarCounter(NULL),

	m_pabPlayerMadeMilitaryPromise(NULL),
	m_pabPlayerBrokenMilitaryPromise(NULL),
	m_pabPlayerIgnoredMilitaryPromise(NULL),
	m_paiPlayerMilitaryPromiseCounter(NULL),

	m_paiPlayerMadeExpansionPromiseTurn(NULL),
	m_pabPlayerBrokenExpansionPromise(NULL),
	m_pabPlayerIgnoredExpansionPromise(NULL),
	m_paePlayerExpansionPromiseData(NULL),

	m_paiPlayerMadeBorderPromiseTurn(NULL),
	m_pabPlayerBrokenBorderPromise(NULL),
	m_pabPlayerIgnoredBorderPromise(NULL),
	m_paePlayerBorderPromiseData(NULL),

	m_pabPlayerMadeAttackCityStatePromise(NULL),
	m_pabPlayerBrokenAttackCityStatePromise(NULL),
	m_pabPlayerIgnoredAttackCityStatePromise(NULL),

	m_pabPlayerMadeBullyCityStatePromise(NULL),
	m_pabPlayerBrokenBullyCityStatePromise(NULL),
	m_pabPlayerIgnoredBullyCityStatePromise(NULL),

	m_pabPlayerMadeSpyPromise(NULL),
	m_pabPlayerBrokenSpyPromise(NULL),
	m_pabPlayerIgnoredSpyPromise(NULL),

	m_pabPlayerForgaveForSpying(NULL),

	m_pabPlayerMadeNoConvertPromise(NULL),
	m_pabPlayerBrokenNoConvertPromise(NULL),
	m_pabPlayerIgnoredNoConvertPromise(NULL),
	m_pabPlayerAskedNotToConvert(NULL),
	m_pabPlayerAgreedNotToConvert(NULL),

	m_pabPlayerMadeNoDiggingPromise(NULL),
	m_pabPlayerBrokenNoDiggingPromise(NULL),
	m_pabPlayerIgnoredNoDiggingPromise(NULL),
	m_pabPlayerAskedNotToDig(NULL),
	m_pabPlayerAgreedNotToDig(NULL),

	m_pabPlayerBrokenCoopWarPromise(NULL),

	m_paiOtherPlayerTurnsSinceAttackedProtectedMinor(NULL),
	m_paiOtherPlayerProtectedMinorAttacked(NULL),
	m_paiOtherPlayerNumProtectedMinorsAttacked(NULL),

	m_paiOtherPlayerTurnsSinceKilledProtectedMinor(NULL),
	m_paiOtherPlayerProtectedMinorKilled(NULL),
	m_paiOtherPlayerNumProtectedMinorsKilled(NULL),

	m_paiOtherPlayerNumProtectedMinorsBullied(NULL),

	m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor(NULL),

	m_paiOtherPlayerNumMinorsAttacked(NULL),
	m_paiOtherPlayerNumMinorsConquered(NULL),
	m_paiOtherPlayerNumMajorsAttacked(NULL),
	m_paiOtherPlayerNumMajorsConquered(NULL),

#if defined(MOD_API_EXTENSIONS)
	m_paiTheyPlottedAgainstUs(NULL),
	m_paiTheyLoweredOurInfluence(NULL),
#else
	m_paiOtherPlayerWarmongerAmount(NULL),
#endif

	m_paiOtherPlayerTurnsSinceWeLikedTheirProposal(NULL),
	m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal(NULL),
	m_paiOtherPlayerTurnsSinceTheySupportedOurProposal(NULL),
	m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal(NULL),
	m_paiOtherPlayerTurnsSinceTheySupportedOurHosting(NULL),

	m_ppaDiploStatementsLog(NULL),

	m_paDeclarationsLog(NULL),

	m_eStateAllWars(STATE_ALL_WARS_NEUTRAL),

#if defined(MOD_ACTIVE_DIPLOMACY)
	m_eTargetPlayerType(DIPLO_ALL_PLAYERS),
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_pabShareOpinionAccepted(NULL),
	m_paiShareOpinionCounter(NULL),

	m_paiHelpRequestCounter(NULL),
	m_paiHelpRequestTooSoonNumTurns(NULL),

	m_paiPlayerVassalageFailedProtectValue(NULL),
	m_paiPlayerVassalageProtectValue(NULL),

	m_pabPlayerVassalagePeacefullyRevokedVassal(NULL),
	m_pabPlayerVassalageForcefullyRevokedVassal(NULL),

	m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage(NULL),
	m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage(NULL),
	m_paiNumTimesDemandedWhenVassal(NULL),
	m_pabPlayerBrokenVassalAgreement(NULL),
	m_pabMoveTroopsRequestAccepted(NULL),
	m_paiMoveTroopsRequestCounter(NULL),
	m_pabOfferingGift(NULL),
	m_pabOfferedGift(NULL),
	m_pabMasterLiberatedMeFromVassalage(NULL),
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
	m_pabWantsDefensivePactWithPlayer(NULL),
	m_pabWantsSneakAttack(NULL),
	m_paiPlayerNumTurnsAtPeace(NULL),
	m_paiPlayerNumTurnsSinceCityCapture(NULL),
	m_paePlayerVictoryBlockLevel(NULL),
	m_pabCantMatchDeal(NULL),
	m_paeDoFType(NULL),
	m_paiNumTimesCoopWarDenied(NULL),
	m_pabDoFBroken(NULL),
	m_paNoExpansionPromise(NULL),
	m_paLastTurnEmpireDistance(NULL),
	m_paiNumTimesRazed(NULL),
	m_pabPlayerEverMadeBorderPromise(NULL),
	m_pabPlayerEverMadeExpansionPromise(NULL),
	m_pabDoFEverAsked(NULL),
	m_pabHelpRequestEverMade(NULL),
	m_paiDemandEverMade(NULL),
	m_pabPlayerNoSettleRequestEverAsked(NULL),
	m_pabPlayerStopSpyingRequestEverAsked(NULL),
	m_paiNumLandmarksBuiltForMeTurn(NULL),
	m_paiCiviliansReturnedToMeTurn(NULL),
	m_paiWarDamageValue(NULL),
#endif
#if defined(MOD_API_EXTENSIONS)
	m_paiOtherPlayerWarmongerAmountTimes100(NULL),
#endif
	m_eTargetPlayer(DIPLO_ALL_PLAYERS),
	m_eTestToPlayer(NO_PLAYER),
	m_eTestStatement(NO_DIPLO_STATEMENT_TYPE),
	m_iTestStatementArg1(-1)
{
}

/// Destructor
CvDiplomacyAI::~CvDiplomacyAI(void)
{
}

/// Initialize
void CvDiplomacyAI::Init(CvPlayer* pPlayer)
{
	// Store off the pointer to the Player active for this game
	m_pPlayer = pPlayer;

	CvAssertMsg(!m_pDiploData, "MEMORY LEAK, CvDiplomacyAI::m_pDiploData");
	m_pDiploData = FNEW(DiplomacyAIData, c_eCiv5GameplayDLL, 0);

	//Init array pointers
	m_paDiploLogStatementTurnCountScratchPad = &m_pDiploData->m_aDiploLogStatementTurnCountScratchPad[0];
	m_paeMajorCivOpinion = &m_pDiploData->m_aiMajorCivOpinion[0];
	m_paeMajorCivApproach = &m_pDiploData->m_aeMajorCivApproach[0];
	m_paeApproachScratchPad = &m_pDiploData->m_aeApproachScratchPad[0];
	m_paeMinorCivApproach = &m_pDiploData->m_aeMinorCivApproach[0];
	m_paeApproachTowardsUsGuess = &m_pDiploData->m_aeApproachTowardsUsGuess[0];
	m_paeApproachTowardsUsGuessCounter = &m_pDiploData->m_aeApproachTowardsUsGuessCounter[0];
	m_paeWantPeaceCounter = &m_pDiploData->m_aeWantPeaceCounter[0];
	m_paePeaceTreatyWillingToOffer = &m_pDiploData->m_aePeaceTreatyWillingToOffer[0];
	m_paePeaceTreatyWillingToAccept = &m_pDiploData->m_aePeaceTreatyWillingToAccept[0];
	m_paiNumWondersBeatenTo = &m_pDiploData->m_aiNumWondersBeatenTo[0];
	m_pabArmyInPlaceForAttack = &m_pDiploData->m_abArmyInPlaceForAttack[0];
	m_pabWantsResearchAgreementWithPlayer = &m_pDiploData->m_abWantsResearchAgreementWithPlayer[0];
	m_pabWantToRouteToMinor = &m_pDiploData->m_abWantToRouteToMinor[0];
	m_paeWarFace = &m_pDiploData->m_aeWarFace[0];
	m_paeWarState = &m_pDiploData->m_aeWarState[0];
	m_paeWarProjection = &m_pDiploData->m_aeWarProjection[0];
	m_paeLastWarProjection = &m_pDiploData->m_aeLastWarProjection[0];
	m_paeWarGoal = &m_pDiploData->m_aeWarGoal[0];
	m_paiPlayerNumTurnsAtWar = &m_pDiploData->m_aiPlayerNumTurnsAtWar[0];
	m_paiNumWarsFought = &m_pDiploData->m_aiNumWarsFought[0];
	m_paePlayerMilitaryStrengthComparedToUs = &m_pDiploData->m_aePlayerMilitaryStrengthComparedToUs[0];
	m_paePlayerEconomicStrengthComparedToUs = &m_pDiploData->m_aePlayerEconomicStrengthComparedToUs[0];
	m_paePlayerTargetValue = &m_pDiploData->m_aePlayerTargetValue[0];
	m_paePlayerLandDisputeLevel = &m_pDiploData->m_aePlayerLandDisputeLevel[0];
	m_paePlayerLastTurnLandDisputeLevel = &m_pDiploData->m_aePlayerLastTurnLandDisputeLevel[0];
	m_paePlayerVictoryDisputeLevel = &m_pDiploData->m_aePlayerVictoryDisputeLevel[0];
	m_paePlayerWonderDisputeLevel = &m_pDiploData->m_aePlayerWonderDisputeLevel[0];
	m_paePlayerMinorCivDisputeLevel = &m_pDiploData->m_aePlayerMinorCivDisputeLevel[0];
	m_paeMilitaryAggressivePosture = &m_pDiploData->m_aeMilitaryAggressivePosture[0];
	m_paeLastTurnMilitaryAggressivePosture = &m_pDiploData->m_aeLastTurnMilitaryAggressivePosture[0];
	m_paeExpansionAggressivePosture = &m_pDiploData->m_aeExpansionAggressivePosture[0];
	m_paePlotBuyingAggressivePosture = &m_pDiploData->m_aePlotBuyingAggressivePosture[0];
	m_paeMilitaryThreat = &m_pDiploData->m_aeMilitaryThreat[0];
	m_paeWarDamageLevel = &m_pDiploData->m_aeWarDamageLevel[0];
	m_paiWarValueLost = &m_pDiploData->m_aiWarValueLost[0];
	m_paeWarmongerThreat = &m_pDiploData->m_aeWarmongerThreat[0];
	m_paiPersonalityMajorCivApproachBiases = &m_pDiploData->m_aiPersonalityMajorCivApproachBiases[0];
	m_paiPersonalityMinorCivApproachBiases = &m_pDiploData->m_aiPersonalityMinorCivApproachBiases[0];
	m_paDeclarationsLog = &m_pDiploData->m_aDeclarationsLog[0];

	// Things a player has told the AI

	m_pabPlayerNoSettleRequestAccepted = &m_pDiploData->m_abPlayerNoSettleRequest[0];
	m_paiPlayerNoSettleRequestCounter = &m_pDiploData->m_aiPlayerNoSettleRequestCounter[0];

	m_pabPlayerStopSpyingRequestAccepted = &m_pDiploData->m_abPlayerStopSpyingRequest[0];
	m_paiPlayerStopSpyingRequestCounter = &m_pDiploData->m_aiPlayerStopSpyingRequestCounter[0];
#if defined(MOD_BALANCE_CORE)
	m_paiPlayerBackstabCounter = &m_pDiploData->m_aiPlayerBackstabCounter[0];
	
	m_paiDefensivePactValue = &m_pDiploData->m_aiDefensivePactValue[0];
	m_paiDoFValue = &m_pDiploData->m_aiDoFValue[0];
	m_paiCompetitorValue = &m_pDiploData->m_aiCompetitorValue[0];
#endif

	m_paiDemandCounter = &m_pDiploData->m_aiDemandCounter[0];
	m_paiDemandTooSoonNumTurns = &m_pDiploData->m_aiDemandTooSoonNumTurns[0];

	m_pabDoFAccepted = &m_pDiploData->m_abDoFAccepted[0];
	m_paiDoFCounter = &m_pDiploData->m_aiDoFCounter[0];

	m_pabDenouncedPlayer = &m_pDiploData->m_abDenouncedPlayer[0];
	m_pabFriendDenouncedUs = &m_pDiploData->m_abFriendDenouncedUs[0];
	m_pabFriendDeclaredWarOnUs = &m_pDiploData->m_abFriendDeclaredWarOnUs[0];
	m_paiDenouncedPlayerCounter = &m_pDiploData->m_aiDenouncedPlayerCounter[0];

	m_paiNumRequestsRefused = &m_pDiploData->m_aiNumRequestsRefused[0];

	m_paiNumCiviliansReturnedToMe = &m_pDiploData->m_aiNumCiviliansReturnedToMe[0];
	m_paiNumLandmarksBuiltForMe = &m_pDiploData->m_aiNumLandmarksBuiltForMe[0];
	m_paiResurrectedOnTurn = &m_pDiploData->m_aiResurrectedOnTurn[0];
	m_paiNumTimesCultureBombed = &m_pDiploData->m_aiNumTimesCultureBombed[0];

	m_paiNegativeReligiousConversionPoints = &m_pDiploData->m_paiNegativeReligiousConversionPoints[0];

	m_paiNegativeArchaeologyPoints = &m_pDiploData->m_paiNegativeArchaeologyPoints[0];
	m_paiNumTimesNuked = &m_pDiploData->m_aiNumTimesNuked[0];
	m_paiNumTimesRobbedBy = &m_pDiploData->m_aiNumTimesRobbedBy[0];
	m_paiNumTimesIntrigueSharedBy = &m_pDiploData->m_aiNumTimesIntrigueSharedBy[0];

	m_paiBrokenExpansionPromiseValue = &m_pDiploData->m_aiBrokenExpansionPromiseValue[0];
	m_paiIgnoredExpansionPromiseValue = &m_pDiploData->m_aiIgnoredExpansionPromiseValue[0];
	m_paiBrokenBorderPromiseValue = &m_pDiploData->m_aiBrokenBorderPromiseValue[0];
	m_paiIgnoredBorderPromiseValue = &m_pDiploData->m_aiIgnoredBorderPromiseValue[0];
	m_paiDeclaredWarOnFriendValue = &m_pDiploData->m_aiDeclaredWarOnFriendValue[0];
	m_paiNumCitiesLiberated = &m_pDiploData->m_aiNumCitiesLiberated[0];
	m_paiTradeValue = &m_pDiploData->m_aiTradeValue[0];
	m_paiCommonFoeValue = &m_pDiploData->m_aiCommonFoeValue[0];
	m_paiAssistValue = &m_pDiploData->m_aiAssistValue[0];

	// Player's response to AI statements

	m_pabPlayerMadeMilitaryPromise = &m_pDiploData->m_abPlayerMadeMilitaryPromise[0];
	m_pabPlayerBrokenMilitaryPromise = &m_pDiploData->m_abPlayerBrokenMilitaryPromise[0];
	m_pabPlayerIgnoredMilitaryPromise = &m_pDiploData->m_abPlayerIgnoredMilitaryPromise[0];
	m_paiPlayerMilitaryPromiseCounter = &m_pDiploData->m_aiPlayerMilitaryPromiseCounter[0];

	m_paiPlayerMadeExpansionPromiseTurn = &m_pDiploData->m_aiPlayerMadeExpansionPromiseTurn[0];
	m_pabPlayerBrokenExpansionPromise = &m_pDiploData->m_abPlayerBrokenExpansionPromise[0];
	m_pabPlayerIgnoredExpansionPromise = &m_pDiploData->m_abPlayerIgnoredExpansionPromise[0];
	m_paePlayerExpansionPromiseData = &m_pDiploData->m_aePlayerExpansionPromiseData[0];

	m_paiPlayerMadeBorderPromiseTurn = &m_pDiploData->m_aiPlayerMadeBorderPromiseTurn[0];
	m_pabPlayerBrokenBorderPromise = &m_pDiploData->m_abPlayerBrokenBorderPromise[0];
	m_pabPlayerIgnoredBorderPromise = &m_pDiploData->m_abPlayerIgnoredBorderPromise[0];
	m_paePlayerBorderPromiseData = &m_pDiploData->m_aePlayerBorderPromiseData[0];

	m_pabPlayerMadeAttackCityStatePromise = &m_pDiploData->m_abPlayerMadeAttackCityStatePromise[0];
	m_pabPlayerBrokenAttackCityStatePromise = &m_pDiploData->m_abPlayerBrokenAttackCityStatePromise[0];
	m_pabPlayerIgnoredAttackCityStatePromise = &m_pDiploData->m_abPlayerIgnoredAttackCityStatePromise[0];

	m_pabPlayerMadeBullyCityStatePromise = &m_pDiploData->m_abPlayerMadeBullyCityStatePromise[0];
	m_pabPlayerBrokenBullyCityStatePromise = &m_pDiploData->m_abPlayerBrokenBullyCityStatePromise[0];
	m_pabPlayerIgnoredBullyCityStatePromise = &m_pDiploData->m_abPlayerIgnoredBullyCityStatePromise[0];

	m_pabPlayerMadeSpyPromise = &m_pDiploData->m_abPlayerMadeSpyPromise[0];
	m_pabPlayerBrokenSpyPromise = &m_pDiploData->m_abPlayerBrokenSpyPromise[0];
	m_pabPlayerIgnoredSpyPromise = &m_pDiploData->m_abPlayerIgnoredSpyPromise[0];

	m_pabPlayerForgaveForSpying = &m_pDiploData->m_abPlayerForgaveForSpying[0];

	m_pabPlayerMadeNoConvertPromise = &m_pDiploData->m_abPlayerMadeNoConvertPromise[0];
	m_pabPlayerBrokenNoConvertPromise = &m_pDiploData->m_abPlayerBrokenNoConvertPromise[0];
	m_pabPlayerIgnoredNoConvertPromise = &m_pDiploData->m_abPlayerIgnoredNoConvertPromise[0];

	m_pabPlayerAskedNotToConvert = &m_pDiploData->m_abPlayerAskedNotToConvert[0];
	m_pabPlayerAgreedNotToConvert = &m_pDiploData->m_abPlayerAgreedNotToConvert[0];

	m_pabPlayerMadeNoDiggingPromise = &m_pDiploData->m_abPlayerMadeNoDiggingPromise[0];
	m_pabPlayerBrokenNoDiggingPromise = &m_pDiploData->m_abPlayerBrokenNoDiggingPromise[0];
	m_pabPlayerIgnoredNoDiggingPromise = &m_pDiploData->m_abPlayerIgnoredNoDiggingPromise[0];

	m_pabPlayerAskedNotToDig = &m_pDiploData->m_abPlayerAskedNotToDig[0];
	m_pabPlayerAgreedNotToDig = &m_pDiploData->m_abPlayerAgreedNotToDig[0];

	m_pabPlayerBrokenCoopWarPromise = &m_pDiploData->m_abPlayerBrokenCoopWarPromise[0];

	// Evaluation of Other Players' Tendencies
	m_paiOtherPlayerTurnsSinceAttackedProtectedMinor = &m_pDiploData->m_aiOtherPlayerTurnsSinceAttackedProtectedMinor[0];
	m_paiOtherPlayerProtectedMinorAttacked = &m_pDiploData->m_aiOtherPlayerProtectedMinorAttacked[0];
	m_paiOtherPlayerNumProtectedMinorsAttacked = &m_pDiploData->m_aiOtherPlayerNumProtectedMinorsAttacked[0];
	m_paiOtherPlayerTurnsSinceKilledProtectedMinor = &m_pDiploData->m_aiOtherPlayerTurnsSinceKilledProtectedMinor[0];
	m_paiOtherPlayerProtectedMinorKilled = &m_pDiploData->m_aiOtherPlayerProtectedMinorKilled[0];
	m_paiOtherPlayerNumProtectedMinorsKilled = &m_pDiploData->m_aiOtherPlayerNumProtectedMinorsKilled[0];
	m_paiOtherPlayerNumProtectedMinorsBullied = &m_pDiploData->m_aiOtherPlayerNumProtectedMinorsBullied[0];
	m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor = &m_pDiploData->m_aiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor[0];
	m_paiOtherPlayerNumMinorsAttacked = &m_pDiploData->m_aiOtherPlayerNumMinorsAttacked[0];
	m_paiOtherPlayerNumMinorsConquered = &m_pDiploData->m_aiOtherPlayerNumMinorsConquered[0];
	m_paiOtherPlayerNumMajorsAttacked = &m_pDiploData->m_aiOtherPlayerNumMajorsAttacked[0];
	m_paiOtherPlayerNumMajorsConquered = &m_pDiploData->m_aiOtherPlayerNumMajorsConquered[0];
#if defined(MOD_API_EXTENSIONS)
	m_paiTheyPlottedAgainstUs = &m_pDiploData->m_aiTheyPlottedAgainstUs[0];
	m_paiTheyLoweredOurInfluence = &m_pDiploData->m_aiTheyLoweredOurInfluence[0];
#else
	m_paiOtherPlayerWarmongerAmount = &m_pDiploData->m_aiOtherPlayerWarmongerAmount[0];
#endif

	m_paiOtherPlayerTurnsSinceWeLikedTheirProposal = &m_pDiploData->m_aiOtherPlayerTurnsSinceWeLikedTheirProposal[0];
	m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal = &m_pDiploData->m_aiOtherPlayerTurnsSinceWeDislikedTheirProposal[0];
	m_paiOtherPlayerTurnsSinceTheySupportedOurProposal = &m_pDiploData->m_aiOtherPlayerTurnsSinceTheySupportedOurProposal[0];
	m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal = &m_pDiploData->m_aiOtherPlayerTurnsSinceTheyFoiledOurProposal[0];
	m_paiOtherPlayerTurnsSinceTheySupportedOurHosting = &m_pDiploData->m_aiOtherPlayerTurnsSinceTheySupportedOurHosting[0];

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_pabShareOpinionAccepted = &m_pDiploData->m_abShareOpinionAccepted[0];
	m_paiShareOpinionCounter = &m_pDiploData->m_aiShareOpinionCounter[0];

	m_paiHelpRequestCounter = &m_pDiploData->m_aiHelpRequestCounter[0];
	m_paiHelpRequestTooSoonNumTurns = &m_pDiploData->m_aiHelpRequestTooSoonNumTurns[0];

	m_paiPlayerVassalageFailedProtectValue = &m_pDiploData->m_aiPlayerVassalageFailedProtectValue[0];
	m_paiPlayerVassalageProtectValue = &m_pDiploData->m_aiPlayerVassalageProtectValue[0];
	m_pabPlayerVassalagePeacefullyRevokedVassal = &m_pDiploData->m_abPlayerVassalagePeacefullyRevokedVassal[0];
	m_pabPlayerVassalageForcefullyRevokedVassal = &m_pDiploData->m_abPlayerVassalageForcefullyRevokedVassal[0];
	m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage = &m_pDiploData->m_aiPlayerVassalageTurnsSincePeacefullyRevokedVassalage[0];
	m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage = &m_pDiploData->m_aiPlayerVassalageTurnsSinceForcefullyRevokedVassalage[0];
	m_paiNumTimesDemandedWhenVassal = &m_pDiploData->m_aiNumTimesDemandedWhenVassal[0];
	m_pabPlayerBrokenVassalAgreement = &m_pDiploData->m_abPlayerBrokenVassalAgreement[0];

	m_pabMoveTroopsRequestAccepted = &m_pDiploData->m_abMoveTroopsRequestAccepted[0];
	m_paiMoveTroopsRequestCounter = &m_pDiploData->m_aiMoveTroopsRequestCounter[0];
	m_pabOfferingGift = &m_pDiploData->m_abOfferingGift[0];
	m_pabOfferedGift = &m_pDiploData->m_abOfferedGift[0];
	m_pabMasterLiberatedMeFromVassalage = &m_pDiploData->m_abMasterLiberatedMeFromVassalage[0];
	m_pabVassalTaxRaised = &m_pDiploData->m_abVassalTaxRaised[0];
	m_pabVassalTaxLowered = &m_pDiploData->m_abVassalTaxLowered[0];
	m_paiVassalGoldPerTurnTaxedSinceVassalStarted = &m_pDiploData->m_aiVassalGoldPerTurnTaxedSinceVassalStarted[0];
	m_paiVassalGoldPerTurnCollectedSinceVassalStarted = &m_pDiploData->m_aiVassalGoldPerTurnCollectedSinceVassalStarted[0];
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
	m_pabWantsDefensivePactWithPlayer = &m_pDiploData->m_abWantsDefensivePactWithPlayer[0];
	m_pabWantsSneakAttack = &m_pDiploData->m_abWantsSneakAttack[0];
	m_paiPlayerNumTurnsAtPeace = &m_pDiploData->m_aiPlayerNumTurnsAtPeace[0];
	m_paiPlayerNumTurnsSinceCityCapture = &m_pDiploData->m_aiPlayerNumTurnsSinceCityCapture[0];
	m_paePlayerVictoryBlockLevel = &m_pDiploData->m_aePlayerVictoryBlockLevel[0];
	m_pabCantMatchDeal = &m_pDiploData->m_abCantMatchDeal[0];
	m_paeDoFType = &m_pDiploData->m_aeDoFType[0];
	m_paiNumTimesCoopWarDenied = &m_pDiploData->m_aiNumTimesCoopWarDenied[0];
	m_paNoExpansionPromise = &m_pDiploData->m_paNoExpansionPromise[0];
	m_paLastTurnEmpireDistance = &m_pDiploData->m_paLastTurnEmpireDistance[0];
	m_pabDoFBroken = &m_pDiploData->m_abDoFBroken[0];
	m_paiNumTimesRazed = &m_pDiploData->m_aiNumTimesRazed[0];
	m_pabPlayerEverMadeBorderPromise = &m_pDiploData->m_abPlayerEverMadeBorderPromise[0];
	m_pabPlayerEverMadeExpansionPromise = &m_pDiploData->m_abPlayerEverMadeExpansionPromise[0];
	m_pabDoFEverAsked = &m_pDiploData->m_abDoFEverAsked[0];
	m_pabHelpRequestEverMade = &m_pDiploData->m_abHelpRequestEverMade[0];
	m_paiDemandEverMade = &m_pDiploData->m_aiDemandEverMade[0];
	m_pabPlayerNoSettleRequestEverAsked = &m_pDiploData->m_abPlayerNoSettleRequestEverAsked[0];
	m_pabPlayerStopSpyingRequestEverAsked = &m_pDiploData->m_abPlayerStopSpyingRequestEverAsked[0];
	m_paiNumLandmarksBuiltForMeTurn = &m_pDiploData->m_aiNumLandmarksBuiltForMeTurn[0];
	m_paiCiviliansReturnedToMeTurn = &m_pDiploData->m_aiCiviliansReturnedToMeTurn[0];
	m_paiWarDamageValue = &m_pDiploData->m_aiWarDamageValue[0];
	m_paiPlayerForgaveForSpyingTurn = &m_pDiploData->m_aiPlayerForgaveForSpyingTurn[0];
	m_paiLiberatedCitiesTurn = &m_pDiploData->m_aiLiberatedCitiesTurn[0];
	m_paiIntrigueSharedTurn = &m_pDiploData->m_aiIntrigueSharedTurn[0];
	m_paiReligiousConversionTurn = &m_pDiploData->m_aiReligiousConversionTurn[0];
	m_paiTimesRobbedTurn = &m_pDiploData->m_aiTimesRobbedTurn[0];
#endif
#if defined(MOD_API_EXTENSIONS)
	m_paiOtherPlayerWarmongerAmountTimes100 = &m_pDiploData->m_aiOtherPlayerWarmongerAmountTimes100[0];
#endif
	//Init 2D array pointers
	int iI;
	m_ppaaeOtherPlayerMajorCivOpinion = &m_pDiploData->m_apaeOtherPlayerMajorCivOpinion[0];
	for(iI = 0; iI <MAX_MAJOR_CIVS; iI++)
	{
		m_ppaaeOtherPlayerMajorCivOpinion[iI] = &m_pDiploData->m_aaeOtherPlayerMajorCivOpinion[ MAX_MAJOR_CIVS * iI ];
	}

	m_ppaaeOtherPlayerLandDisputeLevel = &m_pDiploData->m_apaeOtherPlayerLandDisputeLevel[0];
	for(iI = 0; iI <MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaeOtherPlayerLandDisputeLevel[iI] = &m_pDiploData->m_aaeOtherPlayerLandDisputeLevel[ REALLY_MAX_PLAYERS * iI ];
	}

	m_ppaaeOtherPlayerVictoryDisputeLevel = &m_pDiploData->m_apaeOtherPlayerVictoryDisputeLevel[0];
	for(iI = 0; iI <MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaeOtherPlayerVictoryDisputeLevel[iI] = &m_pDiploData->m_aaeOtherPlayerVictoryDisputeLevel[ REALLY_MAX_PLAYERS * iI ];
	}

	m_ppaaeOtherPlayerWarDamageLevel = &m_pDiploData->m_apaeOtherPlayerWarDamageLevel[0];
	for(iI = 0; iI <MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaeOtherPlayerWarDamageLevel[iI] = &m_pDiploData->m_aaeOtherPlayerWarDamageLevel[REALLY_MAX_PLAYERS * iI];
	}

	m_ppaaiOtherPlayerWarValueLost = &m_pDiploData->m_apaiOtherPlayerWarValueLost[0];
	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaiOtherPlayerWarValueLost[iI] = &m_pDiploData->m_aaiOtherPlayerWarValueLost[REALLY_MAX_PLAYERS*iI];
	}

	m_ppaaiOtherPlayerLastRoundWarValueLost = &m_pDiploData->m_apaiOtherPlayerLastRoundWarValueLost[0];
	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaiOtherPlayerLastRoundWarValueLost[iI] = &m_pDiploData->m_aaiOtherPlayerLastRoundWarValueLost[REALLY_MAX_PLAYERS*iI];
	}

	m_ppaabSentAttackMessageToMinorCivProtector = &m_pDiploData->m_apabSentAttackMessageToMinorCivProtector[0];
	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_ppaabSentAttackMessageToMinorCivProtector[iI] = &m_pDiploData->m_aabSentAttackMessageToMinorCivProtector[REALLY_MAX_PLAYERS* iI];
	}

	m_ppaaeOtherPlayerMilitaryThreat = &m_pDiploData->m_apaeOtherPlayerMilitaryThreat[0];
	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_ppaaeOtherPlayerMilitaryThreat[iI] = &m_pDiploData->m_aaeOtherPlayerMilitaryThreat[REALLY_MAX_PLAYERS*iI];
	}

	m_ppaDiploStatementsLog = &m_pDiploData->m_apaDiploStatementsLog[0];
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_ppaDiploStatementsLog[iI] = &m_pDiploData->m_aaDiploStatementsLog[iI * MAX_DIPLO_LOG_STATEMENTS];
	}

	m_ppaabWorkingAgainstPlayerAccepted = &m_pDiploData->m_apabWorkingAgainstPlayerAccepted[0];
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_ppaabWorkingAgainstPlayerAccepted[iI] = &m_pDiploData->m_aabWorkingAgainstPlayerAccepted[iI * MAX_MAJOR_CIVS];
	}

	m_ppaaiWorkingAgainstPlayerCounter = &m_pDiploData->m_apaiWorkingAgainstPlayerCounter[0];
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_ppaaiWorkingAgainstPlayerCounter[iI] = &m_pDiploData->m_aaiWorkingAgainstPlayerCounter[iI * MAX_MAJOR_CIVS];
	}

	m_ppaacCoopWarAcceptedState = &m_pDiploData->m_apacCoopWarAcceptedState[0];
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_ppaacCoopWarAcceptedState[iI] = &m_pDiploData->m_aacCoopWarAcceptedState[iI * MAX_MAJOR_CIVS];
	}

	m_ppaaiCoopWarCounter = &m_pDiploData->m_apaiCoopWarCounter[0];
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_ppaaiCoopWarCounter[iI] = &m_pDiploData->m_aaiCoopWarCounter[iI * MAX_MAJOR_CIVS];
	}

	Reset();
}

/// Deallocate memory created in initialize
void CvDiplomacyAI::Uninit()
{

	//Init array pointers
	m_paDiploLogStatementTurnCountScratchPad = NULL;
	m_paeMajorCivOpinion = NULL;
	m_paeMajorCivApproach = NULL;
	m_paeApproachScratchPad = NULL;
	m_paeMinorCivApproach = NULL;
	m_paeApproachTowardsUsGuess = NULL;
	m_paeApproachTowardsUsGuessCounter = NULL;
	m_paeWantPeaceCounter = NULL;
	m_paePeaceTreatyWillingToOffer = NULL;
	m_paePeaceTreatyWillingToAccept = NULL;
	m_paiNumWondersBeatenTo = NULL;
	m_pabArmyInPlaceForAttack = NULL;
	m_pabWantsResearchAgreementWithPlayer = NULL;
	m_pabWantToRouteToMinor = NULL;
	m_paeWarFace = NULL;
	m_paeWarState = NULL;
	m_paeWarProjection = NULL;
	m_paeLastWarProjection = NULL;
	m_paeWarGoal = NULL;
	m_paiPlayerNumTurnsAtWar = NULL;
	m_paiNumWarsFought = NULL;
	m_paePlayerMilitaryStrengthComparedToUs = NULL;
	m_paePlayerEconomicStrengthComparedToUs = NULL;
	m_paePlayerTargetValue = NULL;
	m_paePlayerLandDisputeLevel = NULL;
	m_paePlayerLastTurnLandDisputeLevel = NULL;
	m_paePlayerVictoryDisputeLevel = NULL;
	m_paePlayerWonderDisputeLevel = NULL;
	m_paePlayerMinorCivDisputeLevel = NULL;
	m_paeMilitaryAggressivePosture = NULL;
	m_paeLastTurnMilitaryAggressivePosture = NULL;
	m_paeExpansionAggressivePosture = NULL;
	m_paePlotBuyingAggressivePosture = NULL;
	m_paeMilitaryThreat = NULL;
	m_paeWarDamageLevel = NULL;
	m_paiWarValueLost = NULL;
	m_paeWarmongerThreat = NULL;
	m_paiPersonalityMajorCivApproachBiases = NULL;
	m_paiPersonalityMinorCivApproachBiases = NULL;
	m_paDeclarationsLog = NULL;

	// Things a player has told the AI

	m_pabPlayerNoSettleRequestAccepted = NULL;
	m_paiPlayerNoSettleRequestCounter = NULL;

	m_pabPlayerStopSpyingRequestAccepted = NULL;
	m_paiPlayerStopSpyingRequestCounter = NULL;
#if defined(MOD_BALANCE_CORE)
	m_paiPlayerBackstabCounter = NULL;

	m_paiDefensivePactValue = NULL;
	m_paiDoFValue = NULL;
	m_paiCompetitorValue = NULL;
#endif

	m_paiDemandCounter = NULL;
	m_paiDemandTooSoonNumTurns = NULL;

	m_pabDoFAccepted = NULL;
	m_paiDoFCounter = NULL;

	m_pabDenouncedPlayer = NULL;
	m_pabFriendDenouncedUs = NULL;
	m_pabFriendDeclaredWarOnUs = NULL;
	m_paiDenouncedPlayerCounter = NULL;
	m_paiNumRequestsRefused = NULL;

	m_paiNumCiviliansReturnedToMe = NULL;
	m_paiNumLandmarksBuiltForMe = NULL;
	m_paiResurrectedOnTurn = NULL;
	m_paiNumTimesCultureBombed = NULL;

	m_paiNegativeReligiousConversionPoints = NULL;

	m_paiNegativeArchaeologyPoints = NULL;
	m_paiNumTimesNuked = NULL;
	m_paiNumTimesRobbedBy = NULL;
	m_paiNumTimesIntrigueSharedBy = NULL;

	m_paiBrokenExpansionPromiseValue = NULL;
	m_paiIgnoredExpansionPromiseValue = NULL;
	m_paiBrokenBorderPromiseValue = NULL;
	m_paiIgnoredBorderPromiseValue = NULL;
	m_paiDeclaredWarOnFriendValue = NULL;
	m_paiNumCitiesLiberated = NULL;
	m_paiTradeValue = NULL;
	m_paiCommonFoeValue = NULL;
	m_paiAssistValue = NULL;

	m_ppaabWorkingAgainstPlayerAccepted = NULL;
	m_ppaaiWorkingAgainstPlayerCounter = NULL;

	m_ppaacCoopWarAcceptedState = NULL;
	m_ppaaiCoopWarCounter = NULL;

	// Player's response to AI statements

	m_pabPlayerMadeMilitaryPromise = NULL;
	m_pabPlayerBrokenMilitaryPromise = NULL;
	m_pabPlayerIgnoredMilitaryPromise = NULL;
	m_paiPlayerMilitaryPromiseCounter = NULL;

	m_paiPlayerMadeExpansionPromiseTurn = NULL;
	m_pabPlayerBrokenExpansionPromise = NULL;
	m_pabPlayerIgnoredExpansionPromise = NULL;
	m_paePlayerExpansionPromiseData = NULL;

	m_paiPlayerMadeBorderPromiseTurn = NULL;
	m_pabPlayerBrokenBorderPromise = NULL;
	m_pabPlayerIgnoredBorderPromise = NULL;
	m_paePlayerBorderPromiseData = NULL;

	m_pabPlayerMadeAttackCityStatePromise = NULL;
	m_pabPlayerBrokenAttackCityStatePromise = NULL;
	m_pabPlayerIgnoredAttackCityStatePromise = NULL;

	m_pabPlayerMadeBullyCityStatePromise = NULL;
	m_pabPlayerBrokenBullyCityStatePromise = NULL;
	m_pabPlayerIgnoredBullyCityStatePromise = NULL;

	m_pabPlayerMadeSpyPromise = NULL;
	m_pabPlayerBrokenSpyPromise = NULL;
	m_pabPlayerIgnoredSpyPromise = NULL;

	m_pabPlayerForgaveForSpying = NULL;

	m_pabPlayerMadeNoConvertPromise = NULL;
	m_pabPlayerBrokenNoConvertPromise = NULL;
	m_pabPlayerIgnoredNoConvertPromise = NULL;
	m_pabPlayerAskedNotToConvert = NULL;
	m_pabPlayerAgreedNotToConvert = NULL;

	m_pabPlayerMadeNoDiggingPromise = NULL;
	m_pabPlayerBrokenNoDiggingPromise = NULL;
	m_pabPlayerIgnoredNoDiggingPromise = NULL;
	m_pabPlayerAskedNotToDig = NULL;
	m_pabPlayerAgreedNotToDig = NULL;

	m_pabPlayerBrokenCoopWarPromise = NULL;

	// Evaluation of Other Players' Tendencies
	m_paiOtherPlayerTurnsSinceAttackedProtectedMinor = NULL;
	m_paiOtherPlayerProtectedMinorAttacked = NULL;
	m_paiOtherPlayerNumProtectedMinorsAttacked = NULL;
	m_paiOtherPlayerTurnsSinceKilledProtectedMinor = NULL;
	m_paiOtherPlayerProtectedMinorKilled = NULL;
	m_paiOtherPlayerNumProtectedMinorsKilled = NULL;
	m_paiOtherPlayerNumProtectedMinorsBullied = NULL;
	m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor = NULL;
	m_paiOtherPlayerNumMinorsAttacked = NULL;
	m_paiOtherPlayerNumMinorsConquered = NULL;
	m_paiOtherPlayerNumMajorsAttacked = NULL;
	m_paiOtherPlayerNumMajorsConquered = NULL;
#if defined(MOD_API_EXTENSIONS)
	m_paiTheyPlottedAgainstUs = NULL;
	m_paiTheyLoweredOurInfluence = NULL;
#else
	m_paiOtherPlayerWarmongerAmount = NULL;
#endif

	m_paiOtherPlayerTurnsSinceWeLikedTheirProposal = NULL;
	m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal = NULL;
	m_paiOtherPlayerTurnsSinceTheySupportedOurProposal = NULL;
	m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal = NULL;
	m_paiOtherPlayerTurnsSinceTheySupportedOurHosting = NULL;

	m_ppaaeOtherPlayerLandDisputeLevel = NULL;
	m_ppaaeOtherPlayerVictoryDisputeLevel = NULL;
	m_ppaaeOtherPlayerWarDamageLevel = NULL;
	m_ppaaiOtherPlayerWarValueLost = NULL;
	m_ppaaiOtherPlayerLastRoundWarValueLost = NULL;
	m_ppaabSentAttackMessageToMinorCivProtector = NULL;
	m_ppaaeOtherPlayerMilitaryThreat = NULL;
	m_ppaDiploStatementsLog = NULL;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_pabShareOpinionAccepted = NULL;
	m_paiShareOpinionCounter = NULL;
	m_paiHelpRequestCounter = NULL;
	m_paiHelpRequestTooSoonNumTurns = NULL;
	m_paiPlayerVassalageFailedProtectValue = NULL;
	m_paiPlayerVassalageProtectValue = NULL;
	m_pabPlayerVassalagePeacefullyRevokedVassal = NULL;
	m_pabPlayerVassalageForcefullyRevokedVassal = NULL;
	m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage = NULL;
	m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage = NULL;
	m_paiNumTimesDemandedWhenVassal = NULL;
	m_pabPlayerBrokenVassalAgreement = NULL;
	m_pabMoveTroopsRequestAccepted = NULL;
	m_paiMoveTroopsRequestCounter = NULL;
	m_pabOfferingGift = NULL;
	m_pabOfferedGift = NULL;
	m_pabMasterLiberatedMeFromVassalage = NULL;
	m_pabVassalTaxRaised = NULL;
	m_pabVassalTaxLowered = NULL;
	m_paiVassalGoldPerTurnTaxedSinceVassalStarted = NULL;
	m_paiVassalGoldPerTurnCollectedSinceVassalStarted = NULL;
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
	m_pabWantsDefensivePactWithPlayer = NULL;
	m_pabWantsSneakAttack = NULL;
	m_paiPlayerNumTurnsAtPeace = NULL;
	m_paiPlayerNumTurnsSinceCityCapture = NULL;
	m_paePlayerVictoryBlockLevel = NULL;
	m_pabCantMatchDeal = NULL;
	m_paeDoFType =  NULL;
	m_paiNumTimesCoopWarDenied = NULL;
	m_paNoExpansionPromise = NULL;
	m_paLastTurnEmpireDistance = NULL;
	m_pabDoFBroken = NULL;
	m_paiNumTimesRazed = NULL;
	m_pabPlayerEverMadeBorderPromise = NULL;
	m_pabPlayerEverMadeExpansionPromise = NULL;
	m_pabDoFEverAsked = NULL;
	m_pabHelpRequestEverMade = NULL;
	m_paiDemandEverMade = NULL;
	m_pabPlayerNoSettleRequestEverAsked = NULL;
	m_pabPlayerStopSpyingRequestEverAsked = NULL;
	m_paiNumLandmarksBuiltForMeTurn = NULL;
	m_paiCiviliansReturnedToMeTurn = NULL;
	m_paiWarDamageValue = NULL;
	m_paiPlayerForgaveForSpyingTurn = NULL;
	m_paiLiberatedCitiesTurn = NULL;
	m_paiIntrigueSharedTurn = NULL;
	m_paiReligiousConversionTurn = NULL;
	m_paiTimesRobbedTurn = NULL;
#endif
#if defined(MOD_API_EXTENSIONS)
	m_paiOtherPlayerWarmongerAmountTimes100 = NULL;
#endif

	delete m_pDiploData;
	m_pDiploData = NULL;
}

/// Reset everything to default state
void CvDiplomacyAI::Reset()
{
	int iI, iJ;

	for(iI = 0; iI < NUM_DIPLO_LOG_STATEMENT_TYPES; iI++)
	{
		m_paDiploLogStatementTurnCountScratchPad[iI] = NO_DIPLO_STATEMENT_TYPE;
	}

	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		m_paeMajorCivOpinion[iI] = NO_MAJOR_CIV_OPINION_TYPE;

		for(iJ = 0; iJ < MAX_MAJOR_CIVS; iJ++)
		{
			m_ppaaeOtherPlayerMajorCivOpinion[iI][iJ] = NO_MAJOR_CIV_OPINION_TYPE;
			m_ppaabWorkingAgainstPlayerAccepted[iI][iJ] = false;
			m_ppaaiWorkingAgainstPlayerCounter[iI][iJ] = -1;
			m_ppaacCoopWarAcceptedState[iI][iJ] = NO_COOP_WAR_STATE;
			m_ppaaiCoopWarCounter[iI][iJ] = -1;
		}

		m_paeMajorCivApproach[iI] = NO_MAJOR_CIV_APPROACH;
		m_paeApproachTowardsUsGuess[iI] = NO_MAJOR_CIV_APPROACH;
		m_paeApproachTowardsUsGuessCounter[iI] = 0;

		m_paePeaceTreatyWillingToOffer[iI] = NO_PEACE_TREATY_TYPE;
		m_paePeaceTreatyWillingToAccept[iI] = NO_PEACE_TREATY_TYPE;

		m_paiOtherPlayerTurnsSinceAttackedProtectedMinor[iI] = -1;
		m_paiOtherPlayerProtectedMinorAttacked[iI] = NO_PLAYER;
		m_paiOtherPlayerNumProtectedMinorsAttacked[iI] = 0;

		m_paiOtherPlayerTurnsSinceKilledProtectedMinor[iI] = -1;
		m_paiOtherPlayerProtectedMinorKilled[iI] = NO_PLAYER;
		m_paiOtherPlayerNumProtectedMinorsKilled[iI] = 0;

		m_paiOtherPlayerNumProtectedMinorsBullied[iI] = 0;

		m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor[iI] = -1;

		m_paiOtherPlayerNumMinorsAttacked[iI] = 0;
		m_paiOtherPlayerNumMinorsConquered[iI] = 0;
		m_paiOtherPlayerNumMajorsAttacked[iI] = 0;
		m_paiOtherPlayerNumMajorsConquered[iI] = 0;
		
#if defined(MOD_API_EXTENSIONS)
		m_paiTheyPlottedAgainstUs[iI] = 0;
		m_paiTheyLoweredOurInfluence[iI] = 0;
#else
		m_paiOtherPlayerWarmongerAmount[iI] = 0;
#endif

		m_paiOtherPlayerTurnsSinceWeLikedTheirProposal[iI] = -1;
		m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal[iI] = -1;
		m_paiOtherPlayerTurnsSinceTheySupportedOurProposal[iI] = -1;
		m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal[iI] = -1;
		m_paiOtherPlayerTurnsSinceTheySupportedOurHosting[iI] = -1;

		m_pabWantsResearchAgreementWithPlayer[iI] = false;

		// Things a player has told this AI

		m_pabPlayerNoSettleRequestAccepted[iI] = false;
		m_paiPlayerNoSettleRequestCounter[iI] = -1;

		m_pabPlayerStopSpyingRequestAccepted[iI] = false;
		m_paiPlayerStopSpyingRequestCounter[iI] = -1;

#if defined(MOD_BALANCE_CORE)
		m_paiPlayerBackstabCounter[iI] = -1;
#endif

		m_paiDemandCounter[iI] = -1;
		m_paiDemandTooSoonNumTurns[iI] = -1;

		m_pabDoFAccepted[iI] = false;
		m_paiDoFCounter[iI] = -1;

		m_pabDenouncedPlayer[iI] = false;
		m_pabFriendDenouncedUs[iI] = false;
		m_pabFriendDeclaredWarOnUs[iI] = false;
		m_paiDenouncedPlayerCounter[iI] = -1;
		m_paiNumRequestsRefused[iI] = 0;

		m_paiNumCiviliansReturnedToMe[iI] = 0;
		m_paiNumLandmarksBuiltForMe[iI] = 0;
		m_paiResurrectedOnTurn[iI] = -1;
		m_paiNumTimesCultureBombed[iI] = 0;

		m_paiNegativeReligiousConversionPoints[iI] = 0;

		m_paiNegativeArchaeologyPoints[iI] = 0;
		m_paiNumTimesNuked[iI] = 0;
		m_paiNumTimesRobbedBy[iI] = 0;
		m_paiNumTimesIntrigueSharedBy[iI] = 0;

		m_paiBrokenExpansionPromiseValue[iI] = 0;
		m_paiIgnoredExpansionPromiseValue[iI] = 0;
		m_paiBrokenBorderPromiseValue[iI] = 0;
		m_paiIgnoredBorderPromiseValue[iI] = 0;
		m_paiDeclaredWarOnFriendValue[iI] = 0;
		m_paiNumCitiesLiberated[iI] = 0;
		m_paiTradeValue[iI] = 0;
		m_paiCommonFoeValue[iI] = 0;
		m_paiAssistValue[iI] = 0;

		// Player's repsonse to AI statements

		m_pabPlayerMadeMilitaryPromise[iI] = false;
		m_pabPlayerBrokenMilitaryPromise[iI] = false;
		m_pabPlayerIgnoredMilitaryPromise[iI] = false;
		m_paiPlayerMilitaryPromiseCounter[iI] = -1;

		m_paiPlayerMadeExpansionPromiseTurn[iI] = -1;
		m_pabPlayerBrokenExpansionPromise[iI] = false;
		m_pabPlayerIgnoredExpansionPromise[iI] = false;
		m_paePlayerExpansionPromiseData[iI] = NO_AGGRESSIVE_POSTURE_TYPE;

		m_paiPlayerMadeBorderPromiseTurn[iI] = -1;
		m_pabPlayerBrokenBorderPromise[iI] = false;
		m_pabPlayerIgnoredBorderPromise[iI] = false;
		m_paePlayerBorderPromiseData[iI] = NO_AGGRESSIVE_POSTURE_TYPE;

		m_pabPlayerMadeAttackCityStatePromise[iI] = false;
		m_pabPlayerBrokenAttackCityStatePromise[iI] = false;
		m_pabPlayerIgnoredAttackCityStatePromise[iI] = false;

		m_pabPlayerMadeBullyCityStatePromise[iI] = false;
		m_pabPlayerBrokenBullyCityStatePromise[iI] = false;
		m_pabPlayerIgnoredBullyCityStatePromise[iI] = false;

		m_pabPlayerMadeSpyPromise[iI] = false;
		m_pabPlayerBrokenSpyPromise[iI] = false;
		m_pabPlayerIgnoredSpyPromise[iI] = false;

		m_pabPlayerForgaveForSpying[iI] = false;

		m_pabPlayerMadeNoConvertPromise[iI] = false;
		m_pabPlayerBrokenNoConvertPromise[iI] = false;
		m_pabPlayerIgnoredNoConvertPromise[iI] = false;
		m_pabPlayerAskedNotToConvert[iI] = false;
		m_pabPlayerAgreedNotToConvert[iI] = false;

		m_pabPlayerMadeNoDiggingPromise[iI] = false;
		m_pabPlayerBrokenNoDiggingPromise[iI] = false;
		m_pabPlayerIgnoredNoDiggingPromise[iI] = false;
		m_pabPlayerAskedNotToDig[iI] = false;
		m_pabPlayerAgreedNotToDig[iI] = false;

		m_pabPlayerBrokenCoopWarPromise[iI] = false;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		m_pabShareOpinionAccepted[iI] = false;
		m_paiShareOpinionCounter[iI] = -1;
		m_paiHelpRequestCounter[iI] = -1;
		m_paiHelpRequestTooSoonNumTurns[iI] = -1;
		m_paiPlayerVassalageFailedProtectValue[iI] = 0;
		m_paiPlayerVassalageProtectValue[iI] = 0;
		m_pabPlayerVassalagePeacefullyRevokedVassal[iI] = false;
		m_pabPlayerVassalageForcefullyRevokedVassal[iI] = false;
		m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage[iI] = -1;
		m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage[iI] = -1;
		m_paiNumTimesDemandedWhenVassal[iI] = 0;
		m_pabPlayerBrokenVassalAgreement[iI] = false;
		m_pabMoveTroopsRequestAccepted[iI] = false;
		m_paiMoveTroopsRequestCounter[iI] = -1;
		m_pabOfferingGift[iI] = false;
		m_pabOfferedGift[iI] = false;
		m_pabMasterLiberatedMeFromVassalage[iI] = false;
		m_pabVassalTaxRaised[iI] = false;
		m_pabVassalTaxLowered[iI] = false;
		m_paiVassalGoldPerTurnTaxedSinceVassalStarted[iI] = 0;
		m_paiVassalGoldPerTurnCollectedSinceVassalStarted[iI] = 0;
#endif
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		m_pabWantsDefensivePactWithPlayer[iI] = false;
		m_pabWantsSneakAttack[iI] = false;
		m_paePlayerVictoryBlockLevel[iI] = NO_BLOCK_LEVEL;
		m_pabCantMatchDeal[iI] = false;
		m_paeDoFType[iI] = NO_DOF_TYPE;
		m_paiNumTimesCoopWarDenied[iI] = 0;
		m_paNoExpansionPromise[iI] = make_pair(-1, -1);
		m_paLastTurnEmpireDistance[iI] = make_pair(-1, -1);
		m_pabDoFBroken[iI] = false;
		m_pabPlayerEverMadeBorderPromise[iI] = false;
		m_pabPlayerEverMadeExpansionPromise[iI] = false;
		m_pabDoFEverAsked[iI] = false;
		m_pabHelpRequestEverMade[iI] = false;
		m_paiDemandEverMade[iI] = 0;
		m_pabPlayerNoSettleRequestEverAsked[iI] = false;
		m_pabPlayerStopSpyingRequestEverAsked[iI] = false;
		m_paiNumLandmarksBuiltForMeTurn[iI] = 0;
		m_paiCiviliansReturnedToMeTurn[iI] = 0;
		m_paiWarDamageValue[iI] = 0;
		m_paiPlayerForgaveForSpyingTurn[iI] = 0;
		m_paiLiberatedCitiesTurn[iI] = 0;
		m_paiIntrigueSharedTurn[iI] = 0;
		m_paiReligiousConversionTurn[iI] = 0;
		m_paiTimesRobbedTurn[iI] = 0;

		m_paiDefensivePactValue[iI] = 0;
		m_paiDoFValue[iI] = 0;
		m_paiCompetitorValue[iI] = 0;
#endif
#if defined(MOD_API_EXTENSIONS)
		m_paiOtherPlayerWarmongerAmountTimes100[iI] = 0;
#endif
	}

	for(iI = 0; iI < MAX_MINOR_CIVS; iI++)
	{
		m_paeMinorCivApproach[iI] = NO_MINOR_CIV_APPROACH;
		m_pabWantToRouteToMinor[iI] = true;
	}

	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_paeApproachScratchPad[iI] = -1;

		m_paiNumWondersBeatenTo[iI] = 0;
		m_pabArmyInPlaceForAttack[iI] = false;

		m_paeWantPeaceCounter[iI] = 0;

		m_paeWarFace[iI] = NO_WAR_FACE_TYPE;
		m_paeWarState[iI] = NO_WAR_STATE_TYPE;
		m_paeWarProjection[iI] = NO_WAR_PROJECTION_TYPE;
		m_paeLastWarProjection[iI] = NO_WAR_PROJECTION_TYPE;
		m_paeWarGoal[iI] = NO_WAR_GOAL_TYPE;
		m_paiPlayerNumTurnsAtWar[iI] = 0;

		m_paiNumWarsFought[iI] = 0;

		m_paePlayerMilitaryStrengthComparedToUs[iI] = NO_STRENGTH_VALUE;
		m_paePlayerEconomicStrengthComparedToUs[iI] = NO_STRENGTH_VALUE;
		m_paePlayerTargetValue[iI] = NO_TARGET_VALUE;

		m_paePlayerLandDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_paePlayerLastTurnLandDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_paePlayerVictoryDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_paePlayerWonderDisputeLevel[iI] = NO_DISPUTE_LEVEL;
		m_paePlayerMinorCivDisputeLevel[iI] = NO_DISPUTE_LEVEL;

		for(iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
		{
			m_ppaaeOtherPlayerLandDisputeLevel[iI][iJ] = NO_DISPUTE_LEVEL;
			m_ppaaeOtherPlayerVictoryDisputeLevel[iI][iJ] = NO_DISPUTE_LEVEL;

			m_ppaaeOtherPlayerWarDamageLevel[iI][iJ] = NO_WAR_DAMAGE_LEVEL_VALUE;
			m_ppaaiOtherPlayerWarValueLost[iI][iJ] = 0;
			m_ppaaiOtherPlayerLastRoundWarValueLost[iI][iJ] = 0;
			m_ppaabSentAttackMessageToMinorCivProtector[iI][iJ] = false;

			m_ppaaeOtherPlayerMilitaryThreat[iI][iJ] = NO_THREAT_VALUE;
		}

		m_paeWarDamageLevel[iI] = NO_WAR_DAMAGE_LEVEL_VALUE;
		m_paiWarValueLost[iI] = 0;

		m_paeMilitaryAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_paeLastTurnMilitaryAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_paeExpansionAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;
		m_paePlotBuyingAggressivePosture[iI] = NO_AGGRESSIVE_POSTURE_TYPE;

		m_paeMilitaryThreat[iI] = NO_THREAT_VALUE;

		m_paeWarmongerThreat[iI] = NO_THREAT_VALUE;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		m_paiPlayerNumTurnsAtPeace[iI] = 0;
		m_paiPlayerNumTurnsSinceCityCapture[iI] = 0;
		m_paiNumTimesRazed[iI] = 0;
#endif
	}

	m_eDemandTargetPlayer = NO_PLAYER;
	m_bDemandReady = false;

	m_iVictoryCompetitiveness = -1;
	m_iWonderCompetitiveness = -1;
	m_iMinorCivCompetitiveness = -1;
	m_iBoldness = -1;
	m_iDiploBalance = -1;
	m_iWarmongerHate = -1;
	m_iDenounceWillingness = -1;
	m_iDoFWillingness = -1;
	m_iLoyalty = -1;
	m_iNeediness = -1;
	m_iForgiveness = -1;
	m_iChattiness = -1;
	m_iMeanness = -1;

	for(iI = 0; iI < NUM_MAJOR_CIV_APPROACHES; iI++)
	{
		m_paiPersonalityMajorCivApproachBiases[iI] = 0;
	}

	for(iI = 0; iI < NUM_MINOR_CIV_APPROACHES; iI++)
	{
		m_paiPersonalityMinorCivApproachBiases[iI] = 0;
	}

	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		for(iJ = 0; iJ < MAX_DIPLO_LOG_STATEMENTS; iJ++)
		{
			m_ppaDiploStatementsLog[iI][iJ].m_eDiploLogStatement = NO_DIPLO_STATEMENT_TYPE;
			m_ppaDiploStatementsLog[iI][iJ].m_iTurn = -1;
		}
	}

	for(iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		m_paDeclarationsLog[iI].m_eDeclaration = NO_PUBLIC_DECLARATION_TYPE;
		m_paDeclarationsLog[iI].m_iTurn = -1;
	}

	m_eStateAllWars = STATE_ALL_WARS_NEUTRAL;

	m_aGreetPlayers.clear();
}

/// Serialization read
void CvDiplomacyAI::Read(FDataStream& kStream)
{
	// Version number to maintain backwards compatibility
	uint uiVersion;
	kStream >> uiVersion;
	MOD_SERIALIZE_INIT_READ(kStream);

	int iI;

	ArrayWrapper<char> wrapMajorOpinion(MAX_MAJOR_CIVS, m_paeMajorCivOpinion);
	kStream >> wrapMajorOpinion;

	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		ArrayWrapper<char> wrapOtherMajorOpinion(MAX_MAJOR_CIVS, m_ppaaeOtherPlayerMajorCivOpinion[iI]);
		kStream >> wrapOtherMajorOpinion;

		ArrayWrapper<bool> wrapWorkingAgainstPlayerAccepted(MAX_MAJOR_CIVS, m_ppaabWorkingAgainstPlayerAccepted[iI]);
		kStream >> wrapWorkingAgainstPlayerAccepted;

		ArrayWrapper<short> workingAgainstPlayerCounter(MAX_MAJOR_CIVS, m_ppaaiWorkingAgainstPlayerCounter[iI]);
		kStream >> workingAgainstPlayerCounter;

		ArrayWrapper<char> wrapCoopWarAcceptedState(MAX_MAJOR_CIVS, m_ppaacCoopWarAcceptedState[iI]);
		kStream >> wrapCoopWarAcceptedState;

		ArrayWrapper<short> wrapCoopWarCounter(MAX_MAJOR_CIVS, m_ppaaiCoopWarCounter[iI]);
		kStream >> wrapCoopWarCounter;
	}

	ArrayWrapper<char> wrapm_paeMajorCivApproach(MAX_MAJOR_CIVS, m_paeMajorCivApproach);
	kStream >> wrapm_paeMajorCivApproach;

	ArrayWrapper<char> wrapm_paeMinorCivApproach(MAX_MINOR_CIVS, m_paeMinorCivApproach);
	kStream >> wrapm_paeMinorCivApproach;

	ArrayWrapper<char> wrapm_paeApproachTowardsUsGuess(MAX_MAJOR_CIVS, m_paeApproachTowardsUsGuess);
	kStream >> wrapm_paeApproachTowardsUsGuess;

	ArrayWrapper<char> wrapm_paeApproachTowardsUsGuessCounter(MAX_MAJOR_CIVS, m_paeApproachTowardsUsGuessCounter);
	kStream >> wrapm_paeApproachTowardsUsGuessCounter;


	ArrayWrapper<short> wrapm_paiNumWondersBeatenTo(MAX_CIV_PLAYERS, m_paiNumWondersBeatenTo);
	kStream >> wrapm_paiNumWondersBeatenTo;

	ArrayWrapper<bool> wrapm_pabArmyInPlaceForAttack(MAX_CIV_PLAYERS, m_pabArmyInPlaceForAttack);
	kStream >> wrapm_pabArmyInPlaceForAttack;


	ArrayWrapper<bool> wrapm_pabWantsResearchAgreementWithPlayer(MAX_MAJOR_CIVS, m_pabWantsResearchAgreementWithPlayer);
	kStream >> wrapm_pabWantsResearchAgreementWithPlayer;

	ArrayWrapper<bool> wrapm_pabWantToRouteToMinor(MAX_MINOR_CIVS, m_pabWantToRouteToMinor);
	kStream >> wrapm_pabWantToRouteToMinor;


	ArrayWrapper<short> wrapm_paeWantPeaceCounter(MAX_CIV_PLAYERS, m_paeWantPeaceCounter);
	kStream >> wrapm_paeWantPeaceCounter;

	ArrayWrapper<char> wrapm_paePeaceTreatyWillingToOffer(MAX_MAJOR_CIVS, m_paePeaceTreatyWillingToOffer);
	kStream >> wrapm_paePeaceTreatyWillingToOffer;

	ArrayWrapper<char> wrapm_paePeaceTreatyWillingToAccept(MAX_MAJOR_CIVS, m_paePeaceTreatyWillingToAccept);
	kStream >> wrapm_paePeaceTreatyWillingToAccept;


	ArrayWrapper<char> wrapm_paeWarFace(MAX_CIV_PLAYERS, m_paeWarFace);
	kStream >> wrapm_paeWarFace;

	ArrayWrapper<char> wrapm_paeWarState(MAX_CIV_PLAYERS, m_paeWarState);
	kStream >> wrapm_paeWarState;

	ArrayWrapper<char> wrapm_paeWarProjection(MAX_CIV_PLAYERS, m_paeWarProjection);
	kStream >> wrapm_paeWarProjection;

	ArrayWrapper<char> wrapm_paeLastWarProjection(MAX_CIV_PLAYERS, m_paeLastWarProjection);
	kStream >> wrapm_paeLastWarProjection;

	ArrayWrapper<char> wrapm_paeWarGoal(MAX_CIV_PLAYERS, m_paeWarGoal);
	kStream >> wrapm_paeWarGoal;

	ArrayWrapper<short> wrapm_paiPlayerNumTurnsAtWar(MAX_CIV_PLAYERS, m_paiPlayerNumTurnsAtWar);
	kStream >> wrapm_paiPlayerNumTurnsAtWar;

	ArrayWrapper<short> wrapm_paiNumWarsFought(MAX_CIV_PLAYERS, m_paiNumWarsFought);
	kStream >> wrapm_paiNumWarsFought;

	ArrayWrapper<char> wrapm_paePlayerMilitaryStrengthComparedToUs(MAX_CIV_PLAYERS, m_paePlayerMilitaryStrengthComparedToUs);
	kStream >> wrapm_paePlayerMilitaryStrengthComparedToUs;

	ArrayWrapper<char> wrapm_paePlayerEconomicStrengthComparedToUs(MAX_CIV_PLAYERS, m_paePlayerEconomicStrengthComparedToUs);
	kStream >> wrapm_paePlayerEconomicStrengthComparedToUs;

	ArrayWrapper<char> wrapm_paePlayerTargetValue(MAX_CIV_PLAYERS, m_paePlayerTargetValue);
	kStream >> wrapm_paePlayerTargetValue;


	ArrayWrapper<char> wrapm_paePlayerLandDisputeLevel(MAX_CIV_PLAYERS, m_paePlayerLandDisputeLevel);
	kStream >> wrapm_paePlayerLandDisputeLevel;

	ArrayWrapper<char> wrapm_paePlayerLastTurnLandDisputeLevel(MAX_CIV_PLAYERS, m_paePlayerLastTurnLandDisputeLevel);
	kStream >> wrapm_paePlayerLastTurnLandDisputeLevel;

	ArrayWrapper<char> wrapm_paePlayerVictoryDisputeLevel(MAX_CIV_PLAYERS, m_paePlayerVictoryDisputeLevel);
	kStream >> wrapm_paePlayerVictoryDisputeLevel;

	ArrayWrapper<char> wrapm_paePlayerWonderDisputeLevel(MAX_CIV_PLAYERS, m_paePlayerWonderDisputeLevel);
	kStream >> wrapm_paePlayerWonderDisputeLevel;

	ArrayWrapper<char> wrapm_paePlayerMinorCivDisputeLevel(MAX_CIV_PLAYERS, m_paePlayerMinorCivDisputeLevel);
	kStream >> wrapm_paePlayerMinorCivDisputeLevel;


	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		ArrayWrapper<char> wrapm_ppaaeOtherPlayerLandDisputeLevel(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerLandDisputeLevel[iI]);
		kStream >> wrapm_ppaaeOtherPlayerLandDisputeLevel;

		ArrayWrapper<char> wrapm_ppaaeOtherPlayerVictoryDisputeLevel(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerVictoryDisputeLevel[iI]);
		kStream >> wrapm_ppaaeOtherPlayerVictoryDisputeLevel;

		ArrayWrapper<char> wrapm_ppaaeOtherPlayerWarDamageLevel(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerWarDamageLevel[iI]);
		kStream >> wrapm_ppaaeOtherPlayerWarDamageLevel;

		ArrayWrapper<int> wrapm_ppaaiOtherPlayerWarValueLost(MAX_CIV_PLAYERS, m_ppaaiOtherPlayerWarValueLost[iI]);
		kStream >> wrapm_ppaaiOtherPlayerWarValueLost;

		ArrayWrapper<char> wrapm_ppaaeOtherPlayerMilitaryThreat(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerMilitaryThreat[iI]);
		kStream >> wrapm_ppaaeOtherPlayerMilitaryThreat;
	}

	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		ArrayWrapper<int> wrapm_ppaaiOtherPlayerLastRoundWarValueLost(MAX_CIV_PLAYERS, m_ppaaiOtherPlayerLastRoundWarValueLost[iI]);
		kStream >> wrapm_ppaaiOtherPlayerLastRoundWarValueLost;

		ArrayWrapper<bool> wrapm_ppaabSentAttackMessageToMinorCivProtector(MAX_CIV_PLAYERS, m_ppaabSentAttackMessageToMinorCivProtector[iI]);
		kStream >> wrapm_ppaabSentAttackMessageToMinorCivProtector;
	}

	ArrayWrapper<char> wrapm_paeWarDamageLevel(MAX_CIV_PLAYERS, m_paeWarDamageLevel);
	kStream >> wrapm_paeWarDamageLevel;

	ArrayWrapper<int> wrapm_paiWarValueLost(MAX_CIV_PLAYERS, m_paiWarValueLost);
	kStream >> wrapm_paiWarValueLost;

	ArrayWrapper<char> wrapm_paeMilitaryAggressivePosture(MAX_CIV_PLAYERS, m_paeMilitaryAggressivePosture);
	kStream >> wrapm_paeMilitaryAggressivePosture;

	ArrayWrapper<char> wrapm_paeLastTurnMilitaryAggressivePosture(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryAggressivePosture);
	kStream >> wrapm_paeLastTurnMilitaryAggressivePosture;

	ArrayWrapper<char> wrapm_paeExpansionAggressivePosture(MAX_CIV_PLAYERS, m_paeExpansionAggressivePosture);
	kStream >> wrapm_paeExpansionAggressivePosture;

	ArrayWrapper<char> wrapm_paePlotBuyingAggressivePosture(MAX_CIV_PLAYERS, m_paePlotBuyingAggressivePosture);
	kStream >> wrapm_paePlotBuyingAggressivePosture;

	ArrayWrapper<char> wrapm_paeMilitaryThreat(MAX_CIV_PLAYERS, m_paeMilitaryThreat);
	kStream >> wrapm_paeMilitaryThreat;

	ArrayWrapper<char> wrapm_paeWarmongerThreat(MAX_CIV_PLAYERS, m_paeWarmongerThreat);
	kStream >> wrapm_paeWarmongerThreat;

	ArrayWrapper<bool> wrapm_pabPlayerNoSettleRequestAccepted(MAX_MAJOR_CIVS, m_pabPlayerNoSettleRequestAccepted);
	kStream >> wrapm_pabPlayerNoSettleRequestAccepted;

	ArrayWrapper<short> wrapm_paiPlayerNoSettleRequestCounter(MAX_MAJOR_CIVS, m_paiPlayerNoSettleRequestCounter);
	kStream >> wrapm_paiPlayerNoSettleRequestCounter;

	ArrayWrapper<bool> wrapm_pabPlayerStopSpyingRequestAccepted(MAX_MAJOR_CIVS, m_pabPlayerStopSpyingRequestAccepted);
	kStream >> wrapm_pabPlayerStopSpyingRequestAccepted;

	ArrayWrapper<short> wrapm_paiPlayerStopSpyingRequestCounter(MAX_MAJOR_CIVS, m_paiPlayerStopSpyingRequestCounter);
	kStream >> wrapm_paiPlayerStopSpyingRequestCounter;

#if defined(MOD_BALANCE_CORE)
	ArrayWrapper<short> wrapm_paiPlayerBackstabCounter(MAX_MAJOR_CIVS, m_paiPlayerBackstabCounter);
	kStream >> wrapm_paiPlayerBackstabCounter;

	ArrayWrapper<short> wrapm_paiDefensivePactValue(MAX_MAJOR_CIVS, m_paiDefensivePactValue);
	kStream >> wrapm_paiDefensivePactValue;
	ArrayWrapper<short> wrapm_paiDoFValue(MAX_MAJOR_CIVS, m_paiDoFValue);
	kStream >> wrapm_paiDoFValue;
	ArrayWrapper<short> wrapm_paiCompetitorValue(MAX_MAJOR_CIVS, m_paiCompetitorValue);
	kStream >> wrapm_paiCompetitorValue;
#endif

	ArrayWrapper<short> wrapm_paiDemandCounter(MAX_MAJOR_CIVS, m_paiDemandCounter);
	kStream >> wrapm_paiDemandCounter;

	ArrayWrapper<short> wrapm_paiDemandTooSoonNumTurns(MAX_MAJOR_CIVS, m_paiDemandTooSoonNumTurns);
	kStream >> wrapm_paiDemandTooSoonNumTurns;

	ArrayWrapper<bool> wrapm_pabDoFAccepted(MAX_MAJOR_CIVS, m_pabDoFAccepted);
	kStream >> wrapm_pabDoFAccepted;

	ArrayWrapper<short> wrapm_paiDoFCounter(MAX_MAJOR_CIVS, m_paiDoFCounter);
	kStream >> wrapm_paiDoFCounter;

	ArrayWrapper<bool> wrapm_pabDenouncedPlayer(MAX_MAJOR_CIVS, m_pabDenouncedPlayer);
	kStream >> wrapm_pabDenouncedPlayer;

	ArrayWrapper<bool> wrapm_pabFriendDenouncedUs(MAX_MAJOR_CIVS, m_pabFriendDenouncedUs);
	kStream >> wrapm_pabFriendDenouncedUs;

	ArrayWrapper<short> wrapm_paiDenouncedPlayerCounter(MAX_MAJOR_CIVS, m_paiDenouncedPlayerCounter);
	kStream >> wrapm_paiDenouncedPlayerCounter;

	ArrayWrapper<bool> wrapm_pabFriendDeclaredWarOnUs(MAX_MAJOR_CIVS, m_pabFriendDeclaredWarOnUs);
	kStream >> wrapm_pabFriendDeclaredWarOnUs;

	ArrayWrapper<short> wrapm_paiNumRequestsRefused(MAX_MAJOR_CIVS, m_paiNumRequestsRefused);
	kStream >> wrapm_paiNumRequestsRefused;

	ArrayWrapper<short> wrapm_paiNumCiviliansReturnedToMe(MAX_MAJOR_CIVS, m_paiNumCiviliansReturnedToMe);
	kStream >> wrapm_paiNumCiviliansReturnedToMe;

	if (uiVersion >= 4)
	{
		ArrayWrapper<short> wrapm_paiNumLandmarksBuiltForMe(MAX_MAJOR_CIVS, m_paiNumLandmarksBuiltForMe);
		kStream >> wrapm_paiNumLandmarksBuiltForMe;
	}
	else
	{
		for (int i=0;i<MAX_MAJOR_CIVS;i++)
		{
			m_paiNumLandmarksBuiltForMe[i] = 0;
		}
	}

	ArrayWrapper<short> wrapm_paiResurrectedOnTurn(MAX_MAJOR_CIVS, m_paiResurrectedOnTurn);
	kStream >> wrapm_paiResurrectedOnTurn;

	ArrayWrapper<short> wrapm_paiNumTimesCultureBombed(MAX_MAJOR_CIVS, m_paiNumTimesCultureBombed);
	kStream >> wrapm_paiNumTimesCultureBombed;

	ArrayWrapper<short> wrapm_paiNegativeReligiousConversionPoints(MAX_MAJOR_CIVS, m_paiNegativeReligiousConversionPoints);
	kStream >> wrapm_paiNegativeReligiousConversionPoints;

	if (uiVersion > 1)
	{
		ArrayWrapper<short> wrapm_paiNegativeArchaeologyPoints(MAX_MAJOR_CIVS, m_paiNegativeArchaeologyPoints);
		kStream >> wrapm_paiNegativeArchaeologyPoints;
	}
	else
	{
		for (int i=0;i<MAX_MAJOR_CIVS;i++)
		{
			m_paiNegativeArchaeologyPoints[i] = 0;
		}
	}

	ArrayWrapper<short> wrapm_paiNumTimesNuked(MAX_MAJOR_CIVS, m_paiNumTimesNuked);
	kStream >> wrapm_paiNumTimesNuked;

	ArrayWrapper<short> wrapm_paiNumTimesRobbedBy(MAX_MAJOR_CIVS, m_paiNumTimesRobbedBy);
	kStream >> wrapm_paiNumTimesRobbedBy;

	ArrayWrapper<short> wrapm_paiNumTimesIntrigueSharedBy(MAX_MAJOR_CIVS, m_paiNumTimesIntrigueSharedBy);
	kStream >> wrapm_paiNumTimesIntrigueSharedBy;

	ArrayWrapper<short> wrapm_paiBrokenExpansionPromiseValue(MAX_MAJOR_CIVS, m_paiBrokenExpansionPromiseValue);
	kStream >> wrapm_paiBrokenExpansionPromiseValue;
	ArrayWrapper<short> wrapm_paiIgnoredExpansionPromiseValue(MAX_MAJOR_CIVS, m_paiIgnoredExpansionPromiseValue);
	kStream >> wrapm_paiIgnoredExpansionPromiseValue;		

	ArrayWrapper<short> wrapm_paiBrokenBorderPromiseValue(MAX_MAJOR_CIVS, m_paiBrokenBorderPromiseValue);
	kStream >> wrapm_paiBrokenBorderPromiseValue;
	ArrayWrapper<short> wrapm_paiIgnoredBorderPromiseValue(MAX_MAJOR_CIVS, m_paiIgnoredBorderPromiseValue);
	kStream >> wrapm_paiIgnoredBorderPromiseValue;		

	ArrayWrapper<short> wrapm_aiDeclaredWarOnFriendValue(MAX_MAJOR_CIVS, m_paiDeclaredWarOnFriendValue);
	kStream >> wrapm_aiDeclaredWarOnFriendValue;

	ArrayWrapper<short> wrapm_paiTradeValue(MAX_MAJOR_CIVS, m_paiTradeValue);
	kStream >> wrapm_paiTradeValue;

	ArrayWrapper<short> wrapm_paiCommonFoeValue(MAX_MAJOR_CIVS, m_paiCommonFoeValue);
	kStream >> wrapm_paiCommonFoeValue;
	ArrayWrapper<short> wrapm_paiAssistValue(MAX_MAJOR_CIVS, m_paiAssistValue);
	kStream >> wrapm_paiAssistValue;

	ArrayWrapper<bool> wrapm_pabPlayerMadeMilitaryPromise(MAX_MAJOR_CIVS, m_pabPlayerMadeMilitaryPromise);
	kStream >> wrapm_pabPlayerMadeMilitaryPromise;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenMilitaryPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenMilitaryPromise);
	kStream >> wrapm_pabPlayerBrokenMilitaryPromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredMilitaryPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredMilitaryPromise);
	kStream >> wrapm_pabPlayerIgnoredMilitaryPromise;

	ArrayWrapper<short> wrapm_paiPlayerMilitaryPromiseCounter(MAX_MAJOR_CIVS, m_paiPlayerMilitaryPromiseCounter);
	kStream >> wrapm_paiPlayerMilitaryPromiseCounter;

	ArrayWrapper<short> wrapm_paiPlayerMadeExpansionPromiseTurn(MAX_MAJOR_CIVS, m_paiPlayerMadeExpansionPromiseTurn);
	kStream >> wrapm_paiPlayerMadeExpansionPromiseTurn;		

	ArrayWrapper<bool> wrapm_pabPlayerBrokenExpansionPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenExpansionPromise);
	kStream >> wrapm_pabPlayerBrokenExpansionPromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredExpansionPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredExpansionPromise);
	kStream >> wrapm_pabPlayerIgnoredExpansionPromise;

	ArrayWrapper<char> wrapm_paePlayerExpansionPromiseData(MAX_MAJOR_CIVS, m_paePlayerExpansionPromiseData);
	kStream >> wrapm_paePlayerExpansionPromiseData;

	ArrayWrapper<short> wrapm_paiPlayerMadeBorderPromiseTurn(MAX_MAJOR_CIVS, m_paiPlayerMadeBorderPromiseTurn);
	kStream >> wrapm_paiPlayerMadeBorderPromiseTurn;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenBorderPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenBorderPromise);
	kStream >> wrapm_pabPlayerBrokenBorderPromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredBorderPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredBorderPromise);
	kStream >> wrapm_pabPlayerIgnoredBorderPromise;

	ArrayWrapper<char> wrapm_paePlayerBorderPromiseData(MAX_MAJOR_CIVS, m_paePlayerBorderPromiseData);
	kStream >> wrapm_paePlayerBorderPromiseData;

	ArrayWrapper<bool> wrapm_pabPlayerMadeAttackCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerMadeAttackCityStatePromise);
	kStream >> wrapm_pabPlayerMadeAttackCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenAttackCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenAttackCityStatePromise);
	kStream >> wrapm_pabPlayerBrokenAttackCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredAttackCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredAttackCityStatePromise);
	kStream >> wrapm_pabPlayerIgnoredAttackCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerMadeBullyCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerMadeBullyCityStatePromise);
	kStream >> wrapm_pabPlayerMadeBullyCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenBullyCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenBullyCityStatePromise);
	kStream >> wrapm_pabPlayerBrokenBullyCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredBullyCityStatePromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredBullyCityStatePromise);
	kStream >> wrapm_pabPlayerIgnoredBullyCityStatePromise;

	ArrayWrapper<bool> wrapm_pabPlayerMadeSpyPromise(MAX_MAJOR_CIVS, m_pabPlayerMadeSpyPromise);
	kStream >> wrapm_pabPlayerMadeSpyPromise;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenSpyPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenSpyPromise);
	kStream >> wrapm_pabPlayerBrokenSpyPromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredSpyPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredSpyPromise);
	kStream >> wrapm_pabPlayerIgnoredSpyPromise;

	ArrayWrapper<bool> wrapm_pabPlayerForgaveForSpying(MAX_MAJOR_CIVS, m_pabPlayerForgaveForSpying);
	kStream >> wrapm_pabPlayerForgaveForSpying;

	ArrayWrapper<bool> wrapm_pabPlayerMadeNoConvertPromise(MAX_MAJOR_CIVS, m_pabPlayerMadeNoConvertPromise);
	kStream >> wrapm_pabPlayerMadeNoConvertPromise;

	ArrayWrapper<bool> wrapm_pabPlayerBrokenNoConvertPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenNoConvertPromise);
	kStream >> wrapm_pabPlayerBrokenNoConvertPromise;

	ArrayWrapper<bool> wrapm_pabPlayerIgnoredNoConvertPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredNoConvertPromise);
	kStream >> wrapm_pabPlayerIgnoredNoConvertPromise;

	ArrayWrapper<bool> wrapm_pabPlayerAskedNotToConvert(MAX_MAJOR_CIVS, m_pabPlayerAskedNotToConvert);
	kStream >> wrapm_pabPlayerAskedNotToConvert;

	ArrayWrapper<bool> wrapm_pabPlayerAgreedNotToConvert(MAX_MAJOR_CIVS, m_pabPlayerAgreedNotToConvert);
	kStream >> wrapm_pabPlayerAgreedNotToConvert;

	if (uiVersion > 1)
	{
		ArrayWrapper<bool> wrapm_pabPlayerMadeNoDiggingPromise(MAX_MAJOR_CIVS, m_pabPlayerMadeNoDiggingPromise);
		kStream >> wrapm_pabPlayerMadeNoDiggingPromise;

		ArrayWrapper<bool> wrapm_pabPlayerBrokenNoDiggingPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenNoDiggingPromise);
		kStream >> wrapm_pabPlayerBrokenNoDiggingPromise;

		ArrayWrapper<bool> wrapm_pabPlayerIgnoredNoDiggingPromise(MAX_MAJOR_CIVS, m_pabPlayerIgnoredNoDiggingPromise);
		kStream >> wrapm_pabPlayerIgnoredNoDiggingPromise;

		ArrayWrapper<bool> wrapm_pabPlayerAskedNotToDig(MAX_MAJOR_CIVS, m_pabPlayerAskedNotToDig);
		kStream >> wrapm_pabPlayerAskedNotToDig;

		ArrayWrapper<bool> wrapm_pabPlayerAgreedNotToDig(MAX_MAJOR_CIVS, m_pabPlayerAgreedNotToDig);
		kStream >> wrapm_pabPlayerAgreedNotToDig;
	}
	else
	{
		// init these to false
		for (int i=0;i<MAX_MAJOR_CIVS;i++)
		{
			m_pabPlayerMadeNoDiggingPromise[i] = false;
			m_pabPlayerBrokenNoDiggingPromise[i] = false;
			m_pabPlayerIgnoredNoDiggingPromise[i] = false;
			m_pabPlayerAskedNotToDig[i] = false;
			m_pabPlayerAgreedNotToDig[i] = false;
		}
	}

	ArrayWrapper<bool> wrapm_pabPlayerBrokenCoopWarPromise(MAX_MAJOR_CIVS, m_pabPlayerBrokenCoopWarPromise);
	kStream >> wrapm_pabPlayerBrokenCoopWarPromise;


	kStream >> m_eDemandTargetPlayer;
	kStream >> m_bDemandReady;

	kStream >> m_iVictoryCompetitiveness;
	kStream >> m_iWonderCompetitiveness;
	kStream >> m_iMinorCivCompetitiveness;
	kStream >> m_iBoldness;
	kStream >> m_iDiploBalance;
	kStream >> m_iWarmongerHate;
	kStream >> m_iDenounceWillingness;
	kStream >> m_iDoFWillingness;

	kStream >> m_iLoyalty;
	kStream >> m_iNeediness;
	kStream >> m_iForgiveness;
	kStream >> m_iChattiness;
	kStream >> m_iMeanness;

	ArrayWrapper<char> wrapm_paiPersonalityMajorCivApproachBiases(NUM_MAJOR_CIV_APPROACHES, m_paiPersonalityMajorCivApproachBiases);
	kStream >> wrapm_paiPersonalityMajorCivApproachBiases;

	ArrayWrapper<char> wrapm_paiPersonalityMinorCivApproachBiases(NUM_MINOR_CIV_APPROACHES, m_paiPersonalityMinorCivApproachBiases);
	kStream >> wrapm_paiPersonalityMinorCivApproachBiases;

	ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceAttackedProtectedMinor(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceAttackedProtectedMinor);
	kStream >> wrapm_paiOtherPlayerTurnsSinceAttackedProtectedMinor;

	ArrayWrapper<char> wrapm_paiOtherPlayerProtectedMinorAttacked(MAX_MAJOR_CIVS, m_paiOtherPlayerProtectedMinorAttacked);
	kStream >> wrapm_paiOtherPlayerProtectedMinorAttacked;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumProtectedMinorsAttacked(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsAttacked);
	kStream >> wrapm_paiOtherPlayerNumProtectedMinorsAttacked;

	ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceKilledProtectedMinor(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceKilledProtectedMinor);
	kStream >> wrapm_paiOtherPlayerTurnsSinceKilledProtectedMinor;

	ArrayWrapper<char> wrapm_paiOtherPlayerProtectedMinorKilled(MAX_MAJOR_CIVS, m_paiOtherPlayerProtectedMinorKilled);
	kStream >> wrapm_paiOtherPlayerProtectedMinorKilled;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumProtectedMinorsKilled(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsKilled);
	kStream >> wrapm_paiOtherPlayerNumProtectedMinorsKilled;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumProtectedMinorsBullied(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsBullied);
	kStream >> wrapm_paiOtherPlayerNumProtectedMinorsBullied;

	ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor);
	kStream >> wrapm_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumMinorsAttacked(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMinorsAttacked);
	kStream >> wrapm_paiOtherPlayerNumMinorsAttacked;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumMinorsConquered(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMinorsConquered);
	kStream >> wrapm_paiOtherPlayerNumMinorsConquered;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumMajorsAttacked(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMajorsAttacked);
	kStream >> wrapm_paiOtherPlayerNumMajorsAttacked;

	ArrayWrapper<char> wrapm_paiOtherPlayerNumMajorsConquered(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMajorsConquered);
	kStream >> wrapm_paiOtherPlayerNumMajorsConquered;
#if defined(MOD_API_EXTENSIONS)
	ArrayWrapper<char> wrapm_paiTheyPlottedAgainstUs(MAX_MAJOR_CIVS, m_paiTheyPlottedAgainstUs);
	kStream >> wrapm_paiTheyPlottedAgainstUs;

	ArrayWrapper<char> wrapm_paiTheyLoweredOurInfluence(MAX_MAJOR_CIVS, m_paiTheyLoweredOurInfluence);
	kStream >> wrapm_paiTheyLoweredOurInfluence;
#else
	ArrayWrapper<int> wrapm_paiOtherPlayerWarmongerAmount(MAX_MAJOR_CIVS, m_paiOtherPlayerWarmongerAmount);
	kStream >> wrapm_paiOtherPlayerWarmongerAmount;
#endif

	if (uiVersion >= 3)
	{
		ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceWeLikedTheirProposal(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceWeLikedTheirProposal);
		kStream >> wrapm_paiOtherPlayerTurnsSinceWeLikedTheirProposal;

		ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceWeDislikedTheirProposal(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal);
		kStream >> wrapm_paiOtherPlayerTurnsSinceWeDislikedTheirProposal;

		ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceTheySupportedOurProposal(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheySupportedOurProposal);
		kStream >> wrapm_paiOtherPlayerTurnsSinceTheySupportedOurProposal;

		ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceTheyFoiledOurProposal(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal);
		kStream >> wrapm_paiOtherPlayerTurnsSinceTheyFoiledOurProposal;

		ArrayWrapper<short> wrapm_paiOtherPlayerTurnsSinceTheySupportedOurHosting(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheySupportedOurHosting);
		kStream >> wrapm_paiOtherPlayerTurnsSinceTheySupportedOurHosting;
	}
	else
	{
		for (uint i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			m_paiOtherPlayerTurnsSinceWeLikedTheirProposal[i] = -1;
			m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal[i] = -1;
			m_paiOtherPlayerTurnsSinceTheySupportedOurProposal[i] = -1;
			m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal[i] = -1;
			m_paiOtherPlayerTurnsSinceTheySupportedOurHosting[i] = -1;
		}
	}

	ArrayWrapper<short> wrapm_paiNumCitiesLiberated(MAX_MAJOR_CIVS, m_paiNumCitiesLiberated);
	kStream >> wrapm_paiNumCitiesLiberated;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_pabShareOpinionAccepted, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiShareOpinionCounter, short, MAX_MAJOR_CIVS, -1);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiHelpRequestCounter, short, MAX_MAJOR_CIVS, -1);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiHelpRequestTooSoonNumTurns, short, MAX_MAJOR_CIVS, -1);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiPlayerVassalageFailedProtectValue, short, MAX_MAJOR_CIVS, 0);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiPlayerVassalageProtectValue, short, MAX_MAJOR_CIVS, 0);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_pabPlayerVassalagePeacefullyRevokedVassal, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_pabPlayerVassalageForcefullyRevokedVassal, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage, short, MAX_MAJOR_CIVS, -1);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage, short, MAX_MAJOR_CIVS, -1);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiNumTimesDemandedWhenVassal, short, MAX_MAJOR_CIVS, 0);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_pabPlayerBrokenVassalAgreement, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_pabMoveTroopsRequestAccepted, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(36, kStream, m_paiMoveTroopsRequestCounter, short, MAX_MAJOR_CIVS, -1);

	MOD_SERIALIZE_READ_ARRAY(73, kStream, m_pabMasterLiberatedMeFromVassalage, bool, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(73, kStream, m_pabVassalTaxRaised, bool, MAX_MAJOR_CIVS, 0);
	MOD_SERIALIZE_READ_ARRAY(73, kStream, m_pabVassalTaxLowered, bool, MAX_MAJOR_CIVS, 0);

	MOD_SERIALIZE_READ_ARRAY(73, kStream, m_paiVassalGoldPerTurnTaxedSinceVassalStarted, int, MAX_MAJOR_CIVS, false);
	MOD_SERIALIZE_READ_ARRAY(73, kStream, m_paiVassalGoldPerTurnCollectedSinceVassalStarted, int, MAX_MAJOR_CIVS, false);

	ArrayWrapper<bool> wrapm_pabOfferingGift(MAX_MAJOR_CIVS, m_pabOfferingGift);
	kStream >> wrapm_pabOfferingGift;

	ArrayWrapper<bool> wrapm_pabOfferedGift(MAX_MAJOR_CIVS, m_pabOfferedGift);
	kStream >> wrapm_pabOfferedGift;
#endif
#if defined(MOD_BALANCE_CORE)

	ArrayWrapper<bool> wrapm_pabWantsDefensivePactWithPlayer(MAX_MAJOR_CIVS, m_pabWantsDefensivePactWithPlayer);
	kStream >> wrapm_pabWantsDefensivePactWithPlayer;
	
	ArrayWrapper<bool> wrapm_pabWantsSneakAttack(MAX_MAJOR_CIVS, m_pabWantsSneakAttack);
	kStream >> wrapm_pabWantsSneakAttack;

	ArrayWrapper<short> wrapm_paiPlayerNumTurnsAtPeace(MAX_CIV_PLAYERS, m_paiPlayerNumTurnsAtPeace);
	kStream >> wrapm_paiPlayerNumTurnsAtPeace;

	ArrayWrapper<short> wrapm_paiPlayerNumTurnsSinceCityCapture (MAX_CIV_PLAYERS, m_paiPlayerNumTurnsSinceCityCapture );
	kStream >> wrapm_paiPlayerNumTurnsSinceCityCapture;

	ArrayWrapper<char> wrapm_paePlayerVictoryBlockLevel(MAX_MAJOR_CIVS, m_paePlayerVictoryBlockLevel);
	kStream >> wrapm_paePlayerVictoryBlockLevel;

	ArrayWrapper<bool> wrapm_pabCantMatchDeal(MAX_MAJOR_CIVS, m_pabCantMatchDeal);
	kStream >> wrapm_pabCantMatchDeal;

	ArrayWrapper<char> wrapm_paeDoFType(MAX_MAJOR_CIVS, m_paeDoFType);
	kStream >> wrapm_paeDoFType;

	ArrayWrapper<short> wrapm_paiNumTimesCoopWarDenied(MAX_MAJOR_CIVS, m_paiNumTimesCoopWarDenied);
	kStream >> wrapm_paiNumTimesCoopWarDenied;

	ArrayWrapper<pair<int,int>> wrapm_paiNoExpansionPromise(MAX_MAJOR_CIVS, m_paNoExpansionPromise);
	kStream >> wrapm_paiNoExpansionPromise;

	ArrayWrapper<pair<int,int>> wrapm_paiLastTurnEmpireDistance(MAX_MAJOR_CIVS, m_paLastTurnEmpireDistance);
	kStream >> wrapm_paiLastTurnEmpireDistance;

	ArrayWrapper<bool> wrapm_pabDoFBroken(MAX_MAJOR_CIVS, m_pabDoFBroken);
	kStream >> wrapm_pabDoFBroken;
	
	ArrayWrapper<short> wrapm_paiNumTimesRazed(MAX_CIV_PLAYERS, m_paiNumTimesRazed);
	kStream >> wrapm_paiNumTimesRazed;

	ArrayWrapper<bool> wrapm_pabPlayerEverMadeBorderPromise(MAX_MAJOR_CIVS, m_pabPlayerEverMadeBorderPromise);
	kStream >> wrapm_pabPlayerEverMadeBorderPromise; 

	ArrayWrapper<bool> wrapm_pabPlayerEverMadeExpansionPromise(MAX_MAJOR_CIVS, m_pabPlayerEverMadeExpansionPromise);
	kStream >> wrapm_pabPlayerEverMadeExpansionPromise; 

	ArrayWrapper<bool> wrapm_pabDoFEverAsked(MAX_MAJOR_CIVS, m_pabDoFEverAsked);
	kStream >> wrapm_pabDoFEverAsked; 

	ArrayWrapper<bool> wrapm_pabHelpRequestEverMade(MAX_MAJOR_CIVS, m_pabHelpRequestEverMade);
	kStream >> wrapm_pabHelpRequestEverMade; 

	ArrayWrapper<int> wrapm_paiDemandEverMade(MAX_MAJOR_CIVS, m_paiDemandEverMade);
	kStream >> wrapm_paiDemandEverMade; 

	ArrayWrapper<bool> wrapm_pabPlayerNoSettleRequestEverAsked(MAX_MAJOR_CIVS, m_pabPlayerNoSettleRequestEverAsked);
	kStream >> wrapm_pabPlayerNoSettleRequestEverAsked; 

	ArrayWrapper<bool> wrapm_pabPlayerStopSpyingRequestEverAsked(MAX_MAJOR_CIVS, m_pabPlayerStopSpyingRequestEverAsked);
	kStream >> wrapm_pabPlayerStopSpyingRequestEverAsked; 

	ArrayWrapper<short> wrapm_paiNumLandmarksBuiltForMeTurn(MAX_MAJOR_CIVS, m_paiNumLandmarksBuiltForMeTurn);
	kStream >> wrapm_paiNumLandmarksBuiltForMeTurn; 

	ArrayWrapper<short> wrapm_paiCiviliansReturnedToMeTurn(MAX_MAJOR_CIVS, m_paiCiviliansReturnedToMeTurn);
	kStream >> wrapm_paiCiviliansReturnedToMeTurn; 

	ArrayWrapper<short> wrapm_paiWarDamageValue(MAX_MAJOR_CIVS, m_paiWarDamageValue);
	kStream >> wrapm_paiWarDamageValue;

	ArrayWrapper<short> wrapm_paiPlayerForgaveForSpyingTurn(MAX_MAJOR_CIVS, m_paiPlayerForgaveForSpyingTurn);
	kStream >> wrapm_paiPlayerForgaveForSpyingTurn; 

	ArrayWrapper<short> wrapm_paiLiberatedCitiesTurn(MAX_MAJOR_CIVS, m_paiLiberatedCitiesTurn);
	kStream >> wrapm_paiLiberatedCitiesTurn; 

	ArrayWrapper<short> wrapm_paiIntrigueSharedTurn(MAX_MAJOR_CIVS, m_paiIntrigueSharedTurn);
	kStream >> wrapm_paiIntrigueSharedTurn; 

	ArrayWrapper<short> wrapm_paiReligiousConversionTurn(MAX_MAJOR_CIVS, m_paiReligiousConversionTurn);
	kStream >> wrapm_paiReligiousConversionTurn; 

	ArrayWrapper<short> wrapm_paiTimesRobbedTurn(MAX_MAJOR_CIVS, m_paiTimesRobbedTurn);
	kStream >> wrapm_paiTimesRobbedTurn;
#endif
#if defined(MOD_API_EXTENSIONS)
	ArrayWrapper<int> wrapm_paiOtherPlayerWarmongerAmount(MAX_MAJOR_CIVS, m_paiOtherPlayerWarmongerAmountTimes100);
	kStream >> wrapm_paiOtherPlayerWarmongerAmount;

	if (uiDllSaveVersion < 63)
	{
		// Convert pre-v63 saves by multipling by 100
		for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
		{
			m_paiOtherPlayerWarmongerAmountTimes100[iPlayer] = m_paiOtherPlayerWarmongerAmountTimes100[iPlayer] * 100;
		}
	}
#endif

	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		ArrayWrapper<DiploLogData> wrapm_ppaDiploStatementsLog(MAX_DIPLO_LOG_STATEMENTS, m_ppaDiploStatementsLog[iI]);
		kStream >> wrapm_ppaDiploStatementsLog;
	}

	ArrayWrapper<DeclarationLogData> wrapm_paDeclarationsLog(MAX_DIPLO_LOG_STATEMENTS, m_paDeclarationsLog);
	kStream >> wrapm_paDeclarationsLog;
	kStream >> m_eStateAllWars;
}

/// Serialization write
void CvDiplomacyAI::Write(FDataStream& kStream) const
{
	// Current version number
	uint uiVersion = 4;
	kStream << uiVersion;
	MOD_SERIALIZE_INIT_WRITE(kStream);

	int iI;

	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paeMajorCivOpinion);

	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_ppaaeOtherPlayerMajorCivOpinion[iI]);
		kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_ppaabWorkingAgainstPlayerAccepted[iI]);
		kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_ppaaiWorkingAgainstPlayerCounter[iI]);
		kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_ppaacCoopWarAcceptedState[iI]);
		kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_ppaaiCoopWarCounter[iI]);
	}

	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paeMajorCivApproach);
	kStream << ArrayWrapper<char>(MAX_MINOR_CIVS, m_paeMinorCivApproach);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paeApproachTowardsUsGuess);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paeApproachTowardsUsGuessCounter);

	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiNumWondersBeatenTo);
	kStream << ArrayWrapper<bool>(MAX_CIV_PLAYERS, m_pabArmyInPlaceForAttack);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabWantsResearchAgreementWithPlayer);
	kStream << ArrayWrapper<bool>(MAX_MINOR_CIVS, m_pabWantToRouteToMinor);

	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paeWantPeaceCounter);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paePeaceTreatyWillingToOffer);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paePeaceTreatyWillingToAccept);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarFace);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarState);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarProjection);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeLastWarProjection);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarGoal);
	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiPlayerNumTurnsAtWar);
	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiNumWarsFought);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerMilitaryStrengthComparedToUs);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerEconomicStrengthComparedToUs);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerTargetValue);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerLandDisputeLevel);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerLastTurnLandDisputeLevel);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerVictoryDisputeLevel);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerWonderDisputeLevel);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlayerMinorCivDisputeLevel);

	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerLandDisputeLevel[iI]);
		kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerVictoryDisputeLevel[iI]);

		kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerWarDamageLevel[iI]);
		kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_ppaaiOtherPlayerWarValueLost[iI]);

		kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_ppaaeOtherPlayerMilitaryThreat[iI]);
	}

	// Added in Version 29
	for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_ppaaiOtherPlayerLastRoundWarValueLost[iI]);
		kStream << ArrayWrapper<bool>(MAX_CIV_PLAYERS, m_ppaabSentAttackMessageToMinorCivProtector[iI]);
	}

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarDamageLevel);
	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paiWarValueLost);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeMilitaryAggressivePosture);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryAggressivePosture);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeExpansionAggressivePosture);
	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paePlotBuyingAggressivePosture);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeMilitaryThreat);

	kStream << ArrayWrapper<char>(MAX_CIV_PLAYERS, m_paeWarmongerThreat);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerNoSettleRequestAccepted);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerNoSettleRequestCounter);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerStopSpyingRequestAccepted);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerStopSpyingRequestCounter);

#if defined(MOD_BALANCE_CORE)
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerBackstabCounter);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDefensivePactValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDoFValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiCompetitorValue);
#endif

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDemandCounter);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDemandTooSoonNumTurns);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabDoFAccepted);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDoFCounter);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabDenouncedPlayer);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabFriendDenouncedUs);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDenouncedPlayerCounter);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabFriendDeclaredWarOnUs);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumRequestsRefused);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumCiviliansReturnedToMe);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumLandmarksBuiltForMe);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiResurrectedOnTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumTimesCultureBombed);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNegativeReligiousConversionPoints);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNegativeArchaeologyPoints);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumTimesNuked);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumTimesRobbedBy);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumTimesIntrigueSharedBy);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiBrokenExpansionPromiseValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiIgnoredExpansionPromiseValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiBrokenBorderPromiseValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiIgnoredBorderPromiseValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiDeclaredWarOnFriendValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiTradeValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiCommonFoeValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiAssistValue);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeMilitaryPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenMilitaryPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredMilitaryPromise);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerMilitaryPromiseCounter);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerMadeExpansionPromiseTurn);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenExpansionPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredExpansionPromise);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paePlayerExpansionPromiseData);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerMadeBorderPromiseTurn);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenBorderPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredBorderPromise);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paePlayerBorderPromiseData);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeAttackCityStatePromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenAttackCityStatePromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredAttackCityStatePromise);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeBullyCityStatePromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenBullyCityStatePromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredBullyCityStatePromise);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeSpyPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenSpyPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredSpyPromise);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerForgaveForSpying);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeNoConvertPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenNoConvertPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredNoConvertPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerAskedNotToConvert);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerAgreedNotToConvert);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerMadeNoDiggingPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenNoDiggingPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerIgnoredNoDiggingPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerAskedNotToDig);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerAgreedNotToDig);

	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerBrokenCoopWarPromise);

	kStream << m_eDemandTargetPlayer;
	kStream << m_bDemandReady;

	kStream << m_iVictoryCompetitiveness;
	kStream << m_iWonderCompetitiveness;
	kStream << m_iMinorCivCompetitiveness;
	kStream << m_iBoldness;
	kStream << m_iDiploBalance;
	kStream << m_iWarmongerHate;
	kStream << m_iDenounceWillingness;
	kStream << m_iDoFWillingness;
	kStream << m_iLoyalty;
	kStream << m_iNeediness;
	kStream << m_iForgiveness;
	kStream << m_iChattiness;
	kStream << m_iMeanness;

	kStream << ArrayWrapper<char>(NUM_MAJOR_CIV_APPROACHES, m_paiPersonalityMajorCivApproachBiases);
	kStream << ArrayWrapper<char>(NUM_MINOR_CIV_APPROACHES, m_paiPersonalityMinorCivApproachBiases);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceAttackedProtectedMinor);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerProtectedMinorAttacked);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsAttacked);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceKilledProtectedMinor);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerProtectedMinorKilled);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsKilled);

	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumProtectedMinorsBullied);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor);

	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMinorsAttacked);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMinorsConquered);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMajorsAttacked);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiOtherPlayerNumMajorsConquered);
#if defined(MOD_API_EXTENSIONS)
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiTheyPlottedAgainstUs);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paiTheyLoweredOurInfluence);
#else
	kStream << ArrayWrapper<int>(MAX_MAJOR_CIVS, m_paiOtherPlayerWarmongerAmount);
#endif

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceWeLikedTheirProposal);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheySupportedOurProposal);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiOtherPlayerTurnsSinceTheySupportedOurHosting);

	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumCitiesLiberated);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabShareOpinionAccepted, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiShareOpinionCounter, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiHelpRequestCounter, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiHelpRequestTooSoonNumTurns, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiPlayerVassalageFailedProtectValue, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiPlayerVassalageProtectValue, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabPlayerVassalagePeacefullyRevokedVassal, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabPlayerVassalageForcefullyRevokedVassal, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiNumTimesDemandedWhenVassal, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabPlayerBrokenVassalAgreement, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabMoveTroopsRequestAccepted, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiMoveTroopsRequestCounter, short, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabMasterLiberatedMeFromVassalage, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabVassalTaxRaised, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_pabVassalTaxLowered, bool, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiVassalGoldPerTurnTaxedSinceVassalStarted, int, MAX_MAJOR_CIVS);
	MOD_SERIALIZE_WRITE_ARRAY(kStream, m_paiVassalGoldPerTurnCollectedSinceVassalStarted, int, MAX_MAJOR_CIVS);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabOfferingGift);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabOfferedGift);
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabWantsDefensivePactWithPlayer);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabWantsSneakAttack);
	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiPlayerNumTurnsAtPeace);
	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiPlayerNumTurnsSinceCityCapture );
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paePlayerVictoryBlockLevel);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabCantMatchDeal);
	kStream << ArrayWrapper<char>(MAX_MAJOR_CIVS, m_paeDoFType);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumTimesCoopWarDenied);
	kStream << ArrayWrapper<pair<int,int>>(MAX_MAJOR_CIVS, m_paNoExpansionPromise);
	kStream << ArrayWrapper<pair<int,int>>(MAX_MAJOR_CIVS, m_paLastTurnEmpireDistance);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabDoFBroken);
	kStream << ArrayWrapper<short>(MAX_CIV_PLAYERS, m_paiNumTimesRazed);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerEverMadeBorderPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerEverMadeExpansionPromise);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabDoFEverAsked);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabHelpRequestEverMade);
	kStream << ArrayWrapper<int>(MAX_MAJOR_CIVS, m_paiDemandEverMade);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerNoSettleRequestEverAsked);
	kStream << ArrayWrapper<bool>(MAX_MAJOR_CIVS, m_pabPlayerStopSpyingRequestEverAsked);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiNumLandmarksBuiltForMeTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiCiviliansReturnedToMeTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiWarDamageValue);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiPlayerForgaveForSpyingTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiLiberatedCitiesTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiIntrigueSharedTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiReligiousConversionTurn);
	kStream << ArrayWrapper<short>(MAX_MAJOR_CIVS, m_paiTimesRobbedTurn);
#endif
#if defined(MOD_API_EXTENSIONS)
	kStream << ArrayWrapper<int>(MAX_MAJOR_CIVS, m_paiOtherPlayerWarmongerAmountTimes100);
#endif
	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		kStream << ArrayWrapper<DiploLogData>(MAX_DIPLO_LOG_STATEMENTS, m_ppaDiploStatementsLog[iI]);
	}

	kStream << ArrayWrapper<DeclarationLogData>(MAX_DIPLO_LOG_STATEMENTS, m_paDeclarationsLog);
	kStream << m_eStateAllWars;
}

//	-----------------------------------------------------------------------------------------------
void CvDiplomacyAI::update()
{
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (!GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if(!m_aGreetPlayers.empty())
		{
			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
			// In out list?
			PlayerTypesArray::iterator itr = std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), eActivePlayer);
			if(itr != m_aGreetPlayers.end())
			{
				m_aGreetPlayers.erase(itr);

				const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_INTRO);
				if(szText)
				{
					CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), eActivePlayer, DIPLO_UI_STATE_DEFAULT_ROOT, szText, LEADERHEAD_ANIM_INTRO);
				}
			}
		}
	}
#endif
}
//	-----------------------------------------------------------------------------------------------
/// Returns the Player object this class is associated with
CvPlayer* CvDiplomacyAI::GetPlayer()
{
	return m_pPlayer;
}
const CvPlayer* CvDiplomacyAI::GetPlayer() const
{
	return m_pPlayer;
}
/// Returns the Team ID this AI's player is associated with
TeamTypes CvDiplomacyAI::GetTeam() const
{
	return m_pPlayer->getTeam();
}


/// Initializes Personality Members for this player (XML value + random element)
void CvDiplomacyAI::DoInitializePersonality()
{
	// AI Player
	if(!GetPlayer()->isHuman())
	{
		const CvLeaderHeadInfo& playerLeaderInfo = GetPlayer()->getLeaderInfo();

		m_iVictoryCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetVictoryCompetitiveness());
		CvAssertMsg(m_iVictoryCompetitiveness >= 0, "DIPLOMACY_AI: Victory Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iWonderCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetWonderCompetitiveness());
		CvAssertMsg(m_iWonderCompetitiveness >= 0, "DIPLOMACY_AI: Victory Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iMinorCivCompetitiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetMinorCivCompetitiveness());
		CvAssertMsg(m_iMinorCivCompetitiveness >= 0, "DIPLOMACY_AI: Minor Civ Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iBoldness = GetRandomPersonalityWeight(playerLeaderInfo.GetBoldness());
		CvAssertMsg(m_iBoldness >= 0, "DIPLOMACY_AI: Boldness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDiploBalance = GetRandomPersonalityWeight(playerLeaderInfo.GetDiploBalance());
		CvAssertMsg(m_iDiploBalance >= 0, "DIPLOMACY_AI: DiploBalance Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iWarmongerHate = GetRandomPersonalityWeight(playerLeaderInfo.GetWarmongerHate());
		CvAssertMsg(m_iWarmongerHate >= 0, "DIPLOMACY_AI: WarmongerHate Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDenounceWillingness = GetRandomPersonalityWeight(playerLeaderInfo.GetDenounceWillingness());
		CvAssertMsg(m_iDenounceWillingness >= 0, "DIPLOMACY_AI: DenounceWillingness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDoFWillingness = GetRandomPersonalityWeight(playerLeaderInfo.GetDoFWillingness());
		CvAssertMsg(m_iDoFWillingness >= 0, "DIPLOMACY_AI: DoFWillingness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iLoyalty = GetRandomPersonalityWeight(playerLeaderInfo.GetLoyalty());
		CvAssertMsg(m_iLoyalty >= 0, "DIPLOMACY_AI: Loyalty Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iNeediness = GetRandomPersonalityWeight(playerLeaderInfo.GetNeediness());
		CvAssertMsg(m_iNeediness >= 0, "DIPLOMACY_AI: Neediness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iForgiveness = GetRandomPersonalityWeight(playerLeaderInfo.GetForgiveness());
		CvAssertMsg(m_iForgiveness >= 0, "DIPLOMACY_AI: Forgiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iChattiness = GetRandomPersonalityWeight(playerLeaderInfo.GetChattiness());
		CvAssertMsg(m_iChattiness >= 0, "DIPLOMACY_AI: Chattiness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iMeanness = GetRandomPersonalityWeight(playerLeaderInfo.GetMeanness());
		CvAssertMsg(m_iMeanness >= 0, "DIPLOMACY_AI: Meanness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		for(int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_paiPersonalityMajorCivApproachBiases[iApproachLoop] = GetRandomPersonalityWeight(playerLeaderInfo.GetMajorCivApproachBias(iApproachLoop));
			CvAssertMsg(m_paiPersonalityMajorCivApproachBiases[iApproachLoop] >= 0, "DIPLOMACY_AI: Personality Approach weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
		}

		for(int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_paiPersonalityMinorCivApproachBiases[iApproachLoop] = GetRandomPersonalityWeight(playerLeaderInfo.GetMinorCivApproachBias(iApproachLoop));
			CvAssertMsg(m_paiPersonalityMinorCivApproachBiases[iApproachLoop] >= 0, "DIPLOMACY_AI: Personality Approach weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
		}
	}
	// Human player
	else
	{
		int iDefaultFlavorValue = GC.getDEFAULT_FLAVOR_VALUE();

		m_iVictoryCompetitiveness = iDefaultFlavorValue;
		CvAssertMsg(m_iVictoryCompetitiveness >= 0, "DIPLOMACY_AI: Victory Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iWonderCompetitiveness = iDefaultFlavorValue;
		CvAssertMsg(m_iWonderCompetitiveness >= 0, "DIPLOMACY_AI: Wonder Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iMinorCivCompetitiveness = iDefaultFlavorValue;
		CvAssertMsg(m_iMinorCivCompetitiveness >= 0, "DIPLOMACY_AI: Minor Civ Competitiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iBoldness = iDefaultFlavorValue;
		CvAssertMsg(m_iBoldness >= 0, "DIPLOMACY_AI: Boldness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDiploBalance = iDefaultFlavorValue;
		CvAssertMsg(m_iDiploBalance >= 0, "DIPLOMACY_AI: DiploBalance Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iWarmongerHate = iDefaultFlavorValue;
		CvAssertMsg(m_iWarmongerHate >= 0, "DIPLOMACY_AI: WarmongerHate Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDenounceWillingness = iDefaultFlavorValue;
		CvAssertMsg(m_iDenounceWillingness >= 0, "DIPLOMACY_AI: DenounceWillingness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iDoFWillingness = iDefaultFlavorValue;
		CvAssertMsg(m_iDoFWillingness >= 0, "DIPLOMACY_AI: DoFWillingness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iLoyalty = iDefaultFlavorValue;
		CvAssertMsg(m_iLoyalty >= 0, "DIPLOMACY_AI: Loyalty Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iNeediness = iDefaultFlavorValue;
		CvAssertMsg(m_iNeediness >= 0, "DIPLOMACY_AI: Neediness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iForgiveness = iDefaultFlavorValue;
		CvAssertMsg(m_iForgiveness >= 0, "DIPLOMACY_AI: Forgiveness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iChattiness = iDefaultFlavorValue;
		CvAssertMsg(m_iChattiness >= 0, "DIPLOMACY_AI: Chattiness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		m_iMeanness = iDefaultFlavorValue;
		CvAssertMsg(m_iMeanness >= 0, "DIPLOMACY_AI: Meanness Personality weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

		for(int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_paiPersonalityMajorCivApproachBiases[iApproachLoop] = iDefaultFlavorValue;
			CvAssertMsg(m_paiPersonalityMajorCivApproachBiases[iApproachLoop] >= 0, "DIPLOMACY_AI: Personality Approach weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
		}

		for(int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			m_paiPersonalityMinorCivApproachBiases[iApproachLoop] = iDefaultFlavorValue;
			CvAssertMsg(m_paiPersonalityMinorCivApproachBiases[iApproachLoop] >= 0, "DIPLOMACY_AI: Personality Approach weight is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
		}
	}

	LogPersonality();
}

/// Returns a personality weight with a small random element
int CvDiplomacyAI::GetRandomPersonalityWeight(int iOriginalValue) const
{
	int iMin = /*0*/ GC.getPERSONALITY_FLAVOR_MIN_VALUE();
	int iMax = /*20*/ GC.getPERSONALITY_FLAVOR_MAX_VALUE();
	int iPlusMinus = /*2*/ GC.getFLAVOR_RANDOMIZATION_RANGE();

	//maybe we should use the real RNG here? anyway include the player ID which should be somewhat random at least
	int iAdjust = GC.getGame().getSmallFakeRandNum((iPlusMinus * 2 + 1), iOriginalValue + GetPlayer()->GetID());
	int iRtnValue = iOriginalValue + iAdjust - iPlusMinus;

	//for stupid settings, try to make it so that we don't cluster at the extreme values
	if (iRtnValue < iMin)
		iRtnValue = iMin + ((iMin-iRtnValue) % (iMax-iMin));
	if (iRtnValue > iMax)
		iRtnValue = iMax - ((iRtnValue-iMax) % (iMax-iMin));

	//if that didn't help, clamp it down hard
	return range(iRtnValue,iMin,iMax);
}



// ************************************
// Actions/Tests
// ************************************



/// Runs every turn!  The order matters for a lot of this stuff, so be VERY careful about moving anything around (!)
void CvDiplomacyAI::DoTurn(DiplomacyPlayerType eTargetPlayer)
{
	m_eTargetPlayer = eTargetPlayer;
	// Military Stuff
	DoWarDamageDecay();
	DoUpdateWarDamageLevel();
	DoUpdatePlayerMilitaryStrengths();
	DoUpdatePlayerEconomicStrengths();

	DoUpdateWarmongerThreats();
	DoUpdateMilitaryThreats();
	DoUpdatePlayerTargetValues();
	DoUpdateWarStates();
	DoUpdateWarProjections();
	DoUpdateWarGoals();

	DoUpdatePeaceTreatyWillingness();

	// Issues of Dispute
	DoUpdateLandDisputeLevels();
	DoUpdateVictoryDisputeLevels();
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if(MOD_BALANCE_CORE_DIPLOMACY)
	{
		DoUpdateVictoryBlockLevels();
	}
#endif
	DoUpdateWonderDisputeLevels();
	DoUpdateMinorCivDisputeLevels();

	// Has any player gone back on any promises he made?
	DoTestPromises();

	// What we think other Players are up to
#if defined(MOD_BALANCE_CORE)
	DoUpdateOtherPlayerWarDamageLevel();
#endif
	DoUpdateEstimateOtherPlayerLandDisputeLevels();
	DoUpdateEstimateOtherPlayerVictoryDisputeLevels();
	DoUpdateEstimateOtherPlayerMilitaryThreats();
	DoEstimateOtherPlayerOpinions();
	LogOtherPlayerGuessStatus();

	// Look at the situation
	DoUpdateMilitaryAggressivePostures();
	DoUpdateExpansionAggressivePostures();
	DoUpdatePlotBuyingAggressivePosture();

	// Player Opinion & Approach
	DoUpdateApproachTowardsUsGuesses();

	DoUpdateOpinions();
	DoUpdateMajorCivApproaches();
	DoUpdateMinorCivApproaches();

#if defined(MOD_BALANCE_CORE)
	DoRelationshipPairing();
#endif
	// These functions actually DO things, and we don't want the shadow AI behind a human player doing things for him
	if(!GetPlayer()->isHuman())
	{
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if(MOD_DIPLOMACY_CIV4_FEATURES)
		{
			DoDetermineTaxRateForVassals();
		}
#endif
#if defined(MOD_BALANCE_CORE)
		DoUpdateDemands();
#endif
		MakeWar();
		DoMakePeaceWithMinors();
#if !defined(MOD_BALANCE_CORE)
		DoUpdateDemands();
#endif
		DoUpdatePlanningExchanges();
		DoContactMinorCivs();
		DoContactMajorCivs();
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			GC.getGame().GetGameDeals().DoCancelAllProposedMPDealsWithPlayer(GetPlayer()->GetID(), DIPLO_AI_PLAYERS);
		}
		else
		{
			GC.getGame().GetGameDeals().DoCancelAllProposedDealsWithPlayer(GetPlayer()->GetID());	//Proposed deals with AI players are purely transitional.
		}
#else
		GC.getGame().GetGameDeals().DoCancelAllProposedDealsWithPlayer(GetPlayer()->GetID());	//Proposed deals with AI players are purely transitional.
#endif
	}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if(MOD_DIPLOMACY_CIV4_FEATURES)
	{
		DoMakePeaceWithVassals();
		//DoUpdateGlobalStates();
	}
#endif

	// Update Counters
	DoCounters();

	// Save our current war value estimates, so we can compare them with the updated estimates next turn
	CacheOtherPlayerWarValuesLost();

	LogStatus();
	LogWarStatus();
	LogStatements();

	m_eTargetPlayer = DIPLO_ALL_PLAYERS;
}

/// Increment our turn counters
void CvDiplomacyAI::DoCounters()
{
	int iItem;
	DiploStatementTypes eStatement;
	PublicDeclarationTypes eDeclaration;

	PlayerTypes eThirdPlayer;
	int iThirdPlayerLoop;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			bool bAtWar = GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam());
			bool bPermaWar = false;
			bool bMultiplayer = false;
			
			if (GC.getGame().isNetworkMultiPlayer() || GC.getGame().isReallyNetworkMultiPlayer())
				bMultiplayer = true;
			
			if (bAtWar)
			{
				if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
					bPermaWar = true;
			}
			
			// War Counter
#if defined(MOD_BALANCE_CORE)
			if(bAtWar)
			{
				ChangePlayerNumTurnsAtWar(eLoopPlayer, 1);
				ChangePlayerNumTurnsSinceCityCapture(eLoopPlayer, 1);
				SetPlayerNumTurnsAtPeace(eLoopPlayer, 0);
			}
			else
			{
				SetPlayerNumTurnsAtWar(eLoopPlayer, 0);
				SetPlayerNumTurnsSinceCityCapture(eLoopPlayer, 0);
				ChangePlayerNumTurnsAtPeace(eLoopPlayer, 1);
			}
#else
			if(bAtWar)
				ChangePlayerNumTurnsAtWar(eLoopPlayer, 1);
			else if(GetPlayerNumTurnsAtWar(eLoopPlayer) > 0)
				SetPlayerNumTurnsAtWar(eLoopPlayer, 0);
#endif

			///////////////////////////////
			// Major Civs only!
			///////////////////////////////
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Trade value counter
				ChangeRecentTradeValue(eLoopPlayer, -GC.getDEAL_VALUE_PER_TURN_DECAY());
				ChangeCommonFoeValue(eLoopPlayer, -GC.getCOMMON_FOE_VALUE_PER_TURN_DECAY());
				if (GetRecentAssistValue(eLoopPlayer) > 0)
				{
					int iMin = MIN(GetRecentAssistValue(eLoopPlayer), GC.getDEAL_VALUE_PER_TURN_DECAY());
					ChangeRecentAssistValue(eLoopPlayer, -iMin);
				}
				else if (GetRecentAssistValue(eLoopPlayer) < 0)
				{
					int iMin = MIN(-GetRecentAssistValue(eLoopPlayer), GC.getDEAL_VALUE_PER_TURN_DECAY());
					ChangeRecentAssistValue(eLoopPlayer, iMin);
				}
				
				int iBrokenPromisePreValue = GetBrokenExpansionPromiseValue(eLoopPlayer);
				ChangeBrokenExpansionPromiseValue(eLoopPlayer, -GC.getEXPANSION_PROMISE_BROKEN_PER_TURN_DECAY());
				int iIgnoredPromisePreValue = GetIgnoredExpansionPromiseValue(eLoopPlayer);
				ChangeIgnoredExpansionPromiseValue(eLoopPlayer, -GC.getEXPANSION_PROMISE_IGNORED_PER_TURN_DECAY());

				// if the promise penalty of breaking a promise has expired, reset the ability to ask the promise again
				if ((iBrokenPromisePreValue != 0 && GetBrokenExpansionPromiseValue(eLoopPlayer) == 0 && GetIgnoredExpansionPromiseValue(eLoopPlayer) == 0) || 
					(iIgnoredPromisePreValue != 0 && GetIgnoredExpansionPromiseValue(eLoopPlayer) == 0 && GetBrokenExpansionPromiseValue(eLoopPlayer) == 0))
				{
					SetPlayerMadeExpansionPromise(eLoopPlayer, false);
					SetPlayerBrokenExpansionPromise(eLoopPlayer, false);
					SetPlayerIgnoredExpansionPromise(eLoopPlayer, false);
				}

				iBrokenPromisePreValue = GetBrokenBorderPromiseValue(eLoopPlayer);
				ChangeBrokenBorderPromiseValue(eLoopPlayer, -GC.getBORDER_PROMISE_BROKEN_PER_TURN_DECAY());
				iIgnoredPromisePreValue = GetIgnoredBorderPromiseValue(eLoopPlayer);
				ChangeIgnoredBorderPromiseValue(eLoopPlayer, -GC.getBORDER_PROMISE_IGNORED_PER_TURN_DECAY());

				// if the promise penalty of breaking a promise has expired, reset the ability to ask the promise again
				if ((iBrokenPromisePreValue != 0 && GetBrokenBorderPromiseValue(eLoopPlayer) == 0 && GetIgnoredBorderPromiseValue(eLoopPlayer) == 0) || 
					(iIgnoredPromisePreValue != 0 && GetIgnoredBorderPromiseValue(eLoopPlayer) == 0 && GetBrokenBorderPromiseValue(eLoopPlayer) == 0))
				{
					SetPlayerMadeBorderPromise(eLoopPlayer, false);
					SetPlayerBrokenBorderPromise(eLoopPlayer, false);
					SetPlayerIgnoredBorderPromise(eLoopPlayer, false);
				}
				
				int iNegativeDigPoints = GetNegativeArchaeologyPoints(eLoopPlayer);
				if (iNegativeDigPoints > 0)
				{
					if (bAtWar && !bPermaWar && !bMultiplayer && iNegativeDigPoints <= 10)
					{
						// Prevent AI forgetting about stolen artifacts without confronting the player about them
						if (IsPlayerMadeNoDiggingPromise(eLoopPlayer) || IsPlayerBrokenNoDiggingPromise(eLoopPlayer) || IsPlayerIgnoredNoDiggingPromise(eLoopPlayer))
						{
							ChangeNegativeArchaeologyPoints(eLoopPlayer, -1);
						}
					}
					else
					{
						ChangeNegativeArchaeologyPoints(eLoopPlayer, -1);
					}
				}

				ChangeDeclaredWarOnFriendValue(eLoopPlayer, -GC.getDECLARED_WAR_ON_FRIEND_PER_TURN_DECAY());

				// Diplo Statement Log Counter
				for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
				{
					eStatement = GetDiploLogStatementTypeForIndex(eLoopPlayer, iItem);

					if(eStatement != NO_DIPLO_STATEMENT_TYPE)
						ChangeDiploLogStatementTurnForIndex(eLoopPlayer, iItem, 1);
					else
						SetDiploLogStatementTurnForIndex(eLoopPlayer, iItem, 0);
				}

				// Attacked Protected Minor Counter
				if(GetOtherPlayerProtectedMinorAttacked(eLoopPlayer) != NO_PLAYER)
					ChangeOtherPlayerTurnsSinceAttackedProtectedMinor(eLoopPlayer, 1);

				// Killed Protected Minor Counter
				if(GetOtherPlayerProtectedMinorKilled(eLoopPlayer) != NO_PLAYER)
					ChangeOtherPlayerTurnsSinceKilledProtectedMinor(eLoopPlayer, 1);

				// They sided with their Protected Minor Counter
				if(IsOtherPlayerSidedWithProtectedMinor(eLoopPlayer))
					ChangeOtherPlayerTurnsSinceSidedWithProtectedMinor(eLoopPlayer, 1);

				// Did this player ask us not to settle near them?
				if(GetPlayerNoSettleRequestCounter(eLoopPlayer) > -1)
				{
					ChangePlayerNoSettleRequestCounter(eLoopPlayer, 1);

					if(GetPlayerNoSettleRequestCounter(eLoopPlayer) >= 50)
					{
						SetPlayerNoSettleRequestAccepted(eLoopPlayer, false);
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerMadeExpansionPromise(GetPlayer()->GetID(), false);
					}
#if defined(MOD_BALANCE_CORE)			
					if(GetPlayerNoSettleRequestCounter(eLoopPlayer) >= 100)
					{
						SetPlayerNoSettleRequestCounter(eLoopPlayer, -1);
						SetPlayerNoSettleRequestEverAsked(eLoopPlayer, false);
					}
#endif
					
				}

				// Did this player ask us to stop spying on them?
				if(GetPlayerStopSpyingRequestCounter(eLoopPlayer) > -1)
				{
					ChangePlayerStopSpyingRequestCounter(eLoopPlayer, 1);

					if(GetPlayerStopSpyingRequestCounter(eLoopPlayer) >= 50)
					{
						SetPlayerStopSpyingRequestAccepted(eLoopPlayer, false);
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerMadeSpyPromise(GetPlayer()->GetID(), false);
					}
#if defined(MOD_BALANCE_CORE)
					if(GetPlayerStopSpyingRequestCounter(eLoopPlayer) >= 100)
					{
						SetPlayerStopSpyingRequestCounter(eLoopPlayer, -1);
						SetPlayerStopSpyingRequestEverAsked(eLoopPlayer, false);
					}
#endif
				}
#if defined(MOD_BALANCE_CORE)
				//Is this player a backstabber?
				if(GetPlayerBackstabCounter(eLoopPlayer) > -1)
				{
					if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
					{
						ChangePlayerBackstabCounter(eLoopPlayer, 3);
					}
					else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_NEUTRAL)
					{
						ChangePlayerBackstabCounter(eLoopPlayer, 2);
					}
					else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_COMPETITOR)
					{
						ChangePlayerBackstabCounter(eLoopPlayer, 1);
					}
					else if(IsFriendDenouncedUs(eLoopPlayer))
					{
						ChangePlayerBackstabCounter(eLoopPlayer, 1);
					}		
					if(GetPlayerBackstabCounter(eLoopPlayer) >= 150)
					{
						SetPlayerBackstabCounter(eLoopPlayer, -666);
						if(IsPlayerBrokenMilitaryPromise(eLoopPlayer))
						{
							SetPlayerBrokenMilitaryPromise(eLoopPlayer, false);
						}
						if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsBrokenMilitaryPromise())
						{
							GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).SetBrokenMilitaryPromise(false);
						}
						if(IsPlayerBrokenAttackCityStatePromise(eLoopPlayer))
						{
							SetPlayerBrokenAttackCityStatePromise(eLoopPlayer, false);
						}
						if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsBrokenCityStatePromise())
						{
							GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).SetBrokenCityStatePromise(false);
						}
						if(IsPlayerBrokenAttackCityStatePromise(eLoopPlayer))
						{
							SetPlayerBrokenAttackCityStatePromise(eLoopPlayer, false);
						}
						if(IsPlayerBrokenBullyCityStatePromise(eLoopPlayer))
						{
							SetPlayerBrokenBullyCityStatePromise(eLoopPlayer, false);
						}
						if(IsPlayerBrokenSpyPromise(eLoopPlayer))
						{
							SetPlayerBrokenSpyPromise(eLoopPlayer, false);
						}
						if(IsPlayerBrokenNoConvertPromise(eLoopPlayer))
						{
							SetPlayerBrokenNoConvertPromise(eLoopPlayer, false);
						}
						if(IsPlayerBrokenNoDiggingPromise(eLoopPlayer))
						{
							SetPlayerBrokenNoDiggingPromise(eLoopPlayer, false);
						}
						if(IsPlayerBrokenCoopWarPromise(eLoopPlayer))
						{
							SetPlayerBrokenCoopWarPromise(eLoopPlayer, false);
						}
					}
				}		
#endif

				// World Congress mood counters
				if (GetTurnsSinceWeLikedTheirProposal(eLoopPlayer) > -1)
				{
					ChangeTurnsSinceWeLikedTheirProposal(eLoopPlayer, 1);
				}
				if (GetTurnsSinceWeDislikedTheirProposal(eLoopPlayer) > -1)
				{
					ChangeTurnsSinceWeDislikedTheirProposal(eLoopPlayer, 1);
				}
				if (GetTurnsSinceTheySupportedOurProposal(eLoopPlayer) > -1)
				{
					ChangeTurnsSinceTheySupportedOurProposal(eLoopPlayer, 1);
				}
				if (GetTurnsSinceTheyFoiledOurProposal(eLoopPlayer) > -1)
				{
					ChangeTurnsSinceTheyFoiledOurProposal(eLoopPlayer, 1);
				}
				if (GetTurnsSinceTheySupportedOurHosting(eLoopPlayer) > -1)
				{
					ChangeTurnsSinceTheySupportedOurHosting(eLoopPlayer, 1);
				}

				// Did this player make a demand of us?
				if(GetDemandCounter(eLoopPlayer) > -1)
					ChangeDemandCounter(eLoopPlayer, 1);

				// DoF?
				if(GetDoFCounter(eLoopPlayer) > -1)
					ChangeDoFCounter(eLoopPlayer, 1);

				// Denounced?
				if(GetDenouncedPlayerCounter(eLoopPlayer) > -1)
					ChangeDenouncedPlayerCounter(eLoopPlayer, 1);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				if (MOD_DIPLOMACY_CIV4_FEATURES) {
					// Shared Opinion?
					if(GetShareOpinionCounter(eLoopPlayer) > -1)
						ChangeShareOpinionCounter(eLoopPlayer, 1);

					// Agreed to move?
					if(GetPlayerMoveTroopsRequestCounter(eLoopPlayer) > -1)
						ChangePlayerMoveTroopsRequestCounter(eLoopPlayer, 1);
				}
#endif
#if defined(MOD_BALANCE_CORE)
				if(!IsAtWar(eLoopPlayer))
				{
					if(GetNumTimesRazed(eLoopPlayer) > 0)
					{
						if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FRIEND)
						{
							ChangeNumTimesRazed(eLoopPlayer, -10);
						}
						else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_NEUTRAL)
						{
							ChangeNumTimesRazed(eLoopPlayer, -5);
						}
						else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_COMPETITOR)
						{
							ChangeNumTimesRazed(eLoopPlayer, -3);
						}
						else
						{
							ChangeNumTimesRazed(eLoopPlayer, -1);
						}
					}
				}
#endif
				// Are we ready to forget our denunciation?
				if(IsDenouncedPlayer(eLoopPlayer) && GetDenouncedPlayerCounter(eLoopPlayer) >= GC.getGame().getGameSpeedInfo().getRelationshipDuration())
				{
					SetDenouncedPlayer(eLoopPlayer, false);
					SetDenouncedPlayerCounter(eLoopPlayer, -1);
					// Let's become open to becoming friends again
					SetDoFCounter(eLoopPlayer, -1);

					// They no longer hate us either
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), -1);
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetFriendDenouncedUs(GetPlayer()->GetID(), false);

					for(iThirdPlayerLoop = 0; iThirdPlayerLoop < MAX_MAJOR_CIVS; iThirdPlayerLoop++){
						eThirdPlayer = (PlayerTypes) iThirdPlayerLoop;

						// We may even do co-op wars in the future
						if(GetCoopWarCounter(eLoopPlayer, eThirdPlayer) < -1)
							SetCoopWarCounter(eLoopPlayer, eThirdPlayer, -1);
						GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarCounter(GetPlayer()->GetID(), eThirdPlayer, -1);
					}

					//Notify the target of the denouncement that it has expired.
					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if(pNotifications){
						CvString							strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_THEIR_DENUNCIATION_EXPIRED_S");
						Localization::String	strInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_THEIR_DENUNCIATION_EXPIRED");
						Localization::String strTemp = strInfo;
						strTemp << GET_PLAYER(GetPlayer()->GetID()).getCivilizationShortDescriptionKey();
						pNotifications->Add(NOTIFICATION_DENUNCIATION_EXPIRED, strTemp.toUTF8(), strSummary, -1, -1, GetPlayer()->GetID(), eLoopPlayer);
					}
				}

				// Has our Friendship expired?
				if (IsDoFAccepted(eLoopPlayer) && GetDoFCounter(eLoopPlayer) >= GC.getDOF_EXPIRATION_TIME())
				{
					SetDoFCounter(eLoopPlayer, -1);
					SetDoFAccepted(eLoopPlayer, false);

					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), -1);
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), false);

					//Notify both parties that our friendship has expired.
					CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotifications){
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED", GET_PLAYER(GetPlayer()->GetID()).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_FRIENDSHIP_EXPIRED, strBuffer, strSummary, -1, -1, GetPlayer()->GetID(), eLoopPlayer);				
					}

					pNotifications = GET_PLAYER(GetPlayer()->GetID()).GetNotifications();
					if (pNotifications){
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDSHIP_EXPIRED_S");
						pNotifications->Add(NOTIFICATION_FRIENDSHIP_EXPIRED, strBuffer, strSummary, -1, -1, eLoopPlayer, GetPlayer()->GetID());				
					}
				}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				if (MOD_DIPLOMACY_CIV4_FEATURES) {
					// Are we ready to forget we asked to move troops from borders?
					if(GetPlayerMoveTroopsRequestCounter(eLoopPlayer) >= 30)
					{
						SetPlayerMoveTroopsRequestAccepted(eLoopPlayer, false);
						SetPlayerMoveTroopsRequestCounter(eLoopPlayer, -1);
					}
				}
#endif
			}
		}
	}

	///////////////////////////////
	// Declaration Log Counter
	///////////////////////////////

	for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
	{
		eDeclaration = GetDeclarationLogTypeForIndex(iItem);

		if(eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
		{
			ChangeDeclarationLogTurnForIndex(iItem, 1);
		}
		else
		{
			SetDeclarationLogTurnForIndex(iItem, 0);
		}
	}

}



// ************************************
// Player Opinion & Approach
// ************************************



/// Determines our Diplomatic Opinions of all players we've met
void CvDiplomacyAI::DoUpdateOpinions()
{
	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		DoUpdateOnePlayerOpinion(eLoopPlayer);
	}
}

/// What is our basic opinion of the role a player has in our game?
void CvDiplomacyAI::DoUpdateOnePlayerOpinion(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(!IsPlayerValid(ePlayer))
		return;

	MajorCivOpinionTypes eOpinion;
	CvPlayer& kPlayerEvaluating = GET_PLAYER(ePlayer);

	// Teammates?
	if(GetPlayer()->getTeam() == kPlayerEvaluating.getTeam())
	{
		eOpinion = MAJOR_CIV_OPINION_ALLY;

#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH => calculate ai to human trade priority for multiplayer
			DoUpdateHumanTradePriority(ePlayer, GC.getOPINION_THRESHOLD_ALLY());
		}
#endif
	}
	// Different teams
	else
	{
		int iOpinionWeight = GetMajorCivOpinionWeight(ePlayer);

		if(iOpinionWeight >= /*150*/ GC.getOPINION_THRESHOLD_UNFORGIVABLE())
			eOpinion = MAJOR_CIV_OPINION_UNFORGIVABLE;
		else if(iOpinionWeight >= /*70*/ GC.getOPINION_THRESHOLD_ENEMY())
			eOpinion = MAJOR_CIV_OPINION_ENEMY;
		else if(iOpinionWeight >= /*20*/ GC.getOPINION_THRESHOLD_COMPETITOR())
			eOpinion = MAJOR_CIV_OPINION_COMPETITOR;
		else if(iOpinionWeight > /*-20*/ GC.getOPINION_THRESHOLD_FAVORABLE())
			eOpinion = MAJOR_CIV_OPINION_NEUTRAL;
		else if(iOpinionWeight > /*-70*/ GC.getOPINION_THRESHOLD_FRIEND())
			eOpinion = MAJOR_CIV_OPINION_FAVORABLE;
		else if(iOpinionWeight > /*-150*/ GC.getOPINION_THRESHOLD_ALLY())
			eOpinion = MAJOR_CIV_OPINION_FRIEND;
		else
			eOpinion = MAJOR_CIV_OPINION_ALLY;

		// If we've agreed to work against someone, then the worst we can feel towards this guy is enemy
		//if (IsWorkingAgainstPlayer(ePlayer) && eOpinion < MAJOR_CIV_OPINION_COMPETITOR)
		//	eOpinion = MAJOR_CIV_OPINION_COMPETITOR;

#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH => calculate ai to human trade priority for multiplayer
			DoUpdateHumanTradePriority(ePlayer, iOpinionWeight);
		}
#endif
	}

	// Finally, set the Opinion
	SetMajorCivOpinion(ePlayer, eOpinion);

	//LogOpinionUpdate(ePlayer, viOpinionWeights);
}

#if defined(MOD_ACTIVE_DIPLOMACY)
// JdH => calculate ai to human trade priority for multiplayer
void CvDiplomacyAI::DoUpdateHumanTradePriority(PlayerTypes ePlayer, int iOpinionWeight)
{
	if (m_pDiploData && ePlayer >= 0 && ePlayer < MAX_MAJOR_CIVS)
	{
		iOpinionWeight = max(iOpinionWeight, GC.getOPINION_THRESHOLD_ALLY());
		iOpinionWeight = min(iOpinionWeight, GC.getOPINION_THRESHOLD_UNFORGIVABLE());
		iOpinionWeight -= GC.getOPINION_THRESHOLD_UNFORGIVABLE(); // make it >= 0

		float opinion = iOpinionWeight / (float)(GC.getOPINION_THRESHOLD_ALLY() - GC.getOPINION_THRESHOLD_UNFORGIVABLE());

		int turnsPassed = GC.getGame().getGameTurn() - GetNumTurnsSinceSomethingSent(ePlayer);

		m_pDiploData->m_aTradePriority[ePlayer] = 10.0f * opinion + turnsPassed; // factor in turns since last contact and opinion of player
	}
}
#endif

/// What is the number value of our opinion towards ePlayer?
int CvDiplomacyAI::GetMajorCivOpinionWeight(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	//////////////////////////////////////
	// How nasty am I?
	//////////////////////////////////////

	iOpinionWeight += GetLandDisputeLevelScore(ePlayer);
	iOpinionWeight += GetWonderDisputeLevelScore(ePlayer);
	iOpinionWeight += GetMinorCivDisputeLevelScore(ePlayer);
	iOpinionWeight += GetWarmongerThreatScore(ePlayer);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if (MOD_BALANCE_CORE_DIPLOMACY)
	{
		iOpinionWeight += GetVictoryDisputeLevelScore(ePlayer);
		iOpinionWeight += GetVictoryBlockLevelScore(ePlayer);
		iOpinionWeight += (GetMilitaryAggressivePosture(ePlayer) * 5);
	}
#endif

	//////////////////////////////////////
	// Player has done nice stuff
	//////////////////////////////////////
	iOpinionWeight += GetCiviliansReturnedToMeScore(ePlayer);
	iOpinionWeight += GetLandmarksBuiltForMeScore(ePlayer);
	iOpinionWeight += GetResurrectedScore(ePlayer);
	iOpinionWeight += GetLiberatedCitiesScore(ePlayer);
	iOpinionWeight += GetEmbassyScore(ePlayer);
	iOpinionWeight += GetForgaveForSpyingScore(ePlayer);
	iOpinionWeight += GetTimesIntrigueSharedScore(ePlayer);

	//////////////////////////////////////
	// Player has asked us to do stuff we don't like
	//////////////////////////////////////
	iOpinionWeight += GetNoSetterRequestScore(ePlayer);
	iOpinionWeight += GetStopSpyingRequestScore(ePlayer);
	iOpinionWeight += GetDemandEverMadeScore(ePlayer);
	
	//////////////////////////////////////
	// Player stole from us
	//////////////////////////////////////
	iOpinionWeight += GetTimesCultureBombedScore(ePlayer);
	iOpinionWeight += GetTimesRobbedScore(ePlayer);
	iOpinionWeight += GetDugUpMyYardScore(ePlayer);

	//////////////////////////////////////
	// RELIGION/IDEOLOGY
	//////////////////////////////////////
	iOpinionWeight += GetHasAdoptedHisReligionScore(ePlayer);
	iOpinionWeight += GetHasAdoptedMyReligionScore(ePlayer);
	iOpinionWeight += GetReligiousConversionPointsScore(ePlayer);
	
#if defined(MOD_BALANCE_CORE)
	iOpinionWeight += GetPolicyScore(ePlayer);
#endif
	iOpinionWeight += GetSameLatePoliciesScore(ePlayer);
	iOpinionWeight += GetDifferentLatePoliciesScore(ePlayer);
	

	//////////////////////////////////////
	// BROKEN/IGNORED PROMISES ;_;
	//////////////////////////////////////
	iOpinionWeight += GetBrokenMilitaryPromiseScore(ePlayer);
	iOpinionWeight += GetBrokenMilitaryPromiseWithAnybodyScore(ePlayer);
	//iOpinionWeight += GetIgnoredMilitaryPromiseScore(ePlayer);
	
	iOpinionWeight += GetBrokenExpansionPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredExpansionPromiseScore(ePlayer);
	
	iOpinionWeight += GetBrokenBorderPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredBorderPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenAttackCityStatePromiseScore(ePlayer);
	//iOpinionWeight += GetBrokenAttackCityStatePromiseWithAnybodyScore(ePlayer);
	iOpinionWeight += GetIgnoredAttackCityStatePromiseScore(ePlayer);

	iOpinionWeight += GetBrokenBullyCityStatePromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredBullyCityStatePromiseScore(ePlayer);

	iOpinionWeight += GetBrokenNoConvertPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredNoConvertPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenNoDiggingPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredNoDiggingPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenSpyPromiseScore(ePlayer);
	iOpinionWeight += GetIgnoredSpyPromiseScore(ePlayer);

	iOpinionWeight += GetBrokenCoopWarPromiseScore(ePlayer);

	//////////////////////////////////////
	// PROTECTED MINORS
	//////////////////////////////////////
#if defined(MOD_BALANCE_CORE)
	iOpinionWeight += GetPtPSameCSScore(ePlayer);
#endif
	iOpinionWeight += GetAngryAboutProtectedMinorKilledScore(ePlayer);
	iOpinionWeight += GetAngryAboutProtectedMinorAttackedScore(ePlayer);
	iOpinionWeight += GetAngryAboutProtectedMinorBulliedScore(ePlayer);

	//////////////////////////////////////
	// BULLIED MINORS
	//////////////////////////////////////
	iOpinionWeight += GetAngryAboutSidedWithProtectedMinorScore(ePlayer);

	//////////////////////////////////////
	// DECLARATION OF FRIENDSHIP
	//////////////////////////////////////
	iOpinionWeight += GetDOFAcceptedScore(ePlayer);
	iOpinionWeight += GetDOFWithAnyFriendScore(ePlayer);
	iOpinionWeight += GetDOFWithAnyEnemyScore(ePlayer);

#if defined(MOD_BALANCE_CORE_DEALS)
	//////////////////////////////////////
	// RESEARCH AGREEMENT
	//////////////////////////////////////
	iOpinionWeight += GetResearchAgreementScore(ePlayer);

	//////////////////////////////////////
	// DEFENSIVE PACTS
	//////////////////////////////////////
	iOpinionWeight += GetDPAcceptedScore(ePlayer);
	iOpinionWeight += GetDPWithAnyFriendScore(ePlayer);
	iOpinionWeight += GetDPWithAnyEnemyScore(ePlayer);
	iOpinionWeight += GetOpenBordersScore(ePlayer);
#endif

	//////////////////////////////////////
	// FRIENDS NOT GETTING ALONG
	//////////////////////////////////////

	// Begin TraitorOpinion bit
	int iTraitorOpinion = GetFriendDenouncementScore(ePlayer);
	iTraitorOpinion = max(iTraitorOpinion, GetWeDenouncedFriendScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetFriendDenouncedUsScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetWeDeclaredWarOnFriendScore(ePlayer));
	iTraitorOpinion = max(iTraitorOpinion, GetFriendDeclaredWarOnUsScore(ePlayer));
	iOpinionWeight += iTraitorOpinion;
	// End TraitorOpinion bit

	//iOpinionWeight += GetRequestsRefusedScore(ePlayer);

	//////////////////////////////////////
	// DENOUNCING
	//////////////////////////////////////

	iOpinionWeight += GetDenouncedUsScore(ePlayer);
	iOpinionWeight += GetDenouncedThemScore(ePlayer);
	iOpinionWeight += GetDenouncedFriendScore(ePlayer);
	iOpinionWeight += GetDenouncedEnemyScore(ePlayer);

	//////////////////////////////////////
	// RECKLESS EXPANDER
	//////////////////////////////////////
	iOpinionWeight += GetRecklessExpanderScore(ePlayer);

	//////////////////////////////////////
	// JUNE 2011 ADDITIONS
	//////////////////////////////////////
	iOpinionWeight += GetRecentTradeScore(ePlayer);
	iOpinionWeight += GetCommonFoeScore(ePlayer);
	iOpinionWeight += GetRecentAssistScore(ePlayer);

	iOpinionWeight += GetNukedByScore(ePlayer);
	iOpinionWeight += GetCapitalCapturedByScore(ePlayer);
#if defined(MOD_BALANCE_CORE)
	iOpinionWeight += GetCitiesRazedScore(ePlayer);
	iOpinionWeight += GetCitiesRazedGlobalScore(ePlayer);
	iOpinionWeight += GetHolyCityCapturedByScore(ePlayer);
#endif

	//iOpinionWeight += GetTimesNukedScore(ePlayer); DUPLICATE of GetNukedScore above. Removing this from scoring.
	//iOpinionWeight += GetGaveAssistanceToScore(ePlayer);
	//iOpinionWeight += GetPaidTributeToScore(ePlayer);

	//////////////////////////////////////
	// XP2 - WORLD CONGRESS
	//////////////////////////////////////

	iOpinionWeight += GetLikedTheirProposalScore(ePlayer);
	iOpinionWeight += GetDislikedTheirProposalScore(ePlayer);
	iOpinionWeight += GetSupportedMyProposalScore(ePlayer);
	iOpinionWeight += GetFoiledMyProposalScore(ePlayer);
	iOpinionWeight += GetSupportedMyHostingScore(ePlayer);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	//////////////////////////////////////
	// VASSALAGE
	//////////////////////////////////////
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		iOpinionWeight += GetVassalScore(ePlayer);
		iOpinionWeight += GetVassalTreatedScore(ePlayer);
		iOpinionWeight += GetMasterScore(ePlayer);
		iOpinionWeight += GetTooManyVassalsScore(ePlayer);
		iOpinionWeight += GetSameMasterScore(ePlayer);
		iOpinionWeight += GetHappyAboutVassalagePeacefullyRevokedScore(ePlayer);
		iOpinionWeight += GetAngryAboutVassalageForcefullyRevokedScore(ePlayer);
		iOpinionWeight += GetBrokenVassalAgreementScore(ePlayer);
	}
#endif

	//////////////////////////////////////
	// SCENARIO-SPECIFIC
	//////////////////////////////////////
#if defined(MOD_EVENTS_DIPLO_MODIFIERS)
	if (MOD_EVENTS_DIPLO_MODIFIERS && !GC.getGame().isReallyNetworkMultiPlayer() && !GC.getGame().isNetworkMultiPlayer())
	{
		std::vector<Opinion> aOpinions;
		iOpinionWeight += GetDiploModifiers(ePlayer, aOpinions);
	}
#else
	iOpinionWeight += GetScenarioModifier1(ePlayer);
	iOpinionWeight += GetScenarioModifier2(ePlayer);
	iOpinionWeight += GetScenarioModifier3(ePlayer);
#endif

	return iOpinionWeight;
}

/// What is our Diplomatic Opinion of this Major Civ?
MajorCivOpinionTypes CvDiplomacyAI::GetMajorCivOpinion(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (MajorCivOpinionTypes) m_paeMajorCivOpinion[ePlayer];
}

/// Sets what our Diplomatic Opinion of a Major Civ is
void CvDiplomacyAI::SetMajorCivOpinion(PlayerTypes ePlayer, MajorCivOpinionTypes eOpinion)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOpinion >= 0, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOpinion < NUM_MAJOR_CIV_OPINION_TYPES, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeMajorCivOpinion[ePlayer] = eOpinion;
}

/// How many Majors do we have a particular Opinion towards?
int CvDiplomacyAI::GetNumMajorCivOpinion(MajorCivOpinionTypes eOpinion) const
{
	CvAssertMsg(eOpinion >= 0, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOpinion < NUM_MAJOR_CIV_OPINION_TYPES, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iCount = 0;

	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
	{
		if(GetMajorCivOpinion((PlayerTypes) iMajorLoop) == eOpinion)
		{
			iCount++;
		}
	}

	return iCount;
}


/// What is our guess as to other players' Opinions about everyone else?
void CvDiplomacyAI::DoEstimateOtherPlayerOpinions()
{
	MajorCivOpinionTypes eOpinion;
	int iOpinionWeight;

	PlayerTypes eLoopOtherPlayer;
	int iOtherPlayerLoop;
	
	int iLoopPlayerEra;
	int iLoopOtherPlayerEra;

	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			// Now loop through every player HE knows
			for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
			{
				eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

				// Don't compare a player to himself
				if(eLoopPlayer != eLoopOtherPlayer)
				{
					// Do both we and the guy we're looking at know the third guy?
					if(IsPlayerValid(eLoopOtherPlayer, true) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
					{
						iOpinionWeight = 0;
						iLoopPlayerEra = GET_PLAYER(eLoopPlayer).GetCurrentEra();
						iLoopOtherPlayerEra = GET_PLAYER(eLoopOtherPlayer).GetCurrentEra();
						
						//////////////////////////////////////
						// MODIFIERS FROM VISIBLE INFORMATION
						//////////////////////////////////////
						
						// Declaration of Friendship?
						if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopOtherPlayer))
							iOpinionWeight += /*-30*/ GC.getOPINION_WEIGHT_DOF();
					
					    // Defensive Pact?
						if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eLoopOtherPlayer).getTeam()))
							iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_DP();
						
						// Research Agreement?
						if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasResearchAgreement(GET_PLAYER(eLoopOtherPlayer).getTeam()))
						{
							iOpinionWeight += -5;
						}
						
						// Denounced them?
						if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopOtherPlayer))
							iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_THEM();
						
						// Denounced by them?
						if(GET_PLAYER(eLoopOtherPlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
							iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_ME();
						
						// Original capital captured by them?
						if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsCapitalCapturedBy(eLoopOtherPlayer))
							iOpinionWeight += /*80*/ GC.getOPINION_WEIGHT_CAPTURED_CAPITAL();
							
						// Ideologies?
						iOpinionWeight += GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetSameLatePoliciesScore(eLoopOtherPlayer);
						iOpinionWeight += GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetDifferentLatePoliciesScore(eLoopOtherPlayer);
						
#if defined(MOD_BALANCE_CORE)
						// Social Policies?
						int iNumPolicies = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumSamePolicies(eLoopOtherPlayer);
			
						// Flip it!
						iNumPolicies *= -1;
						
						// We can't know their neediness so assume the default
						if(iNumPolicies > 0)
						{
							iOpinionWeight += max(5, (iNumPolicies * 1));
						}
						else if(iNumPolicies < 0)
						{
							iOpinionWeight += min(-5, (iNumPolicies * 1));
						}
#endif
						
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
						if (MOD_DIPLOMACY_CIV4_FEATURES) 
						{
							// Master?
							if(GET_TEAM(GET_PLAYER(eLoopOtherPlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()))
							{
								iOpinionWeight += (-1 * /*20*/ GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_MASTER());
							}
							// Vassal?
							else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(eLoopOtherPlayer).getTeam()))
							{
								bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVoluntaryVassal(GET_PLAYER(eLoopOtherPlayer).getTeam());
								iOpinionWeight += bVoluntaryVassal ? GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VOLUNTARY_VASSAL() : GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VASSAL();
							}
						}
#endif
						
						// Global penalty for breaking a military promise?
						if(GET_TEAM(GET_PLAYER(eLoopOtherPlayer).getTeam()).IsBrokenMilitaryPromise())
							iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD();
						
						// Global penalty for breaking a City-State attack promise?
						// if(GET_TEAM(GET_PLAYER(eLoopOtherPlayer).getTeam()).IsBrokenCityStatePromise())
						//  	iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD();
						
						
						//////////////////////////////////////
						// DISPUTE ESTIMATES
						//////////////////////////////////////						
						
						// Estimate Land Dispute
						DisputeLevelTypes eEstimatedLandDisputeLevel = GetEstimateOtherPlayerLandDisputeLevel(eLoopPlayer, eLoopOtherPlayer);
						
						switch (eEstimatedLandDisputeLevel)
						{
						case DISPUTE_LEVEL_FIERCE:
							iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_LAND_FIERCE();
							break;
						case DISPUTE_LEVEL_STRONG:
							iOpinionWeight += /*25*/ GC.getOPINION_WEIGHT_LAND_STRONG();
							break;
						case DISPUTE_LEVEL_WEAK:
							iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_LAND_WEAK();
							break;
						case DISPUTE_LEVEL_NONE:
							iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_LAND_NONE();
							break;
						}
						
						if (eEstimatedLandDisputeLevel > DISPUTE_LEVEL_NONE)
						{
#if defined(MOD_BALANCE_CORE)
							if (GET_PLAYER(eLoopPlayer).GetPlayerTraits()->IsWarmonger())
							{
								iOpinionWeight += 10;
							}
#endif
							if (iLoopPlayerEra == 0)
							{
								iOpinionWeight += 10;
							}
							else if (iLoopPlayerEra == 1)
							{
								iOpinionWeight += 5;
							}
						}
						else if (eEstimatedLandDisputeLevel == DISPUTE_LEVEL_NONE)
						{
#if defined(MOD_BALANCE_CORE)
							if (GET_PLAYER(eLoopPlayer).GetPlayerTraits()->IsWarmonger())
							{
								iOpinionWeight -= 5;
							}
#endif
							if (iLoopPlayerEra <= 1)
							{
								iOpinionWeight -= 5;
							}
						}

						// Estimate Victory Competition Dispute
						switch(GetEstimateOtherPlayerVictoryDisputeLevel(eLoopPlayer, eLoopOtherPlayer))
						{
						case DISPUTE_LEVEL_FIERCE:
							iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_VICTORY_FIERCE();
							break;
						case DISPUTE_LEVEL_STRONG:
							iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_VICTORY_STRONG();
							break;
						case DISPUTE_LEVEL_WEAK:
							iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_VICTORY_WEAK();
							break;
						case DISPUTE_LEVEL_NONE:
							iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_VICTORY_NONE();
							break;
						}
						
						//////////////////////////////////////
						// FINAL ASSESSMENT
						//////////////////////////////////////
						
						if(iOpinionWeight >= /*150*/ GC.getOPINION_THRESHOLD_UNFORGIVABLE())
							eOpinion = MAJOR_CIV_OPINION_UNFORGIVABLE;
						else if(iOpinionWeight >= /*70*/ GC.getOPINION_THRESHOLD_ENEMY())
							eOpinion = MAJOR_CIV_OPINION_ENEMY;
						else if(iOpinionWeight >= /*20*/ GC.getOPINION_THRESHOLD_COMPETITOR())
							eOpinion = MAJOR_CIV_OPINION_COMPETITOR;
						else if(iOpinionWeight > /*-20*/ GC.getOPINION_THRESHOLD_FAVORABLE())
							eOpinion = MAJOR_CIV_OPINION_NEUTRAL;
						else if(iOpinionWeight > /*-70*/ GC.getOPINION_THRESHOLD_FRIEND())
							eOpinion = MAJOR_CIV_OPINION_FAVORABLE;
						else if(iOpinionWeight > /*-150*/ GC.getOPINION_THRESHOLD_ALLY())
							eOpinion = MAJOR_CIV_OPINION_FRIEND;
						else
							eOpinion = MAJOR_CIV_OPINION_ALLY;

						// Finally, set the Opinion
						SetMajorCivOtherPlayerOpinion(eLoopPlayer, eLoopOtherPlayer, eOpinion);
					}
				}
			}
		}
	}
}

/// What is our guess as to what a player's Diplomatic Opinion is of another player?
MajorCivOpinionTypes CvDiplomacyAI::GetMajorCivOtherPlayerOpinion(PlayerTypes ePlayer, PlayerTypes eWithPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (MajorCivOpinionTypes) m_ppaaeOtherPlayerMajorCivOpinion[ePlayer][eWithPlayer];
}

/// Sets what our guess is as to what a player's Diplomatic Opinion is of another player
void CvDiplomacyAI::SetMajorCivOtherPlayerOpinion(PlayerTypes ePlayer, PlayerTypes eWithPlayer, MajorCivOpinionTypes ePlayerOpinion)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayerOpinion >= 0, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayerOpinion < NUM_MAJOR_CIV_OPINION_TYPES, "DIPLOMACY_AI: Invalid MajorCivOpinionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaeOtherPlayerMajorCivOpinion[ePlayer][eWithPlayer] = ePlayerOpinion;
}


/// Determine our general Approach towards each player we've met
void CvDiplomacyAI::DoUpdateMajorCivApproaches()
{
	int iPlayerLoop;
	PlayerTypes eLoopPlayer;

	// Transfer Approaches from last turn to a separate array so we still have access to the info, then clear out the real one
	for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		m_paeApproachScratchPad[iPlayerLoop] = -1;

		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			m_paeApproachScratchPad[iPlayerLoop] = GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false);
			SetMajorCivApproach(eLoopPlayer, NO_MAJOR_CIV_APPROACH);
		}
	}

	int iHighestWeight;

	MajorCivOpinionTypes eOpinion;
	int iNumCivsWeHaveThisOpinionTowards;

	FStaticVector<PlayerTypes, NUM_MAJOR_CIV_OPINION_TYPES* MAX_MAJOR_CIVS, true, c_eCiv5GameplayDLL, 0> vePlayerApproachOrder;
	CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veTiedPlayerApproachWeights;
	int iTiedPlayerVectorIndex;

	int iNumCivsWereLookingAt = 0;

	bool bAssert;

	// Look at the players we feel are our biggest opponents first
	for(int iOpinionLoop = 0; iOpinionLoop < NUM_MAJOR_CIV_OPINION_TYPES; iOpinionLoop++)
	{
		eOpinion = (MajorCivOpinionTypes) iOpinionLoop;

		iNumCivsWeHaveThisOpinionTowards = GetNumMajorCivOpinion(eOpinion);

		if(iNumCivsWeHaveThisOpinionTowards > 0)
		{
			veTiedPlayerApproachWeights.clear();

			WarFaceTypes eWarFace;	// This is not used, but must be passed into GetBestApproachTowardsMajorCiv() below

			// Loop through all (known) Majors and determine the order of who we pick our Approach for first
			for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(IsPlayerValid(eLoopPlayer))
				{
					if(GetMajorCivOpinion(eLoopPlayer) == eOpinion)
					{
						// If there's only civ we feel this way about then there's no need to look at anything else
						if(iNumCivsWeHaveThisOpinionTowards == 1)
						{
							iNumCivsWereLookingAt++;
							vePlayerApproachOrder.push_back(eLoopPlayer);
							break;
						}
						// More than one other leader we feel this way about - have to rank them now
						else
						{
							// Just grab the highest weight for sorting later
							GetBestApproachTowardsMajorCiv(eLoopPlayer, /*Passed by Ref*/ iHighestWeight, /*bLookAtOtherPlayers*/ false, /*bLog*/ false, /*Passed by Ref, but we won't use it*/ eWarFace);
							veTiedPlayerApproachWeights.push_back(eLoopPlayer, iHighestWeight);
						}
					}
				}
			}

			// Order players
			if(iNumCivsWeHaveThisOpinionTowards > 1)
			{
				veTiedPlayerApproachWeights.SortItems();

				// Now add sorted players to the overall vector that we'll look at in the next code block
				for(iTiedPlayerVectorIndex = 0; iTiedPlayerVectorIndex < (int) veTiedPlayerApproachWeights.size(); iTiedPlayerVectorIndex++)
				{
					eLoopPlayer = (PlayerTypes) veTiedPlayerApproachWeights.GetElement(iTiedPlayerVectorIndex);

					// Assert for Release build!
					if(eLoopPlayer < 0 || eLoopPlayer >= MAX_CIV_PLAYERS)
					{
						bAssert = true;
						CvAssert(false);
					}

					iNumCivsWereLookingAt++;
					vePlayerApproachOrder.push_back(eLoopPlayer);
				}
			}
		}
	}

	// Assert for Release build!
	if(iNumCivsWereLookingAt != (int) vePlayerApproachOrder.size())
	{
		bAssert = true;
		CvAssert(false);
	}

	MajorCivApproachTypes eApproach;

	WarFaceTypes eWarFace;

	// Now that we have our order for who to decide Approaches for, actually decide now!
	for(int iPlayerVectorIndex = 0; iPlayerVectorIndex < (int) vePlayerApproachOrder.size(); iPlayerVectorIndex++)
	{
		eLoopPlayer = vePlayerApproachOrder[iPlayerVectorIndex];

		// See which Approach is best
		eApproach = GetBestApproachTowardsMajorCiv(eLoopPlayer, /*Passed by Ref, but we won't use it*/ iHighestWeight, /*bLookAtOtherPlayers*/ true, /*bLog*/ true, /*Passed by Ref, used below*/ eWarFace);

		// If we're going to war and we haven't picked a War Face yet choose one
		if(eApproach == MAJOR_CIV_APPROACH_WAR && GetWarFaceWithPlayer(eLoopPlayer) == NO_WAR_FACE_TYPE)
			SetWarFaceWithPlayer(eLoopPlayer, eWarFace);

		CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		// Actually assign the (possibly) new Approach
		SetMajorCivApproach(eLoopPlayer, eApproach);
	}
}

/// What is the best Approach to take towards a player?  Can also pass in iHighestWeight by reference if you just want to know what the player feels most strongly about without actually caring about WHAT it is
MajorCivApproachTypes CvDiplomacyAI::GetBestApproachTowardsMajorCiv(PlayerTypes ePlayer, int& iHighestWeight, bool bLookAtOtherPlayers, bool bLog, WarFaceTypes& eWarFace)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	MajorCivApproachTypes eApproach;
	// This vector is what we'll stuff the values into first, and pass it into our logging function (which can't take a CvWeightedVector, which we need to sort...)
	vector<int> viApproachWeights(NUM_MAJOR_CIV_APPROACHES, 0);

	////////////////////////////////////
	// CURRENT APPROACH BIASES
	////////////////////////////////////

	// Bias for our current Approach.  This should prevent it from jumping around from turn-to-turn as much
	// We use the scratch pad here since the normal array has been cleared so that we have knowledge of who we've already assigned an Approach for this turn; this should be the only place the scratch pad is used
	// Not used in VP except if previously planning a war/demand - replaced with a gradual change function using averages
	MajorCivApproachTypes eOldApproach = (MajorCivApproachTypes)m_paeApproachScratchPad[ePlayer];
	if (eOldApproach == NO_MAJOR_CIV_APPROACH)
		eOldApproach = MAJOR_CIV_APPROACH_NEUTRAL;

	vector<int> viApproachWeightsPersonality;
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		viApproachWeightsPersonality.push_back(GetPersonalityMajorCivApproachBias((MajorCivApproachTypes)iApproachLoop));
	}

	////////////////////////////////////
	// NEUTRAL DEFAULT WEIGHT
	////////////////////////////////////

	viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];

	// If we're planning a war then give it a bias so that we don't get away from it too easily
	if (eOldApproach == MAJOR_CIV_APPROACH_WAR && GetWarGoal(ePlayer) == WAR_GOAL_PREPARE)
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];

	// Same for demand
	if (eOldApproach == MAJOR_CIV_APPROACH_HOSTILE && GetWarGoal(ePlayer) == WAR_GOAL_DEMAND)
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];

	// Wanted war last turn bias
	WarStateTypes eWarState = GetWarState(ePlayer);

	// Conquest bias: must be a stalemate or better to apply (or not at war yet)
	if (eWarState == NO_WAR_STATE_TYPE || eWarState > WAR_STATE_DEFENSIVE)
	{
		if (IsGoingForWorldConquest())
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
	}
	
	// Do we want to wipe them off the planet?
	if (eOldApproach == MAJOR_CIV_APPROACH_WAR && GetWarGoal(ePlayer) == WAR_GOAL_CONQUEST)
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];

#if defined(MOD_DIPLOMACY_CITYSTATES) || defined(MOD_BALANCE_CORE)
	// If we were given a quest to go to war with this player, that should influence our decision. Plus, it probably means he's a total jerk.
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes)iMinorLoop;
		if (eMinor != NO_PLAYER)
		{
			CvPlayer* pMinor = &GET_PLAYER(eMinor);
			if (pMinor)
			{
				CvMinorCivAI* pMinorCivAI = pMinor->GetMinorCivAI();
				TeamTypes eConquerorTeam = GET_TEAM(pMinor->getTeam()).GetKilledByTeam();

				if (pMinorCivAI && pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_WAR))
				{
					if (pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_WAR) == ePlayer)
					{
						viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
						break;
					}
				}
				if (pMinorCivAI && pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_LIBERATION))
				{
					if (pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_LIBERATION) == eMinor)
					{
						if (eConquerorTeam == eTeam)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
							break;
						}
					}
				}
				if (pMinorCivAI && pMinorCivAI->IsActiveQuestForPlayer(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY))
				{
					int iX = pMinorCivAI->GetQuestData1(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY);
					int iY = pMinorCivAI->GetQuestData2(eMyPlayer, MINOR_CIV_QUEST_UNIT_GET_CITY);

					CvPlot* pPlot = GC.getMap().plot(iX, iY);
					if (pPlot != NULL && pPlot->isCity())
					{
						if (pPlot->getOwner() == ePlayer)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
							break;
						}
					}
				}
			}
		}
	}
	
	////////////////////////////////////
	// RESEARCH AGREEMENT
	////////////////////////////////////
	
	if (GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(ePlayer).getTeam()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
	}
#endif

	////////////////////////////////////
	// DECLARATION OF FRIENDSHIP
	////////////////////////////////////

	if (IsDoFAccepted(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
	}
	
	// Coop War Denied?
	if (GetNumTimesCoopWarDenied(ePlayer) > 0)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE] + GetNumTimesCoopWarDenied(ePlayer));
	}
	// Coop War Accepted?
	else if (GetNumTimesCoopWarDenied(ePlayer) < 0)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= GetNumTimesCoopWarDenied(ePlayer); // flip the sign
	}
	
	////////////////////////////////////
	// RESURRECTION
	////////////////////////////////////
	
	if (WasResurrectedBy(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
	}
	
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetPlayer()->GetID()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
	}

	////////////////////////////////////
	// DENOUNCEMENTS
	////////////////////////////////////

	// We denounced them
	if (IsDenouncedPlayer(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
	}

	// They denounced us
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eMyPlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
	}
	
	////////////////////////////////////
	// TRAITOR OPINION
	////////////////////////////////////
	
	// Do we think they're a good-for-nothing backstabber?!
	if (IsUntrustworthyFriend(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
		
		// Extra penalties if they betrayed us personally!
		if (IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer) || IsPlayerBrokenMilitaryPromise(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		}
	}
	
	// Are we angry about what they've done to our protected City-States?
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] + GetOtherPlayerNumProtectedMinorsKilled(ePlayer));
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] + GetOtherPlayerNumProtectedMinorsKilled(ePlayer));
	}
	else if (IsAngryAboutProtectedMinorAttacked(ePlayer) && (IsPlayerIgnoredAttackCityStatePromise(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer)))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] + GetOtherPlayerNumProtectedMinorsAttacked(ePlayer));
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] + GetOtherPlayerNumProtectedMinorsAttacked(ePlayer));
	}
	
	////////////////////////////////////
	// VENGEANCE! Grrrr....
	////////////////////////////////////
	
	bool bIsCapitulatedVassal = false;
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(ePlayer))
	{
		if (!GET_TEAM(m_pPlayer->getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam()))
		{
			bIsCapitulatedVassal = true;
		}
	}
#endif
	
	// Note: This is in addition to the weight from being an untrustworthy friend!
	if (IsCapitalCapturedBy(ePlayer) && !bIsCapitulatedVassal)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}
#if defined(MOD_BALANCE_CORE)
	if (IsHolyCityCapturedBy(ePlayer) && !bIsCapitulatedVassal)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}
#endif

	////////////////////////////////////
	// MILITARY THREAT
	////////////////////////////////////

	switch (GetMilitaryThreat(ePlayer))
	{
	case THREAT_CRITICAL:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case THREAT_SEVERE:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case THREAT_MAJOR:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case THREAT_MINOR:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case THREAT_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	}

	switch (GetWarmongerThreat(ePlayer))
	{
	case THREAT_CRITICAL:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	case THREAT_SEVERE:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	case THREAT_MAJOR:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case THREAT_MINOR:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case THREAT_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	}
	
	switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	case STRENGTH_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case STRENGTH_POOR:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case STRENGTH_AVERAGE:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case STRENGTH_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case STRENGTH_POWERFUL:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		break;
	case STRENGTH_IMMENSE:
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID] * 2;
		break;
	}
	
	switch (GetPlayerEconomicStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	case STRENGTH_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case STRENGTH_POOR:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case STRENGTH_AVERAGE:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case STRENGTH_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case STRENGTH_POWERFUL:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		break;
	case STRENGTH_IMMENSE:
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID] * 2;
		break;
	}
	
	// Weight for victory issues
	switch (GetVictoryDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case DISPUTE_LEVEL_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case DISPUTE_LEVEL_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case DISPUTE_LEVEL_FIERCE:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	}
	
	switch (GetVictoryBlockLevel(ePlayer))
	{
	case BLOCK_LEVEL_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case BLOCK_LEVEL_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case BLOCK_LEVEL_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case BLOCK_LEVEL_FIERCE:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	}

	// Weight for World Wonder competition
	switch (GetWonderDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case DISPUTE_LEVEL_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case DISPUTE_LEVEL_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case DISPUTE_LEVEL_FIERCE:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	}
	
	// Weight for City-State friendship dispute
	if (HasMetValidMinorCiv())
	{
		switch (GetMinorCivDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_NONE:
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
			viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
			break;
		case DISPUTE_LEVEL_WEAK:
			viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
			break;
		case DISPUTE_LEVEL_STRONG:
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
			viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
			break;
		case DISPUTE_LEVEL_FIERCE:
			viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			break;
		}
	}

	// Weight for land dispute
	switch (GetLandDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case DISPUTE_LEVEL_WEAK:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case DISPUTE_LEVEL_STRONG:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case DISPUTE_LEVEL_FIERCE:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	}
	
	// Extra weight for land dispute in the early game
	if (GetPlayer()->GetCurrentEra() <= 1 && GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}

	// If we're close to victory, that should influence our decision
	if (IsCloseToDominationVictory())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}
	int iNumCaps = GetPlayer()->GetNumCapitalCities();
	if ((iNumCaps > 0) && GetPlayer()->GetCapitalConqueror() == NO_PLAYER)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] + iNumCaps;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] + iNumCaps;
	}
	if (IsCloseToSSVictory())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
	}
	if (IsCloseToDiploVictory())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
	}
	// Special check for culture
	if (IsCloseToCultureVictory())
	{
		if (ePlayer == GetPlayer()->GetCulture()->GetCivLowestInfluence(false))
		{
			if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) < STRENGTH_AVERAGE)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			}
			else
			{
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
			}
		}
		else
		{
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		}
	}
	
	// If they're close to victory, that should influence our decision
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDominationVictory())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}
	
	if (!IsNoVictoryCompetition())
	{
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToSSVictory())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDiploVictory())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToCultureVictory())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
	}
	
	if (IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
	{
		// Are we both close to a victory condition?
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		}
		else if (!IsCloseToDominationVictory()) // if we're close to victory, victory dispute/block levels should matter more (except domination)
		{
			switch (GetVictoryDisputeLevel(ePlayer))
			{
			case DISPUTE_LEVEL_NONE:
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
				break;
			case DISPUTE_LEVEL_WEAK:
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
				break;
			case DISPUTE_LEVEL_STRONG:
				viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				break;
			case DISPUTE_LEVEL_FIERCE:
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
				break;
			}
			
			switch (GetVictoryBlockLevel(ePlayer))
			{
			case BLOCK_LEVEL_NONE:
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
				break;
			case BLOCK_LEVEL_WEAK:
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
				break;
			case BLOCK_LEVEL_STRONG:
				viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				break;
			case BLOCK_LEVEL_FIERCE:
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
				break;
			}
		}
	}

	VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	VictoryTypes eDiplomaticVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);
	VictoryTypes eDominationVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DOMINATION", true);

	//// Only war? ONLY WAR
	if (!GC.getGame().isVictoryValid(eSpaceshipVictory) && !GC.getGame().isVictoryValid(eCulturalVictory) && !GC.getGame().isVictoryValid(eDiplomaticVictory))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}

	if (GetPlayer()->IsCramped())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}

	if (m_pPlayer->GetCulture()->GetWarWeariness() > 0 && m_pPlayer->IsEmpireVeryUnhappy())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] + m_pPlayer->GetCulture()->GetWarWeariness() / 5;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] + m_pPlayer->GetCulture()->GetWarWeariness() / 5;
	}

	////////////////////////////////////
	// NUKES
	////////////////////////////////////

	int iTheirNukes = GET_PLAYER(ePlayer).getNumNukeUnits();
	int iOurNukes = m_pPlayer->getNumNukeUnits();
	int iHowLikelyAreTheyToNukeUs = GET_PLAYER(ePlayer).isHuman() ? 100 : 0; // assume humans will use 'em if they've got 'em
	if (iHowLikelyAreTheyToNukeUs == 0)
	{
		if (IsNukedBy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsNukedBy(eMyPlayer)) // nukes have been used already
		{
			iHowLikelyAreTheyToNukeUs = 100;
		}
		//else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarProjection(eMyPlayer) == WAR_PROJECTION_DESTRUCTION) // they are surely going to lose a war with 
		//{
		//	iHowLikelyAreTheyToNukeUs = 100;
		//}
		else
		{
			int iFlavorNuke = GET_PLAYER(ePlayer).GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_USE_NUKE")) + 1;
			iHowLikelyAreTheyToNukeUs = iFlavorNuke * iFlavorNuke; // use nukes has to pass 2 rolls
		}
	}
	// Do we have nukes and they don't?
	if (iTheirNukes == 0 && iOurNukes > 0)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
	}
	// Do they have nukes and we don't?
	else if (iTheirNukes > 0 && iOurNukes == 0 && iHowLikelyAreTheyToNukeUs > 50)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 2;
	}
	// Do we both have nukes?
	else if (iTheirNukes > 0 && iOurNukes > 0 && iHowLikelyAreTheyToNukeUs > 25)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}
	
	// THEY NUKED US!
	if (IsNukedBy(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 3;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 3;
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 3;
	}

	////////////////////////////////////
	// AT WAR RIGHT NOW
	////////////////////////////////////
	
	int iPlayerLoop;
	PlayerTypes eLoopPlayer;

	for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Don't look at the guy we're already thinking about or anyone on his team
		if (ePlayer != eLoopPlayer && GET_PLAYER(ePlayer).getTeam() != GET_PLAYER(eLoopPlayer).getTeam())
		{
			if (IsPlayerValid(eLoopPlayer))
			{
				if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					if (GetWarState(eLoopPlayer) == WAR_STATE_CALM || GetWarState(eLoopPlayer) == WAR_STATE_STALEMATE)
					{
						viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
					}
					else if (GetWarState(eLoopPlayer) == WAR_STATE_DEFENSIVE || GetWarState(eLoopPlayer) == WAR_STATE_NEARLY_DEFEATED)
					{
						viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
					}
				}
			}
		}
	}

	////////////////////////////////////
	// APPROACHES TOWARDS OTHER PLAYERS
	////////////////////////////////////

	// Look at Approaches we've already adopted for players we feel more strongly about
	if (bLookAtOtherPlayers)
	{
		for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Don't look at the guy we're already thinking about
			if (eLoopPlayer != ePlayer)
			{
				if (IsPlayerValid(eLoopPlayer))
				{
					// Planning or at war with this player? (Can't ONLY use the War Approach because this could have been cleared before, but we have to also check it because it could have just been set for someone else earlier this turn)
					if (GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE || GetWarGoal(eLoopPlayer) == WAR_GOAL_DEMAND || GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR || GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_HOSTILE || GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
					{
						viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];

						// Is this a neighbor? We want our neighbors on our good side if we're going to war with others
						if (GET_PLAYER(ePlayer).GetProximityToPlayer(GetPlayer()->GetID()) >= PLAYER_PROXIMITY_CLOSE)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						}
						// Is the target a neighbor? We want others on our good side if we're going to war with neighbors
						if (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(GetPlayer()->GetID()) >= PLAYER_PROXIMITY_CLOSE)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						}
					}

					// Approaches already assigned to other higher-priority Majors
					switch (GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false))
					{
						case MAJOR_CIV_APPROACH_HOSTILE:
							viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
							break;
						case MAJOR_CIV_APPROACH_AFRAID:
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
							break;
						case MAJOR_CIV_APPROACH_DECEPTIVE:
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
							break;
						case MAJOR_CIV_APPROACH_GUARDED:
							viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
							break;
					}
					// Has a defensive pact with him? If they're at least as strong as we are, let's reduce our war interest.
					if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
					{
						if (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) >= STRENGTH_AVERAGE)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
						}		
					}

					// Is this guy at war with the other player?
					if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
					{
						// Is this loop player our biggest competitor? We should like this guy!
						if (GetBiggestCompetitor() == eLoopPlayer)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						}
						
						// Are we also at war with the other player?
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
						if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && !bIsCapitulatedVassal)
#else
						if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
#endif
						{
							viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						}
						
						// Is this loop player our most valuable DOF or DP? We hate this other guy!
						else if (GetMostValuableDoF(false) == eLoopPlayer)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
							viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
						}
						else if (GetMostValuableDefensivePact(false) == eLoopPlayer)
						{
							viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
							viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
						}
					}
				}
			}
		}
	}

	////////////////////////////////////
	// Are we getting yields from trade with them?
	////////////////////////////////////
	int iCurrentGoldIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer);
	int iCurrentGoldOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, GetPlayer()->GetID());
	
	int iCurrentScienceIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, ePlayer);
	int iCurrentScienceOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, GetPlayer()->GetID());
	
	int iCurrentCultureIn = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, ePlayer);
	int iCurrentCultureOut = GET_PLAYER(ePlayer).GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, GetPlayer()->GetID());
	
	int iGDPEstimate = GetPlayer()->GetTreasury()->GetGoldFromCitiesTimes100(false);
	int iScienceEstimate = GetPlayer()->GetScienceFromCitiesTimes100(false);
	int iCultureEstimate = GetPlayer()->GetJONSCultureFromCitiesTimes100(false) + (GetPlayer()->GetJONSCulturePerTurnForFree() * 100);
	
	// Scale factor is hard to guess ...
	int iGoldDelta = (5 * (iCurrentGoldIn - iCurrentGoldOut)) / max(iGDPEstimate,1);
	int iScienceDelta = (5 * (iCurrentScienceIn - iCurrentScienceOut)) / max(iScienceEstimate,1);
	int iCultureDelta = (5 * (iCurrentCultureIn - iCurrentCultureOut)) / max(iCultureEstimate,1);

	// Now add in value from ongoing trade deals
	int iTradeDealValue = GC.getGame().GetGameDeals().GetDealValueWithPlayer(GetPlayer()->GetID(), ePlayer);

	// Scale based on personality - how much do we care about trade loyalty?
	iTradeDealValue *= GetLoyalty() + GetDiploBalance();
	iTradeDealValue /= 20;

	// 20% of that passes on...
	iTradeDealValue /= 5;
	
	int iTradeDelta = iGoldDelta + iScienceDelta + iCultureDelta + iTradeDealValue;
	if (iTradeDelta > 0)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += iTradeDelta;
	}
	
	// We're bankrupt!
	if (GetPlayer()->GetTreasury()->GetGold() <= 0 && GetPlayer()->calculateGoldRate() <= 0)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}
	
	// Sanity check - avoid declaring war if we would go bankrupt!
	int iLostGoldPerTurn = CalculateGoldPerTurnLostFromWar(ePlayer, false, false);
	int iAdjustedGoldPerTurn = GetPlayer()->calculateGoldRate() - iLostGoldPerTurn;
	
	if (iLostGoldPerTurn != 0)
	{
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() || IsNoVictoryCompetition())
		{
#if defined(MOD_BALANCE_CORE)
			// Factor in instant yields into our income as well (average of recent turns)
			int iTurn = GC.getGame().getGameTurn();
			int iGoldAverage = 0;
			for (int iI = 0; iI < 10; iI++)
			{
				int iYieldTurn = iTurn - iI;
				if (iYieldTurn <= 0)
					continue;
					
				iGoldAverage += GetPlayer()->getInstantYieldValue(YIELD_GOLD, iYieldTurn);
			}
				
			iGoldAverage /= 10;
			
			iAdjustedGoldPerTurn += iGoldAverage;
#endif
			
			iAdjustedGoldPerTurn *= 100; // multiply x100 to avoid rounding errors
			
			if (iAdjustedGoldPerTurn < 0)
			{
				// Flip it!
				iAdjustedGoldPerTurn *= -1;
				
				int iTurnsUntilBankruptcy = GetPlayer()->GetTreasury()->GetGoldTimes100() / max(iAdjustedGoldPerTurn,1);
				
				if (iTurnsUntilBankruptcy <= 30)
				{
					int iSanityMod = iAdjustedGoldPerTurn / 100;
					
					// Reduce weight by 1% for each turn it would take to go bankrupt
					iSanityMod *= (100 - iTurnsUntilBankruptcy);
					iSanityMod /= 100;
					
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= iSanityMod;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= iSanityMod;
				}
			}
		}
	}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// They have vassals? Let's consider our opinion of them.
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetNumVassals() > 0)
		{
			TeamTypes eLoopTeam;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes)iPlayerLoop;

				if (IsPlayerValid(eLoopPlayer))
				{
					eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();
					if (GET_TEAM(eLoopTeam).IsVassal(GET_PLAYER(ePlayer).getTeam()))
					{
						// Add our approach towards the vassal into this.
						switch (GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false))
						{
						case MAJOR_CIV_APPROACH_HOSTILE:
							viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
							break;
						case MAJOR_CIV_APPROACH_WAR:
							viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
							break;
						case MAJOR_CIV_APPROACH_DECEPTIVE:
							viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
							break;
						case MAJOR_CIV_APPROACH_GUARDED:
							viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
							break;
						}
					}
				}
			}
		}

		// They are our master
		else if (IsVassal(ePlayer))
		{
			// Voluntary vassal
			if (!bIsCapitulatedVassal)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}
			
			// Change approach based on how we are treated (vassal treatment matters A LOT!)
			// todo: magic numbers
			switch (GetVassalTreatmentLevel(ePlayer))
			{
				case VASSAL_TREATMENT_CONTENT:
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 5;
					break;
				case VASSAL_TREATMENT_DISAGREE:
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 2;
					break;
				case VASSAL_TREATMENT_MISTREATED:
					viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 5;
					break;
				case VASSAL_TREATMENT_UNHAPPY:
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 5;
					break;
				case VASSAL_TREATMENT_ENSLAVED:
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 5;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 10;
					viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * 10;
					break;
			}
		}
		
		// We have the same master
		else if (GET_TEAM(GetTeam()).IsVassalOfSomeone() && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		{
			if (GET_TEAM(GetPlayer()->getTeam()).GetMaster() == GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster())
			{
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			}
		}
		
		// They were our vassal and they declared their independence by force!
		if (IsAngryAboutPlayerVassalageForcefullyRevoked(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += /*4*/ GC.getAPPROACH_WAR_VASSAL_FORCEFULLY_REVOKED();
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += /*-10*/ GC.getAPPROACH_DECEPTIVE_VASSAL_FORCEFULLY_REVOKED();
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += /*-10*/ GC.getAPPROACH_FRIENDLY_VASSAL_FORCEFULLY_REVOKED();
		}
		// They were our master and they liberated us peacefully
		if (IsHappyAboutPlayerVassalagePeacefullyRevoked(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += /*-4*/ GC.getAPPROACH_WAR_VASSAL_PEACEFULLY_REVOKED();
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += /*2*/ GC.getAPPROACH_DECEPTIVE_VASSAL_PEACEFULLY_REVOKED();
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += /*5*/ GC.getAPPROACH_FRIENDLY_VASSAL_PEACEFULLY_REVOKED();
		}
	}
#endif

	////////////////////////////////////
	// WAR PROJECTION - how do we think a war against ePlayer will go?
	////////////////////////////////////

	switch (GetWarProjection(ePlayer))
	{
	case WAR_PROJECTION_DESTRUCTION:
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	case WAR_PROJECTION_DEFEAT:
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case WAR_PROJECTION_STALEMATE:
	case WAR_PROJECTION_UNKNOWN:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case WAR_PROJECTION_GOOD:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		break;
	case WAR_PROJECTION_VERY_GOOD:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		break;
	}

	// Military target value - how tough is this guy to kill?
	switch (GetPlayerTargetValue(ePlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	case TARGET_VALUE_BAD:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case TARGET_VALUE_AVERAGE:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case TARGET_VALUE_FAVORABLE:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		break;
	case TARGET_VALUE_SOFT:
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		break;
	}

	// Military Aggressive Posture - how aggressively has ePlayer deployed their units near our borders?
	switch (GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	case AGGRESSIVE_POSTURE_LOW:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
	case AGGRESSIVE_POSTURE_HIGH:
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		break;
	}
	
	////////////////////////////////////
	// ALLIANCES
	////////////////////////////////////
	// Let's play good guys versus bad guys!
	// Good alliances
	if (IsPlayerDenouncedEnemy(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
	}
	if (IsPlayerDoFwithAnyFriend(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
	}
	if (IsPlayerDPWithAnyFriend(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}
	
	// Bad alliances
	if (IsPlayerDenouncedFriend(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
	}
	if (IsPlayerDoFwithAnyEnemy(ePlayer) || IsPlayerDPWithAnyEnemy(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
	}
	
	////////////////////////////////////
	// RELIGION
	////////////////////////////////////
	ReligionTypes eMyReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);
	if (eMyReligion != NO_RELIGION)
	{
		// Have they been converting our cities? Grr...
		if (GetNegativeReligiousConversionPoints(ePlayer) > 0 && (!IsPlayerMadeNoConvertPromise(ePlayer) || IsPlayerIgnoredNoConvertPromise(ePlayer) || IsPlayerBrokenNoConvertPromise(ePlayer)))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
		
		// Do we have the same religion?
		else if (GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) == eMyReligion)
		{
#if defined(MOD_BALANCE_CORE)
			if (!IsHolyCityCapturedBy(ePlayer))
			{
#endif
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				
				// If it's the World Religion and we control its Holy City, we should work together
				if (GC.getGame().GetGameLeagues()->GetReligionSpreadStrengthModifier(GetPlayer()->GetID(), eMyReligion) > 0)
				{
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				}
#if defined(MOD_BALANCE_CORE)
			}
#endif
		}
	}
	
	////////////////////////////////////
	// IDEOLOGY
	////////////////////////////////////
	if (IsPlayerSameIdeology(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}
	else if (IsPlayerOpposingIdeology(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
	}

	////////////////////////////////////
	// Is this player a reckless expander?
	////////////////////////////////////

	if (IsPlayerRecklessExpander(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
	}

	////////////////////////////////////
	// Is this player already in a war with someone who isn't us?
	////////////////////////////////////
	int iBonus = 0;
	bool bThinkingAboutDogpiling = false;
	for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		// Is this a player we have relations with?
		if (IsPlayerValid(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
		{
			if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
			{
				if (IsMajorCompetitor(ePlayer))
				{
					bThinkingAboutDogpiling = true;
				}
				else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarProjection(ePlayer) >= WAR_PROJECTION_GOOD)
				{
					bThinkingAboutDogpiling = true;
				}
				
				// If we can't take them, we don't want them attacking us after finishing with this guy
				if (bThinkingAboutDogpiling && GetWarProjection(eLoopPlayer) <= WAR_PROJECTION_STALEMATE)
				{
					bThinkingAboutDogpiling = false;
					break;
				}

				if (bThinkingAboutDogpiling)
				{	
					iBonus += (int)GetVictoryBlockLevel(ePlayer) + (int)GetVictoryDisputeLevel(ePlayer) + (int)GetWarProjection(ePlayer) + (int)GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarProjection(ePlayer);
				}
			}
		}
	}
	
	if (bThinkingAboutDogpiling && (iBonus > 0))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += iBonus / 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += iBonus / 2;
	}

	////////////////////////////////////
	// THEIR APPROACH TOWARDS US
	////////////////////////////////////
	switch (GetTrueApproachTowardsUsGuess(ePlayer))
	{
	case MAJOR_CIV_APPROACH_WAR:
	case MAJOR_CIV_APPROACH_HOSTILE:
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case MAJOR_CIV_APPROACH_GUARDED:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
		break;
	case MAJOR_CIV_APPROACH_AFRAID:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		if (!GET_PLAYER(ePlayer).isHuman()) // neutral is the default, and we seldom know what humans are thinking
		{
			viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		}
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		break;
	default:
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
		break;
	}

	////////////////////////////////////
	// DUEL - There's only 2 players in this game
	////////////////////////////////////

	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();
	if (iNumMajorsLeft == 2)
	{
		if (!IsNoVictoryCompetition())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		}
		if (IsGoingForWorldConquest())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 10;
		}
	}

	////////////////////////////////////
	// DEFENSIVE PACT
	////////////////////////////////////
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GetTeam()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
	}

	////////////////////////////////////
	// CAN WE DECLARE WAR?
	////////////////////////////////////
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
	if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam()))
#endif
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
	}
	
	////////////////////////////////////
	// COOP WAR - agreed to go to war with someone?
	////////////////////////////////////
	if (GetPlayer()->GetDiplomacyAI()->IsLockedIntoCoopWar(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
	}
	
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (IsPlayerValid(eLoopPlayer) && GetCoopWarAcceptedState(ePlayer, eLoopPlayer) == COOP_WAR_STATE_SOON)
		{
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		}
	}
	
	////////////////////////////////////
	// EASY TARGET
	////////////////////////////////////
	bool bIsEasyTarget = IsEasyTarget(ePlayer);
	
	// They're only an easy target if we're not already at war with somebody else.
	// ...however, if we're already at war with them, let's keep this weight.
	if (!GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
	{
		bool bAtWarWithAtLeastOneMajor = MilitaryAIHelpers::IsTestStrategy_AtWar(m_pPlayer, false);
		bIsEasyTarget = bIsEasyTarget && !bAtWarWithAtLeastOneMajor;
	}
	
	if (bIsEasyTarget)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		
		if (!IsMajorCompetitor(ePlayer) && !GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		}
		if (IsDoFAccepted(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
			viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
		}
	}
	
	////////////////////////////////////
	// UNIQUE UNITS - We've got a UU? Let's see if it is time to go.
	////////////////////////////////////
	if (GetPlayer()->HasUUPeriod())
	{
		bool bHasUU = GetPlayer()->HasUUActive();
		// We got it? Let's strike!
		if (GetPlayer()->GetPlayerTechs()->HasUUTech() && bHasUU)
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
		// Have tech but not UU? Hurry up!
		else if (GetPlayer()->GetPlayerTechs()->HasUUTech() && !bHasUU)
		{
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		}

		// Don't have it but will have it soon? Delay.
		if (GetPlayer()->GetPlayerTechs()->WillHaveUUTechSoon())
		{
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		}
		
		// Going for world conquest?
		if (bHasUU && (IsGoingForWorldConquest() || IsCloseToDominationVictory()))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
		}
		
		// Easy target?
		if (bHasUU && bIsEasyTarget)
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		}
	}
	
	////////////////////////////////////
	// KEY PLAYERS
	////////////////////////////////////
	if (GetBiggestCompetitor() == ePlayer)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2;
		
		// Easy target? Let's get 'em.
		if (bIsEasyTarget && !IsDoFAccepted(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 5;
		}
	}
	else
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
	}
	// Focus our attention on major competitors.
	if (IsMajorCompetitor(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
		
		// Easy target? Let's get 'em.
		if (bIsEasyTarget && !IsDoFAccepted(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2;
		}
	}
	else
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * 2;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * 2;
	}
	
	if (GetMostValuableDoF(false) == ePlayer)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
	}
	if (GetMostValuableDefensivePact(false) == ePlayer)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
	}

#if defined(MOD_BALANCE_CORE)
	// Ignore this entire section if we're somebody's vassal.
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES && !GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
	{
#endif
		// Do we have bonuses towards war?
		int iWarBonus = 0;
		int iDifficultyBonus = 0;
		int iEra = GetPlayer()->GetCurrentEra();
		
		// Leader traits?
		if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		{
			iWarBonus += 3;
			
			// Easy target?
			if (bIsEasyTarget)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			}
			
			// Warmonger + unique unit active? Slay them all!
			if (GetPlayer()->HasUUPeriod() && GetPlayer()->HasUUActive())
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
				
				// AND we're going for world conquest?
				if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
					viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
				}
			}
		}

		// If we picked offensive policy trees, war is better for us.
		PolicyBranchTypes eAuthority = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_HONOR", true /*bHideAssert*/);
		PolicyBranchTypes eImperialism = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_EXPLORATION", true /*bHideAssert*/);
		PolicyBranchTypes eIdeology = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eAuthority))
		{
			iWarBonus++;
			
			if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eAuthority))
			{
				iWarBonus++;
			}
		}
		if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(eImperialism))
		{
			iWarBonus++;
			
			if (GetPlayer()->GetPlayerPolicies()->IsPolicyBranchFinished(eImperialism))
			{
				iWarBonus += 2;
			}
		}
		if (eIdeology == GC.getPOLICY_BRANCH_AUTOCRACY())
		{
			iWarBonus += 3;
		}
		
		// Temporary attack bonus?
		if (GetPlayer()->GetAttackBonusTurns() > 0)
		{
			iWarBonus += 2;
		}

		if (iWarBonus > 0)
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += iWarBonus + iEra;
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += iWarBonus + iEra;
		}

		if (MOD_BALANCE_CORE_DIFFICULTY)
		{
			// If we don't view them favorably, increase hostility based on game difficulty
			if (GetMajorCivOpinion(ePlayer) < MAJOR_CIV_OPINION_NEUTRAL)
			{
				iDifficultyBonus = GC.getGame().getHandicapInfo().getAIDifficultyBonusBase(); // ranges from 0 to 9
				
				int iOpinionFactor = (int)GetMajorCivOpinion(ePlayer);
				iOpinionFactor *= 2; // Unforgivable: 0, Enemy: 2, Competitor: 4
				
				// Protect against a modder setting this too low/high
				if (iDifficultyBonus < 0)
				{
					iDifficultyBonus = 0;
				}
				else if (iDifficultyBonus > 10)
				{
					iDifficultyBonus = 10;
				}
				
				iDifficultyBonus -= iOpinionFactor;
				
				if (iDifficultyBonus > 0)
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] += iDifficultyBonus + iEra;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += iDifficultyBonus + iEra;
					viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += iDifficultyBonus + iEra;
				}
			}
		}
		
		// Personality also matters.
		if ((iWarBonus > 0) || (iDifficultyBonus > 0))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE];
			
			// Easy target?
			if (bIsEasyTarget)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
			}
		}
		
		////////////////////////////////////
		// WORLD CONGRESS - Are there any resolutions we should take into consideration?
		////////////////////////////////////
		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
		if (pLeague != NULL)
		{
			// UN active? Be more friendly if we're trying to win by diplomacy.
			if (pLeague->IsUnitedNations())
			{
				if (IsCloseToDiploVictory() || IsGoingForDiploVictory())
				{
					viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
				}
			}
			
			// If either of us is sanctioned, we should be more hostile.
			if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(GetPlayer()->GetID(), ePlayer))
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			}
			
			// Casus Belli = more war, less friendly
			if (MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->IsWorldWar(GetPlayer()->GetID()) > 0)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			}
			
			// Global Peace Accords = less war, more friendly
			if (MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(GetPlayer()->GetID()) > 0)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
				viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
			}
			
			// COLD WAR = ideology is more important
			bool bColdWar = false;
			if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
			{
				// Loop through all (known) Players
				PlayerTypes eLoopPlayer;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;
					if (IsPlayerValid(eLoopPlayer))
					{
						if (GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetPlayer()->GetID(), eLoopPlayer))
						{
							bColdWar = true;
							break;
						}
					}
				}
				
				if (bColdWar)
				{
					if (GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetPlayer()->GetID(), ePlayer))
					{
						viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
						viApproachWeights[MAJOR_CIV_APPROACH_WAR] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
						viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
						viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
					}
					else
					{
						viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY];
						viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] += viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL];
						viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR];
						viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE];
						viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] -= viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED];
					}
				}
			}
		}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	}
#endif
#endif

	////////////////////////////////////
	// BACKSTABBING IS BAD
	////////////////////////////////////
	// REALLY shouldn't backstab friends = major diplo penalties
	if (IsDoFAccepted(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(GetPlayer()->GetID()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 10);
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 10);
	}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES)
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2);
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2);
	}
#endif
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GetTeam()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 3);
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 3);
	}
	if (WasResurrectedBy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetPlayer()->GetID()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * 2);
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] -= (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * 2);
	}
	
	// If it would backstab somebody else, for now just stop
	// to-do: intelligent AI backstabbing function instead of adding flat weight (better than trying to account for all the different factors)
	if (!IsWarWouldBackstabFriend(ePlayer) && IsWarWouldBackstabFriendTeamCheck(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
	}
	
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// This player is not our master
		if (GET_TEAM(GetTeam()).GetMaster() != GET_PLAYER(ePlayer).getTeam())
		{
			int iNumVassals = 0;
			PlayerTypes eLoopPlayer;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
				if (GET_PLAYER(eLoopPlayer).isMinorCiv())
					continue;

				if (GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetMaster() == GET_PLAYER(ePlayer).getTeam())
					{
						iNumVassals++;
					}
				}
			}

			viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= (100 + (iNumVassals * /*10*/ GC.getAPPROACH_WAR_TOO_MANY_VASSALS()));	// 1 vassal = 110%, 2 vassals = 120%
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
			viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] *= (100 + (iNumVassals * /*10*/ GC.getAPPROACH_GUARDED_TOO_MANY_VASSALS()));	// 1 vassal = 110%, 2 vassals = 120%
			viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] /= 100;
		}
	}
#endif
	
	////////////////////////////////////
	// DISTANCE - the farther away a player is the less likely we are to want to attack them!
	////////////////////////////////////
	// Target capacity should matter! If we can't get to them, let's not try to war on them!
	if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()) && (viApproachWeights[MAJOR_CIV_APPROACH_WAR] > 0 || viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] > 0))
	{
		if (GetPlayer()->GetMilitaryAI()->HaveValidAttackTarget(ePlayer))
		{
			// Factor in distance
			switch (GetPlayer()->GetProximityToPlayer(ePlayer))
			{
			case PLAYER_PROXIMITY_NEIGHBORS:
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*150*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS();
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*150*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS();
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				break;
			case PLAYER_PROXIMITY_CLOSE:
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE();
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE();
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				break;
			case PLAYER_PROXIMITY_FAR:
				if (!IsGoingForWorldConquest())
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*75*/ GC.getAPPROACH_WAR_PROXIMITY_FAR();
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*75*/ GC.getAPPROACH_WAR_PROXIMITY_FAR();
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				}
				else
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS();
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_NEIGHBORS();
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				}
				break;
			case PLAYER_PROXIMITY_DISTANT:
				if (!IsGoingForWorldConquest())
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*50*/ GC.getAPPROACH_WAR_PROXIMITY_DISTANT();
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*50*/ GC.getAPPROACH_WAR_PROXIMITY_DISTANT();
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				}
				else
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE();
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= /*125*/ GC.getAPPROACH_WAR_PROXIMITY_CLOSE();
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
				}
				break;
			}
		}
		else //no targets ...
		{
			//don't want to declare war if we don't have any valid targets
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
			viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		}
	}
	
	// Easy target? War good, demands and sulking less good.
	if (bIsEasyTarget && !IsDoFAccepted(ePlayer))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= 125;
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= 75;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;
	}
	
	int iApproachValue;
	
	// Negative approach weights - cap at zero!
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		iApproachValue = viApproachWeights[iApproachLoop];
		if (iApproachValue < 0)
		{
			viApproachWeights[(MajorCivApproachTypes)iApproachLoop] = 0;
		}
	}

	////////////////////////////////////
	// OPINION
	////////////////////////////////////

	int iWarMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_WAR] * GetBoldness());
	int iHostileMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_HOSTILE] * GetDenounceWillingness());
	int iDeceptiveMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_DECEPTIVE] * GetMeanness());
	int iGuardedMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_GUARDED] * (10 - GetForgiveness()));
	int iAfraidMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_AFRAID] * (10 - GetBoldness()));
	int iFriendlyMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_FRIENDLY] * GetLoyalty());
	int iNeutralMod = (viApproachWeightsPersonality[MAJOR_CIV_APPROACH_NEUTRAL] * GetDiploBalance() * 2);

	int iOpinionWeight = GetMajorCivOpinionWeight(ePlayer);

	// Using weight as +/- % - a bit more fluid than the switch table.
	if (iOpinionWeight > /*20*/ GC.getOPINION_THRESHOLD_COMPETITOR())
	{
		// Increase
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= (100 + iWarMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 100;

		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= (100 + iHostileMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 100;

		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] *= (100 + iDeceptiveMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] /= 100;

		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] *= (100 + iGuardedMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] /= 100;

		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] *= (100 + iAfraidMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] /= 100;

		// Decrease
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] /= max(100, (100 + iFriendlyMod + iOpinionWeight));	

		// Decrease Neutral
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] /=  max(100, (100 + iNeutralMod + iOpinionWeight));

	}
	else if (iOpinionWeight < /*-20*/ GC.getOPINION_THRESHOLD_FAVORABLE())
	{
		// Flip it!
		iOpinionWeight *= -1;

		// Increase
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] *= (100 + iFriendlyMod + iOpinionWeight);
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] /= 100;

		// Decrease
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= max(100,(100 + iWarMod + iOpinionWeight));

		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= max(100,(100 + iHostileMod + iOpinionWeight));

		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] /= max(100,(100 + iDeceptiveMod + iOpinionWeight));

		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] /= max(100,(100 + iGuardedMod + iOpinionWeight));

		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] /= max(100,(100 + iAfraidMod + iOpinionWeight));

		// Decrease Neutral
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] *= 100;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] /= max(100,(100 + iNeutralMod + iOpinionWeight));
	}
	else
	{
		// Increase Neutral
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] *= (100 + iNeutralMod);
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] /= 100;
	}
	
	// NO WAR?
	if (!GC.getGame().isVictoryValid(eDominationVictory))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] /= 2;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] /= 2;
	}
	
	int iWarScratchValueOverride = -1;
	int iHostileScratchValueOverride = -1;
	
	////////////////////////////////////
	// PEACE TREATY - have we made peace with this player recently?  If so, reduce war weight
	////////////////////////////////////
	if (GetNumWarsFought(ePlayer) > 0)
	{
		int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(eTeam);
		if (iPeaceTreatyTurn > -1)
		{
			int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;
			int iPeaceDampenerTurns = /*20*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER();

			if (MOD_BALANCE_CORE_DIFFICULTY)
			{
				int iPeaceDifficultyMod = GC.getGame().getHandicapInfo().getAIDifficultyBonusBase();
				iPeaceDampenerTurns -= iPeaceDifficultyMod;
				
				if (iPeaceDampenerTurns < 11)
					iPeaceDampenerTurns = 11;
			}
			
			if (iTurnsSincePeace < iPeaceDampenerTurns)
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
				iWarScratchValueOverride = 0;
			}
		}
	}
	
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) 
	{
		// If a vassal of someone else, destroy weight for war (if not already at war)
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone() && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() != GetPlayer()->GetID())
		{
			if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
			{
				viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
				iWarScratchValueOverride = 0;
			}
			// If we just started a war, bump last turn's weight up for averaging (helps figure out best approach towards the vassal's master)
			else if (GetPlayerNumTurnsAtWar(ePlayer) <= 1 && GetPlayer()->GetApproachScratchValue(ePlayer, MAJOR_CIV_APPROACH_WAR) == 0)
			{
				iWarScratchValueOverride = viApproachWeights[MAJOR_CIV_APPROACH_WAR];
			}
		}
		// We like our own vassals (unless they're blocking our path to victory)
		else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() == GetTeam())
		{
			// If they control other players' original capitals or are close to victory, don't erase weight for hostility
			if (!IsMajorCompetitor(ePlayer) && GET_PLAYER(ePlayer).GetNumCapitalCities() <= 0)
			{
				// We must control all capitals to win a Domination Victory
				if (IsCloseToDominationVictory() || IsGoingForWorldConquest())
				{
					if (GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
					{
						viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
						viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
						iWarScratchValueOverride = 0;
						iHostileScratchValueOverride = 0;
					}
				}
				else
				{
					viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
					viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
					iWarScratchValueOverride = 0;
					iHostileScratchValueOverride = 0;
				}
			}
		}
		
		// If WE'RE somebody's vassal, we shouldn't usually be hostile to anyone except our master
		if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone() && !IsVassal(ePlayer))
		{
			if (!IsUntrustworthyFriend(ePlayer) && !IsNukedBy(ePlayer))
			{
				viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
				iHostileScratchValueOverride = 0;
			}
		}
		
		////////////////////////////////////
		// Made a military promise?
		////////////////////////////////////

		// Don't declare war if we promised that our troops weren't on their borders for war
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetPlayer()->GetID()))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
			iWarScratchValueOverride = 0;
		}

		// If we agreed to remove our troops from their borders, destroy weight for war
		if (IsPlayerMoveTroopsRequestAccepted(ePlayer))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
			iWarScratchValueOverride = 0;
		}
	}
#endif

	// War disallowed by game options
	if (IsWarDisallowed(ePlayer) && !GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		iWarScratchValueOverride = 0;
	}
	
	////////////////////////////////////
	// ALWAYS WAR
	////////////////////////////////////	
	if ((GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE)) && GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 100;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] = 0;
	}
	
	////////////////////////////////////
	// CAN WE DECLARE WAR? (x2)
	////////////////////////////////////
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
	if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam()))
#endif
	{
		// If we're already at war with this player don't cancel out the weight for them!
		if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		{
			viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		}
	}

	////////////////////////////////////
	// On the same team?
	////////////////////////////////////
	if (GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		viApproachWeights[MAJOR_CIV_APPROACH_WAR] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_HOSTILE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_DECEPTIVE] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_GUARDED] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_AFRAID] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_NEUTRAL] = 0;
		viApproachWeights[MAJOR_CIV_APPROACH_FRIENDLY] = 100;
	}

	bool bAllZero = true;

	// Save off the scratch value for logging!
	vector<int> viApproachWeightsScratch;

	// Let's make this a gradual process - no rapid jumping from value to value!
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		int iLastTurnValue = GetPlayer()->GetApproachScratchValue(ePlayer, (MajorCivApproachTypes)iApproachLoop);
		viApproachWeightsScratch.push_back(iLastTurnValue);
		
		// Certain circumstances call for using a different value than the actual last turn value (for the averaging)
		// Has to be done after pushing back the actual value for logging to work properly
		if (iApproachLoop == /*WAR*/ 0 && iWarScratchValueOverride >= 0)
		{
			iLastTurnValue = iWarScratchValueOverride;
		}
		else if (iApproachLoop == /*HOSTILE*/ 1 && iHostileScratchValueOverride >= 0)
		{
			iLastTurnValue = iHostileScratchValueOverride;
		}

		iApproachValue = viApproachWeights[iApproachLoop];
		if (iApproachValue > 0)
		{
			bAllZero = false;
		}

		float fAlpha = 0.10f;
		int  iAverage = int(0.5f + (iApproachValue * fAlpha) + (iLastTurnValue * ( 1 - fAlpha)));
		
		// If the value changed, make sure it goes up/down by at least one
		if ((iApproachValue > iLastTurnValue) && (iAverage == iLastTurnValue))
		{
			iAverage += 1;
		}
		else if ((iApproachValue < iLastTurnValue) && (iAverage == iLastTurnValue))
		{
			iAverage -= 1;
		}
		
		viApproachWeights[(MajorCivApproachTypes)iApproachLoop] = iAverage;

		// Set the new average for next turn.
		GetPlayer()->SetApproachScratchValue(ePlayer, (MajorCivApproachTypes)iApproachLoop, iAverage);
	}

	// This vector is what we'll use to sort
	CvWeightedVector< MajorCivApproachTypes, 128 > vApproachWeightsForSorting;

	// Transfer values from our normal int vector (which we need for logging) to the Weighted Vector we can sort
	for (int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
	{
		vApproachWeightsForSorting.push_back((MajorCivApproachTypes) iApproachLoop, viApproachWeights[iApproachLoop]);
	}

	vApproachWeightsForSorting.SortItems();

	eApproach = vApproachWeightsForSorting.GetElement(0);
	iHighestWeight = vApproachWeightsForSorting.GetWeight(0);
	
	// Don't bother being friendly (real or fake) if there's been a denouncement or they're untrustworthy
	bool bNoFriendly = false;
	if (IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()) || IsUntrustworthyFriend(ePlayer))
	{
		bNoFriendly = true;
	}
	
	if (bNoFriendly && (eApproach == MAJOR_CIV_APPROACH_FRIENDLY || eApproach == MAJOR_CIV_APPROACH_DECEPTIVE))
	{
		if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		{
			eApproach = MAJOR_CIV_APPROACH_GUARDED;
		}
		else
		{
			eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
		}
	}

	// If we're going to war then update how we're acting
	if (eApproach == MAJOR_CIV_APPROACH_WAR)
	{
		eWarFace = GetWarFaceWithPlayer(ePlayer);

		// If we haven't set War Face on a previous turn, figure out what it should be
		if (eWarFace == NO_WAR_FACE_TYPE)
		{
			MajorCivApproachTypes eTempApproach;

			// Use index of 1 since we already know element 0 is war; that will give us the most reasonable approach
			eTempApproach = vApproachWeightsForSorting.GetElement(1);

			// Pick among the Approach types
			// Select a War Face based on the next highest Approach score
			switch (eTempApproach)
			{
			case MAJOR_CIV_APPROACH_HOSTILE:
				eWarFace = WAR_FACE_HOSTILE;
				break;
			case MAJOR_CIV_APPROACH_GUARDED:
				eWarFace = WAR_FACE_GUARDED;
				break;
			case MAJOR_CIV_APPROACH_DECEPTIVE:
				eWarFace = WAR_FACE_NEUTRAL;
				break;
			case MAJOR_CIV_APPROACH_AFRAID:
				eWarFace = WAR_FACE_HOSTILE;
				break;
			case MAJOR_CIV_APPROACH_FRIENDLY:
				eWarFace = WAR_FACE_FRIENDLY;
				break;
			default:
				eWarFace = WAR_FACE_NEUTRAL;
				break;
			}
		}
	}
	else
	{
		// Reset this so a new War Face can be picked next time
		eWarFace = NO_WAR_FACE_TYPE;
	}
	
	if (bNoFriendly && eWarFace == WAR_FACE_FRIENDLY)
	{
		if (GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_ENEMY)
		{
			eWarFace = WAR_FACE_GUARDED;
		}
		else
		{
			eWarFace = WAR_FACE_NEUTRAL;
		}
	}

	// Don't want to log if we're just seeing what the highest weight is and don't care about what Approach we like
	if (bLog)
	{
		LogMajorCivApproachUpdate(ePlayer, &viApproachWeights[0], eApproach, eOldApproach, eWarFace);
		LogApproachValueDeltas(ePlayer, &viApproachWeights[0], &viApproachWeightsScratch[0]);
	}
	// All at zero? Return neutral.
	if (bAllZero)
	{
		return MAJOR_CIV_APPROACH_NEUTRAL;
	}

	return eApproach;
}


/// What is our Diplomatic Approach towards this Major Civ?
MajorCivApproachTypes CvDiplomacyAI::GetMajorCivApproach(PlayerTypes ePlayer, bool bHideTrueFeelings) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = (MajorCivApproachTypes) m_paeMajorCivApproach[ePlayer];

	// If we're hiding our true feelings then use the War Face or Friendly if we're Deceptive
	if(bHideTrueFeelings)
	{
		// Deceptive = Friendly
		if(eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
		{
			eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
		}

		// War Face
		else if(eApproach == MAJOR_CIV_APPROACH_WAR)
		{
			switch(GetWarFaceWithPlayer(ePlayer))
			{
			case WAR_FACE_HOSTILE:
				eApproach = MAJOR_CIV_APPROACH_HOSTILE;
				break;
			case WAR_FACE_FRIENDLY:
				eApproach = MAJOR_CIV_APPROACH_FRIENDLY;
				break;
			case WAR_FACE_NEUTRAL:
				eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
				break;
			case WAR_FACE_GUARDED:
				eApproach = MAJOR_CIV_APPROACH_GUARDED;
				break;
			default:
				CvAssert(false);
				break;
			}
		}
	}

	return eApproach;
}

/// Sets what our Diplomatic Approach is towards a Major Civ
void CvDiplomacyAI::SetMajorCivApproach(PlayerTypes ePlayer, MajorCivApproachTypes eApproach)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach >= NO_MAJOR_CIV_APPROACH, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");		// NO_MAJOR_CIV_APPROACH is valid because the Approach gets reset at the start of every turn.  We have an assert there that tests it though
	CvAssertMsg(eApproach < NUM_MAJOR_CIV_APPROACHES, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeMajorCivApproach[ePlayer] = eApproach;
}

/// How many Majors do we have a particular Approach towards?
int CvDiplomacyAI::GetNumMajorCivApproach(MajorCivApproachTypes eApproach) const
{
	CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach < NUM_MAJOR_CIV_APPROACHES, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iCount = 0;

	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
	{
		if(GetMajorCivApproach((PlayerTypes) iMajorLoop, /*bHideTrueFeelings*/ false) == eApproach)
		{
			iCount++;
		}
	}

	return iCount;
}


/// Determine our general Approach to each Minor Civ we've met
void CvDiplomacyAI::DoUpdateMinorCivApproaches()
{
	int iPlayerLoop;
	PlayerTypes eLoopPlayer;

	// Transfer Approaches from last turn to a separate array so we still have access to the info, then clear out the real one
	for(iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		m_paeApproachScratchPad[iPlayerLoop] = -1;

		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eLoopPlayer).isMinorCiv())
		{
			if(IsPlayerValid(eLoopPlayer))
			{
				m_paeApproachScratchPad[eLoopPlayer] = GetMinorCivApproach(eLoopPlayer);
				SetMinorCivApproach(eLoopPlayer, NO_MINOR_CIV_APPROACH);
			}
		}
	}

	int iHighestWeight;

	CvWeightedVector<PlayerTypes, MAX_MINOR_CIVS, true> vePlayerApproachWeights;
	int iPlayerVectorIndex;

	// Loop through all (known) Minors and determine the order of who we pick our Approach for first based on PROXIMITY - this is different from Majors
	for(iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			iHighestWeight = GetPlayer()->GetProximityToPlayer(eLoopPlayer);	// Note that the order in the PlayerProximityTYpes enum is very important here: be sure to verify that NEIGHBORS is the last entry
			vePlayerApproachWeights.push_back(eLoopPlayer, iHighestWeight);
		}
	}

	MinorCivApproachTypes eApproach;
	MinorCivApproachTypes eLastTurnApproach;

	// Now sort the list if there's anything in it
	if(vePlayerApproachWeights.size() > 0)
	{
		vePlayerApproachWeights.SortItems();

		// Now that Minors are sorted, ACTUALLY figure out what our Approach will be, taking everything into account
		for(iPlayerVectorIndex = 0; iPlayerVectorIndex < (int) vePlayerApproachWeights.size(); iPlayerVectorIndex++)
		{
			eLoopPlayer = (PlayerTypes) vePlayerApproachWeights.GetElement(iPlayerVectorIndex);

			// See which Approach is best
			eApproach = GetBestApproachTowardsMinorCiv(eLoopPlayer, /*Passed by Ref, but we won't use it*/ iHighestWeight, /*bLookAtOtherPlayers*/ true, /*bLog*/ true);

			eLastTurnApproach = (MinorCivApproachTypes) m_paeApproachScratchPad[eLoopPlayer];

			CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MinorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

			SetMinorCivApproach(eLoopPlayer, eApproach);
		}
	}

	// Debug check

#ifndef FINAL_RELEASE
	for(iPlayerLoop = 0; iPlayerLoop < MAX_MINOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eLoopPlayer).isMinorCiv())
		{
			if(IsPlayerValid(eLoopPlayer))
			{
				if(GetMinorCivApproach(eLoopPlayer) == NO_MINOR_CIV_APPROACH)
					CvAssertMsg(false, "DIPLOMACY_AI: Invalid MinorCivApproachType. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
			}
		}
	}
#endif
}


/// What is the best Approach to take towards a Minor Civ?  Can also pass in iHighestWeight by reference if you just want to know what the player feels most strongly about without actually caring about WHAT it is
MinorCivApproachTypes CvDiplomacyAI::GetBestApproachTowardsMinorCiv(PlayerTypes ePlayer, int& iHighestWeight, bool bLookAtOtherPlayers, bool bLog)
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	MinorCivApproachTypes eApproach;

	// This vector is what we'll stuff the values into first, and pass it into our logging function (which can't take a CvWeightedVector, which we need to sort...)
	vector<int> viApproachWeights(NUM_MINOR_CIV_APPROACHES, 0);

	////////////////////////////////////
	// CURRENT APPROACH BIASES
	////////////////////////////////////

	// Bias for our current Approach.  This should prevent it from jumping around from turn-to-turn as much
	// We use the scratch pad here since the normal array has been cleared so that we have knowledge of who we've already assigned an Approach for this turn; this should be the only place the scratch pad is used
	// Not used in VP except if previously planning a war
	MinorCivApproachTypes eOldApproach = (MinorCivApproachTypes)m_paeApproachScratchPad[ePlayer];
	if (eOldApproach == NO_MAJOR_CIV_APPROACH)
		eOldApproach = MINOR_CIV_APPROACH_IGNORE;

	vector<int> viApproachWeightsPersonality;
	for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		viApproachWeightsPersonality.push_back(GetPersonalityMinorCivApproachBias((MinorCivApproachTypes)iApproachLoop));
	}

	// Bias for our current Approach.  This should prevent it from jumping around from turn-to-turn as much
	// We use the scratch pad here since the normal array has been cleared so that we have knowledge of who we've already assigned an Approach for this turn; this should be the only place the scratch pad is used
	CvAssertMsg(m_paeApproachScratchPad[ePlayer] >= NO_MINOR_CIV_APPROACH && m_paeApproachScratchPad[ePlayer] < NUM_MINOR_CIV_APPROACHES, "m_paeApproachScratchPad[iScratchPadID] is out of bounds for minor civ approaches. Show Jon!");
	if(m_paeApproachScratchPad[ePlayer] < NO_MINOR_CIV_APPROACH || m_paeApproachScratchPad[ePlayer] >= NUM_MINOR_CIV_APPROACHES)
	{
		return NO_MINOR_CIV_APPROACH;
	}

	////////////////////////////////////
	// PERSONALITY
	////////////////////////////////////

	for (int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		viApproachWeights[iApproachLoop] += GetPersonalityMinorCivApproachBias((MinorCivApproachTypes)iApproachLoop);
	}

	////////////////////////////////////
	// NEUTRAL DEFAULT WEIGHT
	////////////////////////////////////

	viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE];
	
	// If we're planning a war then give it a bias so that we don't get away from it too easily
	if(eOldApproach == MINOR_CIV_APPROACH_CONQUEST)
	{
		// Don't give this bias if war is going poorly
		WarStateTypes eWarState = GetWarState(ePlayer);
		if (eWarState >= WAR_STATE_CALM)
		{
			viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST];
		}
	}

	// If we're ALREADY at war with this player then we're much less likely to be Protective
	if(IsAtWar(ePlayer))
	{
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST];
	}

	////////////////////////////////////
	// RESOURCES
	////////////////////////////////////

	int iNumWeLack = GET_PLAYER(ePlayer).GetMinorCivAI()->GetNumResourcesMajorLacks(GetPlayer()->GetID());
	if(iNumWeLack > 0)
	{
		if (GetPlayer()->IsCSResourcesCountMonopolies())
		{
			viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (iNumWeLack + viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
			viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (iNumWeLack + viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
		}
		else
		{
			viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (iNumWeLack + viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
			viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (iNumWeLack + viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		}
	}

	////////////////////////////////////
	// FRIENDS WITH MINOR
	////////////////////////////////////

	if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
	}

	////////////////////////////////////
	// PLEDGE TO PROTECT - have we pledged to protect this minor?
	////////////////////////////////////
	//antonjs: consider: disable this weight after a certain amount of turns, to have this player "reevaluate" its PtP
	if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
	{
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];
	}

	bool bIsGoodWarTarget = false;
	bool bCheckIfGoodWarTarget = false;

	////////////////////////////////////
	// CONQUEST GRAND STRATEGY
	////////////////////////////////////

	if(IsGoingForWorldConquest())
	{
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);

		bCheckIfGoodWarTarget = true;
	}

	////////////////////////////////////
	// DIPLO GRAND STRATEGY
	////////////////////////////////////

	else if(IsGoingForDiploVictory())
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
	}

	////////////////////////////////////
	// CULTURE GRAND STRATEGY
	////////////////////////////////////

	else if(IsGoingForCultureVictory())
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);

		// Minor is cultural
		if(GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED) 
		{
			viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		}
		else
		{
			bCheckIfGoodWarTarget = true;
		}
	}

	////////////////////////////////////
	// SCIENCE GRAND STRATEGY
	////////////////////////////////////
	else
	{
		// Minor is cultural
		if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
		{
			viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		}
		else
		{
			bCheckIfGoodWarTarget = true;
		}
	}

	////////////////////////////////////
	// TRAITS THAT AFFECT MINORS - These are heavy handed, but that is intentional
	////////////////////////////////////
	int iBonusTraitMod = 0;
	iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetCityStateFriendshipModifier() > 0) ? 10 : 0;
	iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetCityStateBonusModifier() > 0) ? 10 : 0;
	iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetCityStateCombatModifier() > 0) ? -10 : 0;
#if defined(MOD_BALANCE_CORE)
	iBonusTraitMod += (m_pPlayer->GetCityStateCombatModifier() > 0) ? -10 : 0;
	iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetAllianceCSStrength() > 0) ? 10 : 0;
	iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetAllianceCSDefense() > 0) ? 10 : 0;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes) iI;
		if(eYield != NO_YIELD)
		{
			iBonusTraitMod += (m_pPlayer->GetPlayerTraits()->GetYieldFromCSAlly(eYield) > 0) ? 10 : 0;
		}
	}
#endif
	if (iBonusTraitMod)
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += iBonusTraitMod / 5;
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += iBonusTraitMod;
	}
	if (iBonusTraitMod >= 0 && m_pPlayer->getNumCities() <= 1)
	{
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
	}

#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
	if (MOD_BALANCE_CORE_AFRAID_ANNEX)
	{
		if (GetPlayer()->GetPlayerTraits()->IsBullyAnnex() || GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
		{
			viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
		}
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if (GetPlayer()->GetYieldFromMinorDemand(eYield) > 0)
			{
				viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
			}
		}
	}
	//Patronage Bonus
	if (GetPlayer()->GetMinorFriendshipAnchorMod() > 0 || GetPlayer()->GetMinorFriendshipDecayMod() < 0 || GetPlayer()->getMinorGoldFriendshipMod() > 0 || GetPlayer()->IsMinorScienceAllies() || GetPlayer()->IsMinorResourceBonus() || GetPlayer()->GetIncreasedQuestInfluence() > 0 || GetPlayer()->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER) > 0)
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];

	}
	if (GetPlayer()->GetPlayerTraits()->IsDiplomaticMarriage() || GetPlayer()->GetPlayerTraits()->IsAbleToAnnexCityStates() || GetPlayer()->GetPlayerTraits()->GetCityStateFriendshipModifier() > 0 || GetPlayer()->GetPlayerTraits()->GetCityStateBonusModifier() > 0)
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];
	}

	if (GetPlayer()->IsCanBullyFriendlyCS())
	{
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
	}

	if (GetPlayer()->GetBullyGlobalCSReduction() > 0)
	{
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
	}
#endif

	////////////////////////////////////
	// AT WAR RIGHT NOW
	////////////////////////////////////
	int iPlayerLoop;
	PlayerTypes eLoopPlayer;
	for(iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Don't look at the guy we're already thinking about or anyone on his team
		if(ePlayer != eLoopPlayer && GET_PLAYER(ePlayer).getTeam() != GET_PLAYER(eLoopPlayer).getTeam())
		{
			if(IsPlayerValid(eLoopPlayer))
			{
				if(GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					if(GetStateAllWars() == STATE_ALL_WARS_NEUTRAL)
					{
						viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE]);
						viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
					}
					else if(GetStateAllWars() == STATE_ALL_WARS_WINNING)
					{
						viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
					}
					else
					{
						viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE]);
						viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
					}
				}
			}
		}
	}

	////////////////////////////////////
	// PROXIMITY
	////////////////////////////////////

	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_NEIGHBORS:
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY];
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		break;
	case PLAYER_PROXIMITY_CLOSE:	
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY];
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		break;
	case PLAYER_PROXIMITY_FAR:
	case PLAYER_PROXIMITY_DISTANT:
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE];
		break;
	}

	////////////////////////////////////
	// MINOR PERSONALITY
	////////////////////////////////////

	switch(GET_PLAYER(ePlayer).GetMinorCivAI()->GetPersonality())
	{
	case MINOR_CIV_PERSONALITY_FRIENDLY:
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
		break;
	case MINOR_CIV_PERSONALITY_NEUTRAL:
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
		break;
	case MINOR_CIV_PERSONALITY_HOSTILE:
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		break;
	case MINOR_CIV_PERSONALITY_IRRATIONAL:
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY];
		break;
	}

	////////////////////////////////////
	// TRIBUTE HISTORY - have we bullied this player before?  If so, we are more likely to keep bullying
	////////////////////////////////////
	if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsEverBulliedByMajor(GetPlayer()->GetID()))
	{
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY];
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
	}

	////////////////////////////////////
	// QUESTS - are there any active quests that might sway our decision?
	////////////////////////////////////
	if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsActiveQuestForPlayer(GetPlayer()->GetID(), MINOR_CIV_QUEST_PLEDGE_TO_PROTECT))
	{
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];
	}

	//If this civ has a kill CS quest, then it means another CS has one too...let's compare.
	if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsActiveQuestForPlayer(GetPlayer()->GetID(), MINOR_CIV_QUEST_KILL_CITY_STATE))
	{
		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			PlayerTypes eOtherMinor = (PlayerTypes) iMinorCivLoop;
			if(eOtherMinor != NO_PLAYER && GET_PLAYER(eOtherMinor).isAlive() && GET_PLAYER(eOtherMinor).isMinorCiv() && GET_TEAM(GET_PLAYER(eOtherMinor).getTeam()).isHasMet(GetPlayer()->getTeam()))
			{
				if(GET_PLAYER(eOtherMinor).GetMinorCivAI()->IsActiveQuestForPlayer(GetPlayer()->GetID(), MINOR_CIV_QUEST_KILL_CITY_STATE))
				{
					PlayerTypes eTarget = (PlayerTypes)GET_PLAYER(eOtherMinor).GetMinorCivAI()->GetQuestData1(GetPlayer()->GetID(), MINOR_CIV_QUEST_KILL_CITY_STATE);
					if(eTarget == ePlayer)
					{
						bool bBadTarget = false;
						int iPTV = GetPlayerTargetValue(ePlayer);
						switch(iPTV)
						{
							//Is this guy a bad target? Let's diplo him instead.
						case TARGET_VALUE_IMPOSSIBLE:
						case TARGET_VALUE_BAD:
						case TARGET_VALUE_AVERAGE:
							bBadTarget = true;
							break;
							//Good target? Let's kill him and get the prize!
						case TARGET_VALUE_FAVORABLE:
						case TARGET_VALUE_SOFT:
							viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
							viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
							break;
						default:
							break;
						}
						int iPTV2 = GetPlayerTargetValue(eOtherMinor);
						switch(iPTV2)
						{
							//Is the other guy also a bad target? Let's diplo them both instead.
						case TARGET_VALUE_IMPOSSIBLE:
						case TARGET_VALUE_BAD:
						case TARGET_VALUE_AVERAGE:
							if(bBadTarget)
							{
								viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
								viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
							}
							break;
						default:
							break;
						}
					}
				}
			}
		}
	}

	// Are we getting yields from trade with them?
	int iCurrentTradeValue = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer) +
							GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_CULTURE, ePlayer) + 
							GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_SCIENCE, ePlayer);
	iCurrentTradeValue /= 300;

	if(iCurrentTradeValue > 0)
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY] * (iCurrentTradeValue / 2);
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE] * iCurrentTradeValue;
	}
	else //not a trade partner
	{
		viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE];
	}

	////////////////////////////////////
	// TARGET VALUE - can we conquer these guys?
	////////////////////////////////////

	int iPTV = GetPlayerTargetValue(ePlayer);
	if (GetPlayer()->GetPlayerTraits()->GetCityStateCombatModifier() > 0 || GetPlayer()->GetCityStateCombatModifier() > 0)
	{
		iPTV++;
		iPTV = iPTV > TARGET_VALUE_SOFT ? TARGET_VALUE_SOFT : iPTV;
	}
	switch(iPTV)
	{
	case TARGET_VALUE_IMPOSSIBLE:
	case TARGET_VALUE_BAD:
		viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE];
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
		break;
	case TARGET_VALUE_AVERAGE:
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];
		break;
	case TARGET_VALUE_FAVORABLE:
	case TARGET_VALUE_SOFT:
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_BULLY]);
		break;
	default:
		break;
	}

	////////////////////////////////////
	// PEACE TREATY - have we made peace with this player recently?  If so, reduce war weight
	////////////////////////////////////

	int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(eTeam);
	if(iPeaceTreatyTurn > -1)
	{
		int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;
		if(iTurnsSincePeace < /*25*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER())
		{
			viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE];
			viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
		}
	}

	////////////////////////////////////
	// CAN WE PLEDGE TO PROTECT?
	////////////////////////////////////
	if(!GET_PLAYER(ePlayer).GetMinorCivAI()->CanMajorProtect(GetPlayer()->GetID()))
	{
		// Disfavor protective if we can't actually pledge protection!
		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] = 0;
	}

	////////////////////////////////////
	// CAN WE DECLARE WAR?
	////////////////////////////////////
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if(!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
	if(!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam()))
#endif
	{
		if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		{
			// Disfavor conquest if we can't even do war with them!
			viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
			viApproachWeights[MINOR_CIV_APPROACH_BULLY] = 0;
		}
	}

	// See if this minor is on the same continent as a major power we want to attack
	if (bCheckIfGoodWarTarget)
	{
		CvCity *pkMinorCapital = GET_PLAYER(ePlayer).getCapitalCity();
		if (pkMinorCapital)		// This should always be valid
		{
			int iMinorAreaID = pkMinorCapital->getArea();

			if (m_pPlayer->getCapitalCity())		// This should always be valid too.
			{
				int iMyAreaID = m_pPlayer->getCapitalCity()->getArea();
				int iPlayerLoop;
				CvTeam& kMyTeam = GET_TEAM(GetTeam());
				for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
					CvPlayer &kLoopPlayer = GET_PLAYER(eLoopPlayer);

					// Make sure it is another valid player and not already at war with them
					if (m_pPlayer->GetID() != eLoopPlayer)
					{
						if (IsPlayerValid(eLoopPlayer))
						{
							if (!kMyTeam.isAtWar(kLoopPlayer.getTeam()))
							{
								// Do we want to attack them?
								if (GetMajorCivApproach(eLoopPlayer, false) == MAJOR_CIV_APPROACH_WAR)
								{
									CvCity* pkLoopPlayerCity = kLoopPlayer.getCapitalCity();
									if (pkLoopPlayerCity)	// It's possible this is not valid
									{
										int iLoopPlayerAreaID = pkLoopPlayerCity->getArea();
										// All of us neighbors on same landmass?
										if (iLoopPlayerAreaID == iMinorAreaID &&
											iMyAreaID == iLoopPlayerAreaID)
										{
											if (kLoopPlayer.GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_NEIGHBORS &&
												m_pPlayer->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_NEIGHBORS)
											{
												bIsGoodWarTarget = true;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if (bIsGoodWarTarget)
	{
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_CONQUEST]);
	}
	else
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;

	////////////////////////////////////
	// APPROACHES TOWARDS OTHER PLAYERS
	////////////////////////////////////

	// Look at Approaches we've already adopted for players we feel more strongly about
	if (bLookAtOtherPlayers)
	{
		bool bMinorCiv;

		// Major Civs
		for (iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Don't look at the guy we're already thinking about
			if (eLoopPlayer != ePlayer)
			{
				if (IsPlayerValid(eLoopPlayer))
				{
					bMinorCiv = GET_PLAYER(eLoopPlayer).isMinorCiv();

					// Planning war with this player? (Can't ONLY use the War Approach because this could have been cleared before, but we have to also check it because it could have just been set for someone else earlier this turn)
					if (!bMinorCiv && (GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE || GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) <= MAJOR_CIV_APPROACH_HOSTILE))	// Major Civs only
					{
						viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
						viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE]);
					}

					// Approaches already assigned to other higher-priority Minors
					if (bMinorCiv)
					{
						switch (GetMinorCivApproach(eLoopPlayer))
						{
						case MINOR_CIV_APPROACH_CONQUEST:
						{
							viApproachWeights[MINOR_CIV_APPROACH_IGNORE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_IGNORE]);
						}
						break;
						case MINOR_CIV_APPROACH_PROTECTIVE:
						{

							viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY]);
						}
						break;
						case MINOR_CIV_APPROACH_BULLY:
						{

							viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += (viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE]);
						}
						break;
						}
					}
				}
			}
		}
	}

	
	////////////////////////////////////
	// ALLIES WITH MINOR?
	////////////////////////////////////
	if (GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == GetPlayer()->GetID() || GET_PLAYER(ePlayer).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
	{
		// Disfavor conquest and bullying if they are our ally
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;

		if (!GetPlayer()->IsCanBullyFriendlyCS())
		{
			viApproachWeights[MINOR_CIV_APPROACH_BULLY] = 0;
		}

		viApproachWeights[MINOR_CIV_APPROACH_PROTECTIVE] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_PROTECTIVE];
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
	}
	else if (GET_PLAYER(ePlayer).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
	{
		viApproachWeights[MINOR_CIV_APPROACH_FRIENDLY] += viApproachWeightsPersonality[MINOR_CIV_APPROACH_FRIENDLY];
	}
	
	// War disallowed by game options
	if (IsWarDisallowed(ePlayer) && !GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
	{
		viApproachWeights[MINOR_CIV_APPROACH_BULLY] = 0;
		viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
	}
	
	////////////////////////////////////
	// Teammates
	////////////////////////////////////
	// Don't attack a minor that a teammate has allied/protected!
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if(IsPlayerValid(eLoopPlayer, true))
		{
			if(eLoopPlayer == GetPlayer()->GetID())
				continue;
	
			if(GetPlayer()->getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
			{
				if(GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() == eLoopPlayer)
				{
					viApproachWeights[MINOR_CIV_APPROACH_BULLY] = 0;
					viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
				}
				else if(GET_PLAYER(ePlayer).GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
				{
					viApproachWeights[MINOR_CIV_APPROACH_BULLY] = 0;
					viApproachWeights[MINOR_CIV_APPROACH_CONQUEST] = 0;
				}
			}
		}
	}

	// This vector is what we'll use to sort
	CvWeightedVector< MinorCivApproachTypes, 128 > vApproachWeightsForSorting;
	vApproachWeightsForSorting.clear();

	// Transfer values from our normal int vector (which we need for logging) to the Weighted Vector we can sort
	for(int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
	{
		vApproachWeightsForSorting.push_back((MinorCivApproachTypes) iApproachLoop, viApproachWeights[iApproachLoop]);
	}

	vApproachWeightsForSorting.SortItems();

	eApproach = vApproachWeightsForSorting.GetElement(0);
	iHighestWeight = vApproachWeightsForSorting.GetWeight(0);

	// Don't want to log if we're just seeing what the highest weight is and don't care about what Approach we like
	if(bLog)
	{
		LogMinorCivApproachUpdate(ePlayer, &viApproachWeights[0], eApproach, eOldApproach);
	}
	return eApproach;
}

/// What is our Diplomatic Approach towards this Minor Civ?
MinorCivApproachTypes CvDiplomacyAI::GetMinorCivApproach(PlayerTypes ePlayer) const
{
	// Remove the Majors from here, since we're only actually storing Data for the Minors
	PlayerTypes eMinor = (PlayerTypes)((int) ePlayer - MAX_MAJOR_CIVS);

	CvAssertMsg(eMinor >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMinor < MAX_MINOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (MinorCivApproachTypes) m_paeMinorCivApproach[eMinor];
}

/// Sets what our Diplomatic Approach is towards a Minor Civ
void CvDiplomacyAI::SetMinorCivApproach(PlayerTypes ePlayer, MinorCivApproachTypes eApproach)
{
	// Remove the Majors from here, since we're only actually storing Data for the Minors
	PlayerTypes eMinor = (PlayerTypes)((int) ePlayer - MAX_MAJOR_CIVS);

	CvAssertMsg(eMinor >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMinor < MAX_MINOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach >= NO_MINOR_CIV_APPROACH, "DIPLOMACY_AI: Invalid MinorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");		// NO_MINOR_CIV_APPROACH is valid because we use it to reset at the start of every turn.  We have an assert to test -1 there.
	CvAssertMsg(eApproach < NUM_MINOR_CIV_APPROACHES, "DIPLOMACY_AI: Invalid MinorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeMinorCivApproach[eMinor] = eApproach;
}

/// How many Minors do we have a particular Approach towards?
int CvDiplomacyAI::GetNumMinorCivApproach(MinorCivApproachTypes eApproach) const
{
	CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MinorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach < NUM_MINOR_CIV_APPROACHES, "DIPLOMACY_AI: Invalid MinorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iCount = 0;

	for(int iMinorLoop = 0; iMinorLoop < MAX_MINOR_CIVS; iMinorLoop++)
	{
		if(GetMinorCivApproach((PlayerTypes) iMinorLoop) == eApproach)
		{
			iCount++;
		}
	}

	return iCount;
}

/// Sets if this AI want to connect to a minor with a route
void CvDiplomacyAI::SetWantToRouteConnectToMinor(PlayerTypes eMinor, bool bWant)
{
	int iArrayIndex = eMinor - MAX_MAJOR_CIVS;
	CvAssertMsg(iArrayIndex >= 0 && iArrayIndex < MAX_MINOR_CIVS, "DIPLOMACY_AI: Index into array is out of bounds");

	if(IsWantToRouteConnectToMinor(eMinor) != bWant)
		m_pabWantToRouteToMinor[iArrayIndex] = bWant;
}

/// Does this AI want to connect to a minor with a route?
bool CvDiplomacyAI::IsWantToRouteConnectToMinor(PlayerTypes eMinor)
{
	int iArrayIndex = eMinor - MAX_MAJOR_CIVS;
	CvAssertMsg(iArrayIndex >= 0 && iArrayIndex < MAX_MINOR_CIVS, "DIPLOMACY_AI: Index into array is out of bounds");
	return m_pabWantToRouteToMinor[iArrayIndex];
}

/// Does this AI have a gold quest active with any minor civ?
bool CvDiplomacyAI::IsHasActiveGoldQuest()
{
	//antonjs: consider: optimize
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes)iMinorLoop;
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsActiveQuestForPlayer(GetPlayer()->GetID(), MINOR_CIV_QUEST_GIVE_GOLD))
			return true;
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsActiveQuestForPlayer(GetPlayer()->GetID(), MINOR_CIV_QUEST_INVEST))
			return true;
	}
	return false;
}

/// Returns ePlayer's visible Approach towards us
MajorCivApproachTypes CvDiplomacyAI::GetApproachTowardsUsGuess(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(GetPlayer()->GetID(), /*bHideTrueFeelings*/ true);

	//return (MajorCivApproachTypes) m_paeApproachTowardsUsGuess[ePlayer];
}

/// Returns our guess as to another player's true Approach towards us
MajorCivApproachTypes CvDiplomacyAI::GetTrueApproachTowardsUsGuess(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return (MajorCivApproachTypes) m_paeApproachTowardsUsGuess[ePlayer];
}

/// Sets our guess as to another player's true Approach towards us
void CvDiplomacyAI::SetApproachTowardsUsGuess(PlayerTypes ePlayer, MajorCivApproachTypes eApproach)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach < NUM_MAJOR_CIV_APPROACHES, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeApproachTowardsUsGuess[ePlayer] = eApproach;
}

/// Returns how long we've thought ePlayer has had his true Approach towards us
int CvDiplomacyAI::GetApproachTowardsUsGuessCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paeApproachTowardsUsGuessCounter[ePlayer];
}

/// Sets how long we've thought ePlayer has had his true Approach towards us
void CvDiplomacyAI::SetApproachTowardsUsGuessCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting ApproachTowardsUsGuessCounter to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeApproachTowardsUsGuessCounter[ePlayer] = iValue;
}

/// Changes how long we've thought ePlayer has had his true Approach towards us
void CvDiplomacyAI::ChangeApproachTowardsUsGuessCounter(PlayerTypes ePlayer, int iChange)
{
	SetApproachTowardsUsGuessCounter(ePlayer, GetApproachTowardsUsGuessCounter(ePlayer) + iChange);
}

/// See if there's anything we need to change with our guesses as to other players' true Approaches towards us
void CvDiplomacyAI::DoUpdateApproachTowardsUsGuesses()
{
	PlayerTypes eLoopPlayer;
	MajorCivApproachTypes eVisibleApproach;
	MajorCivApproachTypes eTrueApproachGuess;
	AggressivePostureTypes eMilitaryAggressivePosture;
	AggressivePostureTypes eLastTurnMilitaryAggressivePosture;
	bool bAtWar = false;
	bool bHuman = false;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			eVisibleApproach = GetApproachTowardsUsGuess(eLoopPlayer);
			eTrueApproachGuess = GetTrueApproachTowardsUsGuess(eLoopPlayer);
			eMilitaryAggressivePosture = GetMilitaryAggressivePosture(eLoopPlayer);
			eLastTurnMilitaryAggressivePosture = GetLastTurnMilitaryAggressivePosture(eLoopPlayer);
			bAtWar = GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam());
			bHuman = GET_PLAYER(eLoopPlayer).isHuman();
			
			// If they're at war with us, then their approach is WAR for all practical purposes
			if (bAtWar && eTrueApproachGuess != MAJOR_CIV_APPROACH_WAR)
			{
				SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
				SetApproachTowardsUsGuessCounter(eLoopPlayer, 1);
				continue;
			}

#if defined(MOD_BALANCE_CORE)
			// If we just made peace, reset any guess for the WAR approach
			else if (eTrueApproachGuess == MAJOR_CIV_APPROACH_WAR && (GetNumWarsFought(eLoopPlayer) > 0 && GetPlayerNumTurnsAtPeace(eLoopPlayer) <= 1))
			{
				SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);	
			}
#endif

			// If their military deployment is very threatening and we haven't made peace recently + they aren't an AFRAID AI, assume they mean WAR
			else if (eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_HIGH)
			{
				if (eTrueApproachGuess != MAJOR_CIV_APPROACH_WAR && (bHuman || (!bHuman && eVisibleApproach != MAJOR_CIV_APPROACH_AFRAID)))
				{
#if defined(MOD_BALANCE_CORE)
					if (GetPlayerNumTurnsAtPeace(eLoopPlayer) > 10 || GetNumWarsFought(eLoopPlayer) <= 0)
					{
#endif
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
						SetApproachTowardsUsGuessCounter(eLoopPlayer, 1);
						continue;
#if defined(MOD_BALANCE_CORE)
					}
#endif
				}
			}
			
			else
			{
				// Use visible approach for AI players
				if (!bHuman)
				{
					// Are they now AFRAID of us? Then they're being honest.
					if (eVisibleApproach == MAJOR_CIV_APPROACH_AFRAID && eTrueApproachGuess != MAJOR_CIV_APPROACH_AFRAID)
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_AFRAID);
						SetApproachTowardsUsGuessCounter(eLoopPlayer, 1);
						continue;
					}
					
					// They can't be FRIENDLY or DECEPTIVE if their visible approach isn't FRIENDLY
					else if (eVisibleApproach != MAJOR_CIV_APPROACH_FRIENDLY && (eTrueApproachGuess == MAJOR_CIV_APPROACH_FRIENDLY || eTrueApproachGuess == MAJOR_CIV_APPROACH_DECEPTIVE))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
					
					// For HOSTILE, reset the guess if it doesn't match the visible approach, *unless* they denounced us (in which case we assume the worst)
					else if (eVisibleApproach != MAJOR_CIV_APPROACH_HOSTILE && eTrueApproachGuess == MAJOR_CIV_APPROACH_HOSTILE)
					{
						if (!GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
						{
							SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
						}
					}
							
					// For AFRAID or GUARDED, reset the guess if it doesn't match the visible approach
					else if (eVisibleApproach != eTrueApproachGuess && (eTrueApproachGuess == MAJOR_CIV_APPROACH_AFRAID || eTrueApproachGuess == MAJOR_CIV_APPROACH_GUARDED))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
				}
				
				// Human player
				else
				{
					// Reset any guess for the FRIENDLY approach if we have no DoF/DP, and they haven't resurrected us
					if (eTrueApproachGuess == MAJOR_CIV_APPROACH_FRIENDLY && !IsDoFAccepted(eLoopPlayer) && !GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GetTeam()) && !WasResurrectedBy(eLoopPlayer))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
					
					// Reset any guess for the FRIENDLY or DECEPTIVE approach if there's been a denouncement either way
					else if ((eTrueApproachGuess == MAJOR_CIV_APPROACH_FRIENDLY || eTrueApproachGuess == MAJOR_CIV_APPROACH_DECEPTIVE) && (IsDenouncedPlayer(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID())))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
					
					// Reset any guess for the GUARDED approach if they denounced us
					else if (eTrueApproachGuess == MAJOR_CIV_APPROACH_GUARDED && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
					
					// Reset any guess for the GUARDED approach if they befriended us or made a DP
					else if (eTrueApproachGuess == MAJOR_CIV_APPROACH_GUARDED && (IsDoFAccepted(eLoopPlayer) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GetTeam())))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
					
					// Reset any guess for the GUARDED approach if we've no longer denounced them/gone to war recently, and they don't have soldiers guarding the border
					else if (eTrueApproachGuess == MAJOR_CIV_APPROACH_GUARDED && !IsDenouncedPlayer(eLoopPlayer) && eMilitaryAggressivePosture <= AGGRESSIVE_POSTURE_MEDIUM)
#if defined(MOD_BALANCE_CORE)
					{
						if (GetNumWarsFought(eLoopPlayer) > 0)
						{
							if (GetPlayerNumTurnsAtPeace(eLoopPlayer) > 30)
							{
								SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
							}
						}
						else
#endif
						{
							SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
						}
#if defined(MOD_BALANCE_CORE)
					}
#endif
					
				}
			}
			
			ChangeApproachTowardsUsGuessCounter(eLoopPlayer, 1);

			// We have no guess, or it's been a while since our last guess...let's make a new one if we can!
			if (GetTrueApproachTowardsUsGuess(eLoopPlayer) == MAJOR_CIV_APPROACH_NEUTRAL || GetApproachTowardsUsGuessCounter(eLoopPlayer) > 30)
			{
				// Reset the counter so we don't run this check again next turn
				SetApproachTowardsUsGuessCounter(eLoopPlayer, 0);
				
				// At war?
				if (bAtWar)
				{
					SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
					continue;
				}
				
				// AI player, make a new guess based on visible approach
				if (!bHuman)
				{	
					// If not AFRAID, haven't recently made peace and their military deployment is extremely threatening, assume WAR
#if defined(MOD_BALANCE_CORE)
					if (eVisibleApproach != MAJOR_CIV_APPROACH_AFRAID && eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_HIGH && (GetPlayerNumTurnsAtPeace(eLoopPlayer) > 10 || GetNumWarsFought(eLoopPlayer) <= 0))
#else
	                if (eVisibleApproach != MAJOR_CIV_APPROACH_AFRAID && eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_HIGH)
#endif
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
					}

					else
					{
						// If they've denounced us, assume they're *at least* HOSTILE, regardless of visible approach
						if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
						{
							SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_HOSTILE);
						}
						
						// FRIENDLY? Let's not make the same mistake twice...
						else if (eVisibleApproach == MAJOR_CIV_APPROACH_FRIENDLY)
						{
							// Untrustworthy?
							if (IsUntrustworthyFriend(eLoopPlayer))
							{
								if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWeDeclaredWarOnFriendCount() > 0)
								{
									SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
								}
								else
								{
									SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_DECEPTIVE);
								}
							}
							else
							{
								SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_FRIENDLY);
							}
						}
						else
						{
							SetApproachTowardsUsGuess(eLoopPlayer, eVisibleApproach);
						}
					}
				}
				
				// Human player, make a new guess based on our current status
				else
				{	
					// Their military deployment is extremely threatening, assume WAR
#if defined(MOD_BALANCE_CORE)
					if (eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_HIGH && (GetPlayerNumTurnsAtPeace(eLoopPlayer) > 10 || GetNumWarsFought(eLoopPlayer) <= 0))
#else
					if (eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_HIGH)
#endif
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
					}
					
					// If they denounced us, assume HOSTILE
					else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_HOSTILE);
					}
					
					// If we denounced them, assume GUARDED
					else if (IsDenouncedPlayer(eLoopPlayer))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_GUARDED);
					}
					
					// They resurrected us, assume FRIENDLY
					else if (WasResurrectedBy(eLoopPlayer))
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_FRIENDLY);
					}
					
					// We're friends or we've made a Defensive Pact, assume FRIENDLY
					else if (IsDoFAccepted(eLoopPlayer) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GetTeam()))
					{
						// ...unless they're untrustworthy
						if (IsUntrustworthyFriend(eLoopPlayer))
						{
							if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWeDeclaredWarOnFriendCount() > 0)
							{
								SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
							}
							else
							{
								SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_DECEPTIVE);
							}
						}
						else
						{
							SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_FRIENDLY);
						}
					}
#if defined(MOD_BALANCE_CORE)
					// We've gone to war recently, assume GUARDED
					else if (GetNumWarsFought(eLoopPlayer) > 0 && GetPlayerNumTurnsAtPeace(eLoopPlayer) <= 30)
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_GUARDED);
					}
#endif
					// They have soldiers guarding the border, assume GUARDED
					else if (eMilitaryAggressivePosture >= AGGRESSIVE_POSTURE_MEDIUM)
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_GUARDED);
					}
					
					// We have no guess
					else
					{
						SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					}
				}
			}
		}
	}
}



// ************************************
// Demands
// ************************************



/// Is there a player we're targeting to make a demand from, backed with force?
PlayerTypes CvDiplomacyAI::GetDemandTargetPlayer() const
{
	return (PlayerTypes) m_eDemandTargetPlayer;
}

/// Sets a player we're targeting to make a demand from, backed with force
void CvDiplomacyAI::SetDemandTargetPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= NO_PLAYER, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// We could be targeting no one to make a demand (duh)
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_eDemandTargetPlayer = ePlayer;
}

/// Updates our desire to make a demand from a player
void CvDiplomacyAI::DoUpdateDemands()
{
	CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veDemandTargetPlayers;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		int iWeight = 0;

		if(IsPlayerValid(eLoopPlayer))
		{
			if (IsWarDisallowed(eLoopPlayer))
				continue;
			
			// If we can't go to war without us/our team backstabbing a friend or ally, then don't demand
			if (IsWarWouldBackstabFriendTeamCheck(eLoopPlayer))
				continue;
			
			// Is eLoopPlayer a good target for making a demand?
			if(IsPlayerDemandAttractive(eLoopPlayer))
			{
#if defined(MOD_BALANCE_CORE)
				//Get target softness.
				switch(GetPlayerTargetValue(eLoopPlayer))
				{
					case TARGET_VALUE_IMPOSSIBLE:
						continue;
					case TARGET_VALUE_BAD:
						iWeight = -10;
						break;
					case TARGET_VALUE_AVERAGE:
						iWeight = 5;
						break;
					case TARGET_VALUE_FAVORABLE:
						iWeight = 10;
						break;
					case TARGET_VALUE_SOFT:
						iWeight = 20;
						break;
					default:
						iWeight = 1;
						break;
				}
				//If we are hostile, up the weight
				if(GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_HOSTILE)
				{
					iWeight += 20;
				}
				//If we want war, up the weight a little
				else if(GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR)
				{
					iWeight += 20;
				}
				//If we are deceptive, up the weight just a bit
				else if(GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)
				{
					iWeight += 5;
				}
				else
				{
					continue;
				}
#else
				iWeight = GC.getGame().getJonRandNumVA(100, "DIPLOMACY_AI: Random weight for player to make demand of. (%d; %d)", (int)GetPlayer()->GetID(), (int)eLoopPlayer);
#endif
#if defined(MOD_BALANCE_CORE)
				if(GetPlayer()->GetProximityToPlayer(eLoopPlayer) == PLAYER_PROXIMITY_NEIGHBORS)
				{
					iWeight += 10;
				}
				else
				{
					iWeight -= 15;
				}
				if(GetMajorCivOpinion(eLoopPlayer) < MAJOR_CIV_OPINION_NEUTRAL)
				{
					iWeight += 10;
				}
				else
				{
					iWeight -= 15;
				}
				//We must be stronger.
				switch(GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer))
				{
					case STRENGTH_STRONG:
					case STRENGTH_POWERFUL:
					case STRENGTH_IMMENSE:
						continue;
						break;
					case STRENGTH_AVERAGE:
						iWeight += -5;
						break;
					case STRENGTH_POOR:
						iWeight += 5;
						break;
					case STRENGTH_WEAK:
						iWeight += 10;
						break;
					case STRENGTH_PATHETIC:
						iWeight += 20;
						break;
				}
				//We must be stronger.
				switch(GetPlayerEconomicStrengthComparedToUs(eLoopPlayer))
				{
					case STRENGTH_STRONG:
					case STRENGTH_POWERFUL:
					case STRENGTH_IMMENSE:
						iWeight -= 25;
						break;
					case STRENGTH_AVERAGE:
						iWeight += -5;
						break;
					case STRENGTH_POOR:
						iWeight += 5;
						break;
					case STRENGTH_WEAK:
						iWeight += 10;
						break;
					case STRENGTH_PATHETIC:
						iWeight += 20;
						break;
				}
				if(GetDemandTargetPlayer() == eLoopPlayer)
				{
					iWeight += 20;
				}
				if(iWeight <= 0)
				{
					continue;
				}
#endif
				veDemandTargetPlayers.push_back(eLoopPlayer, iWeight);
			}
		}
	}

	bool bCancelDemand;

	// Any valid possibilities?
	if(veDemandTargetPlayers.size() > 0)
	{
		bCancelDemand = false;

		// Only assign a player to be the target if we don't already have one
		if(GetDemandTargetPlayer() == NO_PLAYER)
		{
			veDemandTargetPlayers.SortItems();

			// Maybe change this later to a lower value (10%?) - leaving it at 100 for now because the AI has a bit of trouble getting everything together to make a demand right now
			int iChanceOfDemand = /*100*/ GC.getDEMAND_RAND();	
			if (iChanceOfDemand/10 > GC.getGame().getSmallFakeRandNum(10, veDemandTargetPlayers.GetWeight(0)))
			{
				DoStartDemandProcess(veDemandTargetPlayers.GetElement(0));
			}
		}
	}
	// No one we're hostile towards to make a demand of
	else
	{
		bCancelDemand = true;
	}

	// If we're planning on making a demand, make sure it's still a good idea
	if(GetDemandTargetPlayer() != NO_PLAYER)
	{
		if(!IsPlayerDemandAttractive(GetDemandTargetPlayer()))
		{
			bCancelDemand = true;
		}
	}

	// We're not hostile towards anyone so cancel any demand work we have underway (if there's anything going on)
	if(bCancelDemand)
	{
		DoCancelHaltDemandProcess();
	}

	// See if we have a demand ready to make
	DoTestDemandReady();
}

/// AI has picked someone to make a demand of... what does this mean?
void CvDiplomacyAI::DoStartDemandProcess(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	SetDemandTargetPlayer(ePlayer);

	CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetShowOfForceOperation((ePlayer));

	// Not yet readying an attack
	if(pOperation == NULL && !IsArmyInPlaceForAttack(ePlayer))
	{
		if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam()))
#endif
			{
				GetPlayer()->GetMilitaryAI()->RequestShowOfForce(ePlayer);
				SetWarGoal(ePlayer, WAR_GOAL_DEMAND);
			}
		}
	}
}

/// Stop any current progress towards making a demand
void CvDiplomacyAI::DoCancelHaltDemandProcess()
{
	PlayerTypes eDemandTarget = GetDemandTargetPlayer();

	// Are we actually targeting anyone for a demand?
	if(eDemandTarget != NO_PLAYER)
	{
		//CvAssertMsg(GetWarGoal(eDemandTarget) == WAR_GOAL_DEMAND, "DIPLOMACY_AI: AI was preparing to make a demand, but somehow doesn't have an appropriate WarGoal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		if(GetWarGoal(eDemandTarget) == WAR_GOAL_DEMAND)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetMajorCivApproach(eDemandTarget, false) == MAJOR_CIV_APPROACH_WAR)
			{
				SetWarGoal(eDemandTarget, WAR_GOAL_PREPARE);
			}
			else
			{
#endif
			SetWarGoal(eDemandTarget, NO_WAR_GOAL_TYPE);

			// Get rid of the operation to put Units near them
			CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetShowOfForceOperation(eDemandTarget);
			if(pOperation != NULL)
			{
				pOperation->SetToAbort(AI_ABORT_DIPLO_OPINION_CHANGE);
				SetArmyInPlaceForAttack(eDemandTarget, false);
			}
#if defined(MOD_BALANCE_CORE)
			}
#endif
		}

		SetDemandTargetPlayer(NO_PLAYER);
		SetDemandReady(false);
	}
}

/// Are we ready to make a demand, backed with force?
void CvDiplomacyAI::DoTestDemandReady()
{
	PlayerTypes eDemandTarget = GetDemandTargetPlayer();

	// Are we actually targeting anyone for a demand?
	if(eDemandTarget != NO_PLAYER)
	{
		if(GetWarGoal(eDemandTarget) == WAR_GOAL_DEMAND)
		{
			CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetShowOfForceOperation(eDemandTarget);

			if(pOperation)
			{
				if(!IsAtWar(eDemandTarget))
				{
					// If we're at least 85% of the way to our objective, let loose the dogs of war!
					if(IsArmyInPlaceForAttack(eDemandTarget) || (pOperation != NULL && pOperation->PercentFromMusterPointToTarget() >= 50))
					{
						SetArmyInPlaceForAttack(eDemandTarget, false);

						SetDemandReady(true);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			else
			{
				GetPlayer()->GetMilitaryAI()->RequestShowOfForce(eDemandTarget);
			}
#endif
		}
	}
	if (IsDemandReady() && eDemandTarget != NO_PLAYER)
	{
		DiploStatementTypes eStatement;

		// We can use this deal pointer to form a trade offer
		CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

		// These can be used for info about deal items, e.g. what Minor Civ we're telling the guy to stay away from, etc.
		int iData1;
		int iData2;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			//End the gift exchange at the start of each round.
			GetPlayer()->GetDiplomacyAI()->SetOfferingGift(eDemandTarget, false);
			GetPlayer()->GetDiplomacyAI()->SetOfferedGift(eDemandTarget, false);
		}
#endif
#if defined(MOD_BALANCE_CORE)
		pDeal->SetRequestingPlayer(NO_PLAYER);
#endif
#if defined(MOD_BALANCE_CORE)
		//Clear this data out before any deals are offered.
		SetCantMatchDeal(eDemandTarget, false);
#endif

		eStatement = NO_DIPLO_STATEMENT_TYPE;

		iData1 = -1;
		iData2 = -1;

		pDeal->ClearItems();
		pDeal->SetFromPlayer(GetPlayer()->GetID());
		pDeal->SetToPlayer(eDemandTarget);

		DoMakeDemand(eDemandTarget, eStatement, pDeal);
		
		GET_PLAYER(eDemandTarget).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_HOSTILE);
		GET_PLAYER(eDemandTarget).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);
		
	}
}

/// Are we ready to make a demand to GetDemandTargetPlayer?
bool CvDiplomacyAI::IsDemandReady()
{
	return m_bDemandReady;
}

/// Sets that we are ready to make a demand to GetDemandTargetPlayer (or not)
void CvDiplomacyAI::SetDemandReady(bool bValue)
{
	m_bDemandReady = bValue;
}

/// Are we willing to make a demand of ePlayer?
bool CvDiplomacyAI::IsPlayerDemandAttractive(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Being hostile towards this guy? (ignore war face, as if we're planning a war already, making a demand doesn't mesh well with that)
#if defined(MOD_BALANCE_CORE)
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		return false;
	}
	if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_AFRAID || GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_FRIENDLY)
#else
	if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) != MAJOR_CIV_APPROACH_HOSTILE)
#endif
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE)
	//If not deceptive or worse, don't make a demand
	if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) >= MAJOR_CIV_APPROACH_GUARDED)
	{
		return false;
	}
	// Player can't be distant
	if(GetPlayer()->GetProximityToPlayer(ePlayer) <= PLAYER_PROXIMITY_FAR)
	{
		return false;
	}
#else
	// Player can't be distant
	if(GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_FAR)
	{
		return false;
	}
#endif
	// If they're a bad or impossible target then that's not good at all for us
	if(GetPlayerTargetValue(ePlayer) <= TARGET_VALUE_AVERAGE)
	{
		return false;
	}

	// Don't make demands of them too often
	if(GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DEMAND) < 40)
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE)
	if(IsAtWar(ePlayer))
	{
		return false;
	}
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if(!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
	if(!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam()))
#endif
	{
		return false;
	}
#endif

	int iIdealValue = 10 * (GetPlayer()->GetDiplomacyAI()->GetMeanness() + GetPlayer()->GetCurrentEra());
	int Value = NUM_STRENGTH_VALUES - (int)GetPlayer()->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if (Value > 0)
	{
		iIdealValue *= Value;
	}

	// We can use this deal pointer to form a trade offer
	CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

	pDeal->SetRequestingPlayer(NO_PLAYER);
	pDeal->SetFromPlayer(GetPlayer()->GetID());
	pDeal->SetToPlayer(ePlayer);

	int iActualValue = GetPlayer()->GetDealAI()->GetPotentialDemandValue(ePlayer, pDeal);

	pDeal->ClearItems();

	if (iActualValue < (iIdealValue/2))
		return false;

	bool bAlreadyPlanning = false;
	// If we're planning a demand or at war with anyone, making another demand is unwise
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

#if defined(MOD_BALANCE_CORE)
		if(ePlayer == eLoopPlayer)
		{
			continue;
		}
#endif
		if (eLoopPlayer == GetDemandTargetPlayer())
		{
			bAlreadyPlanning = true;
		}

		if(IsAtWar(eLoopPlayer))
		{
			return false;
		}
	}
	if (bAlreadyPlanning)
		return false;
	// Player has to be on the same area as us
	if(GetPlayer()->getCapitalCity() != NULL)
	{
		if(GET_PLAYER(ePlayer).getCapitalCity() != NULL)
		{
			if(GetPlayer()->getCapitalCity()->getArea() == GET_PLAYER(ePlayer).getCapitalCity()->getArea())
			{
				return true;
			}
		}
	}
	return false;
}



/////////////////////////////////////////////////////////
// Requests
/////////////////////////////////////////////////////////




/// Is this AI willing to make a request of ePlayer?
bool CvDiplomacyAI::IsMakeRequest(PlayerTypes ePlayer, CvDeal* pDeal, bool& bRandPassed)
{
	bool bFriendly = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_FRIENDLY;

	if(bFriendly && IsDoFAccepted(ePlayer))
	{
		// Is there something we want?
		bool bWantsSomething = false;
		// Is there a strong reason why we want something? (added to rand roll)
		int iWeightBias = 0;

		// Luxury Request
		if(!bWantsSomething)
			bWantsSomething = IsLuxuryRequest(ePlayer, pDeal, iWeightBias);
		// Gold Request
		if(!bWantsSomething)
			bWantsSomething = IsGoldRequest(ePlayer, pDeal, iWeightBias);

		if(bWantsSomething)
		{
			// Random element
			int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			iRand += iWeightBias;

			if(iRand >= 7)
			{
				bRandPassed = true;
				return true;
			}
			else
			{
				bRandPassed = false;
				return false;
			}
		}
	}

	return false;
}

/// Does this AI want a luxury resource gift from ePlayer?
bool CvDiplomacyAI::IsLuxuryRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	iWeightBias = 0;

	ResourceTypes eLuxuryToAskFor = NO_RESOURCE;

	int iResourceLoop;

	// See if the other player has a Resource to trade
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if(pkResourceInfo)
		{
			// Only look at Luxuries
			if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(ePlayer, GetPlayer()->GetID(), TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			eLuxuryToAskFor = eResource;
			break;
		}
	}

	// Didn't find something they could give us?
	if(eLuxuryToAskFor == NO_RESOURCE)
		return false;

	// See if there's any Luxuries WE can trade (because if there are then we shouldn't be asking for hand outs)
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			// Only look at Luxuries
			if(pkResource->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GetPlayer()->getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), ePlayer, TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			// Found something we can trade to them, so abort
			return false;
		}
	}

	// Add a little something extra since we're in dire straits
	if(GetPlayer()->IsEmpireUnhappy())
		iWeightBias += 5;

	// Now seed the deal
	pDeal->AddResourceTrade(ePlayer, eLuxuryToAskFor, 1, GC.getGame().GetDealDuration());

	return true;
}

/// Does this AI want a gold gift from ePlayer?
bool CvDiplomacyAI::IsGoldRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	iWeightBias = 0;

	int iOurGold = GetPlayer()->GetTreasury()->GetGold();
	int iOurGPT = GetPlayer()->calculateGoldRate();
	int iOurExpenses = GetPlayer()->GetTreasury()->CalculateInflatedCosts();
	int iOurGrossIncome = iOurGPT + iOurExpenses;

	// If we have no expenses, don't ask (and also don't crash)
	if(iOurExpenses == 0)
		return false;

	// If we already have some gold saved up then don't bother
	if(iOurGold > 100)
		return false;

	// If we're making 35% more than we're spending then don't ask, we're doing alright
	if(iOurGrossIncome * 100 / iOurExpenses > 135)
		return false;

	int iTheirGold = GET_PLAYER(ePlayer).GetTreasury()->GetGold();
	int iTheirGPT = GET_PLAYER(ePlayer).calculateGoldRate();
	int iTheirExpenses = GET_PLAYER(ePlayer).GetTreasury()->CalculateInflatedCosts();
	int iTheirGrossIncome = iTheirGPT + iTheirExpenses;

	// Don't divide by zero please
	if(iTheirExpenses != 0)
	{
		// If they're making less than 35% more than they're spending then don't ask, they're not in great shape
		if(iTheirGrossIncome * 100 / iTheirExpenses < 135)
			return false;
	}
	else if(iTheirGPT <= iOurGPT)
	{
		return false;
	}

	// Add a little something extra since we're in dire straits
	if(iOurGPT < 0)
		iWeightBias += 5;

	// If we've made it this far we'd like to ask, so figure out how much we want to ask for
	int iGoldToAskFor = iTheirGPT * GC.getGame().GetDealDuration() / 5;
	int iGPTToAskFor = 0;

	if(iGoldToAskFor > iTheirGold)
	{
		iGoldToAskFor = 0;
		iGPTToAskFor = max(1, iTheirGPT / 6);
	}

	// Now seed the deal
	if(iGoldToAskFor > 0)
		pDeal->AddGoldTrade(ePlayer, iGoldToAskFor);
	else if(iGPTToAskFor > 0)
		pDeal->AddGoldPerTurnTrade(ePlayer, iGPTToAskFor, GC.getGame().GetDealDuration());

	return true;
}

/// Are we willing to swap embassies with ePlayer?
bool CvDiplomacyAI::IsEmbassyExchangeAcceptable(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
#if defined(MOD_BALANCE_CORE)
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
	{
		return false;
	}
#endif
	switch(eApproach)
	{
	case MAJOR_CIV_APPROACH_WAR:
	case MAJOR_CIV_APPROACH_HOSTILE:
	case MAJOR_CIV_APPROACH_GUARDED:
		return false;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
	case MAJOR_CIV_APPROACH_AFRAID:
	case MAJOR_CIV_APPROACH_FRIENDLY:
	case MAJOR_CIV_APPROACH_NEUTRAL:
		return true;
	}

	return false;
}

/// Do we want to have an embassy in the player's capital? - this is only used for when to trigger an AI request, not whether or not the AI will accept a deal period
bool CvDiplomacyAI::WantsEmbassyAtPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// May want to make this logic more sophisticated eventually.  This will do for now
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
	        eApproach == MAJOR_CIV_APPROACH_WAR)
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE)
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
	{
		return false;
	}
	if(IsArmyInPlaceForAttack(ePlayer))
	{
		return false;
	}
	if(IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
#endif

	return true;
}

/// Do we want Open Borders with eOtherPlayer? - this is only used for when to trigger an AI request, not whether or not the AI will accept a deal period
bool CvDiplomacyAI::IsWantsOpenBordersWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

#if defined (MOD_BALANCE_FLIPPED_TOURISM_MODIFIER_OPEN_BORDERS)
	//If they need influence over us, we don't want their OB, thanks.
	if ((GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) > INFLUENCE_LEVEL_FAMILIAR) && (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(m_pPlayer->GetID()) >= INFLUENCE_TREND_STATIC))
	{
		return false;
	}
#else
	//If we need influence over them, we want their OB, thanks.
	if ((m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) > INFLUENCE_LEVEL_FAMILIAR) && (m_pPlayer->GetCulture()->GetInfluenceTrend(ePlayer) >= INFLUENCE_TREND_STATIC))
	{
		return true;
	}
#endif

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (IsVassal(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetPlayer()->GetID()))
		return true;
#endif

#if defined(MOD_BALANCE_CORE)
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
	{
		return false;
	}
	if(IsArmyInPlaceForAttack(ePlayer))
	{
		return false;
	}
	if(IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
	if (GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) || IsDoFAccepted(ePlayer))
	{
		return true;
	}
#endif

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if(m_pPlayer->IsCramped() || (GET_PLAYER(ePlayer).getNumCities() * 3) > (m_pPlayer->getNumCities() * 2))
#else
	if(GetPlayer()->GetProximityToPlayer(ePlayer) != PLAYER_PROXIMITY_NEIGHBORS)
#endif
	{
		return true;
	}

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
	if (eApproach >= MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE)
	EconomicAIStrategyTypes eNeedRecon = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON");
	EconomicAIStrategyTypes eNavalRecon = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON_SEA");
	if(eNeedRecon != NO_ECONOMICAISTRATEGY && m_pPlayer->GetEconomicAI()->IsUsingStrategy(eNeedRecon))
	{
		return true;
	}
	if(eNavalRecon != NO_ECONOMICAISTRATEGY && m_pPlayer->GetEconomicAI()->IsUsingStrategy(eNavalRecon))
	{
		CvCity* pLoopCity = NULL;
		int iCityLoop;
		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
		{
			if(pLoopCity != NULL && pLoopCity->isCoastal())
			{
				return true;
			}
		}
	}
	if(MusteringForNeighborAttack(ePlayer) || IsGoingForWorldConquest() || IsGoingForCultureVictory())
	{
		return true;
	}
	AICityStrategyTypes ePocketCity = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_POCKET_CITY");
	if(ePocketCity != NO_AICITYSTRATEGY && GetPlayer()->GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
	{
		CvCity* pLoopCity = NULL;
		int iCityLoop;
		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
		{
			if(pLoopCity != NULL && pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(ePocketCity))
			{
				return true;
			}
		}
	}
#endif
	return false;
}

/// Do we want to give Open Borders to eOtherPlayer?
bool CvDiplomacyAI::IsWillingToGiveOpenBordersToPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

#if defined(MOD_BALANCE_CORE)
	// Are they here to steal our PRICELESS ARCHAEOLOGICAL ARTIFACTS???
	if (GetNegativeArchaeologyPoints(ePlayer) > 0 || IsPlayerMadeNoDiggingPromise(ePlayer) ||
		IsPlayerIgnoredNoDiggingPromise(ePlayer) || IsPlayerBrokenNoDiggingPromise(ePlayer))
	{
		int iHiddenSites = GetPlayer()->GetEconomicAI()->GetVisibleHiddenAntiquitySitesOwnTerritory();
		int iNormalSites = GetPlayer()->GetEconomicAI()->GetVisibleAntiquitySitesOwnTerritory() - iHiddenSites;
		PolicyBranchTypes eArtistry = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
		
		if (iNormalSites > 0)
		{
			return false;
		}
		// Have they unlocked Artistry?
		if (iHiddenSites > 0 && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(eArtistry))
		{
			return false;
		}
	}
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDominationVictory())
	{
		return false;
	}
#endif

// If going for culture win we always want open borders against civs we need influence on
#if defined (MOD_BALANCE_FLIPPED_TOURISM_MODIFIER_OPEN_BORDERS)
	//If we need influence over them, we want to give OB, thanks.
	if ((m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) > INFLUENCE_LEVEL_FAMILIAR) && (m_pPlayer->GetCulture()->GetInfluenceTrend(ePlayer) >= INFLUENCE_TREND_STATIC))
	{
		return true;
	}
#else
	//If we need influence over them, we want to give OB, thanks.
	if ((GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) > INFLUENCE_LEVEL_FAMILIAR) && (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(m_pPlayer->GetID()) >= INFLUENCE_TREND_STATIC))
	{
		return false;
	}
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (IsVassal(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetPlayer()->GetID()))
		return true;
#endif
#if defined(MOD_BALANCE_CORE)
	if (IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
	{
		return false;
	}
	if (IsArmyInPlaceForAttack(ePlayer) || IsWantsSneakAttack(ePlayer))
	{
		return false;
	}
	if (GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) || IsDoFAccepted(ePlayer))
	{
		return true;
	}
#endif

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
	if (eApproach >= MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}
	if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE)
	{
		return true;
	}

#if defined(MOD_BALANCE_CORE)
	if (!GET_PLAYER(ePlayer).isHuman() && GET_PLAYER(ePlayer).GetDiplomacyAI()->MusteringForNeighborAttack(m_pPlayer->GetID()))
	{
		return true;
	}
#endif
	return false;
}

/// Are we willing to swap Open Borders with ePlayer?
bool CvDiplomacyAI::IsOpenBordersExchangeAcceptable(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if (IsWillingToGiveOpenBordersToPlayer(ePlayer) && IsWantsOpenBordersWithPlayer(ePlayer))
		return true;
#endif

	return false;
}

// ************************************
// Peace!
// ************************************


#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
/// Make peace with vassals if we're not at war with the master
void CvDiplomacyAI::DoMakePeaceWithVassals()
{
	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(eLoopPlayer != NO_PLAYER && IsPlayerValid(eLoopPlayer))
		{
			if(IsAtWar(eLoopPlayer) && GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassalOfSomeone())
			{
				TeamTypes eMaster = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetMaster();
				if(eMaster != NO_TEAM && !GET_TEAM(GetTeam()).isAtWar(eMaster))
				{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
					GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetPlayer()->GetID());
#else
					GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam());
#endif
				}
			}
		}
	}
}
#endif

/// Do we want to make peace with any Minors we're at war with?
void CvDiplomacyAI::DoMakePeaceWithMinors()
{
	if((int)m_eTargetPlayer >= (int)DIPLO_FIRST_PLAYER)
		return;

	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(eLoopPlayer != NO_PLAYER)
		{
			if(GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				if(IsAtWar(eLoopPlayer))
				{
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
					if(MOD_DIPLOMACY_CIV4_FEATURES && !GET_TEAM(GetPlayer()->getTeam()).IsVassalLockedIntoWar(GET_PLAYER(eLoopPlayer).getTeam()))	// Vassals can't make peace if their master is at war
					{
						if(IsWantsPeaceWithPlayer(eLoopPlayer) && GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(eLoopPlayer).getTeam()) <= 0)	// Locked into war for a period of time? (coop war, war deal, etc.)
						{
							if(!GET_PLAYER(eLoopPlayer).GetMinorCivAI()->IsPeaceBlocked(GetPlayer()->getTeam()))
							{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
								GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetPlayer()->GetID());
#else
								GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam());
#endif

								LogPeaceMade(eLoopPlayer);
							}
						}
					}
					else
#else
					if(IsWantsPeaceWithPlayer(eLoopPlayer) && GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(eLoopPlayer).getTeam()) == 0)	// Locked into war for a period of time? (coop war, war deal, etc.)
#endif
					{
						if(!GET_PLAYER(eLoopPlayer).GetMinorCivAI()->IsPeaceBlocked(GetPlayer()->getTeam()))
						{
#if defined(MOD_BALANCE_CORE)
							if(IsWantsPeaceWithPlayer(eLoopPlayer) && GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(eLoopPlayer).getTeam()) <= 0)
							{
#endif
#if defined(MOD_EVENTS_WAR_AND_PEACE)
							GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam(), true, false, GetPlayer()->GetID());
#else
							GET_TEAM(GetTeam()).makePeace(GET_PLAYER(eLoopPlayer).getTeam());
#endif

							LogPeaceMade(eLoopPlayer);
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
				}
			}
		}
	}
}

/// Updates what peace treaties we're willing to offer and accept
void CvDiplomacyAI::DoUpdatePeaceTreatyWillingness()
{
	PeaceTreatyTypes eTreatyWillingToOffer, eTreatyWillingToAccept;
	int iWillingToOfferScore, iWillingToAcceptScore;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	TeamTypes eLoopTeam;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

			eTreatyWillingToOffer = NO_PEACE_TREATY_TYPE;
			eTreatyWillingToAccept = NO_PEACE_TREATY_TYPE;
			iWillingToOfferScore = 0;
			iWillingToAcceptScore = 0;

			if(IsAtWar(eLoopPlayer))
			{
				// Have to be at war with the human for a certain amount of time before the AI will agree to peace
				// No special rules for humans in VP
				if(GET_PLAYER(eLoopPlayer).isHuman())
				{
					if(!IsWillingToMakePeaceWithHuman(eLoopPlayer))
					{
						SetTreatyWillingToOffer(eLoopPlayer, NO_PEACE_TREATY_TYPE);
						SetTreatyWillingToAccept(eLoopPlayer, NO_PEACE_TREATY_TYPE);

						continue;
					}
				}
				else
				{
					//don't give up if we're about to score!
					if (!IsWantsPeaceWithPlayer(eLoopPlayer))
					{
						SetTreatyWillingToOffer(eLoopPlayer, NO_PEACE_TREATY_TYPE);
						SetTreatyWillingToAccept(eLoopPlayer, NO_PEACE_TREATY_TYPE);

						continue;
					}
				}

				// If we're out for conquest then no peace!
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				//Correction - we want conquest, but if the war has stalled out and/or we're losing all our wars, let's consider peace.
				if(GetWarGoal(eLoopPlayer) != WAR_GOAL_CONQUEST || GetWarState(eLoopPlayer) < WAR_STATE_STALEMATE || GetStateAllWars() == STATE_ALL_WARS_LOSING || GetPlayer()->IsEmpireVeryUnhappy())
#else
				if(GetWarGoal(eLoopPlayer) != WAR_GOAL_CONQUEST)
#endif
				{
					// What we're willing to give up.  The higher the number the more we're willing to part with

					int iWarScore = GetWarScore(eLoopPlayer,false);

#if defined(MOD_BALANCE_CORE_HAPPINESS)
					if (MOD_BALANCE_CORE_HAPPINESS && (GetPlayer()->GetCulture()->GetWarWeariness() > 0))
					{
						if (iWarScore <= 0)
						{
							iWillingToOfferScore += (GetPlayer()->GetCulture()->GetWarWeariness());
						}
						else
						{
							iWillingToAcceptScore -= (GetPlayer()->GetCulture()->GetWarWeariness());
						}
					}
#endif

					//Negative Warscore? Offer more.
					if(iWarScore < 0)
					{
						iWillingToOfferScore -= iWarScore;
					}
					//Postitive Warscore? Accept more.
					else
					{
						iWillingToAcceptScore += iWarScore;
					}

					// Do the final assessment
					if(iWillingToOfferScore >= /*180*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_UN_SURRENDER())
						eTreatyWillingToOffer = PEACE_TREATY_UNCONDITIONAL_SURRENDER;
					else if(iWillingToOfferScore >= /*150*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_CAPITULATION())
						eTreatyWillingToOffer = PEACE_TREATY_CAPITULATION;
					else if(iWillingToOfferScore >= /*120*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_CESSION())
						eTreatyWillingToOffer = PEACE_TREATY_CESSION;
					else if(iWillingToOfferScore >= /*95*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SURRENDER())
						eTreatyWillingToOffer = PEACE_TREATY_SURRENDER;
					else if(iWillingToOfferScore >= /*70*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SUBMISSION())
						eTreatyWillingToOffer = PEACE_TREATY_SUBMISSION;
					else if(iWillingToOfferScore >= /*55*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_BACKDOWN())
						eTreatyWillingToOffer = PEACE_TREATY_BACKDOWN;
					else if(iWillingToOfferScore >= /*40*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_SETTLEMENT())
						eTreatyWillingToOffer = PEACE_TREATY_SETTLEMENT;
					else if(iWillingToOfferScore >= /*20*/ GC.getPEACE_WILLINGNESS_OFFER_THRESHOLD_ARMISTICE())
						eTreatyWillingToOffer = PEACE_TREATY_ARMISTICE;
					else	// War Score could be negative here, but we're already assuming this player wants peace.  But he's not willing to give up anything for it
						eTreatyWillingToOffer = PEACE_TREATY_WHITE_PEACE;

					// Do the final assessment
					if(iWillingToAcceptScore >= /*150*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_UN_SURRENDER())
						eTreatyWillingToAccept = PEACE_TREATY_UNCONDITIONAL_SURRENDER;
					else if(iWillingToAcceptScore >= /*115*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CAPITULATION())
						eTreatyWillingToAccept = PEACE_TREATY_CAPITULATION;
					else if(iWillingToAcceptScore >= /*80*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CESSION())
						eTreatyWillingToAccept = PEACE_TREATY_CESSION;
					else if(iWillingToAcceptScore >= /*65*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SURRENDER())
						eTreatyWillingToAccept = PEACE_TREATY_SURRENDER;
					else if(iWillingToAcceptScore >= /*50*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SUBMISSION())
						eTreatyWillingToAccept = PEACE_TREATY_SUBMISSION;
					else if(iWillingToAcceptScore >= /*35*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_BACKDOWN())
						eTreatyWillingToAccept = PEACE_TREATY_BACKDOWN;
					else if(iWillingToAcceptScore >= /*20*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SETTLEMENT())
						eTreatyWillingToAccept = PEACE_TREATY_SETTLEMENT;
					else if(iWillingToAcceptScore >= /*10*/ GC.getPEACE_WILLINGNESS_ACCEPT_THRESHOLD_ARMISTICE())
						eTreatyWillingToAccept = PEACE_TREATY_ARMISTICE;
					else// if (iWillingToAcceptScore >= /*0*/ GC.get())
						eTreatyWillingToAccept = PEACE_TREATY_WHITE_PEACE;

					// If we're losing all wars then let's go ahead and accept a white peace
					if (GetStateAllWars() == STATE_ALL_WARS_LOSING)
					{
						eTreatyWillingToAccept = PEACE_TREATY_WHITE_PEACE;
					}
				}
			}

			SetTreatyWillingToOffer(eLoopPlayer, eTreatyWillingToOffer);
			SetTreatyWillingToAccept(eLoopPlayer, eTreatyWillingToAccept);
		}
	}
}

bool CvDiplomacyAI::IsWillingToMakePeaceWithHuman(PlayerTypes ePlayer)
{
	//no special rules ...
	return IsWantsPeaceWithPlayer(ePlayer);
}

/// What are we willing to give up to ePlayer to make peace?
PeaceTreatyTypes CvDiplomacyAI::GetTreatyWillingToOffer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (PeaceTreatyTypes) m_paePeaceTreatyWillingToOffer[ePlayer];
}

/// Sets what we are willing to give up to ePlayer to make peace
void CvDiplomacyAI::SetTreatyWillingToOffer(PlayerTypes ePlayer, PeaceTreatyTypes eTreaty)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTreaty >= NO_PEACE_TREATY_TYPE, "DIPLOMACY_AI: Invalid PeaceTreatyType Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTreaty < NUM_PEACE_TREATY_TYPES, "DIPLOMACY_AI: Invalid PeaceTreatyType Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePeaceTreatyWillingToOffer[ePlayer] = eTreaty;
}

/// What are we willing to accept from ePlayer to make peace?
PeaceTreatyTypes CvDiplomacyAI::GetTreatyWillingToAccept(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (PeaceTreatyTypes) m_paePeaceTreatyWillingToAccept[ePlayer];
}

/// Sets what we are willing to accept from ePlayer to make peace
void CvDiplomacyAI::SetTreatyWillingToAccept(PlayerTypes ePlayer, PeaceTreatyTypes eTreaty)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTreaty >= NO_PEACE_TREATY_TYPE, "DIPLOMACY_AI: Invalid PeaceTreatyType Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTreaty < NUM_PEACE_TREATY_TYPES, "DIPLOMACY_AI: Invalid PeaceTreatyType Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePeaceTreatyWillingToAccept[ePlayer] = eTreaty;
}

/// Do we actually want peace with ePlayer?
bool CvDiplomacyAI::IsWantsPeaceWithPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayerNumTurnsAtWar(ePlayer) <= GD_INT_GET(WAR_MAJOR_MINIMUM_TURNS) || !GET_TEAM(m_pPlayer->getTeam()).canChangeWarPeace(GET_PLAYER(ePlayer).getTeam()))
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strDesc;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("Cannot change war/peace yet!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	//Vassals will never want peace with a player if their master is at war with a player.
	if(MOD_DIPLOMACY_CIV4_FEATURES)
	{
		TeamTypes eMasterTeam = GET_TEAM(m_pPlayer->getTeam()).GetMaster();
		if(eMasterTeam != NO_TEAM)
		{
			if(GET_TEAM(eMasterTeam).isAtWar(GET_PLAYER(ePlayer).getTeam()))
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strOutBuf;
					CvString strBaseString;
					CvString playerName;
					CvString otherPlayerName;
					CvString strDesc;
					CvString strLogName;

					// Find the name of this civ and city
					playerName = m_pPlayer->getCivilizationShortDescription();

					// Open the log file
					if (GC.getPlayerAndCityAILogSplit())
					{
						strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
					}
					else
					{
						strLogName = "DiplomacyAI_Peace_Log.csv";
					}

					FILogFile* pLog;
					pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

					// Get the leading info for this line
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
					strBaseString += playerName + " VS. " + otherPlayerName;

					strOutBuf.Format("Vassals cannot change war/peace!");

					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
				return false;
			}
		}
		//We don't want peace with vassals.
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strOutBuf;
				CvString strBaseString;
				CvString playerName;
				CvString otherPlayerName;
				CvString strDesc;
				CvString strLogName;

				// Find the name of this civ and city
				playerName = m_pPlayer->getCivilizationShortDescription();

				// Open the log file
				if (GC.getPlayerAndCityAILogSplit())
				{
					strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
				}
				else
				{
					strLogName = "DiplomacyAI_Peace_Log.csv";
				}

				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

				// Get the leading info for this line
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
				strBaseString += playerName + " VS. " + otherPlayerName;

				strOutBuf.Format("Vassals cannot change war/peace!");

				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			return false;
		}
	}
#endif

#if defined(MOD_BALANCE_CORE)
	if (!GET_PLAYER(ePlayer).isMinorCiv())
	{
		if (m_pPlayer->GetDiplomacyAI()->GetWarScore(ePlayer) <= -95 + GC.getGame().getSmallFakeRandNum(3, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			return true;
	}

	if (GET_PLAYER(ePlayer).HasCityInDanger(true,0) && !m_pPlayer->HasCityInDanger(true,0))
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strDesc;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format("No peace! We're about to score, and our cities are safe!");

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		if(GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_CONQUEST)
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strOutBuf;
				CvString strBaseString;
				CvString playerName;
				CvString otherPlayerName;
				CvString strDesc;
				CvString strLogName;

				// Find the name of this civ and city
				playerName = m_pPlayer->getCivilizationShortDescription();

				// Open the log file
				if (GC.getPlayerAndCityAILogSplit())
				{
					strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
				}
				else
				{
					strLogName = "DiplomacyAI_Peace_Log.csv";
				}

				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

				// Get the leading info for this line
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
				strBaseString += playerName + " VS. " + otherPlayerName;

				strOutBuf.Format("We want to conquer this minor!");

				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			return false;
		}
		else
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strOutBuf;
				CvString strBaseString;
				CvString playerName;
				CvString otherPlayerName;
				CvString strDesc;
				CvString strLogName;

				// Find the name of this civ and city
				playerName = m_pPlayer->getCivilizationShortDescription();

				// Open the log file
				if (GC.getPlayerAndCityAILogSplit())
				{
					strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
				}
				else
				{
					strLogName = "DiplomacyAI_Peace_Log.csv";
				}

				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

				// Get the leading info for this line
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
				strBaseString += playerName + " VS. " + otherPlayerName;

				strOutBuf.Format("We no longer want to conquer this minor!");

				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			return true;
		}
	}
	else
	{
		if(GetPlayerNumTurnsAtWar(ePlayer) < GD_INT_GET(WAR_MAJOR_MINIMUM_TURNS))
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strOutBuf;
				CvString strBaseString;
				CvString playerName;
				CvString otherPlayerName;
				CvString strDesc;
				CvString strLogName;

				// Find the name of this civ and city
				playerName = m_pPlayer->getCivilizationShortDescription();

				// Open the log file
				if (GC.getPlayerAndCityAILogSplit())
				{
					strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
				}
				else
				{
					strLogName = "DiplomacyAI_Peace_Log.csv";
				}

				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

				// Get the leading info for this line
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
				strBaseString += playerName + " VS. " + otherPlayerName;

				strOutBuf.Format("It is too soon to end war!");

				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			return false;
		}
		int iRequestPeaceTurnThreshold = /*10*/ GC.getREQUEST_PEACE_TURN_THRESHOLD();
		iRequestPeaceTurnThreshold -= m_pPlayer->GetMilitaryAI()->GetNumberCivsAtWarWith(false);

		int iWantPeace = 0;
		//negative warscore means we're losing - so peace desire is higher!
		int iWarScore = m_pPlayer->GetDiplomacyAI()->GetWarScore(ePlayer);
		if (iWarScore < 0)
		{
			iWantPeace += ((iWarScore / 10) * -1);
		}
		//positive means we are winning - let's ride this out until we get a good peace deal.
		else
		{
			//If we get a bonus from high warscore, let's not end early!
			if (m_pPlayer->GetPositiveWarScoreTourismMod() > 0)
			{
				iWantPeace -= (iWarScore / 10);
			}
			else
			{
				iWantPeace += (iWarScore / 15);
				//At 100? Let's end this (unless we can ride this out!
				if (iWarScore == 100)
					iWantPeace += 5;
			}
		}

		int iWarWeariness = m_pPlayer->GetCulture()->GetWarWeariness();
		iWantPeace += (iWarWeariness / 4);

		if (iWarWeariness > 0 && m_pPlayer->IsEmpireUnhappy())
		{
			iWantPeace += (iWarWeariness / 3);
		}
		CvCity* pLoopCity;
		int iOurDanger = 0;
		int iTheirDanger = 0;
		int iLoop;
		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))
		{
			if(pLoopCity == NULL)
				continue;

			//look at the tactical map (is it up to date?)
			CvTacticalDominanceZone* pLandZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
			CvTacticalDominanceZone* pWaterZone = m_pPlayer->GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
			if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iOurDanger++;
			if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iOurDanger++;

			if (pLoopCity->isUnderSiege() || pLoopCity->isInDangerOfFalling() || pLoopCity->IsBlockadedWaterAndLand())
				iOurDanger++;

			if (pLoopCity->IsInDanger(ePlayer))
				iOurDanger++;
		}

		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
		{
			if(pLoopCity == NULL)
				continue;

			//look at the tactical map (is it up to date?)
			CvTacticalDominanceZone* pLandZone = GET_PLAYER(ePlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,false);
			CvTacticalDominanceZone* pWaterZone = GET_PLAYER(ePlayer).GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByCity(pLoopCity,true);
			
			if (pLandZone && pLandZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iTheirDanger++;
			else if (pWaterZone && pWaterZone->GetOverallDominanceFlag()==TACTICAL_DOMINANCE_ENEMY)
				iTheirDanger++;

			if (pLoopCity->isUnderSiege() || pLoopCity->isInDangerOfFalling() || pLoopCity->IsBlockadedWaterAndLand())
				iTheirDanger++;

			if (pLoopCity->IsInDanger(m_pPlayer->GetID()))
				iTheirDanger++;
		}
		
		iWantPeace += iOurDanger;
		iWantPeace += (iTheirDanger * -1);

		//Lack of progress in war increases desire for peace.
		iWantPeace += max(0, GetPlayerNumTurnsSinceCityCapture(ePlayer) - 12 ); 

		//Num of turns since they captured a city?
		if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(m_pPlayer->GetID()) < 3)
			iWantPeace--;

		if(GetWarProjection(ePlayer) >= WAR_PROJECTION_GOOD)
		{
			iWantPeace--;
		}
		else if(GetWarProjection(ePlayer) <= WAR_PROJECTION_UNKNOWN)
		{
			iWantPeace++;
		}

		if(GetWarState(ePlayer) <= WAR_STATE_STALEMATE)
		{
			iWantPeace++;
		}
		else if(GetWarState(ePlayer) >= WAR_STATE_CALM)
		{
			iWantPeace--;
		}

		iWantPeace += GetWantPeaceCounter(ePlayer);

		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strOutBuf;
			CvString strBaseString;
			CvString playerName;
			CvString otherPlayerName;
			CvString strDesc;
			CvString strLogName;

			// Find the name of this civ and city
			playerName = m_pPlayer->getCivilizationShortDescription();

			// Open the log file
			if (GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Peace_Log.csv";
			}

			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strBaseString += playerName + " VS. " + otherPlayerName;

			strOutBuf.Format(" Value Needed: %03d. Value Have: %03d.", iRequestPeaceTurnThreshold, iWantPeace);

			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		return (iWantPeace > iRequestPeaceTurnThreshold);
	}
#else

	if(GetWantPeaceCounter(ePlayer) >= iRequestPeaceTurnThreshold)
		return true;

	return false;
#endif
}


/// How long have we wanted to make peace with ePlayer?
int CvDiplomacyAI::GetWantPeaceCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarGoalTypes) m_paeWantPeaceCounter[ePlayer];
}

/// Sets how long we've wanted to make peace with ePlayer
void CvDiplomacyAI::SetWantPeaceCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting WantPeaceCounter to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeWantPeaceCounter[ePlayer] = iValue;
}

/// Changes how long we've wanted to make peace with ePlayer
void CvDiplomacyAI::ChangeWantPeaceCounter(PlayerTypes ePlayer, int iChange)
{
	SetWantPeaceCounter(ePlayer, GetWantPeaceCounter(ePlayer) + iChange);
}



// ************************************
// War!
// ************************************



/// Handles declarations of War for this AI
void CvDiplomacyAI::DoMakeWarOnPlayer(PlayerTypes eTargetPlayer)
{
	CvAIOperation* pOperation;
	bool bWantToAttack = false;
	bool bDeclareWar = false;

	if (!IsPlayerValid(eTargetPlayer))
		return;

	if (GetWarGoal(eTargetPlayer) == WAR_GOAL_DEMAND)
		return;

	if (IsAtWar(eTargetPlayer))
		return;

	// If we recently made a demand, don't declare war (either it was accepted, or they called a bluff by us)
	if (GetNumTurnsSinceStatementSent(eTargetPlayer, DIPLO_STATEMENT_DEMAND) <= GC.getGame().getGameSpeedInfo().GetDealDuration())
		return;

	bool bAtWarWithAtLeastOneMajor = MilitaryAIHelpers::IsTestStrategy_AtWar(m_pPlayer, false);

	// Minor Civ
	if (GET_PLAYER(eTargetPlayer).isMinorCiv())
	{
		bWantToAttack = !bAtWarWithAtLeastOneMajor && (GetMinorCivApproach(eTargetPlayer) == MINOR_CIV_APPROACH_CONQUEST);
		pOperation = GetPlayer()->GetMilitaryAI()->GetSneakAttackOperation(eTargetPlayer);
	}
	// Major Civ
	else
	{
		MajorCivApproachTypes eApproach = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ false);
		bWantToAttack = (eApproach == MAJOR_CIV_APPROACH_WAR || (eApproach <= MAJOR_CIV_APPROACH_HOSTILE && (IsGoingForWorldConquest() || IsCloseToDominationVictory())));
		
		// We want to attack more if they're about to win the game (or we're about to win a conquest victory)
		if (!bWantToAttack && eApproach <= MAJOR_CIV_APPROACH_DECEPTIVE && !IsDoFAccepted(ePlayer) && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(GetPlayer()->GetID()))
		{
			if ((IsCloseToDominationVictory() || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition()) && !IsNoVictoryCompetition())
			{
				bWantToAttack = true;
			}
		}
		
		// Don't get into multiple wars at once (unless this is an easy target)
		if (bWantToAttack && !IsEasyTarget(eTargetPlayer))
		{
			bWantToAttack = bWantToAttack && !bAtWarWithAtLeastOneMajor;
		}
		
		if (GET_PLAYER(eTargetPlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetPlayer()->GetID()) && bWantToAttack)
		{
			bWantToAttack = false; // don't declare war on a player we promised not to attack, unless we're wily!
		}
		
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES && bWantToAttack)
		{
			if (IsPlayerMoveTroopsRequestAccepted(eTargetPlayer))
			{
				bWantToAttack = false;	// don't declare war on a player we promised not to attack, unless we're wily!
			}
		}
#endif
		pOperation = GetPlayer()->GetMilitaryAI()->GetSneakAttackOperation(eTargetPlayer);
	}

	// Not yet readying an attack
	if(pOperation == NULL && !IsArmyInPlaceForAttack(eTargetPlayer))
	{
		if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eTargetPlayer).getTeam()))
		{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), GetPlayer()->GetID()))
#else
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam()))
#endif
			{
				// Want to declare war on someone
				if(bWantToAttack)
				{
					SetWarGoal(eTargetPlayer, WAR_GOAL_PREPARE);

					// Attack on minor
					if(GET_PLAYER(eTargetPlayer).isMinorCiv())
						GetPlayer()->GetMilitaryAI()->RequestCityStateAttack(eTargetPlayer);
					// Attack on major
					else
					{
						GetPlayer()->GetMilitaryAI()->RequestSneakAttack(eTargetPlayer);
						SetWantsSneakAttack(eTargetPlayer, true);
					}
				}
				else
				{
					SetWarGoal(eTargetPlayer, NO_WAR_GOAL_TYPE);
					SetWantsSneakAttack(eTargetPlayer, false);

					if (!m_pPlayer->IsAtWar() && GetMinorCivApproach(eTargetPlayer) == MINOR_CIV_APPROACH_BULLY)
						GetPlayer()->GetMilitaryAI()->RequestBullyingOperation(eTargetPlayer);
				}
			}
		}
	}
	// We already have an attack on the way
	else
	{
		// Our Approach with this player calls for war
		if(bWantToAttack)
		{
			if(!IsAtWar(eTargetPlayer))
			{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
				if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), GetPlayer()->GetID()))
#else
				if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam()))
#endif
				{
					if(IsArmyInPlaceForAttack(eTargetPlayer) || (pOperation != NULL && pOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH))
					{
						bDeclareWar = true;
						SetArmyInPlaceForAttack(eTargetPlayer, false);
						SetWantsSneakAttack(eTargetPlayer, false);
					}
				}
			}
		}

		// We were planning an attack, but changed our minds so abort
		else
		{
			if(pOperation != NULL)
			{
				SetWantsSneakAttack(eTargetPlayer, false);
				pOperation->SetToAbort(AI_ABORT_DIPLO_OPINION_CHANGE);
				SetWarGoal(eTargetPlayer, NO_WAR_GOAL_TYPE);
				SetArmyInPlaceForAttack(eTargetPlayer, false);
			}
		}

		// If our Sneak Attack is read then actually initiate the DoW
		if(bDeclareWar)
		{
			DeclareWar(eTargetPlayer);
			SetWantsSneakAttack(eTargetPlayer, false);
		}
	}
}

/// Handles declarations of War for this AI
void CvDiplomacyAI::MakeWar()
{
	CvWeightedVector<int> playerList;
	int iWeight;

	if((int)m_eTargetPlayer >= (int)DIPLO_FIRST_PLAYER)
	{
		DoMakeWarOnPlayer((PlayerTypes)m_eTargetPlayer);
	}
	else
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eTarget = (PlayerTypes)iPlayerLoop;
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (IsPlayerValid(eTarget))
				{
					iWeight = (int)GetWarProjection(eTarget) + 1;

					// Square the distance enum to make it crucial
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));

					if(iPlayerLoop < MAX_MAJOR_CIVS)
					{
						if(GetMajorCivOpinion(eTarget) == MAJOR_CIV_OPINION_UNFORGIVABLE)
						{
							iWeight *= 2;
						}

						iWeight *= 10;  // Make sure majors are looked at before city states
					}

					playerList.push_back(iPlayerLoop, iWeight);
				}
			}
			else
			{
				if(IsValidUIDiplomacyTarget(eTarget) && IsPlayerValid(eTarget))
#else
				if(IsValidUIDiplomacyTarget(eTarget) && IsPlayerValid(eTarget))
#endif
				{
					iWeight = (int)GetWarProjection(eTarget) + 1;

					// Square the distance enum to make it crucial
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));
					iWeight *= (1 + (int)GetPlayer()->GetProximityToPlayer(eTarget));

					if(iPlayerLoop < MAX_MAJOR_CIVS)
					{
						if(GetMajorCivOpinion(eTarget) == MAJOR_CIV_OPINION_UNFORGIVABLE)
						{
							iWeight *= 2;
						}

						iWeight *= 10;  // Make sure majors are looked at before city states
					}

					playerList.push_back(iPlayerLoop, iWeight);
				}
#if defined(MOD_ACTIVE_DIPLOMACY)
			}
#endif
		}

		playerList.SortItems();

		for(int iI = 0; iI < playerList.size(); iI++)
		{
			DoMakeWarOnPlayer((PlayerTypes)playerList.GetElement(iI));
		}
	}

	// Increment counters for co-op wars we have agreed to - this may trigger war
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				for(int iThirdPlayerLoop = 0; iThirdPlayerLoop < MAX_MAJOR_CIVS; iThirdPlayerLoop++)
				{
					PlayerTypes eThirdPlayer = (PlayerTypes) iThirdPlayerLoop;

					bool bInvalid = false;
					if (!IsPlayerValid(eThirdPlayer))
					{
						bInvalid = true;
					}

					if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eThirdPlayer).getTeam(), GetPlayer()->GetID()))
					{
						bInvalid = true;
					}

					if (bInvalid)
					{
						if (GetCoopWarCounter(eLoopPlayer, eThirdPlayer) >= 0)
						{
							SetCoopWarAcceptedState(eLoopPlayer, eThirdPlayer, NO_COOP_WAR_STATE);
							SetCoopWarCounter(eLoopPlayer, eThirdPlayer, -666);
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(GetPlayer()->GetID(), eThirdPlayer, NO_COOP_WAR_STATE);
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetCoopWarCounter(GetPlayer()->GetID(), eThirdPlayer, -666);
						}
						continue;
					}

					if(GetCoopWarCounter(eLoopPlayer, eThirdPlayer) >= 0)
					{
						ChangeCoopWarCounter(eLoopPlayer, eThirdPlayer, 1);

						// AI players will always declare war at 10 turns, so we simplify things here - humans are handled by DoCoopWarTimeStatement()
						if(!GET_PLAYER(eLoopPlayer).isHuman())
						{
							if(GetCoopWarAcceptedState(eLoopPlayer, eThirdPlayer) == COOP_WAR_STATE_SOON &&
								GetCoopWarCounter(eLoopPlayer, eThirdPlayer) == /*10*/ GC.getCOOP_WAR_SOON_COUNTER())
							{
								// Us
								SetCoopWarAcceptedState(eLoopPlayer, eThirdPlayer, COOP_WAR_STATE_ACCEPTED);
								SetCoopWarCounter(eLoopPlayer, eThirdPlayer, 0);
								if (DeclareWar(eThirdPlayer))
								{
#if defined(MOD_BALANCE_CORE)
									GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eThirdPlayer, 2);
#else
									GetPlayer()->GetMilitaryAI()->RequestShowOfForce(eThirdPlayer);
#endif

									int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
									GET_TEAM(GetPlayer()->getTeam()).ChangeNumTurnsLockedIntoWar(GET_PLAYER(eThirdPlayer).getTeam(), iLockedTurns);
								}
							}
						}
					}
				}
			}
		}
	}
}

/// We've decided to declare war on someone
bool CvDiplomacyAI::DeclareWar(PlayerTypes ePlayer)
{
	CvAssertMsg(!GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() != GetPlayer()->GetID(), "Major is declaring war on a city-state it is allied with! Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvTeam& kMyTeam = GET_TEAM(GetTeam());
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();

	if (!GET_TEAM(GetTeam()).canDeclareWar(eTheirTeam, GetPlayer()->GetID()))
		return false;
	
	if (IsWarDisallowed(ePlayer))
		return false;

	// Only do it if we are not already at war.
	if(!kMyTeam.isAtWar(eTheirTeam))
	{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		kMyTeam.declareWar(eTheirTeam, false, GetPlayer()->GetID());
#else
		kMyTeam.declareWar(eTheirTeam);
#endif

		m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NOW_AT_WAR);

		// Show scene to human
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH: deciding whether to send a notification or pop up directy is done in SendRequest
			if (CvPreGame::isHuman(ePlayer))
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
			}
		}
		else
		{
			if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
			}
		}
#else
		if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
		{
			const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
		}
#endif

		LogWarDeclaration(ePlayer);
		return true;
	}
	return false;
}

/// We've decided to declare war on someone
bool CvDiplomacyAI::DeclareWar(TeamTypes eTeam)
{
	for (int i = 0; i < MAX_CIV_PLAYERS; i++)
	{
		PlayerTypes ePlayer = (PlayerTypes)i;

		if (ePlayer == NO_PLAYER)
			continue;

		if (!GET_PLAYER(ePlayer).isAlive())
			continue;

		if (GET_PLAYER(ePlayer).getTeam() != eTeam)
			continue;

		CvAssertMsg(!GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).GetMinorCivAI()->GetAlly() != GetPlayer()->GetID(), "Major is declaring war on a city-state it is allied with! Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		CvTeam& kMyTeam = GET_TEAM(GetTeam());
		TeamTypes eTheirTeam = eTeam;

		if (!kMyTeam.canDeclareWar(eTheirTeam, GetPlayer()->GetID()))
			return false;

		// Only do it if we are not already at war.
		if (!kMyTeam.isAtWar(eTheirTeam))
		{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			kMyTeam.declareWar(eTheirTeam, false, GetPlayer()->GetID());
#else
			kMyTeam.declareWar(eTheirTeam);
#endif

			m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NOW_AT_WAR);

			// Show scene to human
#if defined(MOD_ACTIVE_DIPLOMACY)
			if (GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				// JdH: deciding whether to send a notification or pop up directy is done in SendRequest
				if (CvPreGame::isHuman(ePlayer))
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
					CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
			}
			else
			{
				if (!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
					gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
			}
#else
			if (!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == ePlayer)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_ROOT, ePlayer);
				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_DECLARE_WAR);
			}
#endif

			LogWarDeclaration(ePlayer);
			return true;
		}
	}
	return false;
}


/// If we're planning war with ePlayer, how are we acting towards him?
WarFaceTypes CvDiplomacyAI::GetWarFaceWithPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarFaceTypes) m_paeWarFace[ePlayer];
}

/// Sets how we're acting while we prepare for our war against ePlayer
void CvDiplomacyAI::SetWarFaceWithPlayer(PlayerTypes ePlayer, WarFaceTypes eWarFace)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarFace >= 0, "DIPLOMACY_AI: Invalid WarFaceType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarFace < NUM_WAR_FACES, "DIPLOMACY_AI: Invalid WarFaceType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeWarFace[ePlayer] = eWarFace;
}

/// Are we building up for an attack on ePlayer?
bool CvDiplomacyAI::IsArmyInPlaceForAttack(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabArmyInPlaceForAttack[ePlayer];
}

/// Sets whether or not we're building up for an attack on ePlayer
void CvDiplomacyAI::SetArmyInPlaceForAttack(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabArmyInPlaceForAttack[ePlayer] = bValue;

	if (bValue)
		DoTestDemandReady();
}

/// Player was attacked by another!  Change appropriate diplomacy stuff
void CvDiplomacyAI::DoSomeoneDeclaredWarOnMe(TeamTypes eTeam)
{
	PlayerTypes eLoopPlayer;

	// Loop through all players on our attacker's Team
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(GET_PLAYER(eLoopPlayer).getTeam() == eTeam)
			{
				// Major Civs
				if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					// This will be updated on turn cycling, but for now we're "shocked and disappointed!"
					SetWarGoal(eLoopPlayer, WAR_GOAL_PEACE);
					SetApproachTowardsUsGuess(eLoopPlayer, MAJOR_CIV_APPROACH_WAR);
					SetApproachTowardsUsGuessCounter(eLoopPlayer, 0);
//					SetMajorCivApproach(eLoopPlayer, MAJOR_CIV_APPROACH_DEFENSIVE_WAR);
				}
				// Minor Civs
				else
				{
//					SetMinorCivApproach(eLoopPlayer, MINOR_CIV_APPROACH_WAR);
				}

				m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NOW_AT_WAR);
			}
		}
	}
}


/// What is the state of war with this player?
WarStateTypes CvDiplomacyAI::GetWarState(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarStateTypes) m_paeWarState[ePlayer];
}

void CvDiplomacyAI::SetWarState(PlayerTypes ePlayer, WarStateTypes eWarState)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarState >= NO_WAR_STATE_TYPE, "DIPLOMACY_AI: Invalid WarStateType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_WAR_STATE_TYPE is a valid possibility (if we're not at war)
	CvAssertMsg(eWarState < NUM_WAR_STATES, "DIPLOMACY_AI: Invalid WarStateType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeWarState[ePlayer] = eWarState;
}

/// Updates what the state of war is with all players
void CvDiplomacyAI::DoUpdateWarStates()
{
	WarStateTypes eWarState = WAR_STATE_STALEMATE;


	// Reset overall war state
	int iStateAllWars = 0;   // Used to assess overall war state in this function
	SetStateAllWars(STATE_ALL_WARS_NEUTRAL);

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			// War?
			if(IsAtWar(eLoopPlayer))
			{
				int iMyDanger = 1;
				int iTheirDanger = 1;

				CvCity* pLoopCity;
					
				int iNumMyCities = 0;
				int iNumTheirCities = 0;
				int iLoop;
				for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						iNumMyCities++;

						if(pLoopCity->isInDangerOfFalling())
						{
							iMyDanger += 3;
						}
						if(pLoopCity->isUnderSiege())
						{
							iMyDanger += 2;
						}
						if(pLoopCity->IsInDanger(eLoopPlayer))
						{
							iMyDanger += 1;
						}
					}
				}

				iMyDanger *= 100;
				iMyDanger /= max(1, iNumMyCities);

				for (pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						iNumTheirCities++;

						if (pLoopCity->isInDangerOfFalling())
						{
							iTheirDanger += 3;
						}
						if (pLoopCity->isUnderSiege())
						{
							iTheirDanger += 2;
						}
						if (pLoopCity->IsInDanger(GetPlayer()->GetID()))
						{
							iTheirDanger += 1;
						}
					}
				}

				iTheirDanger *= 100;
				iTheirDanger /= max(1, iNumTheirCities);

				int iDangerPercent = iTheirDanger * 100;
				iDangerPercent /= max(1, iMyDanger);

				//More of my cities in danger than theirs?
				if (iDangerPercent < 100)
				{
					eWarState = WAR_STATE_DEFENSIVE;
				}
				if (iDangerPercent == 100)
				{
					eWarState = WAR_STATE_STALEMATE;
				}
				else if (iDangerPercent > 100)
				{
					eWarState = WAR_STATE_OFFENSIVE;
				}

				int WarScore = GetWarScore(eLoopPlayer);
				if (m_pPlayer->GetCulture()->GetWarWeariness() > 0 && m_pPlayer->IsEmpireUnhappy())
				{
					if (WarScore < 0)
					{
						WarScore *= 2;
					}
					else
					{
						WarScore /= 2;
					}
				}
				if (WarScore >= 50 && eWarState == WAR_STATE_OFFENSIVE)
				{
					eWarState = WAR_STATE_NEARLY_WON;
				}
				else if (WarScore <= -50 && eWarState == WAR_STATE_DEFENSIVE)
				{
					eWarState = WAR_STATE_NEARLY_DEFEATED;
				}

				//Exceptions?

				//If it has been a while since either side captured a city, let's bring it down to calm.
				if ((GetPlayerNumTurnsSinceCityCapture(eLoopPlayer) >= 10) && (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetPlayer()->GetID()) >= 10))
				{
					if (WarScore <= 15 && WarScore >= -15)
						eWarState = WAR_STATE_CALM;
				}

				// If this is a major power, determine what the impact of this war is on our global situation
				if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					if(eWarState == WAR_STATE_NEARLY_WON)
					{
						iStateAllWars += 4;
					}
					else if(eWarState == WAR_STATE_OFFENSIVE)
					{
						iStateAllWars += 3;
					}
					else if(eWarState == WAR_STATE_DEFENSIVE)
					{
						iStateAllWars -= 1;

						// If we are defensive in this war and our capital has been damaged, overall state should be defensive
						CvCity *pCapital = m_pPlayer->getCapitalCity();
						if (pCapital)
						{
							if (pCapital->getDamage() > 0)
							{
								SetStateAllWars(STATE_ALL_WARS_LOSING);
							}
						}
					}
					else if(eWarState == WAR_STATE_NEARLY_DEFEATED)
					{
						// If nearly defeated in any war, overall state should be defensive
						SetStateAllWars(STATE_ALL_WARS_LOSING);
					}
				}
			}
			// Not at war
			else
				eWarState = NO_WAR_STATE_TYPE;

			SetWarState(eLoopPlayer, eWarState);
		}
	}

	// Finalize overall assessment
	if(iStateAllWars < 0 || GetStateAllWars() == STATE_ALL_WARS_LOSING)
		SetStateAllWars(STATE_ALL_WARS_LOSING);
	else if(iStateAllWars > 0)
		SetStateAllWars(STATE_ALL_WARS_WINNING);
}

/// Overall assessment of whether we're winning or losing all the wars we are in
StateAllWars CvDiplomacyAI::GetStateAllWars() const
{
	return m_eStateAllWars;
}

/// Sets our overall assessment of whether we're winning or losing all the wars we are in
void CvDiplomacyAI::SetStateAllWars(StateAllWars eState)
{
	CvAssertMsg(eState >= 0, "DIPLOMACY_AI: Invalid StateAllWar.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eState < NUM_STATES_ALL_WARS, "DIPLOMACY_AI: Invalid StateAllWar.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_eStateAllWars = eState;
}

/// What is the Projection of war with this player?
WarProjectionTypes CvDiplomacyAI::GetWarProjection(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarProjectionTypes) m_paeWarProjection[ePlayer];
}

/// Sets what our Projection of war with this player is
void CvDiplomacyAI::SetWarProjection(PlayerTypes ePlayer, WarProjectionTypes eWarProjection)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarProjection >= 0, "DIPLOMACY_AI: Invalid WarProjectionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarProjection < NUM_WAR_PROJECTION_TYPES, "DIPLOMACY_AI: Invalid WarProjectionType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeWarProjection[ePlayer] = eWarProjection;
}

/// previous value of GetWarProjection
WarProjectionTypes CvDiplomacyAI::GetLastWarProjection(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	return (WarProjectionTypes) m_paeLastWarProjection[ePlayer];

}

/// sets the previous value of GetWarProjection
void CvDiplomacyAI::SetLastWarProjection(PlayerTypes ePlayer, WarProjectionTypes eWarProjection)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarProjection >= 0, "DIPLOMACY_AI: Invalid WarProjectionType.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarProjection < NUM_WAR_PROJECTION_TYPES, "DIPLOMACY_AI: Invalid WarProjectionType.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");

	m_paeLastWarProjection[ePlayer] = eWarProjection;

}


/// Updates what the Projection of war is with all players
void CvDiplomacyAI::DoUpdateWarProjections()
{
	WarProjectionTypes eWarProjection;

	int iWarScore;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			eWarProjection = NO_WAR_PROJECTION_TYPE;

			if (IsAtWar(eLoopPlayer))
				iWarScore = GetWarScore(eLoopPlayer);
			else
				iWarScore = GetWarScore(eLoopPlayer, true);			

			// Do the final math
			if(iWarScore >= /*100*/ GC.getWAR_PROJECTION_THRESHOLD_VERY_GOOD())
				eWarProjection = WAR_PROJECTION_VERY_GOOD;
			else if(iWarScore >= /*25*/ GC.getWAR_PROJECTION_THRESHOLD_GOOD())
				eWarProjection = WAR_PROJECTION_GOOD;
			else if(iWarScore <= /*-100*/ GC.getWAR_PROJECTION_THRESHOLD_DESTRUCTION())
				eWarProjection = WAR_PROJECTION_DESTRUCTION;
			else if(iWarScore <= /*-25*/ GC.getWAR_PROJECTION_THRESHOLD_DEFEAT())
				eWarProjection = WAR_PROJECTION_DEFEAT;
			else if(iWarScore <= /*0*/ GC.getWAR_PROJECTION_THRESHOLD_STALEMATE())
				eWarProjection = WAR_PROJECTION_STALEMATE;
			else
				eWarProjection = WAR_PROJECTION_UNKNOWN;

			// If they're a bad target then the best we can do is a stalemate
			if(GetPlayerTargetValue(eLoopPlayer) <= TARGET_VALUE_BAD)
			{
				if(eWarProjection >= WAR_PROJECTION_GOOD)
					eWarProjection = WAR_PROJECTION_STALEMATE;
			}
			if (IsAtWar(eLoopPlayer) && (eWarProjection < WAR_PROJECTION_STALEMATE))
			{
				MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WINNING_WARS");
				// can't be imminent destruction if none of our cities is in danger at the moment
				if ((GetNumberOfThreatenedCities(eLoopPlayer) == 0))
				{
					eWarProjection = WAR_PROJECTION_STALEMATE;
				}
				// can't be imminent destruction if we are winning wars.		
				else if (GetPlayer()->GetMilitaryAI()->IsUsingStrategy(eStrategy))
				{
					eWarProjection = WAR_PROJECTION_STALEMATE;
				}
				else
				{
					// Are there no enemy military units near our cities? Let's not give in.
					int iLoop;
					int iDX, iDY;
					int iRange = max(1, (GC.getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT() - 2));
					bool bUnit = false;
					CvCity* pLoopCity;
					CvPlot* pLoopPlot;
					for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))
					{
						for(iDX = -(iRange); iDX <= iRange; iDX++)
						{
							for(iDY = -(iRange); iDY <= iRange; iDY++)
							{
								pLoopPlot = plotXYWithRangeCheck(pLoopCity->getX(), pLoopCity->getY(), iDX, iDY, iRange);
								if(pLoopPlot != NULL)
								{
									if(pLoopPlot->getVisibleEnemyDefender(eLoopPlayer) != NULL)
									{
										bUnit = true;
										break;
									}
								}
							}
						}
					}
					if(!bUnit)
					{
						eWarProjection = WAR_PROJECTION_STALEMATE;
					}
				}
			}

			if (GetWarProjection(eLoopPlayer) != NO_WAR_PROJECTION_TYPE)
			{
				SetLastWarProjection(eLoopPlayer, GetWarProjection(eLoopPlayer));
			}
			else
			{
				// for now, set it to be unknown because we can't set it to NO_WAR_PROJECTION_TYPE
				SetLastWarProjection(eLoopPlayer, WAR_PROJECTION_UNKNOWN);
			}

			SetWarProjection(eLoopPlayer, eWarProjection);
		}
	}
}

int CvDiplomacyAI::GetHighestWarscore()
{
	PlayerTypes eLoopPlayer;
	int iHighestWarscore = 0;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes)iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			int iWarscore = GetWarScore(eLoopPlayer);
			if (iWarscore > iHighestWarscore)
			{
				iHighestWarscore = iWarscore;
			}
		}

	}

	iHighestWarscore *= GetPlayer()->GetPositiveWarScoreTourismMod();
	iHighestWarscore /= 100;

	return iHighestWarscore;
}

/// What is the integer value of how well we think the war with ePlayer is going?
#if defined(MOD_BALANCE_CORE)
int CvDiplomacyAI::GetWarScore(PlayerTypes ePlayer, bool bUsePeacetimeCalculation, bool bDebug)
#else
int CvDiplomacyAI::GetWarScore(PlayerTypes ePlayer)
#endif
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iWarScore = 0;

#if defined(MOD_BALANCE_CORE)
	int iAverageScore = 0;
	//If this is a prewar calc, use power estimates (should give us a better idea of how a war might go).
	if (bUsePeacetimeCalculation)
	{
		int iWarScoreModifier = 0;
		switch (GetPlayer()->GetProximityToPlayer(ePlayer))
		{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWarScoreModifier += 30;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWarScoreModifier += 10;
			break;
		case PLAYER_PROXIMITY_FAR:
			iWarScoreModifier += -10;
			break;
		case PLAYER_PROXIMITY_DISTANT:
			iWarScoreModifier += -30;
			break;
		}

		// Their Military Strength compared to us
		switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
		{
			case STRENGTH_PATHETIC:
				iWarScore += 40;
				break;
			case STRENGTH_WEAK:
				iWarScore += 20;
				break;
			case STRENGTH_POOR:
				iWarScore += 10;
				break;
			case STRENGTH_AVERAGE:
				iWarScore += 0;
				break;
			case STRENGTH_STRONG:
				iWarScore += -10;
				break;
			case STRENGTH_POWERFUL:
				iWarScore += -20;
				break;
			case STRENGTH_IMMENSE:
				iWarScore += -40;
				break;
		}

		// Their Economic Strength compared to us
		switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
		{
			case STRENGTH_PATHETIC:
				iWarScore += 20;
				break;
			case STRENGTH_WEAK:
				iWarScore += 10;
				break;
			case STRENGTH_POOR:
				iWarScore += 5;
				break;
			case STRENGTH_AVERAGE:
				iWarScore += 0;
				break;
			case STRENGTH_STRONG:
				iWarScore += -5;
				break;
			case STRENGTH_POWERFUL:
				iWarScore += -10;
				break;
			case STRENGTH_IMMENSE:
				iWarScore += -20;
				break;
		}

		// What is our war projection of them?
		switch(GetMajorCivOpinion(ePlayer))
		{
			case MAJOR_CIV_OPINION_ALLY:
				iWarScore += -20;
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				iWarScore += -10;
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				iWarScore += -5;
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				iWarScore += 0;
				break;
			case MAJOR_CIV_OPINION_COMPETITOR:
				iWarScore += 5;
				break;
			case MAJOR_CIV_OPINION_ENEMY:
				iWarScore += 10;
				break;
			case MAJOR_CIV_OPINION_UNFORGIVABLE:
				iWarScore += 20;
				break;
		}

		// What is our war projection of them?
		switch (GetWarmongerThreat(ePlayer))
		{
		case THREAT_NONE:
			iWarScore += -20;
			break;
		case THREAT_MINOR:
			iWarScore += -10;
			break;
		case THREAT_MAJOR:
			iWarScore += 10;
			break;
		case THREAT_SEVERE:
			iWarScore += 15;
			break;
		case THREAT_CRITICAL:
			iWarScore += 20;
			break;
		}

		iWarScore *= (100 + iWarScoreModifier);
		iWarScore /= 100;

		return iWarScore;
	}
	else
	{
		int iTheirWarScore = GetWarDamageValue(ePlayer);
		int iWarScore = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarDamageValue(GetPlayer()->GetID());
	
		if (bDebug && GC.getAILogging() )
		{
			CvString strMsg;
			strMsg.Format("turn %d - war score for %d against player %d is %d / %d\n", GC.getGame().getGameTurn(), m_pPlayer->GetID(), ePlayer, iWarScore, iTheirWarScore );
			OutputDebugString(strMsg.c_str());
		}

		if (iWarScore == iTheirWarScore)
		{
			return 0;
		}
		if(iTheirWarScore > iWarScore)
		{
			iAverageScore = iTheirWarScore - iWarScore;
			iAverageScore *= -1;
		}
		else
		{
			iAverageScore = iWarScore - iTheirWarScore;
		}

		//Doubled because of the 'average' above.
		iAverageScore *= 2;

		int iWarDurationUs = GetPlayerNumTurnsSinceCityCapture(ePlayer);
		int iWarDurationThem = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerNumTurnsSinceCityCapture(GetPlayer()->GetID());
		int iWarDuration = min(iWarDurationUs, iWarDurationThem);
		iWarDuration /= 5;
		if(iWarDuration > 0)
		{	
			if(iAverageScore > 0)
			{
				iAverageScore -= iWarDuration;
				if(iAverageScore < 0)
				{
					iAverageScore = 0;
				}
			}
			else if(iAverageScore < 0)
			{
				iAverageScore += iWarDuration;
				if(iAverageScore > 0)
				{
					iAverageScore = 0;
				}
			}
		}
		if(iAverageScore >= 100)
		{
			return 100;
		}
		if(iAverageScore <= -100)
		{
			return -100;
		}
	}
	return iAverageScore;
	
#else
	// Military Strength compared to us
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		iWarScore += /*100*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_PATHETIC();
		break;
	case STRENGTH_WEAK:
		iWarScore += /*60*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_WEAK();
		break;
	case STRENGTH_POOR:
		iWarScore += /*25*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_POOR();
		break;
	case STRENGTH_AVERAGE:
		iWarScore += /*0*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_AVERAGE();
		break;
	case STRENGTH_STRONG:
		iWarScore += /*-25*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_STRONG();
		break;
	case STRENGTH_POWERFUL:
		iWarScore += /*-60*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_POWERFUL();
		break;
	case STRENGTH_IMMENSE:
		iWarScore += /*-100*/ GC.getWAR_PROJECTION_THEIR_MILITARY_STRENGTH_IMMENSE();
		break;
	}

	// Economic Strength compared to us
	switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		iWarScore += /*50*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_PATHETIC();
		break;
	case STRENGTH_WEAK:
		iWarScore += /*30*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_WEAK();
		break;
	case STRENGTH_POOR:
		iWarScore += /*12*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POOR();
		break;
	case STRENGTH_AVERAGE:
		iWarScore += /*0*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_AVERAGE();
		break;
	case STRENGTH_STRONG:
		iWarScore += /*-12*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_STRONG();
		break;
	case STRENGTH_POWERFUL:
		iWarScore += /*-30*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POWERFUL();
		break;
	case STRENGTH_IMMENSE:
		iWarScore += /*-50*/ GC.getWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_IMMENSE();
		break;
	}
	// War Damage inflicted on US
	switch(GetWarDamageLevel(ePlayer))
	{
	case WAR_DAMAGE_LEVEL_NONE:
		iWarScore += /*0*/ GC.getWAR_PROJECTION_WAR_DAMAGE_US_NONE();
		// If they're aggressively expanding, it makes them a better target to go after, If they've hurt us, this no longer applies
		if(IsPlayerRecklessExpander(ePlayer))
		{
			iWarScore += /*25*/ GC.getWAR_PROJECTION_RECKLESS_EXPANDER();
		}
		break;
	case WAR_DAMAGE_LEVEL_MINOR:
		iWarScore += /*-10*/ GC.getWAR_PROJECTION_WAR_DAMAGE_US_MINOR();
		break;
	case WAR_DAMAGE_LEVEL_MAJOR:
		iWarScore += /*-20*/ GC.getWAR_PROJECTION_WAR_DAMAGE_US_MAJOR();
		break;
	case WAR_DAMAGE_LEVEL_SERIOUS:
		iWarScore += /*-30*/ GC.getWAR_PROJECTION_WAR_DAMAGE_US_SERIOUS();
		break;
	case WAR_DAMAGE_LEVEL_CRIPPLED:
		iWarScore += /*-40*/ GC.getWAR_PROJECTION_WAR_DAMAGE_US_CRIPPLED();
		break;
	}

	// War Damage inflicted on THEM (less than what's been inflicted on us for the same amount of damage)
	switch(GetOtherPlayerWarDamageLevel(ePlayer, GetPlayer()->GetID()))
	{
	case WAR_DAMAGE_LEVEL_NONE:
		iWarScore += /*0*/ GC.getWAR_PROJECTION_WAR_DAMAGE_THEM_NONE();
		break;
	case WAR_DAMAGE_LEVEL_MINOR:
		iWarScore += /*5*/ GC.getWAR_PROJECTION_WAR_DAMAGE_THEM_MINOR();
		break;
	case WAR_DAMAGE_LEVEL_MAJOR:
		iWarScore += /*10*/ GC.getWAR_PROJECTION_WAR_DAMAGE_THEM_MAJOR();
		break;
	case WAR_DAMAGE_LEVEL_SERIOUS:
		iWarScore += /*15*/ GC.getWAR_PROJECTION_WAR_DAMAGE_THEM_SERIOUS();
		break;
	case WAR_DAMAGE_LEVEL_CRIPPLED:
		iWarScore += /*20*/ GC.getWAR_PROJECTION_WAR_DAMAGE_THEM_CRIPPLED();
		break;
	}
	// the intangibles - our score vs their score
	int iOurScore = GetPlayer()->GetScore();
	iOurScore = iOurScore > 100 ? iOurScore : 100;
	int iTheirScore = GET_PLAYER(ePlayer).GetScore();
	iTheirScore = iTheirScore > 100 ? iTheirScore : 100;
	int iRatio = ((iOurScore-iTheirScore) * 100) / (iOurScore>iTheirScore?iTheirScore:iOurScore);
	iRatio = iRatio >= -50 ? (iRatio <= 50 ? iRatio : 50) : -50;
	iWarScore += iRatio;

	// Decrease war score if we've been fighting for a long time - after 60 turns the effect is -20 on the WarScore
	int iTurnsAtWar = GetPlayerNumTurnsAtWar(ePlayer);
	iTurnsAtWar /= 3;
	iWarScore -= min(iTurnsAtWar, /*20*/ GC.getWAR_PROJECTION_WAR_DURATION_SCORE_CAP());
	return iWarScore;
#endif
}


/// What is the Goal of war with this player?
WarGoalTypes CvDiplomacyAI::GetWarGoal(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarGoalTypes) m_paeWarGoal[ePlayer];
}

/// Sets what the Goal of war is with this player
void CvDiplomacyAI::SetWarGoal(PlayerTypes ePlayer, WarGoalTypes eWarGoal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarGoal >= NO_WAR_GOAL_TYPE, "DIPLOMACY_AI: Invalid WarGoalType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_WAR_GOAL_TYPE is valid (if we're not at war)
	CvAssertMsg(eWarGoal < NUM_WAR_GOALS, "DIPLOMACY_AI: Invalid WarGoalType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	//if (GetWarGoal(ePlayer) == WAR_GOAL_DEMAND && eWarGoal != WAR_GOAL_DEMAND)
	//{
	//	CvAssert(false);
	//}

	m_paeWarGoal[ePlayer] = eWarGoal;
}

/// Updates what the Goal of war is with all players
void CvDiplomacyAI::DoUpdateWarGoals()
{
	// Are we going for World conquest?  If so, then we want to fight our wars to the death
	bool bWorldConquest = false;

	if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
	{
		bWorldConquest = true;
	}

	int iWarGoalValue;
	WarGoalTypes eWarGoal;
	bool bHigherUpsWantWar;
	bool bIsMinor;

	WarProjectionTypes eProjection;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		//don't forget the barbarians
		if (iPlayerLoop == BARBARIAN_PLAYER)
		{
			SetWarGoal(BARBARIAN_PLAYER, WAR_GOAL_CONQUEST);
			continue;
		}

		if(IsPlayerValid(eLoopPlayer))
		{
			eWarGoal = NO_WAR_GOAL_TYPE;

			if(GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				bIsMinor = (GET_PLAYER(eLoopPlayer).isMinorCiv());

				iWarGoalValue = 0;
				bHigherUpsWantWar = false;

				// Higher ups want war with this Minor Civ
				if(bIsMinor)
					bHigherUpsWantWar = GetMinorCivApproach(eLoopPlayer) == MINOR_CIV_APPROACH_CONQUEST;
				// Higher ups want war with this Major Civ
				else
					bHigherUpsWantWar = GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				//Vassals will never want peace with a player if their master is at war with a player.
				if(MOD_DIPLOMACY_CIV4_FEATURES)
				{
					if(GET_TEAM(m_pPlayer->getTeam()).IsVassalOfSomeone())
					{
						TeamTypes eMasterTeam = GET_TEAM(m_pPlayer->getTeam()).GetMaster();
						if(eMasterTeam != NO_TEAM)
						{
							if(GET_TEAM(eMasterTeam).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
							{
								bHigherUpsWantWar = true;
							}
						}
					}
				}
#endif

				eProjection = GetWarProjection(eLoopPlayer);

				//////////////////////////////
				// Higher ups want war, figure out what kind we're waging
				if(bHigherUpsWantWar)
				{
					// Minor Civs
					if(bIsMinor)

						// If we're going for the conquest victory, conquest is our goal with minors
						if(bWorldConquest)
							eWarGoal = WAR_GOAL_CONQUEST;
						else
							eWarGoal = WAR_GOAL_DAMAGE;

					// Major Civs - depends on how things are going
					else
					{
						// Default goal is Damage
						eWarGoal = WAR_GOAL_DAMAGE;
						
						// If we're locked into a coop war, we're out for conquest
						if (IsLockedIntoCoopWar(eLoopPlayer))
							eWarGoal = WAR_GOAL_CONQUEST;
						
						// If they're about to win the game, we're out for conquest
						else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
							eWarGoal = WAR_GOAL_CONQUEST;

						// If we think the war will go well, we can aim for conquest, which means we will not make peace
						else if (eProjection > WAR_PROJECTION_UNKNOWN)
						{
							// If they're unforgivable we're out to destroy them, no less
							if (GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
								eWarGoal = WAR_GOAL_CONQUEST;

							// Out for world conquest?
							else if (bWorldConquest)
								eWarGoal = WAR_GOAL_CONQUEST;
						}
#if defined(MOD_BALANCE_CORE)
						// Let's consider peace if we've been fighting for a long time.
						if (GetPlayerNumTurnsAtWar(eLoopPlayer) > GD_INT_GET(WAR_MAJOR_MINIMUM_TURNS))
						{
							if (GET_TEAM(m_pPlayer->getTeam()).canChangeWarPeace(GET_PLAYER(eLoopPlayer).getTeam()))
							{
								if ((GetPlayer()->GetCulture()->GetWarWeariness() > GetPlayerNumTurnsAtWar(eLoopPlayer)) || GetPlayer()->IsEmpireVeryUnhappy())
								{
									if (GC.getLogging() && GC.getAILogging())
									{
										CvString strOutBuf;
										CvString strBaseString;
										CvString playerName;
										CvString otherPlayerName;
										CvString strDesc;
										CvString strLogName;

										// Find the name of this civ and city
										playerName = GetPlayer()->getCivilizationShortDescription();

										// Open the log file
										if (GC.getPlayerAndCityAILogSplit())
										{
											strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
										}
										else
										{
											strLogName = "DiplomacyAI_Peace_Log.csv";
										}

										FILogFile* pLog;
										pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

										// Get the leading info for this line
										strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
										otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
										strBaseString += playerName + " VS. " + otherPlayerName;

										strOutBuf.Format("Unhappy or Very War Weary, we want peace!");
										strBaseString += strOutBuf;
										pLog->Msg(strBaseString);
									}
									eWarGoal = WAR_GOAL_PEACE;
								}
								else
								{
									int iWarScore = GetWarScore(eLoopPlayer);
									if (iWarScore <= 0)
									{
										int iWarScoreWeWantPeace = ((GetMeanness()) * -9);
										iWarScoreWeWantPeace += GetPlayerNumTurnsAtWar(eLoopPlayer); // -30, but at war for 10 turns? -20 works.

										//Want -20, at -30?
										if (iWarScoreWeWantPeace >= iWarScore)
										{
											if (GC.getLogging() && GC.getAILogging())
											{
												CvString strOutBuf;
												CvString strBaseString;
												CvString playerName;
												CvString otherPlayerName;
												CvString strDesc;
												CvString strLogName;

												// Find the name of this civ and city
												playerName = GetPlayer()->getCivilizationShortDescription();

												// Open the log file
												if (GC.getPlayerAndCityAILogSplit())
												{
													strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
												}
												else
												{
													strLogName = "DiplomacyAI_Peace_Log.csv";
												}

												FILogFile* pLog;
												pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

												// Get the leading info for this line
												strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
												otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
												strBaseString += playerName + " VS. " + otherPlayerName;

												strOutBuf.Format("We are losing badly, we want peace!");

												strBaseString += strOutBuf;
												pLog->Msg(strBaseString);
											}
											eWarGoal = WAR_GOAL_PEACE;
										}
									}
									else
									{
										int iWarScoreWeWantPeace = ((10 - GetDiploBalance()) * 9); //10 minus because higher value = more likey status quo
										iWarScoreWeWantPeace += (GetPlayerNumTurnsAtWar(eLoopPlayer) * -1); // 30, but at war for 10 turns? 20 works.

										//Want 20, at 30?
										if (iWarScoreWeWantPeace <= iWarScore)
										{
											if (GC.getLogging() && GC.getAILogging())
											{
												CvString strOutBuf;
												CvString strBaseString;
												CvString playerName;
												CvString otherPlayerName;
												CvString strDesc;
												CvString strLogName;

												// Find the name of this civ and city
												playerName = GetPlayer()->getCivilizationShortDescription();

												// Open the log file
												if (GC.getPlayerAndCityAILogSplit())
												{
													strLogName = "DiplomacyAI_Peace_Log" + playerName + ".csv";
												}
												else
												{
													strLogName = "DiplomacyAI_Peace_Log.csv";
												}

												FILogFile* pLog;
												pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

												// Get the leading info for this line
												strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
												otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
												strBaseString += playerName + " VS. " + otherPlayerName;

												strOutBuf.Format("We are winning handily, we want peace!");

												strBaseString += strOutBuf;
												pLog->Msg(strBaseString);
											}
											eWarGoal = WAR_GOAL_PEACE;
										}
									}
								}
							}
						}
#endif
					}
				}

				//////////////////////////////
				// Higher ups don't want to be at war, figure out how bad things are
				else
				{
					// If we're about to cause some mayhem then hold off on the peace stuff for a bit - not against Minors though
					if(!bIsMinor && GetStateAllWars() != STATE_ALL_WARS_LOSING)
					{
						//why make peace when we're winning?
						if (GetWarState(eLoopPlayer) == WAR_STATE_NEARLY_WON)
							eWarGoal = WAR_GOAL_CONQUEST;
#if defined(MOD_BALANCE_CORE)
						else if (GetWarState(eLoopPlayer) <= WAR_STATE_STALEMATE)
							eWarGoal = WAR_GOAL_PEACE;
#endif
						else
							eWarGoal = WAR_GOAL_DAMAGE;
					}
					// War isn't decisively in our favor, so we'll make peace if possible
					else
					{
						eWarGoal = WAR_GOAL_PEACE;
					}
				}
			}
			// Getting ready to attack
			else if(GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE)
				eWarGoal = WAR_GOAL_PREPARE;
			// Getting ready to make a forceful demand
			else if (GetWarGoal(eLoopPlayer) == WAR_GOAL_DEMAND)
				eWarGoal = WAR_GOAL_DEMAND;

			// Update the counter for how long we've wanted peace for (used to determine when to ask for peace)
			if(eWarGoal == WAR_GOAL_PEACE)
				ChangeWantPeaceCounter(eLoopPlayer, 1);
			else
				SetWantPeaceCounter(eLoopPlayer, 0);

			// Set the War Goal
			SetWarGoal(eLoopPlayer, eWarGoal);
		}
	}
}

#if defined(MOD_API_EXTENSIONS)
/// How many turns have we been at war with this Team?
int CvDiplomacyAI::GetTeamNumTurnsAtWar(TeamTypes eTeam) const
{
	CvAssertMsg(eTeam >= 0, "DIPLOMACY_AI: Invalid Team Index.");
	CvAssertMsg(eTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.");
	int iMaxTurns = 0;
	
	for (int i = 0; i < MAX_CIV_PLAYERS; ++i) {
		const PlayerTypes ePlayer = static_cast<PlayerTypes>(i);
		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
		if (kPlayer.isAlive() && kPlayer.getTeam() == eTeam) {
			iMaxTurns = std::max(iMaxTurns, (int) m_paiPlayerNumTurnsAtWar[ePlayer]);
		}
	}
	
	return iMaxTurns;
}
#endif

/// How many turns have we been at war with this player?
int CvDiplomacyAI::GetPlayerNumTurnsAtWar(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerNumTurnsAtWar[ePlayer];
}

/// Sets how many turns we've been at war with this player
void CvDiplomacyAI::SetPlayerNumTurnsAtWar(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting PlayerNumTurnsAtWar to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiPlayerNumTurnsAtWar[ePlayer] = iValue;
}

/// Sets how many turns we've been at war with this player
void CvDiplomacyAI::ChangePlayerNumTurnsAtWar(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		SetPlayerNumTurnsAtWar(ePlayer, GetPlayerNumTurnsAtWar(ePlayer) + iChange);
	}
}

#if defined(MOD_BALANCE_CORE)
/// How many turns have we been at peace with this player?
int CvDiplomacyAI::GetPlayerNumTurnsAtPeace(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerNumTurnsAtPeace[ePlayer];
}

/// Sets how many turns we've been at peace with this player
void CvDiplomacyAI::SetPlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting PlayerNumTurnsAtWar to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiPlayerNumTurnsAtPeace[ePlayer] = iValue;
}

/// Updates how many turns we've been at peace with this player
void CvDiplomacyAI::ChangePlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		SetPlayerNumTurnsAtPeace(ePlayer, GetPlayerNumTurnsAtPeace(ePlayer) + iChange);
	}
}

/// How many turns have passed since we captured a city from this player?
int CvDiplomacyAI::GetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerNumTurnsSinceCityCapture[ePlayer];
}

/// Sets how many turns have passed since we captured a city from this player
void CvDiplomacyAI::SetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting PlayerNumTurnsAtWar to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiPlayerNumTurnsSinceCityCapture[ePlayer] = iValue;
}

/// Sets how many turns have passed since we captured a city from this player
void CvDiplomacyAI::ChangePlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		SetPlayerNumTurnsSinceCityCapture(ePlayer, GetPlayerNumTurnsSinceCityCapture(ePlayer) + iChange);
	}
}
#endif

/// How many times have we gone to war with ePlayer?
int CvDiplomacyAI::GetNumWarsFought(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiNumWarsFought[ePlayer];
}

/// Sets how many times we have gone to war with ePlayer
void CvDiplomacyAI::SetNumWarsFought(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting NumWarsFought to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiNumWarsFought[ePlayer] = iValue;
}

/// Updates how many times we have gone to war with ePlayer
void CvDiplomacyAI::ChangeNumWarsFought(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		SetNumWarsFought(ePlayer, GetNumWarsFought(ePlayer) + iChange);
	}
}

/// What is our assessment of this player's overall Military Strength?
StrengthTypes CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (StrengthTypes) m_paePlayerMilitaryStrengthComparedToUs[ePlayer];
}

/// Sets what our assessment is of this player's overall Military Strength
void CvDiplomacyAI::SetPlayerMilitaryStrengthComparedToUs(PlayerTypes ePlayer, StrengthTypes eMilitaryStrength)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMilitaryStrength >= 0, "DIPLOMACY_AI: Invalid StrengthType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMilitaryStrength < NUM_STRENGTH_VALUES, "DIPLOMACY_AI: Invalid StrengthType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerMilitaryStrengthComparedToUs[ePlayer] = eMilitaryStrength;
}

/// Updates what our assessment is of all players' overall Military Strength
void CvDiplomacyAI::DoUpdatePlayerMilitaryStrengths()
{
	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		DoUpdateOnePlayerMilitaryStrength(eLoopPlayer);
	}
}

/// Updates what our assessment is of a player's overall Military Strength
void CvDiplomacyAI::DoUpdateOnePlayerMilitaryStrength(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	StrengthTypes eMilitaryStrength;

	int iBase = /*30*/ GC.getMILITARY_STRENGTH_BASE();
	int iMilitaryStrength = iBase + GetPlayer()->GetMilitaryMight();

	int iOtherPlayerMilitary;
	int iMilitaryRatio;

	if(IsPlayerValid(ePlayer, /*bMyTeamIsValid*/ true))
	{
		// Look at player's Military Strength
		//if (GetPlayer()->GetMilitaryMight() > 0)
		{
			iOtherPlayerMilitary = GET_PLAYER(ePlayer).GetMilitaryMight() + iBase;
#if defined(MOD_BALANCE_CORE)
			PlayerTypes eLoopPlayer;
			int iDPUs = 0;
			int iDPThem = 0;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if (eLoopPlayer == GetPlayer()->GetID())
					continue;

				if (eLoopPlayer != NO_PLAYER && !GET_PLAYER(eLoopPlayer).isMinorCiv() && eLoopPlayer != ePlayer)
				{
					if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
					{
						iDPThem += GET_PLAYER(eLoopPlayer).GetMilitaryMight();
					}
					if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(m_pPlayer->getTeam()))
					{
						iDPUs += GET_PLAYER(eLoopPlayer).GetMilitaryMight();
					}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
					if (MOD_DIPLOMACY_CIV4_FEATURES)
					{
						if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
						{
							iDPThem += GET_PLAYER(eLoopPlayer).GetMilitaryMight();
						}
					}
					if (MOD_DIPLOMACY_CIV4_FEATURES)
					{
						if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(m_pPlayer->getTeam()))
						{
							iDPUs += GET_PLAYER(eLoopPlayer).GetMilitaryMight();
						}
					}
#endif
				}
			}
			if(iDPThem > 0)
			{
				iOtherPlayerMilitary *= (int)((iDPThem * .1f) + 100);
				iOtherPlayerMilitary /= 100;
			}
			if(iDPUs > 0)
			{
				iMilitaryStrength *= (int)((iDPUs * .1f) + 100);
				iMilitaryStrength /= 100;
			}
#endif
			// Example: If another player has double the Military strength of us, the Ratio will be 200
			iMilitaryRatio = iOtherPlayerMilitary* /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / iMilitaryStrength;
		}

		//else
		//{
		//	iMilitaryRatio = /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER();
		//}

		//iMilitaryStrength += iMilitaryRatio;

		// Now do the final assessment
		if(iMilitaryRatio >= /*250*/ GC.getMILITARY_STRENGTH_IMMENSE_THRESHOLD())
			eMilitaryStrength = STRENGTH_IMMENSE;
		else if(iMilitaryRatio >= /*165*/ GC.getMILITARY_STRENGTH_POWERFUL_THRESHOLD())
			eMilitaryStrength = STRENGTH_POWERFUL;
		else if(iMilitaryRatio >= /*115*/ GC.getMILITARY_STRENGTH_STRONG_THRESHOLD())
			eMilitaryStrength = STRENGTH_STRONG;
		else if(iMilitaryRatio >= /*85*/ GC.getMILITARY_STRENGTH_AVERAGE_THRESHOLD())
			eMilitaryStrength = STRENGTH_AVERAGE;
		else if(iMilitaryRatio >= /*60*/ GC.getMILITARY_STRENGTH_POOR_THRESHOLD())
			eMilitaryStrength = STRENGTH_POOR;
		else if(iMilitaryRatio >= /*40*/ GC.getMILITARY_STRENGTH_WEAK_THRESHOLD())
			eMilitaryStrength = STRENGTH_WEAK;
		else
			eMilitaryStrength = STRENGTH_PATHETIC;

		// Set the value
		SetPlayerMilitaryStrengthComparedToUs(ePlayer, eMilitaryStrength);
	}
}


/// What is our assessment of this player's overall Economic Strength?
StrengthTypes CvDiplomacyAI::GetPlayerEconomicStrengthComparedToUs(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (StrengthTypes) m_paePlayerEconomicStrengthComparedToUs[ePlayer];
}

/// Sets what our assessment is of this player's overall Economic Strength
void CvDiplomacyAI::SetPlayerEconomicStrengthComparedToUs(PlayerTypes ePlayer, StrengthTypes eEconomicStrength)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eEconomicStrength >= 0, "DIPLOMACY_AI: Invalid StrengthType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eEconomicStrength < NUM_STRENGTH_VALUES, "DIPLOMACY_AI: Invalid StrengthType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerEconomicStrengthComparedToUs[ePlayer] = eEconomicStrength;
}

/// Updates what our assessment is of all players' overall Economic Strength
void CvDiplomacyAI::DoUpdatePlayerEconomicStrengths()
{
	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		DoUpdateOnePlayerEconomicStrength(eLoopPlayer);
	}
}

/// Updates what our assessment is of a player's overall Economic Strength
void CvDiplomacyAI::DoUpdateOnePlayerEconomicStrength(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(IsPlayerValid(ePlayer, /*bMyTeamIsValid*/ true))
	{
		//just a default
		int iEconomicRatio = /*100*/ GC.getECONOMIC_STRENGTH_RATIO_MULTIPLIER();

		// Look at player's Economic Strength
		if(GetPlayer()->GetEconomicMight() > 0)
		{
			// Example: If another player has double the Economic strength of us, the Ratio will be 200
			iEconomicRatio = GET_PLAYER(ePlayer).GetEconomicMight() * /*100*/ GC.getECONOMIC_STRENGTH_RATIO_MULTIPLIER() / GetPlayer()->GetEconomicMight();
		}

		// Now do the final assessment
		StrengthTypes eEconomicStrength = STRENGTH_PATHETIC;
		if(iEconomicRatio >= /*250*/ GC.getECONOMIC_STRENGTH_IMMENSE_THRESHOLD())
			eEconomicStrength = STRENGTH_IMMENSE;
		else if(iEconomicRatio >= /*153*/ GC.getECONOMIC_STRENGTH_POWERFUL_THRESHOLD())
			eEconomicStrength = STRENGTH_POWERFUL;
		else if(iEconomicRatio >= /*120*/ GC.getECONOMIC_STRENGTH_STRONG_THRESHOLD())
			eEconomicStrength = STRENGTH_STRONG;
		else if(iEconomicRatio >= /*83*/ GC.getECONOMIC_STRENGTH_AVERAGE_THRESHOLD())
			eEconomicStrength = STRENGTH_AVERAGE;
		else if(iEconomicRatio >= /*65*/ GC.getECONOMIC_STRENGTH_POOR_THRESHOLD())
			eEconomicStrength = STRENGTH_POOR;
		else if(iEconomicRatio >= /*40*/ GC.getECONOMIC_STRENGTH_WEAK_THRESHOLD())
			eEconomicStrength = STRENGTH_WEAK;

		// Set the value
		SetPlayerEconomicStrengthComparedToUs(ePlayer, eEconomicStrength);
	}
}


/// What is our assessment of this player's value as a military target?
TargetValueTypes CvDiplomacyAI::GetPlayerTargetValue(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (TargetValueTypes) m_paePlayerTargetValue[ePlayer];
}

/// Sets what our assessment is of this player's value as a military target
void CvDiplomacyAI::SetPlayerTargetValue(PlayerTypes ePlayer, TargetValueTypes eTargetValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetValue >= 0, "DIPLOMACY_AI: Invalid TargetValueType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetValue < NUM_TARGET_VALUES, "DIPLOMACY_AI: Invalid TargetValueType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerTargetValue[ePlayer] = eTargetValue;
}

/// Updates what our assessment is of all players' value as a military target
void CvDiplomacyAI::DoUpdatePlayerTargetValues()
{
	PlayerTypes eLoopPlayer;
	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		DoUpdateOnePlayerTargetValue(eLoopPlayer);
	}
}

int GetPlayerOverallStrengthEstimate(PlayerTypes ePlayer, bool bIgnoreCurrentWar)
{
	int iStrengthEstimate = GET_PLAYER(ePlayer).getPower();

	// City Defensive Strength
	int iCityLoop = 0;
	for(CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
	{
		int iHitpoints = pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage();
		int iPower = (pLoopCity->GetPower() * iHitpoints) / pLoopCity->GetMaxHitPoints();
		iStrengthEstimate += (iPower * /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD()) / 100;
	}

	// Decrease target value if the player is already at war with other players
	int iWarCount = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getAtWarCount(true);
	// Reduce by 1 if WE'RE already at war with him or he with us
	if(bIgnoreCurrentWar)
		iWarCount--;

	if(iWarCount > 0)
	{
		int iScale = max(20, 100 - iWarCount * /*30*/ GC.getTARGET_ALREADY_WAR_EACH_PLAYER());
		iStrengthEstimate *= iScale;
		iStrengthEstimate /= 100;
	}

	// Factor in Minors we are allied to
	if(!GET_PLAYER(ePlayer).isMinorCiv())
	{
		// Loop through all minors to check our relationship with them
		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			PlayerTypes eAlliedMinor = (PlayerTypes) iMinorCivLoop;

			if(GET_PLAYER(eAlliedMinor).isAlive() && GET_PLAYER(eAlliedMinor).isMinorCiv() && GET_PLAYER(eAlliedMinor).GetMinorCivAI()->IsAllies(ePlayer))
			{
				int iThirdPartyValue = 0;
				StrengthTypes eThirdPartyStrength = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eAlliedMinor);
				PlayerProximityTypes eThirdPartyProximity = GET_PLAYER(ePlayer).GetProximityToPlayer(eAlliedMinor);

				// How strong is this friend?
				if(eThirdPartyStrength == STRENGTH_PATHETIC)
					iThirdPartyValue += /* 0*/ GC.getTARGET_MINOR_BACKUP_PATHETIC();
				else if(eThirdPartyStrength == STRENGTH_WEAK)
					iThirdPartyValue += /* 0*/ GC.getTARGET_MINOR_BACKUP_WEAK();
				else if(eThirdPartyStrength == STRENGTH_POOR)
					iThirdPartyValue += /* 5*/ GC.getTARGET_MINOR_BACKUP_POOR();
				else if(eThirdPartyStrength == STRENGTH_AVERAGE)
					iThirdPartyValue += /* 15*/ GC.getTARGET_MINOR_BACKUP_AVERAGE();
				else if(eThirdPartyStrength == STRENGTH_STRONG)
					iThirdPartyValue += /* 25*/ GC.getTARGET_MINOR_BACKUP_STRONG();
				else if(eThirdPartyStrength == STRENGTH_POWERFUL)
					iThirdPartyValue += /* 35*/ GC.getTARGET_MINOR_BACKUP_POWERFUL();
				else if(eThirdPartyStrength == STRENGTH_IMMENSE)
					iThirdPartyValue += /* 50*/ GC.getTARGET_MINOR_BACKUP_IMMENSE();

				// How close is this guy to us?
				if(eThirdPartyProximity == PLAYER_PROXIMITY_DISTANT)
					iThirdPartyValue *= /* 100*/ GC.getTARGET_MINOR_BACKUP_DISTANT();
				else if(eThirdPartyProximity == PLAYER_PROXIMITY_FAR)
					iThirdPartyValue *= /* 115*/ GC.getTARGET_MINOR_BACKUP_FAR();
				else if(eThirdPartyProximity == PLAYER_PROXIMITY_CLOSE)
					iThirdPartyValue *= /* 150*/ GC.getTARGET_MINOR_BACKUP_CLOSE();
				else if(eThirdPartyProximity == PLAYER_PROXIMITY_NEIGHBORS)
					iThirdPartyValue *= /* 200*/ GC.getTARGET_MINOR_BACKUP_NEIGHBORS();

				iThirdPartyValue /= 150;

				// Add the strength of this friend in to the overall eval
				iStrengthEstimate += iThirdPartyValue;
			}
		}
		//Grab their DPs
		for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes eMajor = (PlayerTypes)iMajorLoop;

			if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eMajor) && GET_TEAM(GET_PLAYER(eMajor).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
			{
				int iThirdPartyValue = 0;
				StrengthTypes eThirdPartyStrength = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eMajor);
				PlayerProximityTypes eThirdPartyProximity = GET_PLAYER(ePlayer).GetProximityToPlayer(eMajor);

				// How strong is this friend?
				if (eThirdPartyStrength == STRENGTH_PATHETIC)
					iThirdPartyValue += /* 0*/ GC.getTARGET_MINOR_BACKUP_PATHETIC();
				else if (eThirdPartyStrength == STRENGTH_WEAK)
					iThirdPartyValue += /* 0*/ GC.getTARGET_MINOR_BACKUP_WEAK();
				else if (eThirdPartyStrength == STRENGTH_POOR)
					iThirdPartyValue += /* 5*/ GC.getTARGET_MINOR_BACKUP_POOR();
				else if (eThirdPartyStrength == STRENGTH_AVERAGE)
					iThirdPartyValue += /* 15*/ GC.getTARGET_MINOR_BACKUP_AVERAGE();
				else if (eThirdPartyStrength == STRENGTH_STRONG)
					iThirdPartyValue += /* 25*/ GC.getTARGET_MINOR_BACKUP_STRONG();
				else if (eThirdPartyStrength == STRENGTH_POWERFUL)
					iThirdPartyValue += /* 35*/ GC.getTARGET_MINOR_BACKUP_POWERFUL();
				else if (eThirdPartyStrength == STRENGTH_IMMENSE)
					iThirdPartyValue += /* 50*/ GC.getTARGET_MINOR_BACKUP_IMMENSE();

				// How close is this guy to us?
				if (eThirdPartyProximity == PLAYER_PROXIMITY_DISTANT)
					iThirdPartyValue *= /* 100*/ GC.getTARGET_MINOR_BACKUP_DISTANT();
				else if (eThirdPartyProximity == PLAYER_PROXIMITY_FAR)
					iThirdPartyValue *= /* 115*/ GC.getTARGET_MINOR_BACKUP_FAR();
				else if (eThirdPartyProximity == PLAYER_PROXIMITY_CLOSE)
					iThirdPartyValue *= /* 150*/ GC.getTARGET_MINOR_BACKUP_CLOSE();
				else if (eThirdPartyProximity == PLAYER_PROXIMITY_NEIGHBORS)
					iThirdPartyValue *= /* 200*/ GC.getTARGET_MINOR_BACKUP_NEIGHBORS();

				iThirdPartyValue /= 100;

				// Add the strength of this friend in to the overall eval
				iStrengthEstimate += iThirdPartyValue;
			}
		}
	}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Factor in player's Masters if he has any
	if(MOD_DIPLOMACY_CIV4_FEATURES && !GET_PLAYER(ePlayer).isMinorCiv())
	{
		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes eMajor = (PlayerTypes) iMajorLoop;

			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eMajor))
			{
				if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() == GET_PLAYER(eMajor).getTeam())
				{
					int iThirdPartyValue = 0;
					StrengthTypes eThirdPartyStrength = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eMajor);
					PlayerProximityTypes eThirdPartyProximity = GET_PLAYER(ePlayer).GetProximityToPlayer(eMajor);

					// to-do: globals
					switch(eThirdPartyStrength)
					{
						case STRENGTH_IMMENSE:
							iThirdPartyValue += 50;
							break;
						case STRENGTH_POWERFUL:
							iThirdPartyValue += 35;
							break;
						case STRENGTH_STRONG:
							iThirdPartyValue += 25;
							break;
						case STRENGTH_AVERAGE:
							iThirdPartyValue += 15;
							break;
						case STRENGTH_POOR:
							iThirdPartyValue += 0;
							break;
						case STRENGTH_WEAK:
							iThirdPartyValue += 0;
							break;
						case STRENGTH_PATHETIC:
							iThirdPartyValue += 0;
							break;
					}

					switch(eThirdPartyProximity)
					{
						case PLAYER_PROXIMITY_NEIGHBORS:
							iThirdPartyValue *= 200;
							break;
						case PLAYER_PROXIMITY_CLOSE:
							iThirdPartyValue *= 150;
							break;
						case PLAYER_PROXIMITY_FAR:
							iThirdPartyValue *= 100;
							break;
						case PLAYER_PROXIMITY_DISTANT:
							iThirdPartyValue *= 50;
							break;
					}

					iThirdPartyValue /= 100;
					iStrengthEstimate += iThirdPartyValue;
				}
				else if(GET_TEAM(GET_PLAYER(eMajor).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
				{
					int iThirdPartyValue = 0;
					StrengthTypes eThirdPartyStrength = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eMajor);
					PlayerProximityTypes eThirdPartyProximity = GET_PLAYER(ePlayer).GetProximityToPlayer(eMajor);

					// to-do: globals
					switch(eThirdPartyStrength)
					{
						case STRENGTH_IMMENSE:
							iThirdPartyValue += 50;
							break;
						case STRENGTH_POWERFUL:
							iThirdPartyValue += 35;
							break;
						case STRENGTH_STRONG:
							iThirdPartyValue += 25;
							break;
						case STRENGTH_AVERAGE:
							iThirdPartyValue += 15;
							break;
						case STRENGTH_POOR:
							iThirdPartyValue += 0;
							break;
						case STRENGTH_WEAK:
							iThirdPartyValue += 0;
							break;
						case STRENGTH_PATHETIC:
							iThirdPartyValue += 0;
							break;
					}

					switch(eThirdPartyProximity)
					{
						case PLAYER_PROXIMITY_NEIGHBORS:
							iThirdPartyValue *= 200;
							break;
						case PLAYER_PROXIMITY_CLOSE:
							iThirdPartyValue *= 150;
							break;
						case PLAYER_PROXIMITY_FAR:
							iThirdPartyValue *= 100;
							break;
						case PLAYER_PROXIMITY_DISTANT:
							iThirdPartyValue *= 50;
							break;
					}

					iThirdPartyValue /= 100;
					iStrengthEstimate += iThirdPartyValue;
				}
			}
		}
	}
#endif

	//Add in their defense pacts as a direct boost to their power
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts() > 0)
	{
		iStrengthEstimate *= (100 + (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts() * 10));
		iStrengthEstimate /= 100;
	}

	return iStrengthEstimate;
}

/// Updates what our assessment is of a player's value as a military target
void CvDiplomacyAI::DoUpdateOnePlayerTargetValue(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(!IsPlayerValid(ePlayer))
		return;

	TargetValueTypes eTargetValue = NO_TARGET_VALUE;

	int iMyMilitaryStrength = GetPlayerOverallStrengthEstimate(GetPlayer()->GetID(), GetPlayer()->IsAtWarWith(ePlayer));
	int iOtherPlayerMilitaryStrength = GetPlayerOverallStrengthEstimate(ePlayer, GetPlayer()->IsAtWarWith(ePlayer));

	// Example: If another player has double the Military strength of us, the Ratio will be 200
	int iMilitaryRatio = iOtherPlayerMilitaryStrength* /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / max(1,iMyMilitaryStrength);

	// Factor in distance
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_NEIGHBORS:
		iMilitaryRatio += /*-10*/ GC.getTARGET_NEIGHBORS();
		break;
	case PLAYER_PROXIMITY_CLOSE:
		iMilitaryRatio += /*0*/ GC.getTARGET_CLOSE();
		break;
	case PLAYER_PROXIMITY_FAR:
		iMilitaryRatio += /*30*/ GC.getTARGET_FAR();
		break;
	case PLAYER_PROXIMITY_DISTANT:
		iMilitaryRatio += /*80*/ GC.getTARGET_DISTANT();
		break;
	}

	// Now do the final assessment
	if(iMilitaryRatio >= /*200*/ GC.getTARGET_IMPOSSIBLE_THRESHOLD())
		eTargetValue = TARGET_VALUE_IMPOSSIBLE;
	else if(iMilitaryRatio >= /*125*/ GC.getTARGET_BAD_THRESHOLD())
		eTargetValue = TARGET_VALUE_BAD;
	else if(iMilitaryRatio >= /*80*/ GC.getTARGET_AVERAGE_THRESHOLD())
		eTargetValue = TARGET_VALUE_AVERAGE;
	else if(iMilitaryRatio >= /*50*/ GC.getTARGET_FAVORABLE_THRESHOLD())
		eTargetValue = TARGET_VALUE_FAVORABLE;
	else
		eTargetValue = TARGET_VALUE_SOFT;

	// Set the value
	SetPlayerTargetValue(ePlayer, eTargetValue);
}


/// How much Gold Per Turn would we lose if we went to war with this player?
int CvDiplomacyAI::CalculateGoldPerTurnLostFromWar(PlayerTypes ePlayer, bool bOtherPlayerEstimate, bool bIgnoreDPs)
{
	if (!IsPlayerValid(ePlayer))
		return 0;
	
	if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
		return 0;
	
	int iGPT = 0;
	
	// Minor civ
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(ePlayer) / 100;
#if defined(MOD_BALANCE_CORE)
		iGPT += GET_PLAYER(ePlayer).GetMinorCivAI()->GetCurrentGoldBonus(GetPlayer()->GetID());
#endif
		return iGPT;
	}
	
	// Major civ
	iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(ePlayer);
	iGPT += GC.getGame().GetGameDeals().GetDealGPTLostFromWar(GetPlayer()->GetID(), ePlayer) * 100;
	
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// Vassal taxes?
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() == m_pPlayer->getTeam())
		{
			iGPT += GetPlayer()->GetTreasury()->GetVassalTaxContributionTimes100(ePlayer);
		}
	}
#endif
	
	// Loop through other majors we would go to war with
	if (!bOtherPlayerEstimate)
	{
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if (IsPlayerValid(eLoopPlayer) && eLoopPlayer != ePlayer)
			{
				// Teammate?
				if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
				{
					iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(eLoopPlayer);
					iGPT += GC.getGame().GetGameDeals().GetDealGPTLostFromWar(GetPlayer()->GetID(), eLoopPlayer) * 100;
				}
				// Defensive Pact?
				else if (!bIgnoreDPs && GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
				{
					iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(eLoopPlayer);
					iGPT += GC.getGame().GetGameDeals().GetDealGPTLostFromWar(GetPlayer()->GetID(), eLoopPlayer) * 100;
				}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				else if (MOD_DIPLOMACY_CIV4_FEATURES)
				{
					// Master/vassal?
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
					{
						iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(eLoopPlayer);
						iGPT += GC.getGame().GetGameDeals().GetDealGPTLostFromWar(GetPlayer()->GetID(), eLoopPlayer) * 100;
					}
				}
#endif	
			}
		}
	}
	
	// Loop through minors we would go to war with
	bool bCombatant = false;
	PlayerTypes eMinor;
	PlayerTypes eAlly;
	for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
	{
		eMinor = (PlayerTypes) iMinorCivLoop;
		
		// Must have met the City-State
		if (!IsPlayerValid(eMinor))
			continue;
		
		if (bOtherPlayerEstimate && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eMinor))
			continue;
		
		// Irrelevant if we're not friends
		if (!GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
			continue;
	
		// Irrelevant if we're allies or they don't have an ally
		eAlly = GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly();
		if (eAlly == NO_PLAYER || eAlly == GetPlayer()->GetID())
			continue;
		
		// Is their ally someone we'd be at war with?
		if (GET_PLAYER(eAlly).getTeam() == GET_PLAYER(ePlayer).getTeam())
		{
			bCombatant = true;
		}
		
		else if (!bIgnoreDPs && GET_TEAM(GET_PLAYER(eAlly).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
		{
			bCombatant = true;
		}
		
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		else if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(GET_PLAYER(eAlly).getTeam()) || GET_TEAM(GET_PLAYER(eAlly).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
			{
				bCombatant = true;
			}
		}
#endif
		if (bCombatant)
		{
			iGPT += GetPlayer()->GetTrade()->GetTradeGPTLostFromWarTimes100(eMinor);
#if defined(MOD_BALANCE_CORE)
			iGPT += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentGoldBonus(GetPlayer()->GetID()) * 100;
#endif
			bCombatant = false;
		}
	}
	
	// Bring it out of hundreds
	iGPT /= 100;
	
	return iGPT;
}

/// Would going to war with this player backstab a friend or ally?
bool CvDiplomacyAI::IsWarWouldBackstabFriend(PlayerTypes ePlayer)
{
	if (!IsPlayerValid(ePlayer))
		return false;
	
	// Friend?
	if (IsDoFAccepted(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(GetPlayer()->GetID()))
	{
		return true;
	}
	
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if (GetDoFType(ePlayer) >= DOF_TYPE_ALLIES)
	{
		return true;
	}
#endif
	
	// Defensive Pact?
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GetTeam()))
	{
		return true;
	}
	
	// Ally?
	if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ALLY)
	{
		return true;
	}
	
	// Who else would we go to war with?
	PlayerTypes eLoopPlayer;
	bool bCheckPlayer = false;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if (IsPlayerValid(eLoopPlayer) && eLoopPlayer != ePlayer)
		{
			// Teammate?
			if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
			{
				bCheckPlayer = true;
			}
			// Defensive Pact?
			else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
			{
				bCheckPlayer = true;
			}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			else if (MOD_DIPLOMACY_CIV4_FEATURES)
			{
				// Master/vassal?
				if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
				{
					bCheckPlayer = true;
				}
			}
#endif	
			if (bCheckPlayer)
			{
				// Friend?
				if (IsDoFAccepted(eLoopPlayer) || GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDoFAccepted(GetPlayer()->GetID()))
				{
					return true;
				}
				
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				if (GetDoFType(eLoopPlayer) >= DOF_TYPE_ALLIES)
				{
					return true;
				}
#endif
				// Defensive Pact?
				if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GetTeam()))
				{
					return true;
				}
				
				// Ally?
				if (GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_ALLY)
				{
					return true;
				}
				
				// Military promise?
				if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetPlayer()->GetID()))
				{
					return true;
				}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				if (IsPlayerMoveTroopsRequestAccepted(eLoopPlayer))
				{
					return true;
				}
#endif
				
				bCheckPlayer = false;
			}
		}
	}
	
	return false;
}

/// Would going to war with this player cause one of our team members to backstab a friend or ally?
bool CvDiplomacyAI::IsWarWouldBackstabFriendTeamCheck(PlayerTypes ePlayer)
{
	if (!IsPlayerValid(ePlayer))
		return false;
	
	if (IsWarWouldBackstabFriend(ePlayer))
		return true;
	
	// Loop through all the other players on this team
	PlayerTypes eLoopPlayer;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if (IsPlayerValid(eLoopPlayer, true) && eLoopPlayer != GetPlayer()->GetID())
		{
			if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsWarWouldBackstabFriend(ePlayer))
			{
				return true;
			}
		}
	}
	
	return false;
}

// ************************************
// Threats to this Player
// ************************************

/// How threatening is this player militarily?
ThreatTypes CvDiplomacyAI::GetMilitaryThreat(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (ThreatTypes) m_paeMilitaryThreat[ePlayer];
}

/// Set how threatening this player is militarily
void CvDiplomacyAI::SetMilitaryThreat(PlayerTypes ePlayer, ThreatTypes eMilitaryThreat)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMilitaryThreat >= 0, "DIPLOMACY_AI: Invalid ThreatType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMilitaryThreat < NUM_THREAT_VALUES, "DIPLOMACY_AI: Invalid v.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeMilitaryThreat[ePlayer] = eMilitaryThreat;
}

/// Updates how threatening each player is militarily
void CvDiplomacyAI::DoUpdateMilitaryThreats()
{
	int iMilitaryThreat;
	ThreatTypes eMilitaryThreatType;

	int iWarCount;

	int iMyMilitaryStrength = GetPlayer()->GetMilitaryMight();
	// Prevent divide by 0
	if(iMyMilitaryStrength == 0)
	{
		iMyMilitaryStrength = 1;
	}

	// Add in City Defensive Strength
	CvCity* pLoopCity;
	int iCityLoop;
	int iCityStrengthMod;
#if defined(MOD_BALANCE_CORE)
	int iCityStrengthUsTotal = 0;
#endif
	for(pLoopCity = GetPlayer()->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iCityLoop))
	{
		iCityStrengthMod = pLoopCity->GetPower();
		iCityStrengthMod *= (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage());
		iCityStrengthMod /= pLoopCity->GetMaxHitPoints();
		iCityStrengthMod /= 100;
		iCityStrengthMod *= /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD();
		iCityStrengthMod /= 100;
#if defined(MOD_BALANCE_CORE)
		iCityStrengthUsTotal += iCityStrengthMod;
#else
		iMyMilitaryStrength += iCityStrengthMod;
#endif
	}

	int iOtherPlayerMilitaryStrength;
	int iMilitaryRatio;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			iMilitaryThreat = 0;

			iOtherPlayerMilitaryStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

#if defined(MOD_BALANCE_CORE)
			// Add in City Defensive Strength
			CvCity* pLoopCity2;
			int iCityLoop2;
			int iCityStrengthMod2;
			int iCityStrengthTotal = 0;
			for(pLoopCity2 = GET_PLAYER(eLoopPlayer).firstCity(&iCityLoop2); pLoopCity2 != NULL; pLoopCity2 = GET_PLAYER(eLoopPlayer).nextCity(&iCityLoop2))
			{
				iCityStrengthMod2 = pLoopCity2->GetPower();
				iCityStrengthMod2 *= (pLoopCity2->GetMaxHitPoints() - pLoopCity2->getDamage());
				iCityStrengthMod2 /= pLoopCity2->GetMaxHitPoints();
				iCityStrengthMod2 /= 100;
				iCityStrengthMod2 *= /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD();
				iCityStrengthMod2 /= 100;
				iCityStrengthTotal += iCityStrengthMod2;
			}
			//Divide by # of cities.
			iOtherPlayerMilitaryStrength += (iCityStrengthTotal / max(1, GET_PLAYER(eLoopPlayer).getNumCities()));
#endif

			// Example: If another player has double the Military strength of us, the Ratio will be 200
			iMilitaryRatio = iOtherPlayerMilitaryStrength* /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / iMyMilitaryStrength;

			iMilitaryThreat += iMilitaryRatio;

			// At war: what is the current status of things?
			if(GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				// War State
				switch(GetWarState(eLoopPlayer))
				{
				case WAR_STATE_CALM:
					iMilitaryThreat += /*0*/ GC.getMILITARY_THREAT_WAR_STATE_CALM();
					break;
				case WAR_STATE_NEARLY_WON:
					iMilitaryThreat += /*-100*/ GC.getMILITARY_THREAT_WAR_STATE_NEARLY_WON();
					break;
				case WAR_STATE_OFFENSIVE:
					iMilitaryThreat += /*-40*/ GC.getMILITARY_THREAT_WAR_STATE_OFFENSIVE();
					break;
				case WAR_STATE_STALEMATE:
					iMilitaryThreat += /*30*/ GC.getMILITARY_THREAT_WAR_STATE_STALEMATE();
					break;
				case WAR_STATE_DEFENSIVE:
					iMilitaryThreat += /*80*/ GC.getMILITARY_THREAT_WAR_STATE_DEFENSIVE();
					break;
				case WAR_STATE_NEARLY_DEFEATED:
					iMilitaryThreat += /*150*/ GC.getMILITARY_THREAT_WAR_STATE_NEARLY_DEFEATED();
					break;
				}
			}

			// Factor in Friends this player has

			// TBD

			// Factor in distance
			switch(GetPlayer()->GetProximityToPlayer(eLoopPlayer))
			{
			case PLAYER_PROXIMITY_NEIGHBORS:
				iMilitaryThreat += /*100*/ GC.getMILITARY_THREAT_NEIGHBORS();
				break;
			case PLAYER_PROXIMITY_CLOSE:
				iMilitaryThreat += /*40*/ GC.getMILITARY_THREAT_CLOSE();
				break;
			case PLAYER_PROXIMITY_FAR:
				iMilitaryThreat += /*-40*/ GC.getMILITARY_THREAT_FAR();
				break;
			case PLAYER_PROXIMITY_DISTANT:
				iMilitaryThreat += /*-100*/ GC.getMILITARY_THREAT_DISTANT();
				break;
			}

			// Don't factor in # of players attacked or at war with now if we ARE at war with this guy already
			if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				// Increase threat based on how many Player's we've already seen this guy attack and conquer
				iMilitaryThreat += (GetOtherPlayerNumMinorsAttacked(eLoopPlayer) * /*20*/ GC.getMILITARY_THREAT_PER_MINOR_ATTACKED()) / max(1, GC.getGame().GetNumMinorCivsEver());
				iMilitaryThreat += (GetOtherPlayerNumMinorsConquered(eLoopPlayer) * /*10*/ GC.getMILITARY_THREAT_PER_MINOR_CONQUERED()) / max(1, GC.getGame().GetNumMinorCivsEver());
				iMilitaryThreat += (GetOtherPlayerNumMajorsAttacked(eLoopPlayer) * /*40*/ GC.getMILITARY_THREAT_PER_MAJOR_ATTACKED()) / max(1, GC.getGame().countMajorCivsEverAlive());
				iMilitaryThreat += (GetOtherPlayerNumMajorsConquered(eLoopPlayer) * /*20*/ GC.getMILITARY_THREAT_PER_MAJOR_CONQUERED()) / max(1, GC.getGame().countMajorCivsEverAlive());

				// Reduce the Threat (dramatically) if the player is already at war with other players
				iWarCount = GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).getAtWarCount(true);
				if(iWarCount > 0)
				{
					iMilitaryThreat += (/*-30*/ GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * iWarCount * iMilitaryThreat / 100);
				}
			}

			// Now do the final assessment
			if(iMilitaryThreat >= /*300*/ GC.getMILITARY_THREAT_CRITICAL_THRESHOLD())
				eMilitaryThreatType = THREAT_CRITICAL;
			else if(iMilitaryThreat >= /*220*/ GC.getMILITARY_THREAT_SEVERE_THRESHOLD())
				eMilitaryThreatType = THREAT_SEVERE;
			else if(iMilitaryThreat >= /*170*/ GC.getMILITARY_THREAT_MAJOR_THRESHOLD())
				eMilitaryThreatType = THREAT_MAJOR;
			else if(iMilitaryThreat >= /*100*/ GC.getMILITARY_THREAT_MINOR_THRESHOLD())
				eMilitaryThreatType = THREAT_MINOR;
			else
				eMilitaryThreatType = THREAT_NONE;

			// Set the Threat
			SetMilitaryThreat(eLoopPlayer, eMilitaryThreatType);
		}
	}
}


/// What is our guess as to the level of Military Threat one player feels from another?
ThreatTypes CvDiplomacyAI::GetEstimateOtherPlayerMilitaryThreat(PlayerTypes ePlayer, PlayerTypes eWithPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (ThreatTypes) m_ppaaeOtherPlayerMilitaryThreat[ePlayer][eWithPlayer];
}

void CvDiplomacyAI::SetEstimateOtherPlayerMilitaryThreat(PlayerTypes ePlayer, PlayerTypes eWithPlayer, ThreatTypes eThreatType)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eThreatType >= 0, "DIPLOMACY_AI: Invalid ThreatType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eThreatType < NUM_THREAT_VALUES, "DIPLOMACY_AI: Invalid ThreatType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaeOtherPlayerMilitaryThreat[ePlayer][eWithPlayer] = eThreatType;
}

/// Updates what our guess is as to the level of Military Threat one player feels from another
void CvDiplomacyAI::DoUpdateEstimateOtherPlayerMilitaryThreats()
{
	int iMilitaryThreat;
	ThreatTypes eMilitaryThreatType;

	int iWarCount;

	int iPlayerMilitaryStrength;

	CvCity* pLoopCity;
	int iCityLoop;
	int iCityStrengthMod;

	int iThirdPlayerMilitaryStrength;
	int iMilitaryRatio;

	PlayerTypes eLoopOtherPlayer;
	int iOtherPlayerLoop;

	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			iPlayerMilitaryStrength = GET_PLAYER(eLoopPlayer).GetMilitaryMight();

			// Add in City Defensive Strength
			for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iCityLoop))
			{
				iCityStrengthMod = pLoopCity->GetPower();
				iCityStrengthMod *= (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage());
				iCityStrengthMod /= pLoopCity->GetMaxHitPoints();
				iCityStrengthMod /= 100;
				iCityStrengthMod *= /*33*/ GC.getMILITARY_STRENGTH_CITY_MOD();
				iCityStrengthMod /= 100;
				iPlayerMilitaryStrength += (MAX(iCityStrengthMod, 0));
			}

			// Prevent divide by 0
			if(iPlayerMilitaryStrength == 0)
				iPlayerMilitaryStrength = 1;

			// Now loop through every player HE knows
			for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
			{
				eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

				// Don't compare a player to himself
				if(eLoopPlayer != eLoopOtherPlayer)
				{
					// Do both we and the guy we're looking about know the third guy?
					if(IsPlayerValid(eLoopOtherPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
					{
						eMilitaryThreatType = THREAT_NONE;
						iMilitaryThreat = 0;

						iThirdPlayerMilitaryStrength = GET_PLAYER(eLoopOtherPlayer).GetMilitaryMight();

						// Example: If another player has double the Military strength of us, the Ratio will be 200
						iMilitaryRatio = iThirdPlayerMilitaryStrength* /*100*/ GC.getMILITARY_STRENGTH_RATIO_MULTIPLIER() / iPlayerMilitaryStrength;

						iMilitaryThreat += iMilitaryRatio;

						//// At war: what is the current status of things?
						//if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
						//{
						//	// War State
						//	switch (GetWarState(eLoopPlayer))
						//	{
						//	case WAR_STATE_CALM:
						//		iMilitaryThreat += /*0*/ GC.getMILITARY_THREAT_WAR_STATE_CALM();
						//		break;
						//	case WAR_STATE_NEARLY_WON:
						//		iMilitaryThreat += /*-100*/ GC.getMILITARY_THREAT_WAR_STATE_NEARLY_WON();
						//		break;
						//	case WAR_STATE_OFFENSIVE:
						//		iMilitaryThreat += /*-40*/ GC.getMILITARY_THREAT_WAR_STATE_OFFENSIVE();
						//		break;
						//	case WAR_STATE_STALEMATE:
						//		iMilitaryThreat += /*30*/ GC.getMILITARY_THREAT_WAR_STATE_STALEMATE();
						//		break;
						//	case WAR_STATE_DEFENSIVE:
						//		iMilitaryThreat += /*80*/ GC.getMILITARY_THREAT_WAR_STATE_DEFENSIVE();
						//		break;
						//	case WAR_STATE_NEARLY_DEFEATED:
						//		iMilitaryThreat += /*150*/ GC.getMILITARY_THREAT_WAR_STATE_NEARLY_DEFEATED();
						//		break;
						//	}
						//}

						// Factor in Friends this player has

						// TBD

						// Factor in distance
						switch(GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eLoopOtherPlayer))
						{
						case PLAYER_PROXIMITY_NEIGHBORS:
							iMilitaryThreat += /*100*/ GC.getMILITARY_THREAT_NEIGHBORS();
							break;
						case PLAYER_PROXIMITY_CLOSE:
							iMilitaryThreat += /*40*/ GC.getMILITARY_THREAT_CLOSE();
							break;
						case PLAYER_PROXIMITY_FAR:
							iMilitaryThreat += /*-40*/ GC.getMILITARY_THREAT_FAR();
							break;
						case PLAYER_PROXIMITY_DISTANT:
							iMilitaryThreat += /*-100*/ GC.getMILITARY_THREAT_DISTANT();
							break;
						}

						// Don't factor in # of players attacked or at war with now if we ARE at war with this guy already
//						if (!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
						{
							// Increase threat based on how many Player's we've already seen this guy attack and conquer
							iMilitaryThreat += (GetOtherPlayerNumMinorsAttacked(eLoopOtherPlayer)  * /*20*/ GC.getMILITARY_THREAT_PER_MINOR_ATTACKED());
							iMilitaryThreat += (GetOtherPlayerNumMinorsConquered(eLoopOtherPlayer) * /*10*/ GC.getMILITARY_THREAT_PER_MINOR_CONQUERED());
							iMilitaryThreat += (GetOtherPlayerNumMajorsAttacked(eLoopOtherPlayer)  * /*40*/ GC.getMILITARY_THREAT_PER_MAJOR_ATTACKED());
							iMilitaryThreat += (GetOtherPlayerNumMajorsConquered(eLoopOtherPlayer) * /*20*/ GC.getMILITARY_THREAT_PER_MAJOR_CONQUERED());

							// Reduce the Threat (dramatically) if the player is already at war with other players
							iWarCount = GET_TEAM(GET_PLAYER(eLoopOtherPlayer).getTeam()).getAtWarCount(true);
							if(iWarCount > 0)
#if defined(MOD_BALANCE_CORE)
								iMilitaryThreat += (/*-30*/ GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * iWarCount);
#else
								iMilitaryThreat += (/*-30*/ GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * iWarCount * iMilitaryThreat / 100);
#endif
						}
#if defined(MOD_BALANCE_CORE)
						if(!GET_PLAYER(eLoopPlayer).isHuman())
						{
							if(GetWarmongerThreat(eLoopOtherPlayer) >= THREAT_MAJOR)
							{
								iMilitaryThreat += (GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * -1);
							}
							if(GetVictoryBlockLevel(eLoopOtherPlayer) >= BLOCK_LEVEL_STRONG)
							{
								iMilitaryThreat += (GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * -1);
							}
							if(GetVictoryDisputeLevel(eLoopOtherPlayer) >= DISPUTE_LEVEL_STRONG)
							{
								iMilitaryThreat += (GC.getMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER() * -1);
							}
						}
#endif
						// Now do the final assessment
						if(iMilitaryThreat >= /*300*/ GC.getMILITARY_THREAT_CRITICAL_THRESHOLD())
							eMilitaryThreatType = THREAT_CRITICAL;
						else if(iMilitaryThreat >= /*220*/ GC.getMILITARY_THREAT_SEVERE_THRESHOLD())
							eMilitaryThreatType = THREAT_SEVERE;
						else if(iMilitaryThreat >= /*170*/ GC.getMILITARY_THREAT_MAJOR_THRESHOLD())
							eMilitaryThreatType = THREAT_MAJOR;
						else if(iMilitaryThreat >= /*100*/ GC.getMILITARY_THREAT_MINOR_THRESHOLD())
							eMilitaryThreatType = THREAT_MINOR;

						// Set the Threat
						SetEstimateOtherPlayerMilitaryThreat(eLoopPlayer, eLoopOtherPlayer, eMilitaryThreatType);
					}
				}
			}
		}
	}
}

/// How much of a threat are these guys to run amok and break everything?
ThreatTypes CvDiplomacyAI::GetWarmongerThreat(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (ThreatTypes) m_paeWarmongerThreat[ePlayer];
}

/// Sets how much of a threat these guys are to run amok and break everything
void CvDiplomacyAI::SetWarmongerThreat(PlayerTypes ePlayer, ThreatTypes eWarmongerThreat)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarmongerThreat >= 0, "DIPLOMACY_AI: Invalid ThreatType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWarmongerThreat < NUM_THREAT_VALUES, "DIPLOMACY_AI: Invalid ThreatType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeWarmongerThreat[ePlayer] = eWarmongerThreat;
}

/// Updates how much of a threat each player is to run amok and break everything
void CvDiplomacyAI::DoUpdateWarmongerThreats(bool bUpdateOnly)
{
	ThreatTypes eThreatType;

	int iThreatValue;

	int iNumPlayersKilled;
	int iNumPlayersEver = GC.getGame().countCivPlayersEverAlive();
	int iPlayersKilledPercent;
	int iWarmongerMod;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES)
			{
				// If they're our master, we don't care.
				if (IsVassal(eLoopPlayer))
				{
					SetOtherPlayerWarmongerAmountTimes100(eLoopPlayer, 0);
					SetWarmongerThreat(eLoopPlayer, THREAT_NONE);
					continue;
				}
				// Don't count vassals, since they can't declare war themselves.
				else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).GetMaster() != NO_TEAM)
				{
					SetOtherPlayerWarmongerAmountTimes100(eLoopPlayer, 0);
					SetWarmongerThreat(eLoopPlayer, THREAT_NONE);
					continue;
				}
			}
#endif
			eThreatType = THREAT_NONE;
			iThreatValue = GetOtherPlayerWarmongerScore(eLoopPlayer);

			// Now do the final assessment
			if (iThreatValue >= /*200*/ GC.getWARMONGER_THREAT_CRITICAL_THRESHOLD())
				eThreatType = THREAT_CRITICAL;
			else if (iThreatValue >= /*100*/ GC.getWARMONGER_THREAT_SEVERE_THRESHOLD())
				eThreatType = THREAT_SEVERE;
			else if (iThreatValue >= /*50*/ GC.getWARMONGER_THREAT_MAJOR_THRESHOLD())
				eThreatType = THREAT_MAJOR;
			else if (iThreatValue >= /*20*/ GC.getWARMONGER_THREAT_MINOR_THRESHOLD())
				eThreatType = THREAT_MINOR;

			// Also test % of players killed (in case we're on a map with very few players or something)
#if defined(MOD_BALANCE_CORE)
			if (GC.getGame().countCivPlayersEverAlive() <= 4)
			{
#endif
				iNumPlayersKilled = GetOtherPlayerNumMinorsConquered(eLoopPlayer) + GetOtherPlayerNumMajorsConquered(eLoopPlayer);
				if (iNumPlayersKilled > 0)
				{
					iPlayersKilledPercent = iNumPlayersKilled * 100 / iNumPlayersEver;

					iWarmongerMod = GetWarmongerHate() - /*5*/ GC.getDEFAULT_FLAVOR_VALUE();	// Calculate difference from default
					iWarmongerMod *= /*10*/ GC.getWARMONGER_THREAT_PERSONALITY_MOD();	// This will range from -50 to 50 (%)
					iPlayersKilledPercent += (iPlayersKilledPercent * iWarmongerMod / 100);

					if (iPlayersKilledPercent >= /*40*/ GC.getWARMONGER_THREAT_CRITICAL_PERCENT_THRESHOLD())
						eThreatType = THREAT_CRITICAL;
					if (iPlayersKilledPercent >= /*25*/ GC.getWARMONGER_THREAT_SEVERE_PERCENT_THRESHOLD())
						eThreatType = THREAT_SEVERE;
				}
#if defined(MOD_BALANCE_CORE)
			}
#endif

			// Set the Threat
			bool bUpdateLogsSpecial = false;
			if (eThreatType != GetWarmongerThreat(eLoopPlayer))
			{
				SetWarmongerThreat(eLoopPlayer, eThreatType);
				bUpdateLogsSpecial = true;
			}

			if (!bUpdateOnly)
			{
				// decay score
#if defined(MOD_API_EXTENSIONS)
				int iDecayModifier = 100;
#if defined(MOD_CONFIG_AI_IN_XML)
				// INCREASE if he's big and nasty, less so if he's not.
				switch (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer))
				{
				case STRENGTH_IMMENSE:
				case STRENGTH_POWERFUL:
					iDecayModifier = GC.getWARMONGER_THREAT_APPROACH_DECAY_SMALL();
					break;
				case STRENGTH_AVERAGE:
				case STRENGTH_STRONG:
					iDecayModifier = GC.getWARMONGER_THREAT_APPROACH_DECAY_MEDIUM();
					break;
				case STRENGTH_WEAK:
				case STRENGTH_POOR:
				case STRENGTH_PATHETIC:
					iDecayModifier = GC.getWARMONGER_THREAT_APPROACH_DECAY_LARGE();
					break;
				default:
					break;
				}

				int iDecayValue = GC.getWARMONGER_THREAT_PER_TURN_DECAY() * 100;

				//Protect against positives.
				if (iDecayValue > 0)
					iDecayValue *= -1;

				if (GC.getGame().GetGameLeagues()->IsWorldWar(GetPlayer()->GetID()) > 0)
				{
					iDecayModifier += GC.getWARMONGER_THREAT_PER_TURN_DECAY_INCREASED();
				}
				else if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(GetPlayer()->GetID()) > 0)
				{
					iDecayModifier += GC.getWARMONGER_THREAT_PER_TURN_DECAY_DECREASED();
				}

				iDecayValue *= iDecayModifier;
				iDecayValue /= 100;

				LogMajorCivWarmongerUpdate(eLoopPlayer, iDecayValue, bUpdateLogsSpecial);

				ChangeOtherPlayerWarmongerAmountTimes100(eLoopPlayer, iDecayValue);
			}
#endif
#endif
		}
	}
}



/////////////////////////////////////////////////////////
// Planning Exchanges
/////////////////////////////////////////////////////////


/// Updates our desire to make Research Agreements and Defensive Pacts with all players
void CvDiplomacyAI::DoUpdatePlanningExchanges()
{
	//int iRandRoll;
	//int iThreshold;

	int iNumRAsWanted = GetNumResearchAgreementsWanted();

	if (GET_TEAM(GetPlayer()->getTeam()).IsResearchAgreementTradingAllowed())
	{
		// Loop through all (known) Players
		PlayerTypes eLoopPlayer;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes)iPlayerLoop;

			if (IsPlayerValid(eLoopPlayer))
			{
				// RESEARCH AGREEMENT
				// Do we already have a RA?
				if (!GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					// If we're Friendly and have the appropriate Tech, there's a chance we want to make a Research Agreement
					if (!IsWantsResearchAgreementWithPlayer(eLoopPlayer))
					{
						//if(GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_FRIENDLY)
						//{
						if (GET_TEAM(GetPlayer()->getTeam()).IsResearchAgreementTradingAllowedWithTeam(GET_PLAYER(eLoopPlayer).getTeam()) ||	   // We have Tech & embassy to make a RA
							GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsResearchAgreementTradingAllowedWithTeam(GetPlayer()->getTeam())) // They have Tech & embassy to make RA
						{
							//iRandRoll = GC.getGame().getJonRandNumVA(100, "DIPLOMACY_AI: Random weight for player to make Research Agreement (%d; %d)", (int)GetPlayer()->GetID(), (int)eLoopPlayer);

							//iThreshold = /*8*/ GC.getWANT_RESEARCH_AGREEMENT_RAND();

							//iThreshold -= (iNumRAsWanted * 6);	// Reduce the likelihood of making another another RA if we've already got some on the books.  These things are expensive you know

							//if(iRandRoll < iThreshold)
							//{
							DoAddWantsResearchAgreementWithPlayer(eLoopPlayer);
							iNumRAsWanted++;	// This was calculated above, increment it by one since we know we've added another
							//}
						}
						//}
					}
				}

				// Already planning an RA?
				if (IsWantsResearchAgreementWithPlayer(eLoopPlayer))
				{
					bool bCancel = false;
					if (GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
					{
						bCancel = true;
					}
					else if (!(GET_TEAM(GetPlayer()->getTeam()).IsResearchAgreementTradingAllowedWithTeam(GET_PLAYER(eLoopPlayer).getTeam()) ||	   // We have Tech & embassy to make a RA
						GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsResearchAgreementTradingAllowedWithTeam(GetPlayer()->getTeam()))) // They have Tech & embassy to make RA
					{
						bCancel = true;
					}

					if (bCancel)
					{
						DoCancelWantsResearchAgreementWithPlayer(eLoopPlayer);
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_DEALS)
	if (MOD_BALANCE_CORE_DEALS && GET_TEAM(GetPlayer()->getTeam()).isDefensivePactTradingAllowed())
	{
		// Loop through all (known) Players and find ones we no longer want DP with.
		PlayerTypes eLoopPlayer;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes)iPlayerLoop;

			//We don't want spam - let's limit this to the civ's loyalty metric (to prevent backstabs and to keep the AI from overcomitting).
			if (!IsPlayerValid(eLoopPlayer))
				continue;

			if (IsWantsDefensivePactWithPlayer(eLoopPlayer) && !IsGoodChoiceForDefensivePact(eLoopPlayer))
			{
				DoCancelWantsDefensivePactWithPlayer(eLoopPlayer);
			}
		}

		//Second loop for new ones.
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes)iPlayerLoop;

			//We don't want spam - let's limit this to the civ's loyalty metric (to prevent backstabs and to keep the AI from overcomitting).
			if (!IsPlayerValid(eLoopPlayer))
				continue;

			if (!IsWantsDefensivePactWithPlayer(eLoopPlayer) && IsGoodChoiceForDefensivePact(eLoopPlayer))
			{
				DoAddWantsDefensivePactWithPlayer(eLoopPlayer); 
			}
		}
	}
#endif
}

/// Does this AI want to make a Research Agreement with ePlayer?
bool CvDiplomacyAI::IsWantsResearchAgreementWithPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabWantsResearchAgreementWithPlayer[ePlayer];
}

/// Sets if this AI wants to make a Research Agreement with ePlayer
void CvDiplomacyAI::SetWantsResearchAgreementWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabWantsResearchAgreementWithPlayer[ePlayer] = bValue;
}

/// How many different players does this AI want a RA with?
int CvDiplomacyAI::GetNumResearchAgreementsWanted() const
{
	int iNum = 0;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsWantsResearchAgreementWithPlayer(eLoopPlayer))
			iNum++;
	}

	return iNum;
}

/// AI wants a Research Agreement with ePlayer, so handle everything that means
void CvDiplomacyAI::DoAddWantsResearchAgreementWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(!IsWantsResearchAgreementWithPlayer(ePlayer), "DIPLOMACY_AI: AI trying to save for multiple Research Agreements with a player.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

	SetWantsResearchAgreementWithPlayer(ePlayer, true);

	// Start saving the Gold
	int iGoldAmount = GC.getGame().GetGameDeals().GetTradeItemGoldCost(TRADE_ITEM_RESEARCH_AGREEMENT, GetPlayer()->GetID(), ePlayer);
	GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MAJOR_CIV_TRADE, iGoldAmount, /*Priority*/ 1);

	LogWantRA(ePlayer);
}

/// AI wants to cancel its desire to make a Research Agreement with ePlayer, so handle everything that means
void CvDiplomacyAI::DoCancelWantsResearchAgreementWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(IsWantsResearchAgreementWithPlayer(ePlayer), "DIPLOMACY_AI: AI trying to cancel saving for a Research Agreements he doesn't have.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

	SetWantsResearchAgreementWithPlayer(ePlayer, false);

	GetPlayer()->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_MAJOR_CIV_TRADE);
}

/// Are we able to make a Research Agreement with ePlayer right now?
bool CvDiplomacyAI::IsCanMakeResearchAgreementRightNow(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Either side already have all techs?
	if(GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasResearchedAllTechs() || GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->HasResearchedAllTechs())
	{
		return false;
	}

	// We don't want a RA with this guy
	if(!IsWantsResearchAgreementWithPlayer(ePlayer))
	{
		return false;
	}

	// Already have a RA?
	if(GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(ePlayer).getTeam()))
	{
		return false;
	}

	// Can we have a research agreement right now?
	if(!(GET_TEAM(GetPlayer()->getTeam()).IsResearchAgreementTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam())   || // We have Tech & embassy to make a RA
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsResearchAgreementTradingAllowedWithTeam(GetPlayer()->getTeam())))    // They have Tech & embassy to make RA
	{
		return false;
	}

	int iGoldAmount = GC.getGame().GetGameDeals().GetTradeItemGoldCost(TRADE_ITEM_RESEARCH_AGREEMENT, GetPlayer()->GetID(), ePlayer);

	// We don't have enough Gold
	if(GetPlayer()->GetTreasury()->GetGold() < iGoldAmount)
	{
		return false;
	}

	// They don't have enough Gold
	if(GET_PLAYER(ePlayer).GetTreasury()->GetGold() < iGoldAmount)
	{
		return false;
	}

	return true;
}
#if defined(MOD_BALANCE_CORE_DEALS)
/// Does this AI want to sneak attack ePlayer?
bool CvDiplomacyAI::IsWantsSneakAttack(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabWantsSneakAttack[ePlayer];
}

/// Sets if this AI wants to sneak attack ePlayer
void CvDiplomacyAI::SetWantsSneakAttack(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabWantsSneakAttack[ePlayer] = bValue;
}

// Does the AI even want to conquer another player if they are at war?
// Since there is no "defensive war" flag, this seems to be the best way to differentiate
bool CvDiplomacyAI::IsWantsToConquer(PlayerTypes ePlayer) const
{
	if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
		return true;
	
	if (GC.getGame().countMajorCivsAlive() == 2)
		return true;
	
	//we don't have a target value for the barbarians ... could change it but that would break savegames
	if (ePlayer == BARBARIAN_PLAYER)
		return true;
	
	// If they're about to win, we have nothing to lose!
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
	{
		return true;
	}
	
	// If we're doing too badly, retreat!
	if (GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED || GetPlayer()->IsEmpireVeryUnhappy())
		return false;
	
	// They're an easy target, so play offensively!
	if (IsEasyTarget(ePlayer))
	{
		return true;
	}
	
	// We're going for world conquest, so play offensively!
	if ((IsGoingForWorldConquest() || IsCloseToDominationVictory()) && GetWarState(ePlayer) > WAR_STATE_DEFENSIVE)
	{
		return true;
	}
	
	// If we're locked into a coop war, we want to conquer them, period!
	if (GetPlayer()->GetDiplomacyAI()->IsLockedIntoCoopWar(ePlayer))
	{
		return true;
	}
	
	TargetValueTypes eTargetValue = GetPlayerTargetValue(ePlayer);
	
	// Medieval or earlier and strong territorial disputes...attack if we can
	if (GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetPlayer()->GetCurrentEra() <= 2)
	{
		if (eTargetValue >= TARGET_VALUE_AVERAGE)
		{
			return true;
		}
		else if (GetBoldness() > 6 && eTargetValue != TARGET_VALUE_IMPOSSIBLE)
		{
			return true;
		}
	}
	
	// bold players
	if (GetBoldness() > 6)
	{
		// Fiercely competitive with this guy? Who cares if he's tough to kill?
		if (!IsMajorCompetitor(ePlayer) && eTargetValue < TARGET_VALUE_AVERAGE)
		{
			return false;
		}
	}
	// less bold players
	else
	{
		// If we're fiercely competitive, lower our standards
		if (IsMajorCompetitor(ePlayer))
		{
			if (eTargetValue < TARGET_VALUE_AVERAGE)
			{
				return false;
			}
		}
		else
		{
			if (eTargetValue < TARGET_VALUE_FAVORABLE)
			{
				return false;
			}
		}
	}

	return true; //by default we conquer everything
}

/// Does this AI want to make a Defensive Pact with ePlayer?
bool CvDiplomacyAI::IsWantsDefensivePactWithPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabWantsDefensivePactWithPlayer[ePlayer];
}

/// Sets if this AI wants to make a Defensive Pact with ePlayer
void CvDiplomacyAI::SetWantsDefensivePactWithPlayer(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabWantsDefensivePactWithPlayer[ePlayer] = bValue;
}

/// How many different players does this AI want a DP with?
int CvDiplomacyAI::GetNumDefensivePactsWanted(PlayerTypes ePlayer) const
{
	int iNum = 0;

	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (ePlayer == eLoopPlayer)
			continue;

		if(IsWantsDefensivePactWithPlayer(eLoopPlayer))
			iNum++;
	}

	return iNum;
}

/// AI wants to make a Defensive Pact with ePlayer, so handle everything that means
void CvDiplomacyAI::DoAddWantsDefensivePactWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(!IsWantsDefensivePactWithPlayer(ePlayer), "DIPLOMACY_AI: AI trying to save for multiple Defensive Pacts with a player.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

	SetWantsDefensivePactWithPlayer(ePlayer, true);

	LogWantDP(ePlayer);
}

/// AI wants to cancel its desire to make a Defensive Pact with ePlayer, so handle everything that means
void CvDiplomacyAI::DoCancelWantsDefensivePactWithPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(IsWantsDefensivePactWithPlayer(ePlayer), "DIPLOMACY_AI: AI trying to cancel saving for a Defensive Pacts he doesn't have.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")

	SetWantsDefensivePactWithPlayer(ePlayer, false);
}

/// Are we able to make a Defensive Pact with ePlayer right now?
bool CvDiplomacyAI::IsCanMakeDefensivePactRightNow(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We don't want a DP with this guy
	if(!IsWantsDefensivePactWithPlayer(ePlayer))
	{
		return false;
	}

	if(IsArmyInPlaceForAttack(ePlayer))
	{
		return false;
	}
	if(GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
	{
		return false;
	}

	// Already have a DP?
	if(GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
	{
		return false;
	}

	// Can we have a Defensive Pact right now?
	if(!(GET_TEAM(GetPlayer()->getTeam()).isDefensivePactTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam())   || // We have Tech & embassy to make a RA
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isDefensivePactTradingAllowedWithTeam(GetPlayer()->getTeam())))    // They have Tech & embassy to make RA
	{
		return false;
	}

	return true;
}

bool CvDiplomacyAI::IsGoodChoiceForDefensivePact(PlayerTypes ePlayer)
{
	// Defensive Pacts
	// Do we already have a DP?
	if (GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
	{
		return false;
	}
	if (!GET_TEAM(GetPlayer()->getTeam()).isDefensivePactTradingAllowedWithTeam(GET_PLAYER(ePlayer).getTeam()) ||	   // We have Tech & embassy to make a RA
		!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isDefensivePactTradingAllowed()) // They have Tech & embassy to make RA
	{
		return false;
	}

	//No DPs if last two!
	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();
	if (iNumMajorsLeft <= 2)
		return false;
	
	// No DPs if we're hostile or want war
	if (GetMajorCivApproach(ePlayer) <= MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	int iValue = 0;

	int iNumDPsAlreadyWanted = GetNumDefensivePactsWanted(ePlayer);
	int iLoyalty = GetPlayer()->GetDiplomacyAI()->GetLoyalty();
	int iNumCivs = 0;

	PlayerTypes eLoopTest;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopTest = (PlayerTypes)iPlayerLoop;
		if (IsPlayerValid(eLoopTest) && (eLoopTest != GetPlayer()->GetID()))
		{
			iNumCivs++;
		}
	}
	iLoyalty = ((iLoyalty * iNumCivs) / 40);
	if (iLoyalty <= 0)
	{
		iLoyalty = 1;
	}
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	//Increase this to encourage more DPs below.
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && GetPlayer()->GetDefensePactsToVotes() > 0)
	{
		iLoyalty *= iNumCivs;
	}
#endif

	//Capped?
	if (iLoyalty <= (GetNumDefensePacts() + iNumDPsAlreadyWanted))
		return false;

	iValue = GetDefensivePactValue(ePlayer);

	if (GetMostValuableDefensivePact(true) == ePlayer)
		iValue += 10;
	else if (GetMostValuableDefensivePact(false) == ePlayer)
		iValue += 3;

	if (iValue > 25)
	{
		return true;
	}
	return false;
}
#endif

// ************************************
// Issues of Dispute
// ************************************



/// What is our level of Dispute with a player over Land?
DisputeLevelTypes CvDiplomacyAI::GetLandDisputeLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_paePlayerLandDisputeLevel[ePlayer];
}

/// Sets what our level of Dispute is with a player over Land
void CvDiplomacyAI::SetLandDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerLandDisputeLevel[ePlayer] = eDisputeLevel;
}

/// Updates what our level of Dispute is with a player over Land
void CvDiplomacyAI::DoUpdateLandDisputeLevels()
{
	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		// Update last turn's values
		m_paePlayerLastTurnLandDisputeLevel[ePlayer] = GetLandDisputeLevel(ePlayer);

		if (IsPlayerValid(ePlayer))
		{
			// Look at our Proximity to the other Player
			PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
			if (eProximity < PLAYER_PROXIMITY_CLOSE)
			{
				SetLandDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
				continue;
			}
			
			int iContestedScore = 0;

			// Loop through all of this player's Cities
			int iCityLoop;
			for (const CvCity* pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))
				iContestedScore += pLoopCity->GetContestedPlotScore(ePlayer);

			// Is the player already cramped in on other sides? If so, bump up the score
			if(m_pPlayer->IsCramped())
			{
				iContestedScore *= GC.getLAND_DISPUTE_CRAMPED_MULTIPLIER(); //150
				iContestedScore /= 100;
			}
			
			// Land disputes matter more in the early game.
			if (m_pPlayer->GetCurrentEra() == 0)
			{
				iContestedScore *= 2;
			}
			else if (m_pPlayer->GetCurrentEra() == 1)
			{
				iContestedScore *= 150;
				iContestedScore /= 100;
			}

			// Now see what our new Dispute Level should be
			DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
			if(iContestedScore >= /*8*/ GC.getLAND_DISPUTE_FIERCE_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_FIERCE;
			else if(iContestedScore >= /*4*/ GC.getLAND_DISPUTE_STRONG_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_STRONG;
			else if(iContestedScore >= /*1*/ GC.getLAND_DISPUTE_WEAK_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_WEAK;

			// Actually set the Level
			if (GetLandDisputeLevel(ePlayer) != eDisputeLevel)
			{
				SetLandDisputeLevel(ePlayer, eDisputeLevel);

				if (GC.getLogging() && GC.getAILogging())
				{
					// Find the name of this civ and city
					CvString playerName = GetPlayer()->getCivilizationShortDescription();
					CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

					// Open the log file
					CvString strLogName = GC.getPlayerAndCityAILogSplit() ? "DiplomacyAI_ExpansionLogic_Log_" + playerName + ".csv" : "DiplomacyAI_ExpansionLogic_Log.csv";
					FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

					// Get the leading info for this line
					CvString strBaseString;
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", " + otherPlayerName + ", ";

					char *names[] = {
						"DISPUTE_LEVEL_NONE",
						"DISPUTE_LEVEL_WEAK",
						"DISPUTE_LEVEL_STRONG",
						"DISPUTE_LEVEL_FIERCE" };

					// Actual info
					CvString strOutBuf(strBaseString);
					CvString strTmp;
					strTmp.Format("%s, score %d", names[eDisputeLevel], iContestedScore);
					strOutBuf += strTmp;

					pLog->Msg(strOutBuf);
				}
			}
		}
	}
}

/// Returns an integer that increases as the number and severity of land disputes rises
int CvDiplomacyAI::GetTotalLandDisputeLevel()
{
	int iRtnValue = 0; // slewis added, to fix a compile error. I'm guessing zero is correct.
	PlayerTypes ePlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(ePlayer))
		{
			switch(GetLandDisputeLevel(ePlayer))
			{
			case DISPUTE_LEVEL_FIERCE:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_FIERCE();
				break;
			case DISPUTE_LEVEL_STRONG:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_STRONG();
				break;
			case DISPUTE_LEVEL_WEAK:
				iRtnValue += GC.getAI_DIPLO_LAND_DISPUTE_WEIGHT_WEAK();
				break;
			}
		}
	}
	return iRtnValue;
}

/// What was our level of Dispute with a player over Land last turn?
DisputeLevelTypes CvDiplomacyAI::GetLastTurnLandDisputeLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_paePlayerLastTurnLandDisputeLevel[ePlayer];
}

/// What is our guess as to the level of Dispute between two players over Land?
DisputeLevelTypes CvDiplomacyAI::GetEstimateOtherPlayerLandDisputeLevel(PlayerTypes ePlayer, PlayerTypes eWithPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_ppaaeOtherPlayerLandDisputeLevel[ePlayer][eWithPlayer];
}

/// Sets what our guess is as to the level of Dispute between two players over Land
void CvDiplomacyAI::SetEstimateOtherPlayerLandDisputeLevel(PlayerTypes ePlayer, PlayerTypes eWithPlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaeOtherPlayerLandDisputeLevel[ePlayer][eWithPlayer] = eDisputeLevel;
}

/// Is ePlayer expanding recklessly?
bool CvDiplomacyAI::IsPlayerRecklessExpander(PlayerTypes ePlayer)
{
	if (!IsPlayerValid(ePlayer, true))
		return false;
	
	// We don't care what our teammates do.
	if (ePlayer != GetPlayer()->GetID() && GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return false;
	
	// If the player is too far away from us, we don't care
	if (GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
		return false;

	// If the player has too few cities, don't worry about it
	int iNumCities = GET_PLAYER(ePlayer).getNumCities();
	if (iNumCities < 4)
		return false;
	
	// If the player doesn't have more cities than we do, don't worry about it
	if (iNumCities <= GetPlayer()->getNumCities())
		return false;
	
	// If this guy's military is as big as ours, then it probably means he's just stronger than us
	if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) >= STRENGTH_AVERAGE)
		return false;

	double fAverageNumCities = 0;
	int iNumPlayers = 0;

	// Find out what the average is (minus the player we're looking at)
	PlayerTypes eLoopPlayer;
	CvPlayer* pPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		pPlayer = &GET_PLAYER(eLoopPlayer);
		
		// Dead, haven't met them, no cities, etc.
		if (!IsPlayerValid(eLoopPlayer, true))
			continue;
		
		// Only count City-States that have more than 1 city
		if (pPlayer->isMinorCiv() && pPlayer->getNumCities() <= 1)
			continue;

		// Not the guy we're looking at
		if (eLoopPlayer == ePlayer)
			continue;

		iNumPlayers++;
		fAverageNumCities += pPlayer->getNumCities();
	}

	fAverageNumCities /= max(1,iNumPlayers);

	// Must have way more cities than the average player in the game
	if (iNumCities < fAverageNumCities * 1.5)
		return false;

	return true;
}

/// Returns the value of broken expansion promises
int CvDiplomacyAI::GetBrokenExpansionPromiseValue(PlayerTypes ePlayer)
{
	return m_paiBrokenExpansionPromiseValue[(int)ePlayer];
}

/// Sets the value of broken expansion promises
void CvDiplomacyAI::SetBrokenExpansionPromiseValue(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	m_paiBrokenExpansionPromiseValue[(int)ePlayer] = iValue;
}

/// Changes the value of broken expansion promises
void CvDiplomacyAI::ChangeBrokenExpansionPromiseValue(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiBrokenExpansionPromiseValue[(int)ePlayer] += iChange;
		if (m_paiBrokenExpansionPromiseValue[(int)ePlayer] < 0)
		{
			m_paiBrokenExpansionPromiseValue[(int)ePlayer] = 0;
		}
	}
}

/// Returns the value of ignored expansion promises
int CvDiplomacyAI::GetIgnoredExpansionPromiseValue(PlayerTypes ePlayer)
{
	return m_paiIgnoredExpansionPromiseValue[(int)ePlayer];	
}

/// Sets the value of ignored expansion promises
void CvDiplomacyAI::SetIgnoredExpansionPromiseValue(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	m_paiIgnoredExpansionPromiseValue[(int)ePlayer] = iValue;
}

/// Changes the value of ignored expansion promises
void CvDiplomacyAI::ChangeIgnoredExpansionPromiseValue(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiIgnoredExpansionPromiseValue[(int)ePlayer] += iChange;
		if (m_paiIgnoredExpansionPromiseValue[(int)ePlayer] < 0)
		{
			m_paiIgnoredExpansionPromiseValue[(int)ePlayer] = 0;
		}
	}
}

/// Returns the value of broken border promises
int CvDiplomacyAI::GetBrokenBorderPromiseValue(PlayerTypes ePlayer)
{
	return m_paiBrokenBorderPromiseValue[(int)ePlayer];
}

/// Sets the value of broken border promises
void CvDiplomacyAI::SetBrokenBorderPromiseValue(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	m_paiBrokenBorderPromiseValue[(int)ePlayer] = iValue;

}

/// Changes the value of broken border promises
void CvDiplomacyAI::ChangeBrokenBorderPromiseValue(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiBrokenBorderPromiseValue[(int)ePlayer] += iChange;
		if (m_paiBrokenBorderPromiseValue[(int)ePlayer] < 0)
		{
			m_paiBrokenBorderPromiseValue[(int)ePlayer] = 0;
		}
	}
}

/// Returns the value of ignored border promises
int CvDiplomacyAI::GetIgnoredBorderPromiseValue(PlayerTypes ePlayer)
{
	return m_paiIgnoredBorderPromiseValue[(int)ePlayer];	
}

/// Sets the value of ignored border promises
void CvDiplomacyAI::SetIgnoredBorderPromiseValue(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	m_paiIgnoredBorderPromiseValue[(int)ePlayer] = iValue;
}

/// Changes the value of ignored border promises
void CvDiplomacyAI::ChangeIgnoredBorderPromiseValue(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiIgnoredBorderPromiseValue[(int)ePlayer] += iChange;
		if (m_paiIgnoredBorderPromiseValue[(int)ePlayer] < 0)
		{
			m_paiIgnoredBorderPromiseValue[(int)ePlayer] = 0;
		}
	}
}

/// Returns the value of friend ePlayer backstabbing this player
int CvDiplomacyAI::GetDeclaredWarOnFriendValue(PlayerTypes ePlayer)
{
	return m_paiDeclaredWarOnFriendValue[(int)ePlayer];
}

/// Changes the value of friend ePlayer backstabbing this player
void CvDiplomacyAI::ChangeDeclaredWarOnFriendValue(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiDeclaredWarOnFriendValue[(int)ePlayer] += iChange;
		if (m_paiDeclaredWarOnFriendValue[(int)ePlayer] < 0)
		{
			m_paiDeclaredWarOnFriendValue[(int)ePlayer] = 0;
		}
	}
}

/// Returns the number of cities liberated by ePlayer
int CvDiplomacyAI::GetNumCitiesLiberated(PlayerTypes ePlayer)
{
	return m_paiNumCitiesLiberated[(int)ePlayer];
}

/// Changes the number of cities liberated by ePlayer
void CvDiplomacyAI::ChangeNumCitiesLiberated(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	if (iChange != 0)
	{
		m_paiNumCitiesLiberated[(int)ePlayer] += iChange;
		CvAssertMsg(m_paiNumCitiesLiberated[(int)ePlayer] >= 0, "Num cities liberated is less than zero");
	}
}


/// Returns the value of recent trades
int CvDiplomacyAI::GetRecentTradeValue(PlayerTypes ePlayer)
{
	return m_paiTradeValue[(int)ePlayer];
}

/// Sets the value of recent trades
void CvDiplomacyAI::ChangeRecentTradeValue(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		int iNewValue = m_paiTradeValue[ePlayer]+iChange;
		iNewValue = MIN(iNewValue,MAX_SHORT);

		int iMaxOpinionValue = GC.getDEAL_VALUE_PER_OPINION_WEIGHT() * -(GC.getOPINION_WEIGHT_TRADE_MAX());

		// Must be between 0 and maximum possible boost to opinion
		m_paiTradeValue[ePlayer] = MAX(0,MIN(iMaxOpinionValue,iNewValue));
	}
}

/// Returns the value of combat damage inflicted on a common enemy
int CvDiplomacyAI::GetCommonFoeValue(PlayerTypes ePlayer)
{
	return m_paiCommonFoeValue[(int)ePlayer];
}

/// Sets the value of combat damage inflicted on a common enemy
void CvDiplomacyAI::ChangeCommonFoeValue(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0 && ePlayer < MAX_MAJOR_CIVS)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES && iChange > 0)
		{
			// Capitulated vassals don't care.
			if (IsVassal(ePlayer))
			{
				if (!GET_TEAM(m_pPlayer->getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam()))
				{
					return;
				}
			}
		}
#endif
		m_paiCommonFoeValue[ePlayer] += iChange;
		short iMaxOpinionValue = GC.getCOMMON_FOE_VALUE_PER_OPINION_WEIGHT() * -(GC.getOPINION_WEIGHT_COMMON_FOE_MAX());

		// Must be between 0 and maximum possible boost to opinion
		if(m_paiCommonFoeValue[ePlayer] < 0)
		{
			m_paiCommonFoeValue[ePlayer] = 0;
		}
		else if(m_paiCommonFoeValue[ePlayer] > iMaxOpinionValue)
		{
			m_paiCommonFoeValue[ePlayer] = iMaxOpinionValue;
		}
	}
}

/// Returns the value of diplomatic assistance given
int CvDiplomacyAI::GetRecentAssistValue(PlayerTypes ePlayer)
{
	return m_paiAssistValue[(int)ePlayer];
}

/// Sets the value of diplomatic assistance given
void CvDiplomacyAI::ChangeRecentAssistValue(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiAssistValue[ePlayer] += iChange;
		short iMaxOpinionValue = GC.getDEAL_VALUE_PER_OPINION_WEIGHT() * GC.getOPINION_WEIGHT_ASSIST_MAX();

		if (m_paiAssistValue[ePlayer] < -iMaxOpinionValue)
		{
			m_paiAssistValue[ePlayer] = -iMaxOpinionValue;
		}
		else if (m_paiAssistValue[ePlayer] > iMaxOpinionValue)
		{
			m_paiAssistValue[ePlayer] = iMaxOpinionValue;
		}
	}
}

/// Unused vanilla value
bool CvDiplomacyAI::IsGaveAssistanceTo(PlayerTypes /*ePlayer*/) const
{
	return false;
}

/// Unused vanilla value
bool CvDiplomacyAI::IsHasPaidTributeTo(PlayerTypes /*ePlayer*/) const
{
	return false;
}

/// Returns if this player has been nuked by ePlayer
bool CvDiplomacyAI::IsNukedBy(PlayerTypes ePlayer) const
{
	return (GetNumTimesNuked(ePlayer) > 0);
}

/// Returns if this player's original capital is currently owned by ePlayer
bool CvDiplomacyAI::IsCapitalCapturedBy(PlayerTypes ePlayer) const
{
	if(m_pPlayer->IsHasLostCapital() && m_pPlayer->GetCapitalConqueror() == ePlayer)
	{
		return true;
	}
	return false;
}

/// Returns if this player's Holy City is currently owned by ePlayer
bool CvDiplomacyAI::IsHolyCityCapturedBy(PlayerTypes ePlayer) const
{
	if (m_pPlayer->IsHasLostHolyCity() && m_pPlayer->GetHolyCityConqueror() == ePlayer)
	{
		return true;
	}
	return false;
}

/// Are we angry about ePlayer killing one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorKilled(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	int iNumProtectedMinorsKilled = GetOtherPlayerNumProtectedMinorsKilled(ePlayer);
	if (iNumProtectedMinorsKilled > 0)
	{
		int iTurnsSinceMinorKilled = GetTurnsSincePlayerKilledProtectedMinor(ePlayer);
		if (iTurnsSinceMinorKilled > -1 && iTurnsSinceMinorKilled < /*125*/ GC.getOPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN()) //antonjs: consider: scale by game speed
		{
			return true;
		}
	}
	return false;
}

/// Are we angry about ePlayer attacking one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorAttacked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// Anger over killed city-states trumps this, don't stack
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
		return false;
	
	int iNumProtectedMinorsAttacked = GetOtherPlayerNumProtectedMinorsAttacked(ePlayer);
	if(iNumProtectedMinorsAttacked > 0)
	{
		int iTurnsSinceMinorAttack = GetTurnsSincePlayerAttackedProtectedMinor(ePlayer);
		if (iTurnsSinceMinorAttack > -1 && iTurnsSinceMinorAttack < /*75*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN()) //antonjs: consider: scale by game speed
		{
			return true;
		}
	}
	return false;
}

/// Are we angry about ePlayer bullying one of our protected Minors?
bool CvDiplomacyAI::IsAngryAboutProtectedMinorBullied(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	int iNumProtectedMinorsBullied = GetOtherPlayerNumProtectedMinorsBullied(ePlayer);
	if (iNumProtectedMinorsBullied > 0)
	{
		int iTurnsSinceBully = GetTurnsSincePlayerBulliedProtectedMinor(ePlayer);
		if (iTurnsSinceBully > -1 && iTurnsSinceBully < /*75*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN()) //antonjs: consider: scale by game speed
		{
			return true;
		}
	}
	return false;
}

/// Are we angry about ePlayer choosing to side with one of their protected minors that we attacked/bullied?
bool CvDiplomacyAI::IsAngryAboutSidedWithTheirProtectedMinor(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	// Has ePlayer ever done this?
	if (IsOtherPlayerSidedWithProtectedMinor(ePlayer))
	{
		// How long ago?
		int iTurnsSinceDispute = GetTurnsSinceOtherPlayerSidedWithProtectedMinor(ePlayer);
		if (iTurnsSinceDispute > -1 && iTurnsSinceDispute < /*25*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FORGIVEN()) //antonjs: consider: scale by game speed
		{
			return true;
		}
	}
	return false;
}

/// How many turns has it been since we really liked this player's proposal to the World Congress?
int CvDiplomacyAI::GetTurnsSinceWeLikedTheirProposal(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	return m_paiOtherPlayerTurnsSinceWeLikedTheirProposal[ePlayer];
}

/// Sets how many turns it has been since we really liked this player's proposal to the World Congress
void CvDiplomacyAI::SetTurnsSinceWeLikedTheirProposal(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceWeLikedTheirProposal[ePlayer] = iValue;
}

/// Changes how many turns it has been since we really liked this player's proposal to the World Congress
void CvDiplomacyAI::ChangeTurnsSinceWeLikedTheirProposal(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceWeLikedTheirProposal(ePlayer, GetTurnsSinceWeLikedTheirProposal(ePlayer) + iChange);
}

/// How many turns has it been since we really disliked this player's proposal to the World Congress?
int CvDiplomacyAI::GetTurnsSinceWeDislikedTheirProposal(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	return m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal[ePlayer];
}

/// Sets how many turns it has been since we really disliked this player's proposal to the World Congress
void CvDiplomacyAI::SetTurnsSinceWeDislikedTheirProposal(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceWeDislikedTheirProposal[ePlayer] = iValue;
}

/// Changes how many turns it has been since we really disliked this player's proposal to the World Congress
void CvDiplomacyAI::ChangeTurnsSinceWeDislikedTheirProposal(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceWeDislikedTheirProposal(ePlayer, GetTurnsSinceWeDislikedTheirProposal(ePlayer) + iChange);
}

/// How many turns has it been since they supported our proposal to the World Congress?
int CvDiplomacyAI::GetTurnsSinceTheySupportedOurProposal(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	return m_paiOtherPlayerTurnsSinceTheySupportedOurProposal[ePlayer];
}

/// Sets how many turns it has been since they supported our proposal to the World Congress
void CvDiplomacyAI::SetTurnsSinceTheySupportedOurProposal(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceTheySupportedOurProposal[ePlayer] = iValue;
}

/// Changes how many turns it has been since they supported our proposal to the World Congress
void CvDiplomacyAI::ChangeTurnsSinceTheySupportedOurProposal(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceTheySupportedOurProposal(ePlayer, GetTurnsSinceTheySupportedOurProposal(ePlayer) + iChange);
}


/// How many turns has it been since they foiled our proposal to the World Congress?
int CvDiplomacyAI::GetTurnsSinceTheyFoiledOurProposal(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	return m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal[ePlayer];
}

/// Sets how many turns it has been since they foiled our proposal to the World Congress
void CvDiplomacyAI::SetTurnsSinceTheyFoiledOurProposal(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceTheyFoiledOurProposal[ePlayer] = iValue;
}

/// Changes how many turns it has been since they foiled our proposal to the World Congress
void CvDiplomacyAI::ChangeTurnsSinceTheyFoiledOurProposal(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceTheyFoiledOurProposal(ePlayer, GetTurnsSinceTheyFoiledOurProposal(ePlayer) + iChange);
}

/// How many turns has it been since they supported relocating the World Congress to our lands?
int CvDiplomacyAI::GetTurnsSinceTheySupportedOurHosting(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	return m_paiOtherPlayerTurnsSinceTheySupportedOurHosting[ePlayer];
}

/// Sets how many turns it has been since they supported relocating the World Congress to our lands
void CvDiplomacyAI::SetTurnsSinceTheySupportedOurHosting(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceTheySupportedOurHosting[ePlayer] = iValue;
}

/// Changes how many turns it has been since they supported relocating the World Congress to our lands
void CvDiplomacyAI::ChangeTurnsSinceTheySupportedOurHosting(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceTheySupportedOurHosting(ePlayer, GetTurnsSinceTheySupportedOurHosting(ePlayer) + iChange);
}


/// Updates what our guesses are as to the levels of Dispute between other players over Land
void CvDiplomacyAI::DoUpdateEstimateOtherPlayerLandDisputeLevels()
{
	// Loop through all (known) Majors
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (IsPlayerValid(eLoopPlayer))
		{
			// Now loop through every player HE knows
			for (int iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
			{
				PlayerTypes eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

				// Don't compare a player to himself
				if (eLoopPlayer != eLoopOtherPlayer)
				{
					// Do both we and the guy we're looking at know the third guy?
					if (IsPlayerValid(eLoopOtherPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
					{
						// Look at our Proximity to the other Player
						PlayerProximityTypes eProximity = GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eLoopOtherPlayer);
						if (eProximity == PLAYER_PROXIMITY_DISTANT || eProximity == PLAYER_PROXIMITY_FAR)
						{
							SetEstimateOtherPlayerLandDisputeLevel(eLoopPlayer, eLoopOtherPlayer, DISPUTE_LEVEL_NONE);
							continue;
						}
			
						int iContestedScore = 0;

						// Loop through all of this player's Cities
						int iCityLoop;
						for (const CvCity* pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iCityLoop))
						{
							if (pLoopCity->isVisible(m_pPlayer->getTeam(), false)) //should really check if the other city is visible as well ...
								iContestedScore += pLoopCity->GetContestedPlotScore(eLoopOtherPlayer);
						}

						// Is the player already cramped in on other sides? If so, bump up the score
						if (GET_PLAYER(eLoopPlayer).IsCramped()) //again, there should be a visibility check here ...
						{
							iContestedScore *= GC.getLAND_DISPUTE_CRAMPED_MULTIPLIER(); //150
							iContestedScore /= 100;
						}
						
						// Land disputes matter more in the early game.
						if (GET_PLAYER(eLoopPlayer).GetCurrentEra() == 0)
						{
							iContestedScore *= 2;
						}
						else if (GET_PLAYER(eLoopPlayer).GetCurrentEra() == 1)
						{
							iContestedScore *= 150;
							iContestedScore /= 100;
						}

						// Now see what our new Dispute Level should be
						DisputeLevelTypes eDisputeLevel = DISPUTE_LEVEL_NONE;
						if(iContestedScore >= /*8*/ GC.getLAND_DISPUTE_FIERCE_THRESHOLD())
							eDisputeLevel = DISPUTE_LEVEL_FIERCE;
						else if(iContestedScore >= /*4*/ GC.getLAND_DISPUTE_STRONG_THRESHOLD())
							eDisputeLevel = DISPUTE_LEVEL_STRONG;
						else if(iContestedScore >= /*1*/ GC.getLAND_DISPUTE_WEAK_THRESHOLD())
							eDisputeLevel = DISPUTE_LEVEL_WEAK;

						// Actually set the Level
						SetEstimateOtherPlayerLandDisputeLevel(eLoopPlayer, eLoopOtherPlayer, eDisputeLevel);
					}
				}
			}
		}
	}
}


/// How aggressively has this player settled in relation to us?
AggressivePostureTypes CvDiplomacyAI::GetExpansionAggressivePosture(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paeExpansionAggressivePosture[ePlayer];
}

/// Sets how aggressively this player has settled in relation to us
void CvDiplomacyAI::SetExpansionAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture >= 0, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture < NUM_AGGRESSIVE_POSTURE_TYPES, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeExpansionAggressivePosture[ePlayer] = ePosture;
}

/// Updates how aggressively all players have settled in relation to us
void CvDiplomacyAI::DoUpdateExpansionAggressivePostures()
{
	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		DoUpdateOnePlayerExpansionAggressivePosture((PlayerTypes)iPlayerLoop);
}

/// Returns plot indices!
//returns plot indices!
pair<int,int> CvDiplomacyAI::GetClosestCityPair(PlayerTypes eOtherPlayer)
{
	int iCityLoop = 0;
	int iMinDistance = INT_MAX;
	pair<int, int> result(-1,-1);
	for (CvCity* pOtherCity = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop); pOtherCity != NULL; pOtherCity = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop))
	{
		CvCity* pOurClosestCity = m_pPlayer->GetClosestCityByPlots(pOtherCity->plot()); //use estimated turns here?
		if (!pOurClosestCity)
			continue;

		int iDistance = plotDistance(*pOtherCity->plot(), *pOurClosestCity->plot());
		if (iDistance < iMinDistance)
		{
			iMinDistance = iDistance;
			result = make_pair( pOurClosestCity->plot()->GetPlotIndex(),pOtherCity->plot()->GetPlotIndex() );
		}
	}

	return result;
}

CvCity* GetPlotCityAndVerifyOwnership(int iPlotIndex, PlayerTypes eSupposedOwner)
{
	if (iPlotIndex < 0)
		return NULL;

	CvCity* pResult = GC.getMap().plotByIndex(iPlotIndex)->getPlotCity();
	if (pResult && pResult->getOwner() == eSupposedOwner)
		return pResult;

	return NULL;
}

/// Updates how aggressively a player has settled in relation to us
void CvDiplomacyAI::DoUpdateOnePlayerExpansionAggressivePosture(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (!IsPlayerValid(ePlayer))
		return;

	if (GET_PLAYER(ePlayer).isMinorCiv())
		return;

	CvCity* pOurOldClosestCity = NULL;
	CvCity* pTheirOldClosestCity = NULL;
	bool bFromPromise = false;

	//They promised not to expand?
	if (IsPlayerMadeExpansionPromise(ePlayer))
	{
		pair<int, int> promisedPair = GetNoExpansionPromiseClosestCities(ePlayer);
		if (promisedPair.first >= 0) //valid?
		{
			pOurOldClosestCity = GetPlotCityAndVerifyOwnership(promisedPair.first, m_pPlayer->GetID());
			pTheirOldClosestCity = GetPlotCityAndVerifyOwnership(promisedPair.second, ePlayer);
			bFromPromise = true;
		}
	}

	//if no promise, use the previous closest pair
	if (!pOurOldClosestCity || !pTheirOldClosestCity)
	{
		pair<int, int> lastTurnPair = GetLastTurnClosestCityPair(ePlayer);
		if (lastTurnPair.first >= 0) //valid?
		{
			pOurOldClosestCity = GetPlotCityAndVerifyOwnership(lastTurnPair.first, m_pPlayer->GetID());
			pTheirOldClosestCity = GetPlotCityAndVerifyOwnership(lastTurnPair.second, ePlayer);
			bFromPromise = false;
		}
	}

	//the current pair for comparison
	pair<int, int> thisTurnPair = GetClosestCityPair(ePlayer);
	CvCity* pOurNewClosestCity = GetPlotCityAndVerifyOwnership(thisTurnPair.first, m_pPlayer->GetID());
	CvCity* pTheirNewClosestCity = GetPlotCityAndVerifyOwnership(thisTurnPair.second, ePlayer);

	//In any case save off our new value for next turn, it'll be our new test point ...
	SetLastTurnClosestCityPair(ePlayer, thisTurnPair);

	//Null? Must be first turn or something. Ignore.
	if (!pOurOldClosestCity || !pTheirOldClosestCity || !pOurNewClosestCity || !pTheirNewClosestCity)
		return;

	// First calculate distance
	int iOldDistance = plotDistance(*pOurOldClosestCity->plot(), *pTheirOldClosestCity->plot());
	int iNewDistance = plotDistance(*pOurNewClosestCity->plot(), *pTheirNewClosestCity->plot());

	// Assume no change
	AggressivePostureTypes eLastAggressivePosture = GetExpansionAggressivePosture(ePlayer);
	AggressivePostureTypes eNewAggressivePosture = eLastAggressivePosture;

	if (
		//if we got closer to each other and their city is newer, they are being aggressive (else we are being aggressive)
		(iNewDistance < iOldDistance && pTheirNewClosestCity->getGameTurnAcquired() > pOurNewClosestCity->getGameTurnAcquired())
		||
		//if one of us lost a city relax the posture, no matter what
		(iNewDistance > iOldDistance)
		)
	{
		if (iNewDistance <= /*2*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_HIGH() + (GetBoldness() / 4)))
			eNewAggressivePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
		else if (iNewDistance <= /*5*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_MEDIUM() + (GetBoldness() / 4)))
			eNewAggressivePosture = AGGRESSIVE_POSTURE_HIGH;
		else if (iNewDistance <= /*9*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW() + (GetBoldness() / 4)))
			eNewAggressivePosture = AGGRESSIVE_POSTURE_MEDIUM;
		else if (iNewDistance <= /*18*/ (GC.getEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW()*2 + (GetBoldness() / 4)))
			eNewAggressivePosture = AGGRESSIVE_POSTURE_LOW;
		else //default
			eNewAggressivePosture = AGGRESSIVE_POSTURE_NONE;
	}

	if (eNewAggressivePosture != eLastAggressivePosture)
	{
		SetExpansionAggressivePosture(ePlayer, eNewAggressivePosture);

		if (GC.getLogging() && GC.getAILogging())
		{
			// Find the name of this civ and city
			CvString playerName = GetPlayer()->getCivilizationShortDescription();
			CvString otherplayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

			// Open the log file
			CvString strLogName = GC.getPlayerAndCityAILogSplit() ? "DiplomacyAI_ExpansionLogic_Log_" + playerName + ".csv" : "DiplomacyAI_ExpansionLogic_Log.csv";
			FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

			// Get the leading info for this line
			CvString strBaseString;
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strBaseString += otherplayerName + ", ";

			char *names[] = {
				"AGGRESSIVE_POSTURE_UNDEFINED",
				"AGGRESSIVE_POSTURE_NONE",
				"AGGRESSIVE_POSTURE_LOW",
				"AGGRESSIVE_POSTURE_MEDIUM",
				"AGGRESSIVE_POSTURE_HIGH",
				"AGGRESSIVE_POSTURE_INCREDIBLE" };

			// Actual info
			CvString strOutBuf(strBaseString);
			CvString strTmp;
			strOutBuf += (bFromPromise ? "promised: " : "previous: ");
			strOutBuf += pOurOldClosestCity->getName() + ", ";
			strOutBuf += pTheirOldClosestCity->getName() + ", ";
			strTmp.Format("%s, distance %d", names[eLastAggressivePosture+1], iOldDistance);
			strOutBuf += strTmp + ", ";
			strOutBuf += "now: ";
			strOutBuf += pOurNewClosestCity->getName() + ", ";
			strOutBuf += pTheirNewClosestCity->getName() + ", ";
			strTmp.Format("%s, distance %d", names[eNewAggressivePosture+1], iNewDistance);
			strOutBuf += strTmp;

			pLog->Msg(strOutBuf);
		}
	}
}

/// How aggressively is ePlayer buying land near us?
AggressivePostureTypes CvDiplomacyAI::GetPlotBuyingAggressivePosture(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paePlotBuyingAggressivePosture[ePlayer];
}

/// Sets how aggressively this player has bought land near us
void CvDiplomacyAI::SetPlotBuyingAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture >= 0, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture < NUM_AGGRESSIVE_POSTURE_TYPES, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paePlotBuyingAggressivePosture[ePlayer] = ePosture;
}

/// Updates how aggressively all players have bought land near us
void CvDiplomacyAI::DoUpdatePlotBuyingAggressivePosture()
{
	PlayerTypes eLoopPlayer;

	AggressivePostureTypes ePosture;

	int iCityLoop;
	CvCity* pLoopCity;

	int iAggressionScore;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			iAggressionScore = 0;

			// Loop through all of our Cities to see if this player has bought land near them
			for(pLoopCity = GetPlayer()->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iCityLoop))
			{
				iAggressionScore += pLoopCity->AI_GetNumPlotsAcquiredByOtherPlayer(eLoopPlayer);
			}

			// Now See what our new Dispute Level should be
			if(iAggressionScore >= /*10*/ GC.getPLOT_BUYING_POSTURE_INCREDIBLE_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
			else if(iAggressionScore >= /*7*/ GC.getPLOT_BUYING_POSTURE_HIGH_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_HIGH;
			else if(iAggressionScore >= /*4*/ GC.getPLOT_BUYING_POSTURE_MEDIUM_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_MEDIUM;
			else if(iAggressionScore >= /*2*/ GC.getPLOT_BUYING_POSTURE_LOW_THRESHOLD())
				ePosture = AGGRESSIVE_POSTURE_LOW;
			else
				ePosture = AGGRESSIVE_POSTURE_NONE;

			SetPlotBuyingAggressivePosture(eLoopPlayer, ePosture);
		}
	}
}

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// What is our level of Desire to block this player over Victory?
BlockLevelTypes CvDiplomacyAI::GetVictoryBlockLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (BlockLevelTypes) m_paePlayerVictoryBlockLevel[ePlayer];
}

/// Sets what our level of Desire is to block a player over Victory
void CvDiplomacyAI::SetVictoryBlockLevel(PlayerTypes ePlayer, BlockLevelTypes eBlockLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eBlockLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eBlockLevel < NUM_BLOCK_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerVictoryBlockLevel[ePlayer] = eBlockLevel;
}

/// Updates what our level of Desire is to block all players over Victory
void CvDiplomacyAI::DoUpdateVictoryBlockLevels()
{
	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");
	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");
	AIGrandStrategyTypes eUNGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");
	AIGrandStrategyTypes eSpaceshipGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	PlayerTypes ePlayer;

	BlockLevelTypes eBlockLevel;

	int iVictoryBlockWeight;
	
	// Disallowed by game options
	if (IsNoVictoryCompetition())
	{
		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes)iPlayerLoop;
			SetVictoryBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
		}
		return;
	}
	
	// If we're somebody's vassal, chances are we can't compete with them anyway, so hatred is pointless.
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
		{
			// Loop through all (known) Players
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				SetVictoryBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
			}
			return;
		}
	}
#endif

	//Don't do this at the start of the game.
	if (GC.getGame().getGameTurn() <= 150)
		return;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(ePlayer))
		{
			eBlockLevel = BLOCK_LEVEL_NONE;
			if(eMyGrandStrategy == NO_AIGRANDSTRATEGY)
			{
				SetVictoryBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			if(GetPlayer()->GetGrandStrategyAI()->GetGrandStrategyPriority(eMyGrandStrategy) <= 500)
			{
				SetVictoryBlockLevel(ePlayer, BLOCK_LEVEL_NONE);
				continue;
			}
			// Minors and Barbarians can't really be an issue with Victory!
			if(!GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
			{
				MajorCivOpinionTypes eOpinion;
				eOpinion = GetMajorCivOpinion(ePlayer);
				if(eOpinion > MAJOR_CIV_OPINION_FRIEND)
				{
					continue;
				}
				AIGrandStrategyTypes eTheirGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer);
				if(eTheirGrandStrategy == NO_AIGRANDSTRATEGY && !GET_PLAYER(ePlayer).isHuman())
				{
					continue;
				}
				iVictoryBlockWeight = 0;
				bool bLeagueCompetitor = false;
				bool bSpaceRace = false;
				bool bCulture = false;
				bool bWar = false;
				int iVotes = 0;
				int iNeededVotes = 0;
				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
				if(pLeague != NULL)
				{
					iVotes = pLeague->CalculateStartingVotesForMember(ePlayer);
					iNeededVotes = GC.getGame().GetVotesNeededForDiploVictory();
					if(iNeededVotes > 0)
					{
						// 33% there? Close!
						if(iVotes >= (iNeededVotes / 3))
						{
							bLeagueCompetitor = true;
						}
					}
				}
				int iProjectCount = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetSSProjectCount();
				if(iProjectCount > 1)
				{
					bSpaceRace = true;
				}
				else
				{
					int iTheirTechNum = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

					int iNumOtherPlayers = 0;
					int iNumPlayersAheadInTech = 0;
					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
					{
						PlayerTypes eOtherPlayer = (PlayerTypes)ui;
						if(!GET_PLAYER(eOtherPlayer).isAlive())
						{
							continue;
						}

						if (eOtherPlayer == ePlayer)
						{
							continue;
						}

						iNumOtherPlayers++;
						int iNumTechs = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
						if (iTheirTechNum > iNumTechs )
						{
							iNumPlayersAheadInTech++;
						}
					}
					if(iNumPlayersAheadInTech >= iNumOtherPlayers)
					{
						bSpaceRace = true;
					}
				}
				if(GetWarmongerThreat(ePlayer) >= THREAT_SEVERE || (GET_PLAYER(ePlayer).GetNumCapitalCities() >= (GC.getGame().countMajorCivsEverAlive() / 2)))
				{
					bWar = true;
				}
				if(GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn() > 1)
				{
					bCulture = true;
				}
				if((eConquestGrandStrategy == eTheirGrandStrategy) && !bWar)
				{
					continue;
				}
				if((eCultureGrandStrategy == eTheirGrandStrategy) && !bCulture)
				{
					continue;
				}
				if((eUNGrandStrategy == eTheirGrandStrategy) && !bLeagueCompetitor)
				{
					continue;
				}
				if((eSpaceshipGrandStrategy == eTheirGrandStrategy) && !bSpaceRace)
				{
					continue;
				}

				if (bSpaceRace)
					iVictoryBlockWeight += iProjectCount * 10;
				
				// Does the other player's (estimated) Grand Strategy differ from ours? If so, how positive are we about this?
				if((eTheirGrandStrategy != eMyGrandStrategy))
				{
					switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(ePlayer))
					{
					case GUESS_CONFIDENCE_POSITIVE:
						iVictoryBlockWeight += 20;
						break;
					case GUESS_CONFIDENCE_LIKELY:
						iVictoryBlockWeight += 15;
						break;
					case GUESS_CONFIDENCE_UNSURE:
						iVictoryBlockWeight += 5;
						break;
					}
				}
				if(iVictoryBlockWeight > 0)
				{
					// Add weight for Player's meanness and diplobalance desires (0 - 10)
					// Average of each is 5, and era goes up by one throughout game.
					iVictoryBlockWeight += (GetVictoryCompetitiveness() + GetMeanness() + GetDiploBalance() + GetPlayer()->GetCurrentEra());

					// Now see what our new Block Level should be
					if(iVictoryBlockWeight >= 40)
					{					
						eBlockLevel = BLOCK_LEVEL_FIERCE;
					}
					else if(iVictoryBlockWeight >= 30)
					{					
						eBlockLevel = BLOCK_LEVEL_STRONG;
					}
					else if(iVictoryBlockWeight >= 20)
					{					
						eBlockLevel = BLOCK_LEVEL_WEAK;
					}
				}	
			}

			// Actually set the Level
			SetVictoryBlockLevel(ePlayer, eBlockLevel);
		}
	}
}

/// Updates our valuation of potential friends, DPs or enemies
void CvDiplomacyAI::DoRelationshipPairing()
{
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;

		int iEnemyWeight = GetMeanness();
		int iDPWeight = GetDiploBalance();
		int iDoFWeight = GetDoFWillingness();

		m_paiCompetitorValue[ePlayer] = 0;
		m_paiDefensivePactValue[ePlayer] = 0;
		m_paiDoFValue[ePlayer] = 0;

		if (IsPlayerValid(ePlayer))
		{
			//Let's build the competitor list first.

			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

			switch (eApproach)
			{
			case MAJOR_CIV_APPROACH_WAR:
				iEnemyWeight += 10;
				iDPWeight -= 10;
				iDoFWeight -= 10;
				break;
			case MAJOR_CIV_APPROACH_HOSTILE:
				iEnemyWeight += 7;
				iDPWeight -= 7;
				iDoFWeight -= 7;
				break;
			case MAJOR_CIV_APPROACH_GUARDED:
				iEnemyWeight += 5;
				iDPWeight -= 5;
				iDoFWeight -= 5;
				break;
			case MAJOR_CIV_APPROACH_DECEPTIVE:
				iEnemyWeight += 3;
				iDPWeight += 3;
				iDoFWeight += 1;
				break;
			case MAJOR_CIV_APPROACH_NEUTRAL:
				iEnemyWeight += 0;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case MAJOR_CIV_APPROACH_AFRAID:
				iEnemyWeight += 1;
				iDPWeight += 5;
				iDoFWeight += 3;
				break;
			case MAJOR_CIV_APPROACH_FRIENDLY:
				iEnemyWeight += -5;
				iDPWeight += 5;
				iDoFWeight += 5;
				break;
			}

			switch (eOpinion)
			{
			case MAJOR_CIV_OPINION_UNFORGIVABLE:
				iEnemyWeight += 10;
				iDPWeight += -10;
				iDoFWeight += -10;
				break;
			case MAJOR_CIV_OPINION_ENEMY:
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case MAJOR_CIV_OPINION_COMPETITOR:
				iEnemyWeight += 3;
				iDPWeight += -3;
				iDoFWeight += -3;
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				iEnemyWeight += 0;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				iEnemyWeight += -3;
				iDPWeight += 3;
				iDoFWeight += 3;
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				iEnemyWeight += -5;
				iDPWeight += 5;
				iDoFWeight += 5;
				break;
			case MAJOR_CIV_OPINION_ALLY:
				iEnemyWeight += -10;
				iDPWeight += 10;
				iDoFWeight += 10;
				break;
			}
			
			// What about their (estimated) Approach towards us?
			switch (GetTrueApproachTowardsUsGuess(ePlayer))
			{
			case MAJOR_CIV_APPROACH_WAR:
			case MAJOR_CIV_APPROACH_HOSTILE:
				iEnemyWeight += 10;
				iDPWeight += -15;
				iDoFWeight += -15;
				break;
			case MAJOR_CIV_APPROACH_GUARDED:
			case MAJOR_CIV_APPROACH_NEUTRAL:
				iEnemyWeight += -3;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case MAJOR_CIV_APPROACH_DECEPTIVE:
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case MAJOR_CIV_APPROACH_AFRAID:
				iEnemyWeight += -15;
				iDPWeight += -10;
				iDoFWeight += 7;
				break;
			case MAJOR_CIV_APPROACH_FRIENDLY:
				iEnemyWeight += -5;
				iDPWeight += 3;
				iDoFWeight += 3;
				break;
			default:
				iEnemyWeight += -3;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			}

			// Military Strength compared to us
			switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
			{
			case STRENGTH_PATHETIC:
				iEnemyWeight += -5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case STRENGTH_WEAK:
				iEnemyWeight += -3;
				iDPWeight += -3;
				iDoFWeight += 1;
				break;
			case STRENGTH_POOR:
				iEnemyWeight += -1;
				iDPWeight += -1;
				iDoFWeight += 2;
				break;
			case STRENGTH_AVERAGE:
				iEnemyWeight += 1;
				iDPWeight += 3;
				iDoFWeight += 5;
				break;
			case STRENGTH_STRONG:
				iEnemyWeight += 3;
				iDPWeight += 5;
				iDoFWeight += 3;
				break;
			case STRENGTH_POWERFUL:
				iEnemyWeight += 5;
				iDPWeight += 7;
				iDoFWeight += 1;
				break;
			case STRENGTH_IMMENSE:
				iEnemyWeight += 7;
				iDPWeight += 10;
				iDoFWeight += -3;
				break;
			}
			// Economic Strength compared to us
			switch (GetPlayerEconomicStrengthComparedToUs(ePlayer))
			{
			case STRENGTH_PATHETIC:
				iEnemyWeight += -5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case STRENGTH_WEAK:
				iEnemyWeight += -3;
				iDPWeight += -3;
				iDoFWeight += 1;
				break;
			case STRENGTH_POOR:
				iEnemyWeight += -1;
				iDPWeight += -1;
				iDoFWeight += 2;
				break;
			case STRENGTH_AVERAGE:
				iEnemyWeight += 1;
				iDPWeight += 3;
				iDoFWeight += 5;
				break;
			case STRENGTH_STRONG:
				iEnemyWeight += 3;
				iDPWeight += 5;
				iDoFWeight += 3;
				break;
			case STRENGTH_POWERFUL:
				iEnemyWeight += 5;
				iDPWeight += 7;
				iDoFWeight += 1;
				break;
			case STRENGTH_IMMENSE:
				iEnemyWeight += 7;
				iDPWeight += 10;
				iDoFWeight += -3;
				break;
			}

			switch (GetPlayer()->GetProximityToPlayer(ePlayer))
			{
			case PLAYER_PROXIMITY_NEIGHBORS:
				iEnemyWeight += 3;
				iDPWeight += 5;
				iDoFWeight += 3;
				break;
			case PLAYER_PROXIMITY_CLOSE:
				iEnemyWeight += 1;
				iDPWeight += 2;
				iDoFWeight += 1;
				break;
			case PLAYER_PROXIMITY_FAR:
				iEnemyWeight += -1;
				iDPWeight += -1;
				iDoFWeight += 1;
				break;
			case PLAYER_PROXIMITY_DISTANT:
				iEnemyWeight += -5;
				iDPWeight += -5;
				iDoFWeight += 2;
				break;
			}

			//On a different continent? Friends good, war bad.
			if (GET_PLAYER(ePlayer).getCapitalCity() && 
				GetPlayer()->getCapitalCity() &&
				GET_PLAYER(ePlayer).getCapitalCity()->getArea() != GetPlayer()->getCapitalCity()->getArea())
			{
				iEnemyWeight -= 5;
				iDPWeight -= 10;
				iDoFWeight += 5;
			}

			// We denounced them and/or they denounced us
			if (IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
			{
				iEnemyWeight += 10;
				iDPWeight += -10;
				iDoFWeight += -10;
			}

			// Do we think they're a good-for-nothing backstabber?!
			if (IsUntrustworthyFriend(ePlayer))
			{
				iEnemyWeight += 25;
				iDPWeight += -25;
				iDoFWeight += -25;
				
				// Extra penalties if they betrayed us personally!
				if (IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer))
				{
					iEnemyWeight += 10;
					iDPWeight += -25;
					iDoFWeight += -25;
				}
			}
			
			// Focus our aggression on major competitors.
			if (!IsMajorCompetitor(ePlayer))
			{
				iEnemyWeight += -3;
				iDPWeight += 3;
				iDoFWeight += 3;
			}
			
			// Easy targets don't make good DPs, but friends is fine if we aren't major competitors
			if (IsEasyTarget(ePlayer))
			{
				iDPWeight -= 10;
				
				if (IsMajorCompetitor(ePlayer))
				{
					iEnemyWeight += 5;
					iDoFWeight -= 10;
				}
				else
				{
					iEnemyWeight -= 10;
					iDoFWeight += 5;
				}
			}

			////////////////////////////////////
			// MILITARY THREAT
			////////////////////////////////////

			switch (GetMilitaryThreat(ePlayer))
			{
			case THREAT_CRITICAL:
				iEnemyWeight += 15;
				iDPWeight += 15;
				iDoFWeight += -15;
				break;
			case THREAT_SEVERE:
				iEnemyWeight += 10;
				iDPWeight += 10;
				iDoFWeight += -10;
				break;
			case THREAT_MAJOR:
				iEnemyWeight += 5;
				iDPWeight += 5;
				iDoFWeight += -5;
				break;
			case THREAT_MINOR:
				iEnemyWeight += 1;
				iDPWeight += -5;
				iDoFWeight += 5;
				break;
			case THREAT_NONE:
				iEnemyWeight += -5;
				iDPWeight += -10;
				iDoFWeight += 10;
				break;
			}

			switch (GetWarmongerThreat(ePlayer))
			{
			case THREAT_CRITICAL:
				iEnemyWeight += 15;
				iDPWeight += 15;
				iDoFWeight += -15;
				break;
			case THREAT_SEVERE:
				iEnemyWeight += 10;
				iDPWeight += 10;
				iDoFWeight += -10;
				break;
			case THREAT_MAJOR:
				iEnemyWeight += 5;
				iDPWeight += 5;
				iDoFWeight += -5;
				break;
			case THREAT_MINOR:
				iEnemyWeight += 1;
				iDPWeight += -5;
				iDoFWeight += 5;
				break;
			case THREAT_NONE:
				iEnemyWeight += -5;
				iDPWeight += -10;
				iDoFWeight += 10;
				break;
			}

			// Weight for victory issues
			switch (GetVictoryDisputeLevel(ePlayer))
			{
			case DISPUTE_LEVEL_NONE:
				iEnemyWeight += -5;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case DISPUTE_LEVEL_WEAK:
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case DISPUTE_LEVEL_STRONG:
				iEnemyWeight += 10;
				iDPWeight += -10;
				iDoFWeight += -10;
				break;
			case DISPUTE_LEVEL_FIERCE:
				iEnemyWeight += 15;
				iDPWeight += -15;
				iDoFWeight += -15;
				break;
			}

			switch (GetVictoryBlockLevel(ePlayer))
			{
			case BLOCK_LEVEL_NONE:
				iEnemyWeight += -5;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case BLOCK_LEVEL_WEAK:
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case BLOCK_LEVEL_STRONG:
				iEnemyWeight += 10;
				iDPWeight += -10;
				iDoFWeight += -10;
				break;
			case BLOCK_LEVEL_FIERCE:
				iEnemyWeight += 15;
				iDPWeight += -15;
				iDoFWeight += -15;
				break;
			}

			// Weight for land dispute
			switch (GetLandDisputeLevel(ePlayer))
			{
			case DISPUTE_LEVEL_NONE:
				iEnemyWeight += -5;
				iDPWeight += 1;
				iDoFWeight += 1;
				break;
			case DISPUTE_LEVEL_WEAK:
				iEnemyWeight += 3;
				iDPWeight += -3;
				iDoFWeight += -3;
				break;
			case DISPUTE_LEVEL_STRONG:
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
				break;
			case DISPUTE_LEVEL_FIERCE:
				iEnemyWeight += 10;
				iDPWeight += -10;
				iDoFWeight += -10;
				break;
			}
			
			// Extra weight for land dispute in the early game
			if (GetPlayer()->GetCurrentEra() <= 1 && GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			{
				iEnemyWeight += 5;
				iDPWeight += -5;
				iDoFWeight += -5;
			}
			
			// Modify based on grand strategy
			if (!IsNoVictoryCompetition() && GetPlayer()->GetCurrentEra() >= 2)
			{
				if (IsGoingForWorldConquest())
				{
					int iNumCaps = GET_PLAYER(ePlayer).GetNumCapitalCities();
					if ((iNumCaps > 0) && GET_PLAYER(ePlayer).GetCapitalConqueror() == NO_PLAYER)
					{
						iEnemyWeight += 5 + iNumCaps;
						
						if (IsCloseToDominationVictory())
						{
							iEnemyWeight += 10 + iNumCaps;
						}
					}
					
					switch (GetLandDisputeLevel(ePlayer))
					{
					case DISPUTE_LEVEL_NONE:
						iEnemyWeight += -3;
						iDPWeight += 3;
						iDoFWeight += 3;
						break;
					case DISPUTE_LEVEL_WEAK:
						iEnemyWeight += 5;
						iDPWeight += -5;
						iDoFWeight += -5;
						break;
					case DISPUTE_LEVEL_STRONG:
						iEnemyWeight += 10;
						iDPWeight += -10;
						iDoFWeight += -10;
						break;
					case DISPUTE_LEVEL_FIERCE:
						iEnemyWeight += 15;
						iDPWeight += -15;
						iDoFWeight += -5;
						break;
					}
				}
				
				else if (IsGoingForSpaceshipVictory())
				{
					// Higher in tech = better friend choice (Research Agreements/Tech Trading), but also worse enemies
					if (GetPlayer()->GetCurrentEra() < GET_PLAYER(ePlayer).GetCurrentEra())
					{
						iEnemyWeight += 10;
						iDPWeight += -5;
						iDoFWeight += 10;
					}
					else if (GetPlayer()->GetCurrentEra() == GET_PLAYER(ePlayer).GetCurrentEra())
					{
						iEnemyWeight += 5;
						iDoFWeight += 5;
						
						// We want other civs to guard our back
						if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) >= STRENGTH_AVERAGE)
							iDPWeight += 5;
					}
					else
					{
						iEnemyWeight += -10;
						iDoFWeight += -10;
						
						// We want other civs to guard our back
						if (GetPlayerMilitaryStrengthComparedToUs(ePlayer) >= STRENGTH_AVERAGE)
							iDPWeight += 10;
					}
				}
				
				
				else if (IsGoingForCultureVictory())
				{
					switch (GetWonderDisputeLevel(ePlayer))
					{
					case DISPUTE_LEVEL_NONE:
						iEnemyWeight += -5;
						iDPWeight += 3;
						iDoFWeight += 3;
						break;
					case DISPUTE_LEVEL_WEAK:
						iEnemyWeight += 3;
						iDPWeight += -3;
						iDoFWeight += -3;
						break;
					case DISPUTE_LEVEL_STRONG:
						iEnemyWeight += 5;
						iDPWeight += -5;
						iDoFWeight += -5;
						break;
					case DISPUTE_LEVEL_FIERCE:
						iEnemyWeight += 10;
						iDPWeight += -10;
						iDoFWeight += -10;
						break;
					}
				}
				
				else if (IsGoingForDiploVictory())
				{
					switch (GetMinorCivDisputeLevel(ePlayer))
					{
					case DISPUTE_LEVEL_NONE:
						iEnemyWeight += -5;
						iDPWeight += 5;
						iDoFWeight += 5;
						break;
					case DISPUTE_LEVEL_WEAK:
						iEnemyWeight += 3;
						iDPWeight += -1;
						iDoFWeight += -1;
						break;
					case DISPUTE_LEVEL_STRONG:
						iEnemyWeight += 5;
						iDPWeight += -5;
						iDoFWeight += -5;
						break;
					case DISPUTE_LEVEL_FIERCE:
						iEnemyWeight += 10;
						iDPWeight += -10;
						iDoFWeight += -10;
						break;
					}
				}
			}

			// Do we already have a DP? Let's keep this alive then.
			if (GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
			{
				iDPWeight += 10;
				iDoFWeight += 15;
				iEnemyWeight += -10;
			}

			// If they're close to victory, that should influence our decision
			// Modify enemy weight for humans based on human difficulty level
			if (!IsNoVictoryCompetition())
			{
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDominationVictory())
				{
					if (GET_PLAYER(ePlayer).isHuman())
					{
						int EnemyMod = 15 * GC.getGame().getHandicapInfo().getAIDeclareWarProb();
						EnemyMod /= 100;
						iEnemyWeight += EnemyMod;
						iDPWeight += -EnemyMod;
						iDoFWeight += -EnemyMod;
					}
					else
					{
						iEnemyWeight += 20;
						iDPWeight += -10;
						iDoFWeight += -10;
					}
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToSSVictory())
				{
					if (GET_PLAYER(ePlayer).isHuman())
					{
						int EnemyMod = 15 * GC.getGame().getHandicapInfo().getAIDeclareWarProb();
						EnemyMod /= 100;
						iEnemyWeight += EnemyMod;
						iDPWeight += -EnemyMod;
						iDoFWeight += -EnemyMod;
					}
					else
					{
						iEnemyWeight += 20;
						iDPWeight += -10;
						iDoFWeight += -10;
					}
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToDiploVictory())
				{
					if (GET_PLAYER(ePlayer).isHuman())
					{
						int EnemyMod = 15 * GC.getGame().getHandicapInfo().getAIDeclareWarProb();
						EnemyMod /= 100;
						iEnemyWeight += EnemyMod;
						iDPWeight += -EnemyMod;
						iDoFWeight += -EnemyMod;
					}
					else
					{
						iEnemyWeight += 20;
						iDPWeight += -10;
						iDoFWeight += -10;
					}
				}
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToCultureVictory())
				{
					if (GET_PLAYER(ePlayer).isHuman())
					{
						int EnemyMod = 15 * GC.getGame().getHandicapInfo().getAIDeclareWarProb();
						EnemyMod /= 100;
						iEnemyWeight += EnemyMod;
						iDPWeight += -EnemyMod;
						iDoFWeight += -EnemyMod;
					}
					else
					{
						iEnemyWeight += 20;
						iDPWeight += -10;
						iDoFWeight += -10;
					}
				}
			}

			if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() == GetPlayer()->getTeam())
			{
				iEnemyWeight += -25;
				iDPWeight += 25;
				iDoFWeight += 25;
			}
			if (GET_TEAM(GetPlayer()->getTeam()).GetMaster() == GET_PLAYER(ePlayer).getTeam())
			{
				iEnemyWeight += -25;
				iDPWeight += 25;
				iDoFWeight += 25;
			}

			//Let's not have too many defensive pacts.
			iDPWeight -= (GetNumDefensePacts() * 15);

			//Subtract for # of existing DoFs - want only a few close friends.
			iDoFWeight -= (GetNumDoF() * 15);

			//He hates who we hate? We love this guy!
			if (!GET_PLAYER(ePlayer).isHuman())
			{
				if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBiggestCompetitor() == GetBiggestCompetitor())
				{
					iDPWeight += 5;
					iDoFWeight += 5;
					iEnemyWeight += -5;
				}
			}

			if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(GetPlayer()->GetID()) == INFLUENCE_LEVEL_POPULAR)
			{
				if (GET_PLAYER(ePlayer).GetCulture()->GetInfluenceTrend(GetPlayer()->GetID()) == INFLUENCE_TREND_RISING)
				{
					iDoFWeight -= 5;
					iDPWeight += -5;
					iEnemyWeight += 5;
				}
			}
			
			// Ongoing trade with them?
			if ((GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer) > 0) || (GC.getGame().GetGameDeals().GetDealValueWithPlayer(GetPlayer()->GetID(), ePlayer) > 0))
			{
				iDoFWeight += 2;
				iEnemyWeight -= 2;
			}

			// Loop through all (known) Players and see who he likes/hates - if he likes/hates who we like/hate, then add those points in!
			for (int iPlayerLoop2 = 0; iPlayerLoop2 < MAX_MAJOR_CIVS; iPlayerLoop2++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes)iPlayerLoop2;

				if (eOtherPlayer == ePlayer)
					continue;

				if (eOtherPlayer == GetPlayer()->GetID())
					continue;

				if (IsPlayerValid(eOtherPlayer))
				{
					//Friend or DP?
					if (IsDoFAccepted(eOtherPlayer) || GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).IsHasDefensivePact(GetPlayer()->getTeam()))
					{
						//At war?
						if (GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->IsAtWar(ePlayer))
						{
							iEnemyWeight += 5;
							iDPWeight += -5;
							iDoFWeight += -5;
						}
						if (GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer))
						{
							iEnemyWeight += 5;
							iDPWeight += -5;
							iDoFWeight += -5;
						}
						if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eOtherPlayer))
						{
							iEnemyWeight += 5;
							iDPWeight += -5;
							iDoFWeight += -5;
						}
					}

					//We dislike the same people? Good!
					if (!GET_PLAYER(ePlayer).isHuman())
					{
						if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetCompetitorValue(eOtherPlayer) > GC.getDOF_THRESHOLD() && GetCompetitorValue(eOtherPlayer) > GC.getDOF_THRESHOLD())
						{
							iDPWeight += 5;
							iDoFWeight += 5;
							iEnemyWeight += -5;
						}
					}

					//We have defensive pacts with the same people? Good!
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eOtherPlayer).getTeam()) && GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(eOtherPlayer).getTeam()))
					{
						iDPWeight += 5;
						iDoFWeight += 5;
						iEnemyWeight += -5;
					}

					//We have DoFs with the same people? Good!
					if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eOtherPlayer) && IsDoFAccepted(eOtherPlayer))
					{
						iDPWeight += 5;
						iDoFWeight += 5;
						iEnemyWeight += -5;
					}

					//War? Are we threatened?
					if (GET_PLAYER(ePlayer).IsAtWarWith(eOtherPlayer))
					{
						if (GetPlayer()->IsAtWarWith(eOtherPlayer))
						{
							iDPWeight += 5;
							iDoFWeight += 5;
							iEnemyWeight += -5;
						}

						//Close? We might be next!
						if (GetPlayer()->GetProximityToPlayer(eOtherPlayer) >= PLAYER_PROXIMITY_CLOSE)
						{
							iDPWeight += 5;
							iDoFWeight += 5;
							iEnemyWeight += -5;
						}

						//Warmonger? We might be next!
						if (GetWarmongerThreat(eOtherPlayer) >= THREAT_MAJOR)
						{
							iDPWeight += 5;
							iDoFWeight += 5;
							iEnemyWeight += -5;
						}
					}
				}
			}

			if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone() || GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
			{
				iDPWeight = 0;
				iDoFWeight /= 2;
				iEnemyWeight /= 2;
			}
			
			// Sanity check - don't want friendship or defensive pacts if we're hostile or want war
			if (GetMajorCivApproach(ePlayer) <= MAJOR_CIV_APPROACH_HOSTILE)
			{
				iDPWeight = 0;
				iDoFWeight = 0;
			}	
		}
		//Total it up and add it to the pool of values.
		m_paiCompetitorValue[ePlayer] = iEnemyWeight;
		m_paiDoFValue[ePlayer] = iDoFWeight;
		m_paiDefensivePactValue[ePlayer] = iDPWeight;
	}
	
	//Let's log this data
	if (GC.getLogging() && GC.getAILogging())
	{

		CvString strLogName;

		CvString strOutBuf1;
		CvString strOutBuf2 = "";
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_GlobalRelations_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_GlobalRelations_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		strOutBuf1 = strBaseString;
		strOutBuf2 = strBaseString;

		// Loop through all (known) Players
		int iNumPlayers = 0;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;

			if (IsPlayerValid(ePlayer))
			{
				if (iNumPlayers != 0)
				{
					strTemp.Format("\n     -");
					strOutBuf1 += strTemp;
				}
				// Strategy Info
				strTemp.Format(" ** %s Valuation: Competitor - %d; DoF - %d, DP - %d **", GET_PLAYER(ePlayer).getCivilizationShortDescription(), GetCompetitorValue(ePlayer), GetDoFValue(ePlayer), GetDefensivePactValue(ePlayer));
				strOutBuf1 += strTemp;
				iNumPlayers++;
			}
		}

		if (GetBiggestCompetitor() != NO_PLAYER)
		{
			strTemp.Format("\n     - ** Our biggest COMPETITOR: %s", GET_PLAYER(GetBiggestCompetitor()).getCivilizationShortDescription());
			strOutBuf2 += strTemp;
		}

		if (GetMostValuableDefensivePact(false) != NO_PLAYER)
		{
			strTemp.Format("\n     - ** Our best DEFENSIVE PACT: %s", GET_PLAYER(GetMostValuableDefensivePact(false)).getCivilizationShortDescription());
			strOutBuf2 += strTemp;
		}

		if (GetMostValuableDoF(false) != NO_PLAYER)
		{
			strTemp.Format("\n     - ** Our best FRIENDSHIP: %s", GET_PLAYER(GetMostValuableDoF(false)).getCivilizationShortDescription());
			strOutBuf2 += strTemp;
		}
		pLog->Msg(strOutBuf1);
		if (strOutBuf2 != "")
		{
			pLog->Msg(strOutBuf2);
		}
	}
}

/// Returns the value of a Defensive Pact with ePlayer
int CvDiplomacyAI::GetDefensivePactValue(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDefensivePactValue[ePlayer];
}

/// Returns the player who we consider our most valuable potential DP
PlayerTypes CvDiplomacyAI::GetMostValuableDefensivePact(bool bIgnoreDPs)
{
	int iBestValue = 18;
	PlayerTypes eBestPlayer = NO_PLAYER;

	int iNumPlayers = 0;
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			iNumPlayers++;
			//Ignore DPs we already have.
			if (!bIgnoreDPs && GET_TEAM(GetTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
				continue;

			int iValue = GetDefensivePactValue(ePlayer);
			if (iValue >= iBestValue)
			{
				iBestValue = iValue;
				eBestPlayer = ePlayer;
			}
		}
	}

	//If we have a choice, return it. If only one person is known to us, they can't be our DP!
	if (iNumPlayers > 1)
	{
		return eBestPlayer;
	}
	return NO_PLAYER;
}

/// Returns the value of a Declaration of Friendship with ePlayer
int CvDiplomacyAI::GetDoFValue(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDoFValue[ePlayer];
}

/// Returns the player who we consider our most valuable potential friend
PlayerTypes CvDiplomacyAI::GetMostValuableDoF(bool bIgnoreDoFs)
{
	int iBestValue = GC.getDOF_THRESHOLD();
	PlayerTypes eBestPlayer = NO_PLAYER;

	int iNumPlayers = 0;
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			iNumPlayers++;
			//Ignore DoFs we already have.
			if (!bIgnoreDoFs && IsDoFAccepted(ePlayer))
				continue;

			int iValue = GetDoFValue(ePlayer);
			if (iValue >= iBestValue)
			{
				iBestValue = iValue;
				eBestPlayer = ePlayer;
			}
		}
	}

	//If we have a choice, return it. If only one person is known to us, they can't be our best friend!
	if (iNumPlayers > 1 || IsNoVictoryCompetition())
	{
		return eBestPlayer;
	}
	return NO_PLAYER;
}

/// Returns how much we numerically consider ePlayer a competitor/enemy
int CvDiplomacyAI::GetCompetitorValue(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiCompetitorValue[ePlayer];
}

/// Returns the player who we consider our biggest competitor
PlayerTypes CvDiplomacyAI::GetBiggestCompetitor() const
{
	int iBestValue = 18;
	PlayerTypes eBestPlayer = NO_PLAYER;
	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;

		if (IsPlayerValid(ePlayer))
		{
			if (MOD_DIPLOMACY_CIV4_FEATURES && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
				continue;

			int iValue = GetCompetitorValue(ePlayer);
			if (iValue >= iBestValue)
			{
				iBestValue = iValue;
				eBestPlayer = ePlayer;
			}
		}
	}

	return eBestPlayer;
}

/// Is this player one of our major competitors?
bool CvDiplomacyAI::IsMajorCompetitor(PlayerTypes ePlayer) const
{
	if (!IsPlayerValid(ePlayer) || GET_PLAYER(ePlayer).isMinorCiv())
		return false;
	
	if (IsCapitalCapturedBy(ePlayer))
		return true;
	
	if (IsHolyCityCapturedBy(ePlayer))
		return true;
	
	if (GC.getGame().countMajorCivsAlive() == 2 && !IsNoVictoryCompetition())
		return true;
	
	if (IsNukedBy(ePlayer) || GET_PLAYER(ePlayer).getNumNukeUnits() > 0)
		return true;
	
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
	{
		return true;
	}
	
	if (GET_PLAYER(ePlayer).GetCapitalConqueror() != NO_PLAYER)
		return false;
	
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
			return false;
	}
#endif

	if (IsCloseToDominationVictory())
		return true;

	if (IsUntrustworthyFriend(ePlayer))
		return true;
	
	if (IsPlayerOpposingIdeology(ePlayer))
		return true;

	if (GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
		return true;
	
	if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return true;
	
	if (GetBiggestCompetitor() == ePlayer)
		return true;
	
	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG || GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		return true;
	
	if (GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		if (GetPlayer()->GetCurrentEra() <= 2 || IsGoingForWorldConquest())
		{
			return true;
		}
	}
	
	if (!IsNoVictoryCompetition())
	{
		if (IsGoingForWorldConquest())
		{
			if (GET_PLAYER(ePlayer).GetNumCapitalCities() > 0)
				return true;
			
			if (GetPlayer()->GetCurrentEra() >= 4 && GetLandDisputeLevel(ePlayer) > DISPUTE_LEVEL_NONE)
				return true;
			
			if (GetPlayer()->GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
				return true;
		}
		
		if (IsGoingForDiploVictory() && GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			return true;
		
		if (IsGoingForCultureVictory() && GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			return true;
		
		if (IsGoingForSpaceshipVictory())
		{
			if (GetPlayer()->GetCurrentEra() < GET_PLAYER(ePlayer).GetCurrentEra())
			{
				return true;
			}
		}
	}

	return false;
}

/// Is this player an easy attack target?
bool CvDiplomacyAI::IsEasyTarget(PlayerTypes ePlayer) const
{
	if (!IsPlayerValid(ePlayer) || GET_PLAYER(ePlayer).isMinorCiv())
		return false;
	
	if (GetWarState(ePlayer) == WAR_STATE_NEARLY_WON)
		return true;
	
	// If they're too far away, they can't be an easy target
	if (GetPlayer()->GetProximityToPlayer(ePlayer) <= PLAYER_PROXIMITY_FAR)
		return false;
	
	// If we're doing very badly, they can't be an easy target
	if (GetWarState(ePlayer) == WAR_STATE_NEARLY_DEFEATED || GetStateAllWars() == STATE_ALL_WARS_LOSING || GetPlayer()->IsEmpireVeryUnhappy())
		return false;
	
	// If we're bankrupt, they can't be an easy target
	if (GetPlayer()->GetTreasury()->GetGold() <= 0 && GetPlayer()->calculateGoldRate() <= 0)
	{
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() || IsNoVictoryCompetition())
		{
			return false;
		}
	}
	
	// If we're at a stalemate or defensive in a war against any other players, they can't be an easy target
	int iPlayerLoop;
	PlayerTypes eLoopPlayer;
	for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		// Don't look at the guy we're already thinking about
		if (IsPlayerValid(eLoopPlayer) && ePlayer != eLoopPlayer)
		{
			if (GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				if (GetWarState(eLoopPlayer) <= WAR_STATE_CALM)
				{
					return false;
				}
			}
		}
	}
	
	bool bIsEasyTarget = false;
	bool bWantsConquest = false;
	
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	StrengthTypes eEconomicStrength = GetPlayerEconomicStrengthComparedToUs(ePlayer);
	
	if (GetPlayerTargetValue(ePlayer) == TARGET_VALUE_SOFT || GetWarProjection(ePlayer) == WAR_PROJECTION_VERY_GOOD ||
		eMilitaryStrength == STRENGTH_PATHETIC || eEconomicStrength == STRENGTH_PATHETIC)
	{
		bIsEasyTarget = true;
	}
	
	if (!bIsEasyTarget)
	{
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() || IsNoVictoryCompetition())
		{
			// If we would go bankrupt by declaring war on them, they can't be an easy target
			int iLostGoldPerTurn = CalculateGoldPerTurnLostFromWar(ePlayer, false, false);
			int iAdjustedGoldPerTurn = GetPlayer()->calculateGoldRate() - iLostGoldPerTurn;
			
			if (iLostGoldPerTurn != 0)
			{
#if defined(MOD_BALANCE_CORE)
				// Factor in instant yields into our income as well (average of recent turns)
				int iTurn = GC.getGame().getGameTurn();
				int iGoldAverage = 0;
				for (int iI = 0; iI < 10; iI++)
				{
					int iYieldTurn = iTurn - iI;
					if (iYieldTurn <= 0)
						continue;

					iGoldAverage += GetPlayer()->getInstantYieldValue(YIELD_GOLD, iYieldTurn);
				}

				iGoldAverage /= 10;

				iAdjustedGoldPerTurn += iGoldAverage;
#endif

				iAdjustedGoldPerTurn *= 100; // multiply x100 to avoid rounding errors

				if (iAdjustedGoldPerTurn < 0)
				{
					// Flip it!
					iAdjustedGoldPerTurn *= -1;

					int iTurnsUntilBankruptcy = GetPlayer()->GetTreasury()->GetGoldTimes100() / max(iAdjustedGoldPerTurn, 1);

					if (iTurnsUntilBankruptcy <= 30)
					{
						return false;
					}
				}
			}
		}
	}
	
	// Humans can tell this by mousing over any of the AI's units (only apply if at war, for fairness)
	if (GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()) && GET_PLAYER(ePlayer).IsEmpireVeryUnhappy())
	{
		bIsEasyTarget = true;
	}
	
	if (!bIsEasyTarget)
	{
		if (GetWarProjection(ePlayer) > WAR_PROJECTION_UNKNOWN && GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
		{
			bWantsConquest = true;
		}
		else if (IsGoingForWorldConquest() || IsCloseToDominationVictory())
		{
			bWantsConquest = true;
		}
		else if (GetPlayer()->GetDiplomacyAI()->IsLockedIntoCoopWar(ePlayer))
		{
			bWantsConquest = true;
		}
		else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
		{
			bWantsConquest = true;
		}
	}
	
	bool bAtWarWithAtLeastOneMajor = MilitaryAIHelpers::IsTestStrategy_AtWar(m_pPlayer, false);
	
	// Compare military and economic strengths to look for opportunities to strike
	// We sense more opportunities to attack our biggest competitor or people we want to conquer
	if ((GetBiggestCompetitor() == ePlayer || bWantsConquest) && !bAtWarWithAtLeastOneMajor)
	{
		if (eMilitaryStrength <= STRENGTH_POOR && eEconomicStrength <= STRENGTH_POOR)
		{
			bIsEasyTarget = true;
		}
		if (eMilitaryStrength <= STRENGTH_POOR && eEconomicStrength <= STRENGTH_POWERFUL)
		{
			bIsEasyTarget = true;
		}
		if (eMilitaryStrength <= STRENGTH_WEAK && eEconomicStrength <= STRENGTH_STRONG)
		{
			bIsEasyTarget = true;
		}
		if (eEconomicStrength <= STRENGTH_POOR && eMilitaryStrength <= STRENGTH_POWERFUL)
		{
			bIsEasyTarget = true;
		}
		if (eEconomicStrength <= STRENGTH_WEAK && eMilitaryStrength <= STRENGTH_STRONG)
		{
			bIsEasyTarget = true;
		}
	}
	else
	{
		if (eMilitaryStrength <= STRENGTH_WEAK && eEconomicStrength <= STRENGTH_WEAK)
		{
			bIsEasyTarget = true;
		}
		if (eMilitaryStrength <= STRENGTH_WEAK && eEconomicStrength <= STRENGTH_AVERAGE)
		{
			bIsEasyTarget = true;
		}
		if (eEconomicStrength <= STRENGTH_WEAK && eMilitaryStrength <= STRENGTH_AVERAGE)
		{
			bIsEasyTarget = true;
		}
	}
	
	if (bIsEasyTarget)
	{
		return true;
	}
	else
	{
		return false;
	}
}
#endif

/// What is our level of Dispute with a player over Victory?
DisputeLevelTypes CvDiplomacyAI::GetVictoryDisputeLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_paePlayerVictoryDisputeLevel[ePlayer];
}

/// Sets what our level of Dispute is with a player over Victory
void CvDiplomacyAI::SetVictoryDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerVictoryDisputeLevel[ePlayer] = eDisputeLevel;
}

/// Updates what our level of Dispute is with all players over Victory
void CvDiplomacyAI::DoUpdateVictoryDisputeLevels()
{
	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();

	PlayerTypes ePlayer;

	DisputeLevelTypes eDisputeLevel;

	int iVictoryDisputeWeight;
	
	// Disallowed by game options
	if (IsNoVictoryCompetition())
	{
		// Loop through all (known) Players
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes)iPlayerLoop;
			SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
		}
		return;
	}
	
	// If we're somebody's vassal, chances are we can't compete with them anyway, so hatred is pointless.
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
		{
			// Loop through all (known) Players
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
			}
			return;
		}
	}
#endif

	//Don't do this at the start of the game.
	if (GC.getGame().getGameTurn() <= 150)
		return;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(ePlayer))
		{
			eDisputeLevel = DISPUTE_LEVEL_NONE;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			if(eMyGrandStrategy == NO_AIGRANDSTRATEGY)
			{
				SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
				continue;
			}
			else if(GetPlayer()->GetGrandStrategyAI()->GetGrandStrategyPriority(eMyGrandStrategy) <= 500)
			{
				SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
				continue;
			}
#endif
			// Minors and Barbarians can't really be an issue with Victory!
			if(!GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
			{
				iVictoryDisputeWeight = 0;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				if(MOD_BALANCE_CORE_DIPLOMACY)
				{
					AIGrandStrategyTypes eTheirGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer);
					if(eTheirGrandStrategy == NO_AIGRANDSTRATEGY)
					{
						SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
						continue;
					}
					MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
					if(eOpinion > MAJOR_CIV_OPINION_FRIEND)
					{
						SetVictoryDisputeLevel(ePlayer, DISPUTE_LEVEL_NONE);
						continue;
					}
				}
#endif

				// Does the other player's (estimated) Grand Strategy match our own?
				if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer) == eMyGrandStrategy)
				{
					switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(ePlayer))
					{
					case GUESS_CONFIDENCE_POSITIVE:
						iVictoryDisputeWeight += /*14*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_POSITIVE();
						break;
					case GUESS_CONFIDENCE_LIKELY:
						iVictoryDisputeWeight += /*10*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_LIKELY();
						break;
					case GUESS_CONFIDENCE_UNSURE:
						iVictoryDisputeWeight += /*6*/ GC.getVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_UNSURE();
						break;
					}
				}

				// Add weight for Player's competitiveness (0 - 10)
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				int iEraReduction = (6 - GetPlayer()->GetCurrentEra());
				if(MOD_BALANCE_CORE_DIPLOMACY && iEraReduction > 0)
				{
					iVictoryDisputeWeight -= iEraReduction;
				}
#endif
				iVictoryDisputeWeight *= GetVictoryCompetitiveness();

				// Grand Strategy Matches: 10
				// VictoryCompetitiveness 10	: 100
				// VictoryCompetitiveness 5		: 50
				// VictoryCompetitiveness 1		: 10

				// Now see what our new Dispute Level should be
				if(iVictoryDisputeWeight >= /*80*/ GC.getVICTORY_DISPUTE_FIERCE_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_FIERCE;
				else if(iVictoryDisputeWeight >= /*50*/ GC.getVICTORY_DISPUTE_STRONG_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_STRONG;
				else if(iVictoryDisputeWeight >= /*30*/ GC.getVICTORY_DISPUTE_WEAK_THRESHOLD())
					eDisputeLevel = DISPUTE_LEVEL_WEAK;
			}

			// Actually set the Level
			SetVictoryDisputeLevel(ePlayer, eDisputeLevel);
		}
	}
}


/// What is our guess as to the level of Dispute between two players over Victory?
DisputeLevelTypes CvDiplomacyAI::GetEstimateOtherPlayerVictoryDisputeLevel(PlayerTypes ePlayer, PlayerTypes eWithPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_ppaaeOtherPlayerVictoryDisputeLevel[ePlayer][eWithPlayer];
}

/// Sets what our guess is as to the level of Dispute between two players over Victory
void CvDiplomacyAI::SetEstimateOtherPlayerVictoryDisputeLevel(PlayerTypes ePlayer, PlayerTypes eWithPlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eWithPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaeOtherPlayerVictoryDisputeLevel[ePlayer][eWithPlayer] = eDisputeLevel;
}

/// Updates what our guesses are as to the levels of Dispute between other players over Victory
void CvDiplomacyAI::DoUpdateEstimateOtherPlayerVictoryDisputeLevels()
{
	PlayerTypes eLoopOtherPlayer;
	int iOtherPlayerLoop;

	int iVictoryDisputeWeight;

	DisputeLevelTypes eDisputeLevel;

	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			// Now loop through every player HE knows
			for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
			{
				eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

				// Don't compare a player to himself
				if(eLoopPlayer != eLoopOtherPlayer)
				{
					// Do both we and the guy we're looking about know the third guy?
					if(IsPlayerValid(eLoopOtherPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
					{
						eDisputeLevel = DISPUTE_LEVEL_NONE;
						iVictoryDisputeWeight = 0;

						// Do we think their Grand Strategies match?
						if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer) == GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopOtherPlayer))
						{
							switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
							{
							case GUESS_CONFIDENCE_POSITIVE:
								iVictoryDisputeWeight += /*7*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_POSITIVE();
								break;
							case GUESS_CONFIDENCE_LIKELY:
								iVictoryDisputeWeight += /*5*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_LIKELY();
								break;
							case GUESS_CONFIDENCE_UNSURE:
								iVictoryDisputeWeight += /*3*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_UNSURE();
								break;
							}
							switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopOtherPlayer))
							{
							case GUESS_CONFIDENCE_POSITIVE:
								iVictoryDisputeWeight += /*7*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_POSITIVE();
								break;
							case GUESS_CONFIDENCE_LIKELY:
								iVictoryDisputeWeight += /*5*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_LIKELY();
								break;
							case GUESS_CONFIDENCE_UNSURE:
								iVictoryDisputeWeight += /*3*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_UNSURE();
								break;
							}

							// Add weight for Player's competitiveness: assume default (5), since we can't actually know how competitive a player is
							iVictoryDisputeWeight *= /*5*/ GC.getDEFAULT_FLAVOR_VALUE();

							// Example Victory Dispute Weights
							// Positive on Both:		70
							// Positive, Unsure:		50
							// Unsure, Unsure:			30

							// Now see what our new estimated Dispute Level should be
							if(iVictoryDisputeWeight >= /*70*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_FIERCE_THRESHOLD())
								eDisputeLevel = DISPUTE_LEVEL_FIERCE;
							else if(iVictoryDisputeWeight >= /*50*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_STRONG_THRESHOLD())
								eDisputeLevel = DISPUTE_LEVEL_STRONG;
							else if(iVictoryDisputeWeight >= /*30*/ GC.getVICTORY_DISPUTE_OTHER_PLAYER_WEAK_THRESHOLD())
								eDisputeLevel = DISPUTE_LEVEL_WEAK;
						}

						// Actually set the estimated Level
						SetEstimateOtherPlayerVictoryDisputeLevel(eLoopPlayer, eLoopOtherPlayer, eDisputeLevel);
					}
				}
			}
		}
	}
}


/// What is our level of Dispute with a player over World Wonders?
DisputeLevelTypes CvDiplomacyAI::GetWonderDisputeLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_paePlayerWonderDisputeLevel[ePlayer];
}

/// Sets what our level of Dispute is with a player over World Wonders
void CvDiplomacyAI::SetWonderDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerWonderDisputeLevel[ePlayer] = eDisputeLevel;
}

/// Updates what our level of Dispute is with all players over World Wonders
void CvDiplomacyAI::DoUpdateWonderDisputeLevels()
{
	PlayerTypes ePlayer;

	DisputeLevelTypes eDisputeLevel;

	int iWonderDisputeWeight;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(ePlayer))
		{
			eDisputeLevel = DISPUTE_LEVEL_NONE;

			iWonderDisputeWeight = GetNumWondersBeatenTo(ePlayer);

			// Add weight for Player's competitiveness (0 - 10)
			iWonderDisputeWeight *= GetWonderCompetitiveness();

			// Now see what our new Dispute Level should be
			if(iWonderDisputeWeight >= /*10*/ GC.getWONDER_DISPUTE_FIERCE_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_FIERCE;
			else if(iWonderDisputeWeight >= /*7*/ GC.getWONDER_DISPUTE_STRONG_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_STRONG;
			else if(iWonderDisputeWeight >= /*5*/ GC.getWONDER_DISPUTE_WEAK_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_WEAK;

			// Actually set the Level
			SetWonderDisputeLevel(ePlayer, eDisputeLevel);
		}
	}
}


/// What is our level of Dispute with a player over Minor Civ Friendship?
DisputeLevelTypes CvDiplomacyAI::GetMinorCivDisputeLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DisputeLevelTypes) m_paePlayerMinorCivDisputeLevel[ePlayer];
}

/// Sets what our level of Dispute is with a player over Minor Civ Friendship
void CvDiplomacyAI::SetMinorCivDisputeLevel(PlayerTypes ePlayer, DisputeLevelTypes eDisputeLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDisputeLevel < NUM_DISPUTE_LEVELS, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerMinorCivDisputeLevel[ePlayer] = eDisputeLevel;
}

/// Updates what our level of Dispute is with all players over Minor Civ Friendship
void CvDiplomacyAI::DoUpdateMinorCivDisputeLevels()
{
	PlayerTypes ePlayer;

	DisputeLevelTypes eDisputeLevel;

	int iMinorCivDisputeWeight;

	// Personality factors in quite a bit here, which is why we square the value
	int iPersonalityMod = GetMinorCivCompetitiveness() * GetMinorCivCompetitiveness();	// Ranges from 0 to 100

	int iMinorCivLoop;
	PlayerTypes eMinor;

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(ePlayer))
		{
			eDisputeLevel = DISPUTE_LEVEL_NONE;
			iMinorCivDisputeWeight = 0;

			// Loop through all minors to check our relationship with them
			for(iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
			{
				eMinor = (PlayerTypes) iMinorCivLoop;
				
				// Don't evaluate City-States that are unmet/dead
				if (!IsPlayerValid(eMinor))
					continue;
				
#if defined(MOD_BALANCE_CORE)
				// Ignore if League resolutions make it irrelevant
				if (GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly() || GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == GetPlayer()->GetID())
					continue;

				// We are at least friends
				//if they're constantly affecting our influence, or we're friends.
				int iThreshold = ((10 - GetMinorCivCompetitiveness()) + GC.getGame().getCurrentEra());
				bool bThreatening = false;
				if (GetNumTimesTheyLoweredOurInfluence(ePlayer) > 0 && GetNumTimesTheyLoweredOurInfluence(ePlayer) >= iThreshold)
					bThreatening = true;
				if (bThreatening || GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
				{
					bool bOneIsAllied = false;
					// Other Player is Allies with this minor
					if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(ePlayer))
					{
						if (GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_PROTECTIVE)
						{
							iMinorCivDisputeWeight += iPersonalityMod / 2;
						}
						bOneIsAllied = true;
					}
					// Other Player is Friends with this minor
					else if (GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(ePlayer))
					{
						//We're allies? Grr...
						if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetPlayer()->GetID()))
						{
							iMinorCivDisputeWeight += iPersonalityMod;
							bOneIsAllied = true;
						}
						else
						{
							iMinorCivDisputeWeight -= iPersonalityMod;
						}
					}
					//Let's look at influence.
					int iOurInfluence = GET_PLAYER(eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetPlayer()->GetID());
					int iTheirInfluence = GET_PLAYER(eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(ePlayer);

					if (bOneIsAllied)
					{
						iMinorCivDisputeWeight += (iOurInfluence / 5);
						iMinorCivDisputeWeight += GetNumTimesTheyLoweredOurInfluence(ePlayer) * 10;

						if (iTheirInfluence > iOurInfluence)
						{
							int iInfluenceStart = iPersonalityMod;
							//Are our influences within 20 of each other?
							if ((iTheirInfluence - iOurInfluence) <= 20)
							{
								iInfluenceStart *= 40;
								iInfluenceStart /= 10;
							}
							//Are our influences within 40 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 40)
							{
								iInfluenceStart *= 35;
								iInfluenceStart /= 10;
							}
							//Are our influences within 60 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 60)
							{
								iInfluenceStart *= 30;
								iInfluenceStart /= 10;
							}
							//Are our influences within 80 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 80)
							{
								iInfluenceStart *= 20;
								iInfluenceStart /= 10;
							}
							//Are our influences within 100 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 100)
							{
								iInfluenceStart *= 10;
								iInfluenceStart /= 10;
							}
							//Are our influences within 120 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 120)
							{
								iInfluenceStart *= 5;
								iInfluenceStart /= 10;
							}
							//Are our influences within 150 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 150)
							{
								iInfluenceStart *= 3;
								iInfluenceStart /= 10;
							}
							//Are our influences within 200 of each other?
							else if ((iTheirInfluence - iOurInfluence) <= 200)
							{
								iInfluenceStart *= 2;
								iInfluenceStart /= 10;
							}
							// We have a PtP with this minor - bump it up a little bit.
							if (GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
							{
								iInfluenceStart *= 15;
								iInfluenceStart /= 10;
							}
							iMinorCivDisputeWeight += iInfluenceStart;
						}
						else if (iOurInfluence > iTheirInfluence)
						{
							int iInfluenceStart = iPersonalityMod;

							//Are our influences within 20 of each other?
							if ((iOurInfluence - iTheirInfluence) <= 20)
							{
								iInfluenceStart *= 40;
								iInfluenceStart /= 10;
							}
							//Are our influences within 40 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 40)
							{
								iInfluenceStart *= 30;
								iInfluenceStart /= 10;
							}
							//Are our influences within 60 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 60)
							{
								iInfluenceStart *= 20;
								iInfluenceStart /= 10;
							}
							//Are our influences within 80 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 80)
							{
								iInfluenceStart *= 15;
								iInfluenceStart /= 10;
							}
							//Are our influences within 100 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 100)
							{
								iInfluenceStart *= 10;
								iInfluenceStart /= 10;
							}
							//Are our influences within 120 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 120)
							{
								iInfluenceStart *= 8;
								iInfluenceStart /= 10;
							}
							//Are our influences within 150 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 150)
							{
								iInfluenceStart *= 6;
								iInfluenceStart /= 10;
							}
							//Are our influences within 200 of each other?
							else if ((iOurInfluence - iTheirInfluence) <= 200)
							{
								iInfluenceStart *= 4;
								iInfluenceStart /= 10;
							}
							// We have a PtP with this minor - bump it up a little bit.
							if (GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
							{
								iInfluenceStart *= 15;
								iInfluenceStart /= 10;
							}

							iMinorCivDisputeWeight += iInfluenceStart;
						}
						//Tied? Ramp it up!
						else if (iOurInfluence == iTheirInfluence)
						{
							iMinorCivDisputeWeight += iOurInfluence;
						}
					}
					else
					{
						//Add in our influence.
						iMinorCivDisputeWeight += GetNumTimesTheyLoweredOurInfluence(ePlayer) * 20;
					}
				}
#endif
			}

			// Now see what our new Dispute Level should be
			if(iMinorCivDisputeWeight >= /*700*/ GC.getMINOR_CIV_DISPUTE_FIERCE_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_FIERCE;
			else if(iMinorCivDisputeWeight >= /*400*/ GC.getMINOR_CIV_DISPUTE_STRONG_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_STRONG;
			else if(iMinorCivDisputeWeight >= /*200*/ GC.getMINOR_CIV_DISPUTE_WEAK_THRESHOLD())
				eDisputeLevel = DISPUTE_LEVEL_WEAK;

			// Actually set the Level
			SetMinorCivDisputeLevel(ePlayer, eDisputeLevel);
		}
	}
}

/// How many World Wonders has ePlayer beaten us to?
int CvDiplomacyAI::GetNumWondersBeatenTo(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiNumWondersBeatenTo[ePlayer];
}

/// Sets how many World Wonders ePlayer has beaten us to
void CvDiplomacyAI::SetNumWondersBeatenTo(PlayerTypes ePlayer, int iNewValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iNewValue >= 0, "DIPLOMACY_AI: Setting NumWondersBeatenTo to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiNumWondersBeatenTo[ePlayer] = iNewValue;
}

/// Changes how many World Wonders ePlayer has beaten us to
void CvDiplomacyAI::ChangeNumWondersBeatenTo(PlayerTypes ePlayer, int iChange)
{
	SetNumWondersBeatenTo(ePlayer, GetNumWondersBeatenTo(ePlayer) + iChange);
}

/// How much damage have we taken in a war against a particular player?
WarDamageLevelTypes CvDiplomacyAI::GetWarDamageLevel(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarDamageLevelTypes) m_paeWarDamageLevel[ePlayer];
}

/// Sets how much damage we have taken in a war against a particular player
void CvDiplomacyAI::SetWarDamageLevel(PlayerTypes ePlayer, WarDamageLevelTypes eDamageLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDamageLevel >= 0, "DIPLOMACY_AI: Invalid WarDamageLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDamageLevel < NUM_WAR_DAMAGE_LEVEL_TYPES, "DIPLOMACY_AI: Invalid WarDamageLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paeWarDamageLevel[ePlayer] = eDamageLevel;
}

/// Updates how much damage we have taken in wars against all players
void CvDiplomacyAI::DoUpdateWarDamageLevel()
{
	PlayerTypes eLoopPlayer;

	WarDamageLevelTypes eWarDamageLevel;

	int iValueLost;
	int iCurrentValue;
	int iValueLostRatio = 0;

	CvCity* pLoopCity;
	CvUnit* pLoopUnit;
	int iValueLoop;

	// Calculate the value of what we have currently
	// This is invariant so we will just do it once
	iCurrentValue = 0;

	int iTypicalPower = m_pPlayer->GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_LAND);
	// City value
	for(pLoopCity = GetPlayer()->firstCity(&iValueLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iValueLoop))
	{
		iCurrentValue += (pLoopCity->getPopulation() * /*150*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
		if (pLoopCity->IsOriginalCapital()) // anybody's
		{
			iCurrentValue *= 3;
			iCurrentValue /= 2;
		}
	}

	// Unit value
	for(pLoopUnit = GetPlayer()->firstUnit(&iValueLoop); pLoopUnit != NULL; pLoopUnit = GetPlayer()->nextUnit(&iValueLoop))
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
		if(pkUnitInfo)
		{
			int iUnitValue = pkUnitInfo->GetPower();
			if(iTypicalPower > 0)
			{
				iUnitValue = iUnitValue* /*100*/ GC.getDEFAULT_WAR_VALUE_FOR_UNIT() / iTypicalPower;
			}
			else
			{
				iUnitValue = /*100*/ GC.getDEFAULT_WAR_VALUE_FOR_UNIT();
			}
			iCurrentValue += iUnitValue;
		}
	}

	// Loop through all (known) Players
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			eWarDamageLevel = WAR_DAMAGE_LEVEL_NONE;

			iValueLost = GetWarValueLost(eLoopPlayer);

			if(iValueLost > 0)
			{
				// Total original value is the current value plus the amount lost, so compute the percentage on that
				if(iCurrentValue > 0)
					iValueLostRatio = iValueLost * 100 / (iCurrentValue + iValueLost);
				else
					iValueLostRatio = iValueLost;
				if(iValueLostRatio >= /*67*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED())
					eWarDamageLevel = WAR_DAMAGE_LEVEL_CRIPPLED;
				else if(iValueLostRatio >= /*50*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS())
					eWarDamageLevel = WAR_DAMAGE_LEVEL_SERIOUS;
				else if(iValueLostRatio >= /*25*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MAJOR())
					eWarDamageLevel = WAR_DAMAGE_LEVEL_MAJOR;
				else if(iValueLostRatio >= /*10*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MINOR())
					eWarDamageLevel = WAR_DAMAGE_LEVEL_MINOR;
			}
#if defined(MOD_BALANCE_CORE)
			SetWarDamageValue(eLoopPlayer, iValueLostRatio);
#endif

			SetWarDamageLevel(eLoopPlayer, eWarDamageLevel);
		}
	}
}

#if defined(MOD_BALANCE_CORE)
/// How much damage have we taken in a war against a particular player?
int CvDiplomacyAI::GetWarDamageValue(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiWarDamageValue[ePlayer];
}

/// Sets how much damage we have taken in a war against a particular player
void CvDiplomacyAI::SetWarDamageValue(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiWarDamageValue[ePlayer] = iValue;
}

#endif

/// Every turn we're at peace war damage goes down a bit
void CvDiplomacyAI::DoWarDamageDecay()
{
	if((int)m_eTargetPlayer >= (int)DIPLO_FIRST_PLAYER)
		return;

	int iValue;

	TeamTypes eLoopThirdTeam;
	PlayerTypes eLoopThirdPlayer;
	int iThirdPlayerLoop;

	// Loop through all (known) Players
	TeamTypes eLoopTeam;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

		if(IsPlayerValid(eLoopPlayer, /*bMyTeamIsValid*/ true))
		{
			// Update war damage we've suffered
			if(!IsAtWar(eLoopPlayer))
			{
				iValue = GetWarValueLost(eLoopPlayer);

				if(iValue > 0)
				{
					// Go down by 1/20th every turn at peace
#if defined(MOD_BALANCE_CORE)
					// 1/10th instead.
					iValue /= 10;
#else
					iValue /= 20;
#endif

					// Make sure it's changing by at least 1
					iValue = max(1, iValue);

					ChangeWarValueLost(eLoopPlayer, -iValue);
				}
			}

			// Update war damage other players have suffered from our viewpoint
			for(iThirdPlayerLoop = 0; iThirdPlayerLoop < MAX_CIV_PLAYERS; iThirdPlayerLoop++)
			{
				eLoopThirdPlayer = (PlayerTypes) iThirdPlayerLoop;
				eLoopThirdTeam = GET_PLAYER(eLoopThirdPlayer).getTeam();

				// These two players not at war?
				if(!GET_TEAM(eLoopThirdTeam).isAtWar(eLoopTeam))
				{
					iValue = GetOtherPlayerWarValueLost(eLoopPlayer, eLoopThirdPlayer);

					if(iValue > 0)
					{
						// Go down by 1/20th every turn at peace
#if defined(MOD_BALANCE_CORE)
						// 1/10th instead.
						iValue /= 10;
#else
						iValue /= 20;
#endif

						// Make sure it's changing by at least 1
						iValue = max(1, iValue);

						ChangeOtherPlayerWarValueLost(eLoopPlayer, eLoopThirdPlayer, -iValue);
					}
				}
#if defined(MOD_BALANCE_CORE)
				// Update war damage we've suffered while at war (slower, but necessary to bring chance of white peace)
				else
				{
					iValue = GetOtherPlayerWarValueLost(eLoopPlayer, eLoopThirdPlayer);

					if(iValue > 0)
					{
						// Go down by 1/50 every turn at war
						iValue /= 50;

						// Make sure it's changing by at least 1
						iValue = max(1, iValue);

						ChangeOtherPlayerWarValueLost(eLoopPlayer, eLoopThirdPlayer, -iValue);
					}
				}
#endif

			}
		}
	}
}

// What is the value of stuff (Units & Cities) lost in a war against a particular player?
int CvDiplomacyAI::GetWarValueLost(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiWarValueLost[ePlayer];
}

// Sets the value of stuff (Units & Cities) lost in a war against a particular player
void CvDiplomacyAI::SetWarValueLost(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting WarValueLost to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiWarValueLost[ePlayer] = iValue;

	// Reset War Damage
	if(iValue == 0)
		m_paeWarDamageLevel[ePlayer] = WAR_DAMAGE_LEVEL_NONE;
}

// Changes the value of stuff (Units & Cities) lost in a war against a particular player
void CvDiplomacyAI::ChangeWarValueLost(PlayerTypes ePlayer, int iChange)
{
	SetWarValueLost(ePlayer, GetWarValueLost(ePlayer) + iChange);

	if(iChange > 0)
	{
		// Loop through all the other major civs and see if any of them are fighting us.  If so, they are happy this player damaged us.
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(eLoopPlayer != ePlayer && eLoopPlayer != m_pPlayer->GetID() && IsPlayerValid(eLoopPlayer))
			{
				// Are they at war with me too?
				CvPlayer& kOtherPlayer = GET_PLAYER(eLoopPlayer);
				if(IsAtWar(eLoopPlayer))
				{
					kOtherPlayer.GetDiplomacyAI()->ChangeCommonFoeValue(ePlayer, iChange);
				}
			}
		}
	}
}


/// How much damage do we think players we know have suffered in war against other players?
WarDamageLevelTypes CvDiplomacyAI::GetOtherPlayerWarDamageLevel(PlayerTypes ePlayer, PlayerTypes eLostToPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (WarDamageLevelTypes) m_ppaaeOtherPlayerWarDamageLevel[ePlayer][eLostToPlayer];
}

/// Sets how much damage we think players we know have suffered in war against other players
void CvDiplomacyAI::SetOtherPlayerWarDamageLevel(PlayerTypes ePlayer, PlayerTypes eLostToPlayer, WarDamageLevelTypes eDamageLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDamageLevel >= 0, "DIPLOMACY_AI: Invalid WarDamageLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDamageLevel < NUM_WAR_DAMAGE_LEVEL_TYPES, "DIPLOMACY_AI: Invalid WarDamageLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaeOtherPlayerWarDamageLevel[ePlayer][eLostToPlayer] = eDamageLevel;
}

/// Updates what our guess is as to the amount of war damage a player has suffered to another player
void CvDiplomacyAI::DoUpdateOtherPlayerWarDamageLevel()
{
	PlayerTypes eLoopOtherPlayer;
	int iOtherPlayerLoop;

	int iValueLost;
	int iCurrentValue;
	int iValueLostRatio;

	CvCity* pLoopCity;
	int iValueLoop;

	WarDamageLevelTypes eWarDamageLevel;

	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			// Now loop through every player HE knows
			for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
			{
				eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

				// Don't compare a player to himself
				if(eLoopPlayer != eLoopOtherPlayer)
				{
					// Do both we and the guy we're looking at know the third guy?
					if(IsPlayerValid(eLoopOtherPlayer) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
					{
						// At War?
						if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(GET_PLAYER(eLoopOtherPlayer).getTeam()))
						{
							iValueLost = GetOtherPlayerWarValueLost(eLoopPlayer, eLoopOtherPlayer);

							// Calculate the value of what we have currently
							iCurrentValue = 0;

							// City value
							if(GET_PLAYER(eLoopPlayer).getNumCities() > 0)
							{
								for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iValueLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iValueLoop))
								{
									iCurrentValue += (pLoopCity->getPopulation() * /*150*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
									if (pLoopCity->IsOriginalCapital()) // anybody's
									{
										iCurrentValue *= 3;
										iCurrentValue /= 2;
									}
								}
							}

							// Prevents divide by 0
							iCurrentValue = max(1,iCurrentValue);

							iValueLostRatio = iValueLost * 100 / iCurrentValue;

							if(iValueLostRatio >= /*50*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED())
								eWarDamageLevel = WAR_DAMAGE_LEVEL_CRIPPLED;
							else if(iValueLostRatio >= /*35*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS())
								eWarDamageLevel = WAR_DAMAGE_LEVEL_SERIOUS;
							else if(iValueLostRatio >= /*20*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MAJOR())
								eWarDamageLevel = WAR_DAMAGE_LEVEL_MAJOR;
							else if(iValueLostRatio >= /*10*/ GC.getWAR_DAMAGE_LEVEL_THRESHOLD_MINOR())
								eWarDamageLevel = WAR_DAMAGE_LEVEL_MINOR;
							else
								eWarDamageLevel = WAR_DAMAGE_LEVEL_NONE;
						}

						else
							eWarDamageLevel = WAR_DAMAGE_LEVEL_NONE;

						SetOtherPlayerWarDamageLevel(eLoopPlayer, eLoopOtherPlayer, eWarDamageLevel);
					}
				}
			}
		}
	}
}

/// What is the value of stuff (Units & Cities) we estimate a player has lost in a war against another player?
int CvDiplomacyAI::GetOtherPlayerWarValueLost(PlayerTypes ePlayer, PlayerTypes eLostToPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_ppaaiOtherPlayerWarValueLost[ePlayer][eLostToPlayer];
}

/// Sets the value of stuff (Units & Cities) we estimate a player has lost in a war against another player
void CvDiplomacyAI::SetOtherPlayerWarValueLost(PlayerTypes ePlayer, PlayerTypes eLostToPlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting OtherPlayerWarValueLost to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaiOtherPlayerWarValueLost[ePlayer][eLostToPlayer] = iValue;

	// Reset War Damage
	if(iValue == 0)
		m_ppaaeOtherPlayerWarDamageLevel[ePlayer][eLostToPlayer] = WAR_DAMAGE_LEVEL_NONE;
}

/// Changes the value of stuff (Units & Cities) we estimate a player has lost in a war against another player
void CvDiplomacyAI::ChangeOtherPlayerWarValueLost(PlayerTypes ePlayer, PlayerTypes eLostToPlayer, int iChange)
{
	SetOtherPlayerWarValueLost(ePlayer, eLostToPlayer, GetOtherPlayerWarValueLost(ePlayer, eLostToPlayer) + iChange);
}

/// Cache the current war value other players have lost in a separate place, so we can track when it changes value
void CvDiplomacyAI::CacheOtherPlayerWarValuesLost()
{
	for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayer;
		for(int iLostToPlayer = 0; iLostToPlayer < MAX_CIV_PLAYERS; iLostToPlayer++)
		{
			PlayerTypes eLostToPlayer = (PlayerTypes) iLostToPlayer;
			SetOtherPlayerLastRoundWarValueLost(ePlayer, eLostToPlayer, GetOtherPlayerWarValueLost(ePlayer, eLostToPlayer));
		}
	}
}

/// Old estimate of value ePlayer has lost in war with eLostToPlayer (before this turn)
int CvDiplomacyAI::GetOtherPlayerLastRoundWarValueLost(PlayerTypes ePlayer, PlayerTypes eLostToPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_ppaaiOtherPlayerLastRoundWarValueLost[ePlayer][eLostToPlayer];
}

/// Sets the old estimate of value ePlayer has lost in war with eLostToPlayer (before this turn)
void CvDiplomacyAI::SetOtherPlayerLastRoundWarValueLost(PlayerTypes ePlayer, PlayerTypes eLostToPlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eLostToPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eLostToPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting OtherPlayerLastRoundWarValueLost to a negative value.  Please send Anton your save file and version.");
	m_ppaaiOtherPlayerLastRoundWarValueLost[ePlayer][eLostToPlayer] = iValue;
}

/// How aggressively are this player's military Units positioned in relation to us?
AggressivePostureTypes CvDiplomacyAI::GetMilitaryAggressivePosture(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paeMilitaryAggressivePosture[ePlayer];
}

/// Sets how aggressively this player has stationed his military Units in relation to us
void CvDiplomacyAI::SetMilitaryAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture >= 0, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture < NUM_AGGRESSIVE_POSTURE_TYPES, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeMilitaryAggressivePosture[ePlayer] = ePosture;
}

/// How aggressively were this player's military Units positioned in relation to us last turn?
AggressivePostureTypes CvDiplomacyAI::GetLastTurnMilitaryAggressivePosture(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paeLastTurnMilitaryAggressivePosture[ePlayer];
}

/// Sets how aggressively this player had stationed his military Units in relation to us last turn
void CvDiplomacyAI::SetLastTurnMilitaryAggressivePosture(PlayerTypes ePlayer, AggressivePostureTypes ePosture)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture >= 0, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePosture < NUM_AGGRESSIVE_POSTURE_TYPES, "DIPLOMACY_AI: Invalid AggressivePostureType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeLastTurnMilitaryAggressivePosture[ePlayer] = ePosture;
}

/// Updates how aggressively all players' military Units are positioned in relation to us
void CvDiplomacyAI::DoUpdateMilitaryAggressivePostures()
{
	// Loop through all (known) Players
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		DoUpdateOnePlayerMilitaryAggressivePosture(eLoopPlayer);
	}
}

/// Updates how aggressively a player's military Units are positioned in relation to us
void CvDiplomacyAI::DoUpdateOnePlayerMilitaryAggressivePosture(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (!IsPlayerValid(ePlayer))
		return;

	// We're allowing them Open Borders? We shouldn't care.
	if (GET_TEAM(GetPlayer()->getTeam()).IsAllowsOpenBordersToTeam(GET_PLAYER(ePlayer).getTeam()))
	{
		SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		return;
	}

	// We're working together, so don't worry about it
	if (IsDoFAccepted(ePlayer))
	{
		SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		return;
	}
	
	// We have a Defensive Pact, so don't worry about it
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GetTeam()))
	{
		SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		return;
	}

	// They resurrected us, so don't worry about it
	if (WasResurrectedBy(ePlayer))
	{
		SetMilitaryAggressivePosture(ePlayer, AGGRESSIVE_POSTURE_NONE);
		return;
	}
	
	bool bIgnoreOtherWars = false;
	
	// For humans (Move Troops request), ignore other wars the AI may be waging
	if (GetPlayer()->isHuman())
		bIgnoreOtherWars = true;

	AggressivePostureTypes eAggressivePosture;
	AggressivePostureTypes eLastTurnAggressivePosture;

	int iUnitValueOnMyHomeFront;
	int iValueToAdd;
	bool bIsAtWarWithSomeone;

	CvUnit* pLoopUnit;
	int iUnitLoop;

	int iOtherPlayerLoop;
	PlayerTypes eLoopOtherPlayer;

	// Keep a record of last turn
	eLastTurnAggressivePosture = GetMilitaryAggressivePosture(ePlayer);
	if(eLastTurnAggressivePosture != NO_AGGRESSIVE_POSTURE_TYPE)
		SetLastTurnMilitaryAggressivePosture(ePlayer, eLastTurnAggressivePosture);

	iUnitValueOnMyHomeFront = 0;
	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
	CvTeam& kTeam = GET_TEAM(kPlayer.getTeam());
	bIsAtWarWithSomeone = (kTeam.getAtWarCount(false) > 0);

	TeamTypes eOurTeam = GetTeam();
	PlayerTypes eOurPlayerID = GetPlayer()->GetID();

	// Loop through the other guy's units
	for(pLoopUnit = kPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iUnitLoop))
	{
		// Don't be scared of noncombat Units!
		if (pLoopUnit->IsCombatUnit() && pLoopUnit->getUnitInfo().GetDefaultUnitAIType() != UNITAI_EXPLORE)
		{
			CvPlot* pUnitPlot = pLoopUnit->plot();
			// Can we actually see this Unit's Plot?  No cheating!
			if(pUnitPlot->isVisible(eOurTeam))
			{
				// On our home front
				if(pUnitPlot->IsHomeFrontForPlayer(eOurPlayerID))
				{
					// At war with someone?  Because if this Unit is in the vicinity of another player he's already at war with, don't count this Unit as aggressive
					if(bIsAtWarWithSomeone && !bIgnoreOtherWars)
					{
						// Loop through all players...
						for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_CIV_PLAYERS; iOtherPlayerLoop++)
						{
							eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

							// Don't look at us or see if this player is at war with himself
							if(eLoopOtherPlayer != ePlayer && eLoopOtherPlayer != eOurPlayerID)
							{
								// At war with this player?
								if(kTeam.isAtWar(GET_PLAYER(eLoopOtherPlayer).getTeam()))
								{
									if(GET_PLAYER(eLoopOtherPlayer).isAlive())
									{
										if(pUnitPlot->IsHomeFrontForPlayer(eLoopOtherPlayer))
										{
											continue;
										}
									}
								}
							}
						}
					}

					iValueToAdd = 10;

					// If the Unit is in the other player's territory, halve its "aggression value," since he may just be defending himself
					if(pLoopUnit->plot()->isOwned())
					{
						if(pLoopUnit->plot()->getOwner() == ePlayer)
							iValueToAdd /= 2;
					}

					// Maybe look at Unit Power here instead?
					iUnitValueOnMyHomeFront += iValueToAdd;
				}
			}
		}
	}

	// So how threatening is he being?
	if(iUnitValueOnMyHomeFront >= /*80*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_INCREDIBLE())
		eAggressivePosture = AGGRESSIVE_POSTURE_INCREDIBLE;
	else if(iUnitValueOnMyHomeFront >= /*50*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_HIGH())
		eAggressivePosture = AGGRESSIVE_POSTURE_HIGH;
	else if(iUnitValueOnMyHomeFront >= /*30*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_MEDIUM())
		eAggressivePosture = AGGRESSIVE_POSTURE_MEDIUM;
	else if(iUnitValueOnMyHomeFront >= /*10*/ GC.getMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_LOW())
		eAggressivePosture = AGGRESSIVE_POSTURE_LOW;
	else
		eAggressivePosture = AGGRESSIVE_POSTURE_NONE;

	SetMilitaryAggressivePosture(ePlayer, eAggressivePosture);
}

/// Advanced Diplo AI Aggression Options (defined in CoreChanges.sql)

/// Disables AI war declarations
bool CvDiplomacyAI::IsWarDisallowedGlobal() const
{
	if (GC.getDIPLO_AI_WAR_DISALLOWED_GLOBAL() == 1)
	{
		return true;
	}
	
	return false;
}

/// Disables AI initiating wars involving humans
bool CvDiplomacyAI::IsWarDisallowedHuman() const
{
	if (GC.getDIPLO_AI_WAR_DISALLOWED_HUMAN() == 1)
	{
		return true;
	}
	
	return false;
}

/// Would declaring war on ePlayer be in violation of these game options?
bool CvDiplomacyAI::IsWarDisallowed(PlayerTypes ePlayer) const
{
	if (GetPlayer()->isHuman())
	{
		return false;
	}
	else if (GET_PLAYER(ePlayer).isBarbarian())
	{
		return false;
	}
	else if (IsWarDisallowedGlobal())
	{
		return true;
	}
	else if (IsWarDisallowedHuman())
	{
		if (GET_PLAYER(ePlayer).isHuman())
			return true;
		
		if (GetPlayer()->IsAITeammateOfHuman())
			return true;
		
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			if (GET_TEAM(GetPlayer()->getTeam()).GetNumVassals() > 0)
			{
				PlayerTypes eVassal;
				for(int iVassalLoop = 0; iVassalLoop < MAX_MAJOR_CIVS; iVassalLoop++)
				{
					eVassal = (PlayerTypes) iVassalLoop;
					if (GET_TEAM(GET_PLAYER(eVassal).getTeam()).GetMaster() == m_pPlayer->getTeam())
					{
						if (GET_PLAYER(eVassal).isHuman())
						{
							return true;
						}
					}
				}
			}
		}
#endif
		
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if (GET_PLAYER(eLoopPlayer).isHuman() && eLoopPlayer != ePlayer)
			{
				// Teammate?
				if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
				{
					return true;
				}
				// Defensive Pact?
				else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
				{
					return true;
				}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				else if (MOD_DIPLOMACY_CIV4_FEATURES)
				{
					// Master/vassal?
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
					{
						return true;
					}
				}
#endif	
			}
		}
		
	}
	
	return false;
}

/// Disables victory competition (Victory Dispute/Victory Block/Is Close To X Victory penalties, etc.)
bool CvDiplomacyAI::IsNoVictoryCompetition() const
{
	if (GC.getDIPLO_AI_NO_VICTORY_COMPETITION() == 1)
	{
		return true;
	}
	
	return false;
}


// ************************************
// Personality Members
// ************************************

/// How much is this player annoyed when he thinks another player is going for the same victory type?
int CvDiplomacyAI::GetVictoryCompetitiveness() const
{
	return m_iVictoryCompetitiveness;
}

/// How annoyed does this player get when beaten to a World Wonder?
int CvDiplomacyAI::GetWonderCompetitiveness() const
{
	return m_iWonderCompetitiveness;
}

/// How annoyed does this player get when another player is befriending "their" minor civs?
int CvDiplomacyAI::GetMinorCivCompetitiveness() const
{
	return m_iMinorCivCompetitiveness;
}

/// How likely is this player to go for World Conquest?
int CvDiplomacyAI::GetBoldness() const
{
	return m_iBoldness;
}

/// How much does this leader want to maintain a balance of power in the world?
int CvDiplomacyAI::GetDiploBalance() const
{
	return m_iDiploBalance;
}

/// How much does this AI get angry when someone's being a warmonger?
int CvDiplomacyAI::GetWarmongerHate() const
{
	return m_iWarmongerHate;
}

/// How much is this AI willing to work with someone AGAINST another player?
int CvDiplomacyAI::GetDenounceWillingness() const
{
	return m_iDenounceWillingness;
}

/// How much is this AI willing to work WITH someone?
int CvDiplomacyAI::GetDoFWillingness() const
{
	return m_iDoFWillingness;
}

/// How willing is this AI to backstab its friends?
int CvDiplomacyAI::GetLoyalty() const
{
	return m_iLoyalty;
}

/// How much does this AI want the support of its friends in rough times?
int CvDiplomacyAI::GetNeediness() const
{
	return m_iNeediness;
}

/// How willing is this AI to overlook transgressions between friends?
int CvDiplomacyAI::GetForgiveness() const
{
	return m_iForgiveness;
}

/// How much does this AI like to pop up and talk?
int CvDiplomacyAI::GetChattiness() const
{
	return m_iChattiness;
}

/// How much does this AI like to talk smack?
int CvDiplomacyAI::GetMeanness() const
{
	return m_iMeanness;
}

/// What is our bias towards a particular Major Civ Approach?
int CvDiplomacyAI::GetPersonalityMajorCivApproachBias(MajorCivApproachTypes eApproach) const
{
	CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Trying to queury invalid Major Approach for personality bias.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach < NUM_MAJOR_CIV_APPROACHES, "DIPLOMACY_AI: Trying to queury invalid Major Approach for personality bias.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPersonalityMajorCivApproachBiases[eApproach];
}

/// What is our bias towards a particular Minor Civ Approach?
int CvDiplomacyAI::GetPersonalityMinorCivApproachBias(MinorCivApproachTypes eApproach) const
{
	CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Trying to queury invalid Minor Approach for personality bias.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eApproach < NUM_MINOR_CIV_APPROACHES, "DIPLOMACY_AI: Trying to queury invalid Minor Approach for personality bias.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPersonalityMinorCivApproachBiases[eApproach];
}



// ************************************
// Evaluation of Other Players' Tendencies
// ************************************



/// ePlayer made peace with someone, so figure out what that means
void CvDiplomacyAI::DoWeMadePeaceWithSomeone(TeamTypes eOtherTeam)
{
	CvAssertMsg(eOtherTeam >= 0, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PlayerTypes eThirdPlayer;
	int iThirdPlayerLoop;

	PlayerTypes ePeacePlayer;
	for(int iPeacePlayerLoop = 0; iPeacePlayerLoop < MAX_CIV_PLAYERS; iPeacePlayerLoop++)
	{
		ePeacePlayer = (PlayerTypes) iPeacePlayerLoop;

		if(GET_PLAYER(ePeacePlayer).getTeam() == eOtherTeam)
		{
			// In case we had an ongoing operation, kill it
			SetArmyInPlaceForAttack(ePeacePlayer, false);
#if defined(MOD_BALANCE_CORE_DEALS)
			SetWantsSneakAttack(ePeacePlayer, false);
#endif

			if(!GET_PLAYER(ePeacePlayer).isMinorCiv())
			{
				// If we made peace, reset coop war and working against status
				for(iThirdPlayerLoop = 0; iThirdPlayerLoop < MAX_MAJOR_CIVS; iThirdPlayerLoop++)
				{
					eThirdPlayer = (PlayerTypes) iThirdPlayerLoop;

					SetCoopWarAcceptedState(eThirdPlayer, ePeacePlayer, NO_COOP_WAR_STATE);
					//SetWorkingAgainstPlayerAccepted(eThirdPlayer, ePeacePlayer, false);
					//SetWorkingAgainstPlayerCounter(eThirdPlayer, ePeacePlayer, -666);
				}

				// If we made peace with someone, set our Approach with them to Neutral to bias against another war
				if(GetMajorCivApproach(ePeacePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR)
					SetMajorCivApproach(ePeacePlayer, MAJOR_CIV_APPROACH_NEUTRAL);
			}
			else
			{
				// Reset flags for taunt messages we sent to other civs about attacking this minor
				ResetSentAttackProtectedMinorTaunts(ePeacePlayer);
			}
		}
	}
}

/// ePlayer declared war on someone, so figure out what that means
#if defined(MOD_BALANCE_CORE)
void CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone(PlayerTypes ePlayer, TeamTypes eOtherTeam, bool bDefensivePact)
#else
void CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone(PlayerTypes ePlayer, TeamTypes eOtherTeam)
#endif
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherTeam >= 0, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherTeam <= MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Disregard barbarians
	if(GET_PLAYER(ePlayer).isBarbarian() || GET_TEAM(eOtherTeam).isBarbarian())
		return;
	
	PlayerTypes eMyPlayer = GetPlayer()->GetID();
	PlayerTypes eAttackedPlayer;
	PlayerTypes eThirdParty;

	for(int iAttackedPlayerLoop = 0; iAttackedPlayerLoop < MAX_CIV_PLAYERS; iAttackedPlayerLoop++)
	{
		eAttackedPlayer = (PlayerTypes) iAttackedPlayerLoop;

		// This player was attacked by ePlayer
		if(GET_PLAYER(eAttackedPlayer).getTeam() == eOtherTeam)
		{
			// We're on the defending team
			if(eAttackedPlayer == eMyPlayer)
			{
				ChangeNumWarsFought(ePlayer, 1);
				
				// Only stuff for major civs
				if(!GET_PLAYER(ePlayer).isMinorCiv())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumWarsFought(eMyPlayer, 1);
					
					// Change our Approach to War so that it's not inappropriate the next time the turn cycles
					SetMajorCivApproach(ePlayer, MAJOR_CIV_APPROACH_WAR);
					SetWarFaceWithPlayer(ePlayer, WAR_FACE_NEUTRAL);
					
					// WAS working with this player
					if(IsDoFAccepted(ePlayer))
					{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						if(!bDefensivePact)
						{
							SetDoFBroken(ePlayer, true);
							ChangeRecentAssistValue(ePlayer, 300);
#endif
							SetFriendDeclaredWarOnUs(ePlayer, true);
							ChangeDeclaredWarOnFriendValue(ePlayer, GC.getOPINION_WEIGHT_WAR_FRIEND_EACH() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						}
#endif
					}
					
					// Reset DoF values
					SetDoFAccepted(ePlayer, false);
					SetDoFCounter(ePlayer, -1);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, -1);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
					SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(eMyPlayer, DOF_TYPE_UNTRUSTWORTHY);
#endif

					// End all coop war agreements with this player
					for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
					{
						eThirdParty = (PlayerTypes) iThirdPartyLoop;

						// WAS working with the guy we're now at war with against someone else
						//if (IsWorkingAgainstPlayerAccepted(ePlayer, eThirdParty))
						//{
						//	SetWorkingAgainstPlayerAccepted(ePlayer, eThirdParty, false);
						//	SetWorkingAgainstPlayerCounter(ePlayer, eThirdParty, -666);
						//}
						
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						// If they broke a coop war promise, penalize them for it
						if(GetCoopWarAcceptedState(ePlayer, eThirdParty) == COOP_WAR_STATE_SOON && !bDefensivePact)
						{
							SetPlayerBrokenCoopWarPromise(ePlayer, true);
							SetPlayerBackstabCounter(ePlayer, 0);
							ChangeRecentAssistValue(ePlayer, 300);
							ChangeNumTimesCoopWarDenied(ePlayer, 2);
						}
#endif
						// WAS in or planning a coop war with the guy we're now at war with
						if(GetCoopWarAcceptedState(ePlayer, eThirdParty) >= COOP_WAR_STATE_SOON)
						{
							SetCoopWarAcceptedState(ePlayer, eThirdParty, NO_COOP_WAR_STATE);
							SetCoopWarCounter(ePlayer, eThirdParty, -666);
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(eMyPlayer, eThirdParty, NO_COOP_WAR_STATE);
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(eMyPlayer, eThirdParty, -666);
						}
					}
					
					// Reset expansion, border and spy promises for both of us...all is fair in war!
					SetPlayerMadeExpansionPromise(ePlayer, false);
					SetPlayerMadeBorderPromise(ePlayer, false);
					SetPlayerMadeSpyPromise(ePlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeExpansionPromise(eMyPlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeBorderPromise(eMyPlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeSpyPromise(eMyPlayer, false);
					
					// Player broke a promise that he wasn't going to attack us
					if(IsPlayerMadeMilitaryPromise(ePlayer))
					{
						SetPlayerMadeMilitaryPromise(ePlayer, false);
						SetPlayerMilitaryPromiseCounter(ePlayer, -1);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						if (!bDefensivePact)
						{
							SetPlayerBackstabCounter(ePlayer, 0);
#endif
							SetPlayerBrokenMilitaryPromise(ePlayer, true);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						}
#endif
					}
					
					// HAD agreed not to attack each other
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeMilitaryPromise(eMyPlayer, false);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseCounter(eMyPlayer, -1);
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
					if (MOD_DIPLOMACY_CIV4_FEATURES) {
						if(IsPlayerMoveTroopsRequestAccepted(ePlayer))
						{
							SetPlayerMoveTroopsRequestAccepted(ePlayer, false);
							SetPlayerMoveTroopsRequestCounter(ePlayer, -666);
						}
						if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerMoveTroopsRequestAccepted(eMyPlayer))
						{
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMoveTroopsRequestAccepted(eMyPlayer, false);
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMoveTroopsRequestCounter(eMyPlayer, -666);
						}
					}
#endif
					// HAD agreed not to settle near each other
					if(IsPlayerNoSettleRequestAccepted(ePlayer))
					{
						SetPlayerNoSettleRequestAccepted(ePlayer, false);
					}
					if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerNoSettleRequestAccepted(eMyPlayer))
					{
						GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerNoSettleRequestAccepted(eMyPlayer, false);
					}
					
					// HAD agreed not to spy on each other
					if(IsPlayerStopSpyingRequestAccepted(ePlayer))
					{
						SetPlayerStopSpyingRequestAccepted(ePlayer, false);
					}
					if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerStopSpyingRequestAccepted(eMyPlayer))
					{
						GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerStopSpyingRequestAccepted(eMyPlayer, false);
					}
					
					// We're no longer trade partners
					ChangeRecentTradeValue(ePlayer, -GetRecentTradeValue(ePlayer));
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentTradeValue(eMyPlayer, -GetRecentTradeValue(eMyPlayer));
					
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
					if (!bDefensivePact)
					{
#endif
						// Forget any of that liberation crud!
						ChangeNumCitiesLiberated(ePlayer, -GetNumCitiesLiberated(ePlayer));
						
						// Forget civilians returned, landmarks built, and intrigue shared so they don't affect relations any more
						ChangeNumCiviliansReturnedToMe(ePlayer, -GetNumCiviliansReturnedToMe(ePlayer));
						ChangeNumLandmarksBuiltForMe(ePlayer, -GetNumLandmarksBuiltForMe(ePlayer));
						ChangeNumTimesIntrigueSharedBy(ePlayer, -GetNumTimesIntrigueSharedBy(ePlayer));
						
						// Clear positive diplomatic values					
						ChangeCommonFoeValue(ePlayer, -GetCommonFoeValue(ePlayer));
						if (GetRecentAssistValue(ePlayer) < 0)
							ChangeRecentAssistValue(ePlayer, -GetRecentAssistValue(ePlayer));
						
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
					}
#endif
				}
			}
			
			// If it was someone else, see what it means
			else if(IsPlayerValid(eAttackedPlayer))
			{
				if(GET_PLAYER(eAttackedPlayer).isMinorCiv())
				{
					// Did they attack a Minor we're protecting?
					if(GET_PLAYER(eAttackedPlayer).GetMinorCivAI()->IsProtectedByMajor(eMyPlayer))
					{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						if(!bDefensivePact)
						{
#endif
							SetOtherPlayerTurnsSinceAttackedProtectedMinor(ePlayer, 0);
							SetOtherPlayerProtectedMinorAttacked(ePlayer, eAttackedPlayer);
							ChangeOtherPlayerNumProtectedMinorsAttacked(ePlayer, 1);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
						}
#endif
					}
				}
			}
		}
	}
}

/// ePlayer killed eDeadPlayer, so figure out what that means
void CvDiplomacyAI::DoPlayerKilledSomeone(PlayerTypes ePlayer, PlayerTypes eDeadPlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeadPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeadPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(IsPlayerValid(ePlayer))
	{
		// Minor Civ
		if(GET_PLAYER(eDeadPlayer).isMinorCiv())
		{
			ChangeOtherPlayerNumMinorsConquered(ePlayer, 1);

			// Did they kill a Minor we're protecting?
			if(GET_PLAYER(eDeadPlayer).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
			{
				SetOtherPlayerTurnsSinceKilledProtectedMinor(ePlayer, 0);
				SetOtherPlayerProtectedMinorKilled(ePlayer, eDeadPlayer);
				ChangeOtherPlayerNumProtectedMinorsKilled(ePlayer, 1);

				// Player broke a promise that he wasn't going to kill the Minor
				if(IsPlayerMadeAttackCityStatePromise(ePlayer))
#if defined(MOD_BALANCE_CORE)
				{
					SetPlayerBackstabCounter(ePlayer, 0);
#endif
					SetPlayerBrokenAttackCityStatePromise(ePlayer, true);
#if defined(MOD_BALANCE_CORE)
				}
#endif
			}
		}
		// Major Civ
		else
			ChangeOtherPlayerNumMajorsConquered(ePlayer, 1);
	}
}

/// ePlayer bullied eOtherPlayer (minor civ), so figure out what that means
void CvDiplomacyAI::DoPlayerBulliedSomeone(PlayerTypes ePlayer, PlayerTypes eOtherPlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// The bully was someone else
	if(IsPlayerValid(ePlayer) && ePlayer != GetPlayer()->GetID())
	{
		if(GET_PLAYER(eOtherPlayer).isMinorCiv())
		{
			// Did they bully a Minor we're protecting?
			if(GET_PLAYER(eOtherPlayer).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
			{				
				ChangeOtherPlayerNumProtectedMinorsBullied(ePlayer, 1);
			}
		}
	}
}

/// Someone met a new player
void CvDiplomacyAI::DoPlayerMetSomeone(PlayerTypes ePlayer, PlayerTypes eOtherPlayer)
{
	// Have to have met both players (since this function is called upon EVERY contact)
	if(IsPlayerValid(ePlayer) && IsPlayerValid(eOtherPlayer))
	{
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// Catch up on Public Declarations
			PublicDeclarationTypes eDeclaration;
			int iData1;
			int iData2;
			bool bActive;

			for(int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
			{
				// Did ePlayer just meet the person this declaration is about?
				if(GetDeclarationLogMustHaveMetPlayerForIndex(iLoop) == eOtherPlayer)
				{
					eDeclaration = GetDeclarationLogTypeForIndex(iLoop);

					// Does this entry in the log exist?
					if(eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
					{
						bActive = IsDeclarationLogForIndexActive(iLoop);

						// Is this still an active declaration?
						if(bActive)
						{
							iData1 = GetDeclarationLogData1ForIndex(iLoop);
							iData2 = GetDeclarationLogData2ForIndex(iLoop);

							DoMakePublicDeclaration(eDeclaration, iData1, iData2, eOtherPlayer, ePlayer);
						}
					}
				}
			}
		}
	}
}

/// How many turns has it been since ePlayer attacked a Minor we were protecting?
int CvDiplomacyAI::GetTurnsSincePlayerAttackedProtectedMinor(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(GetOtherPlayerProtectedMinorAttacked(ePlayer) == NO_PLAYER)
		return -1;

	return m_paiOtherPlayerTurnsSinceAttackedProtectedMinor[ePlayer];
}

/// Sets when the last time ePlayer attacked a Minor we were protecting was
void CvDiplomacyAI::SetOtherPlayerTurnsSinceAttackedProtectedMinor(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting OtherPlayerTurnsSinceAttackedProtectedMinor to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerTurnsSinceAttackedProtectedMinor[ePlayer] = iValue;
}

/// Changes when the last time ePlayer attacked a Minor we were protecting was
void CvDiplomacyAI::ChangeOtherPlayerTurnsSinceAttackedProtectedMinor(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerTurnsSinceAttackedProtectedMinor(ePlayer, GetTurnsSincePlayerAttackedProtectedMinor(ePlayer) + iChange);
}

/// Who was the last Minor ePlayer attacked that we were protecting?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorAttacked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (PlayerTypes) m_paiOtherPlayerProtectedMinorAttacked[ePlayer];
}

/// Sets who the last Minor that ePlayer attacked that we were protecting is
void CvDiplomacyAI::SetOtherPlayerProtectedMinorAttacked(PlayerTypes ePlayer, PlayerTypes eAttackedPlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eAttackedPlayer >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eAttackedPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerProtectedMinorAttacked[ePlayer] = eAttackedPlayer;
}

/// How many protected Minors have we seen this player attack?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumProtectedMinorsAttacked[ePlayer];
}

/// Sets how many protected Minors we have seen this player attack
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of protected Minors to be negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumProtectedMinorsAttacked[ePlayer] = iValue;
}

/// Changes how many protected Minors we have seen this player attack
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsAttacked(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsAttacked(ePlayer, GetOtherPlayerNumProtectedMinorsAttacked(ePlayer) + iChange);
}

/// How many turns has it been since ePlayer killed a Minor we were protecting?
int CvDiplomacyAI::GetTurnsSincePlayerKilledProtectedMinor(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(GetOtherPlayerProtectedMinorKilled(ePlayer) == NO_PLAYER)
		return -1;

	return m_paiOtherPlayerTurnsSinceKilledProtectedMinor[ePlayer];
}

/// Sets when the last time ePlayer killed a Minor we were protecting was
void CvDiplomacyAI::SetOtherPlayerTurnsSinceKilledProtectedMinor(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of turns since protected Minor was killed to be negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerTurnsSinceKilledProtectedMinor[ePlayer] = iValue;
}

/// Changes when the last time ePlayer killed a Minor we were protecting was
void CvDiplomacyAI::ChangeOtherPlayerTurnsSinceKilledProtectedMinor(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerTurnsSinceKilledProtectedMinor(ePlayer, GetTurnsSincePlayerKilledProtectedMinor(ePlayer) + iChange);
}

/// Who was the last Minor ePlayer killed that we were protecting?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorKilled(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (PlayerTypes) m_paiOtherPlayerProtectedMinorKilled[ePlayer];
}

/// Sets who the last Minor that ePlayer killed that we were protecting is
void CvDiplomacyAI::SetOtherPlayerProtectedMinorKilled(PlayerTypes ePlayer, PlayerTypes eKilledPlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eKilledPlayer >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eKilledPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerProtectedMinorKilled[ePlayer] = eKilledPlayer;
}

/// How many protected Minors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumProtectedMinorsKilled[ePlayer];
}

/// Sets how many protected Minors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumProtectedMinorsKilled[ePlayer] = iValue;
}

/// Changes how many protected Minors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsKilled(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsKilled(ePlayer, GetOtherPlayerNumProtectedMinorsKilled(ePlayer) + iChange);
}

/// How many turns has it been since this player bullied a Minor we were protecting?
int CvDiplomacyAI::GetTurnsSincePlayerBulliedProtectedMinor(PlayerTypes eBullyPlayer) const
{
	CvAssertMsg(eBullyPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eBullyPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	PlayerTypes eMostRecentBulliedMinor = GetOtherPlayerProtectedMinorBullied(eBullyPlayer);
	if(eMostRecentBulliedMinor == NO_PLAYER)
		return -1;

	int iMostRecentBullyTurn = GET_PLAYER(eMostRecentBulliedMinor).GetMinorCivAI()->GetTurnLastBulliedByMajor(eBullyPlayer);
	return (GC.getGame().getGameTurn() - iMostRecentBullyTurn);
}

/// Which of our protected Minors has this player most recently bullied?
PlayerTypes CvDiplomacyAI::GetOtherPlayerProtectedMinorBullied(PlayerTypes eBullyPlayer) const
{
	CvAssertMsg(eBullyPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eBullyPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	int iMostRecentBullyTurn = -1;
	PlayerTypes eMostRecentBulliedMinor = NO_PLAYER;

	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if(IsPlayerValid(eMinor))
		{
			if(GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
			{
				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsEverBulliedByMajor(eBullyPlayer))
				{
					int iBullyTurn = GET_PLAYER(eMinor).GetMinorCivAI()->GetTurnLastBulliedByMajor(eBullyPlayer);
					if(iBullyTurn > iMostRecentBullyTurn)
					{
						iMostRecentBullyTurn = iBullyTurn;
						eMostRecentBulliedMinor = eMinor;
					}
				}
			}
		}
	}

	return eMostRecentBulliedMinor;
}

/// How many protected Minors have we seen this Player bully?
int CvDiplomacyAI::GetOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_paiOtherPlayerNumProtectedMinorsBullied[ePlayer];
}

/// Sets how many protected Minors we have seen this Player bully
void CvDiplomacyAI::SetOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of protected Minors to be negative.  Please send Anton your save file and version.");
	m_paiOtherPlayerNumProtectedMinorsBullied[ePlayer] = iValue;
}

/// Changes how many protected Minors we have seen this Player bully
void CvDiplomacyAI::ChangeOtherPlayerNumProtectedMinorsBullied(PlayerTypes ePlayer, int iChange)
{
	SetOtherPlayerNumProtectedMinorsBullied(ePlayer, GetOtherPlayerNumProtectedMinorsBullied(ePlayer) + iChange);
}

/// We bullied or attacked their protected Minor, and they didn't take our side!
bool CvDiplomacyAI::IsOtherPlayerSidedWithProtectedMinor(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	return (GetTurnsSinceOtherPlayerSidedWithProtectedMinor(ePlayer) >= 0); // -1 means it never happened, as defined in Reset()
}

/// How many turns has it been since we bullied or attacked their protected Minor and they didn't take our side?
int CvDiplomacyAI::GetTurnsSinceOtherPlayerSidedWithProtectedMinor(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // -1 means it never happened, as defined in Reset()

	return m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor[ePlayer];
}

/// Sets how many turns it has been since we bullied or attacked their protected Minor and they didn't take our side
void CvDiplomacyAI::SetOtherPlayerTurnsSinceSidedWithProtectedMinor(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	m_paiOtherPlayerTurnsSinceSidedWithTheirProtectedMinor[ePlayer] = iValue;
}

/// Changes how many turns it has been since we bullied or attacked their protected Minor and they didn't take our side
void CvDiplomacyAI::ChangeOtherPlayerTurnsSinceSidedWithProtectedMinor(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	SetOtherPlayerTurnsSinceSidedWithProtectedMinor(ePlayer, GetTurnsSinceOtherPlayerSidedWithProtectedMinor(ePlayer) + iChange);
}

/// How many Minors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumMinorsAttacked[ePlayer];
}

/// Sets how many Minors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of minors attacked to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumMinorsAttacked[ePlayer] = iValue;
}

/// Changes how many Minors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked(PlayerTypes ePlayer, int iChange)
{
	// We don't care if it's us or a teammate
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return;
	
	// Don't apply warmongering if we haven't met the attacker (otherwise that's cheating)
	if(!GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
		return;

	SetOtherPlayerNumMinorsAttacked(ePlayer, GetOtherPlayerNumMinorsAttacked(ePlayer) + iChange);

	int iWarMongerValue = GC.getWARMONGER_THREAT_MINOR_ATTACKED_WEIGHT();
	if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(m_pPlayer->GetID(), ePlayer) || GC.getGame().GetGameLeagues()->IsWorldWar(GetPlayer()->GetID()) > 0)
	{
		iWarMongerValue = GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_WAR();
	}
	else if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(GetPlayer()->GetID()) > 0)
	{
		iWarMongerValue = GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_PEACE();
	}

	iWarMongerValue *= (100 + (GetOtherPlayerNumMinorsAttacked(ePlayer) * 25));
	iWarMongerValue /= 100;

	if (iWarMongerValue <= 0)
		return;

#if defined(MOD_API_EXTENSIONS)
	int iWarmongerModifier = 100;

	// INCREASE if he's big and nasty, less so if he's not.
	switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
	case STRENGTH_POWERFUL:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
		break;
	case STRENGTH_AVERAGE:
	case STRENGTH_STRONG:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();
		break;
	case STRENGTH_WEAK:
	case STRENGTH_POOR:
	case STRENGTH_PATHETIC:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
		break;
	default:
		break;
	}
#endif

	iWarMongerValue *= iWarmongerModifier;
	iWarMongerValue /= 100;
	
	iWarMongerValue *= iChange;

	iWarMongerValue *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
	iWarMongerValue /= 100;
	
#if defined(MOD_API_EXTENSIONS)
	ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarMongerValue * 100);
#else
	ChangeOtherPlayerWarmongerAmount(ePlayer, iChange * iWarMongerValue);
#endif

	DoUpdateWarmongerThreats(true);
}

/// How many Minors have we seen this Player conquer?
int CvDiplomacyAI::GetOtherPlayerNumMinorsConquered(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumMinorsConquered[ePlayer];
}

/// Sets how many Minors we have seen this Player conquer
void CvDiplomacyAI::SetOtherPlayerNumMinorsConquered(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of minors conquered to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumMinorsConquered[ePlayer] = iValue;
}

/// Changes how many Minors we have seen this Player conquer
void CvDiplomacyAI::ChangeOtherPlayerNumMinorsConquered(PlayerTypes ePlayer, int iChange)
{
	// We don't care if it's us or a teammate
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return;
	
	SetOtherPlayerNumMinorsConquered(ePlayer, GetOtherPlayerNumMinorsConquered(ePlayer) + iChange);
	//ChangeOtherPlayerWarmongerAmount(ePlayer, iChange * /*1000*/ GC.getWARMONGER_THREAT_MINOR_CONQUERED_WEIGHT());
}

/// How many Majors have we seen this Player attack?
int CvDiplomacyAI::GetOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumMajorsAttacked[ePlayer];
}

/// Sets how many Majors we have seen this Player attack
void CvDiplomacyAI::SetOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Majors attacked to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumMajorsAttacked[ePlayer] = iValue;
}

/// Changes how many Majors we have seen this Player attack
void CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked(PlayerTypes ePlayer, int iChange, TeamTypes eAttackedTeam)
{
	// We don't care if it's us or a teammate
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return;
	
	// Don't apply warmongering if we haven't met the attacker (otherwise that's cheating)
	if(!GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
		return;
	
	if(iChange > 0)
	{
		PlayerTypes eAttackedPlayer;
		for(int iAttackedPlayerLoop = 0; iAttackedPlayerLoop < MAX_MAJOR_CIVS; iAttackedPlayerLoop++)
		{
			eAttackedPlayer = (PlayerTypes) iAttackedPlayerLoop;

			// Player must be on this team
			if(GET_PLAYER(eAttackedPlayer).getTeam() != eAttackedTeam)
				continue;

			// Don't ACTUALLY count this if we're at war with the guy also
			if(IsAtWar(eAttackedPlayer))
				return;
		}
	}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// Don't count this if the guy declaring war is a vassal because he can't declare war himself
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() != NO_TEAM)
			return;
	}
#endif

	SetOtherPlayerNumMajorsAttacked(ePlayer, GetOtherPlayerNumMajorsAttacked(ePlayer) + iChange);

	int iWarMongerValue = GC.getWARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT();
	if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(m_pPlayer->GetID(), ePlayer) || GC.getGame().GetGameLeagues()->IsWorldWar(GetPlayer()->GetID()) > 0)
	{
		iWarMongerValue = GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_WAR();
	}
	else if (GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(GetPlayer()->GetID()) > 0)
	{
		iWarMongerValue = GC.getWARMONGER_THREAT_ATTACKED_WEIGHT_WORLD_PEACE();
	}

	iWarMongerValue *= (100 + GetOtherPlayerNumMajorsAttacked(ePlayer));
	iWarMongerValue /= 100;

	if (iWarMongerValue <= 0)
		return;

#if defined(MOD_API_EXTENSIONS)
	int iWarmongerModifier = 100;

	// INCREASE if he's big and nasty, less so if he's not.
	switch (GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
	case STRENGTH_POWERFUL:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
		break;
	case STRENGTH_AVERAGE:
	case STRENGTH_STRONG:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
		break;
	case STRENGTH_WEAK:
	case STRENGTH_POOR:
	case STRENGTH_PATHETIC:
		iWarmongerModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();
		break;
	default:
		break;
	}
#endif

	iWarMongerValue *= iWarmongerModifier;
	iWarMongerValue /= 100;

	iWarMongerValue *= iChange;

	iWarMongerValue *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
	iWarMongerValue /= 100;
		
#if defined(MOD_API_EXTENSIONS)
	ChangeOtherPlayerWarmongerAmountTimes100(ePlayer, iWarMongerValue * 100);
#else
	ChangeOtherPlayerWarmongerAmount(ePlayer, iWarMongerValue);
#endif

	DoUpdateWarmongerThreats(true);
}

/// How many Majors have we seen this Player conquer?
int CvDiplomacyAI::GetOtherPlayerNumMajorsConquered(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiOtherPlayerNumMajorsConquered[ePlayer];
}

/// Sets how many Majors we have seen this Player conquer
void CvDiplomacyAI::SetOtherPlayerNumMajorsConquered(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Majors conquered to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiOtherPlayerNumMajorsConquered[ePlayer] = iValue;
}

/// Changes how many Majors we have seen this Player conquer
void CvDiplomacyAI::ChangeOtherPlayerNumMajorsConquered(PlayerTypes ePlayer, int iChange)
{
	// We don't care if it's us or a teammate
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return;
	
	SetOtherPlayerNumMajorsConquered(ePlayer, GetOtherPlayerNumMajorsConquered(ePlayer) + iChange);
	//ChangeOtherPlayerWarmongerAmount(ePlayer, iChange * /*1000 */ GC.getWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT());
}

#if defined(MOD_BALANCE_CORE)

/// How many times has ePlayer plotted against us?
int CvDiplomacyAI::GetNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiTheyPlottedAgainstUs[ePlayer];
}

/// Sets how many times ePlayer has plotted against us
void CvDiplomacyAI::SetNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Majors conquered to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiTheyPlottedAgainstUs[ePlayer] = iValue;
}

/// Changes how many times ePlayer has plotted against us
void CvDiplomacyAI::ChangeNumTimesTheyPlottedAgainstUs(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesTheyPlottedAgainstUs(ePlayer, GetNumTimesTheyPlottedAgainstUs(ePlayer) + iChange);
	//ChangeOtherPlayerWarmongerAmount(ePlayer, iChange * /*1000 */ GC.getWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT());
}

/// How many times has ePlayer lowered our influence with a Minor Civ?
int CvDiplomacyAI::GetNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiTheyLoweredOurInfluence[ePlayer];
}

/// Sets how many times ePlayer has lowered our influence with a Minor Civ
void CvDiplomacyAI::SetNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Majors conquered to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiTheyLoweredOurInfluence[ePlayer] = iValue;
}

/// Changes how many times ePlayer has lowered our influence with a Minor Civ
void CvDiplomacyAI::ChangeNumTimesTheyLoweredOurInfluence(PlayerTypes ePlayer, int iChange)
{
	SetNumTimesTheyLoweredOurInfluence(ePlayer, GetNumTimesTheyLoweredOurInfluence(ePlayer) + iChange);
	//ChangeOtherPlayerWarmongerAmount(ePlayer, iChange * /*1000 */ GC.getWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT());
}
#endif

/// Get the amount of warmongerishness felt toward this player
int CvDiplomacyAI::GetOtherPlayerWarmongerAmount(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	
#if defined(MOD_API_EXTENSIONS)
	int iReturnValue = m_paiOtherPlayerWarmongerAmountTimes100[ePlayer] / 100;
#else
	int iReturnValue = m_paiOtherPlayerWarmongerAmount[ePlayer];
#endif

	// Modify warmonger amount based on global politics
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	bool bUntrustworthy = false;
	bool bAtWar = GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam());
	
	if (IsUntrustworthyFriend(ePlayer) || IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
		bUntrustworthy = true;
	
	if (!bUntrustworthy && !bAtWar)
	{
		bool bFriendReduction = false;
		
		// We're friends - halve it!
		if (IsDoFAccepted(ePlayer))
		{
			iReturnValue /= 2;
			bFriendReduction = true;
		}
		// 3+ DoFs without bad blood - halve it!
		else if (GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
		{
			iReturnValue /= 2;
			bFriendReduction = true;
		}
		// 2 DoFs...reduce by 25%
		else if (GetDoFType(ePlayer) == DOF_TYPE_ALLIES)
		{
			iReturnValue *= 75;
			iReturnValue /= 100;
			bFriendReduction = true;
		}
		// 1 DoF...reduce by 10%
		else if (GetDoFType(ePlayer) == DOF_TYPE_FRIENDS)
		{
			iReturnValue *= 90;
			iReturnValue /= 100;
			bFriendReduction = true;
		}

		// Defensive Pact? Reduce by one third.
		if (GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
		{
			iReturnValue *= 67;
			iReturnValue /= 100;
			bFriendReduction = true;
		}
		
		// If we have a strategic alliance, let's not break this apart too easily
		if (bFriendReduction && !IsPlayerDenouncedFriend(ePlayer))
		{
			if (IsPlayerDoFwithAnyFriend(ePlayer))
			{
				iReturnValue *= 75;
				iReturnValue /= 100;
			}
			if (IsPlayerDPWithAnyFriend(ePlayer))
			{
				iReturnValue *= 80;
				iReturnValue /= 100;
			}
			if (IsPlayerDenouncedEnemy(ePlayer))
			{
				iReturnValue *= 90;
				iReturnValue /= 100;
			}
		}
		else
		{
			if (IsPlayerDoFwithAnyFriend(ePlayer))
			{
				iReturnValue *= 90;
				iReturnValue /= 100;
			}
			if (IsPlayerDPWithAnyFriend(ePlayer))
			{
				iReturnValue *= 95;
				iReturnValue /= 100;
			}
			if (IsPlayerDenouncedEnemy(ePlayer))
			{
				iReturnValue *= 95;
				iReturnValue /= 100;
			}
		}
	}
	
	if (!bAtWar)
	{
		// Small reduction if they've given us Open Borders
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsAllowsOpenBordersToTeam(m_pPlayer->getTeam()))
		{
			iReturnValue *= 95;
			iReturnValue /= 100;
		}
	
		// Increase if their global politics are a threat to us
		if (IsPlayerDoFwithAnyEnemy(ePlayer))
		{
			iReturnValue *= 110;
			iReturnValue /= 100;
		}
		if (IsPlayerDenouncedFriend(ePlayer))
		{
			iReturnValue *= 115;
			iReturnValue /= 100;
		}
		if (IsPlayerDPWithAnyEnemy(ePlayer))
		{
			iReturnValue *= 120;
			iReturnValue /= 100;
		}
		if (bUntrustworthy)
		{
			iReturnValue *= 125;
			iReturnValue /= 100;
		}
	}
	
	// Religion/ideology should impact this - including if at war!
	ReligionTypes eMyReligion = GetPlayer()->GetReligions()->GetCurrentReligion(false);
	
	if (eMyReligion != NO_RELIGION)
	{
		if (GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) == eMyReligion)
		{
			iReturnValue *= 75;
			iReturnValue /= 100;
		}
		else if (GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) != NO_RELIGION)
		{
			iReturnValue *= 125;
			iReturnValue /= 100;
		}
	}
	
	if (IsPlayerSameIdeology(ePlayer))
	{
		iReturnValue *= 60;
		iReturnValue /= 100;
	}
	else if (IsPlayerOpposingIdeology(ePlayer))
	{
		iReturnValue *= 140;
		iReturnValue /= 100;
	}
	
	// Large reduction if either of us resurrected the other
	if (WasResurrectedBy(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->WasResurrectedBy(GetPlayer()->GetID()))
	{
		if (!bAtWar)
		{
			iReturnValue /= 2;
		}
	}
#endif
	
	return iReturnValue;
}

/// Change the amount of warmongerishness felt toward this player
#if defined(MOD_API_EXTENSIONS)
void CvDiplomacyAI::SetOtherPlayerWarmongerAmountTimes100(PlayerTypes ePlayer, int iNewValue)
{
	m_paiOtherPlayerWarmongerAmountTimes100[ePlayer] = iNewValue;
}

void CvDiplomacyAI::ChangeOtherPlayerWarmongerAmountTimes100(PlayerTypes ePlayer, int iChangeAmount)
{
	if (iChangeAmount != 0)
	{
		m_paiOtherPlayerWarmongerAmountTimes100[ePlayer] += iChangeAmount;
		if (m_paiOtherPlayerWarmongerAmountTimes100[ePlayer] <= 0)
			m_paiOtherPlayerWarmongerAmountTimes100[ePlayer] = 0;
	}
}
#else
void CvDiplomacyAI::ChangeOtherPlayerWarmongerAmount(PlayerTypes ePlayer, int iChangeAmount)
{
	int iNewValue = m_paiOtherPlayerWarmongerAmount[ePlayer] + (iChangeAmount * GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent()) / 100;
	iNewValue = max(0, iNewValue);
	m_paiOtherPlayerWarmongerAmount[ePlayer] = iNewValue;
}
#endif

/// Return the value of the warmonger amount adjusted by how much this player hates warmongers
int CvDiplomacyAI::GetOtherPlayerWarmongerScore(PlayerTypes ePlayer)
{
	int iReturnValue = GetOtherPlayerWarmongerAmount(ePlayer);

	// Value at this point is from 250 (DOW) to upwards of 2000 (after capturing several cities)
	// Want final value to be about 1/20th that (Jon wanted max Opinion hit to be 100)
	// Average WarmongerHate is 5, so divide by 100 to get to 1/20th.
	iReturnValue *= GetWarmongerHate();
	iReturnValue /= 100;
	
	return iReturnValue;
}

/////////////////////////////////////////////////////////
// Contact
/////////////////////////////////////////////////////////

/// First contact between this player and another
void CvDiplomacyAI::DoFirstContact(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(ePlayer != GetPlayer()->GetID())
	{
		DoFirstContactInitRelationship(ePlayer);

		//// Major Civ
		//if (!GET_PLAYER(ePlayer).isMinorCiv())
		//{
		//	SetPlayerMilitaryStrengthComparedToUs(ePlayer, STRENGTH_AVERAGE);
		//	SetMajorCivApproach(ePlayer, MAJOR_CIV_APPROACH_NEUTRAL);
		//	SetMajorCivOpinion(ePlayer, MAJOR_CIV_OPINION_NEUTRAL);
		//}
		//// Minor Civ
		//else
		//	SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);

		// Default States, will be updated on turn cycling
		//SetPlayerTargetValue(ePlayer, TARGET_VALUE_AVERAGE);

		// Humans don't say hi to one another through the shadow diplo AI and, uh, don't show up in MP please
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH: notifications do get send in MP + updated to new 
			if (GC.getGame().isFinalInitialized())
			{
				if (!IsAtWar(ePlayer) && CvPreGame::isHuman(ePlayer))
				{
					const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_INTRO);
					CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DEFAULT_ROOT, szText, LEADERHEAD_ANIM_INTRO);
				}
			}
		}
		else
		{
			if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
			{
				if(!GetPlayer()->isHuman())
				{
					// Should fire off a diplo message when we meet a human
					if(GET_PLAYER(ePlayer).isHuman())
					{
						if(!IsAtWar(ePlayer))
						{
							if(GC.getGame().isFinalInitialized())
							{
								if(std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), ePlayer) == m_aGreetPlayers.end())
								{
									// Put in the list of people to greet when their turn comes up.
									m_aGreetPlayers.push_back(ePlayer);
								}
							}
						}
					}
				}
				else
				{
					// Human to Human will just send a notification
					CvPlayer& kTargetPlayer = GET_PLAYER(ePlayer);
					if(kTargetPlayer.isHuman())
					{
						if(!IsAtWar(ePlayer))
						{
							if(GC.getGame().isFinalInitialized())
							{
								CvNotifications* pNotifications = kTargetPlayer.GetNotifications();
								if(pNotifications)
								{
									CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GetPlayer()->getNameKey());
									pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strBuffer, -1, -1, GetPlayer()->GetID());
								}
							}
						}
					}
				}
			}
		}

#else
		if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
		{
			if(!GetPlayer()->isHuman())
			{
				// Should fire off a diplo message when we meet a human
				if(GET_PLAYER(ePlayer).isHuman())
				{
					if(!IsAtWar(ePlayer))
					{
						if(GC.getGame().isFinalInitialized())
						{
							if(std::find(m_aGreetPlayers.begin(), m_aGreetPlayers.end(), ePlayer) == m_aGreetPlayers.end())
							{
								// Put in the list of people to greet when their turn comes up.
								m_aGreetPlayers.push_back(ePlayer);
							}
						}
					}
				}
			}
			else
			{
				// Human to Human will just send a notification
				CvPlayer& kTargetPlayer = GET_PLAYER(ePlayer);
				if(kTargetPlayer.isHuman())
				{
					if(!IsAtWar(ePlayer))
					{
						if(GC.getGame().isFinalInitialized())
						{
							CvNotifications* pNotifications = kTargetPlayer.GetNotifications();
							if(pNotifications)
							{
								CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GetPlayer()->getNameKey());
								pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strBuffer, -1, -1, GetPlayer()->GetID());
							}
						}
					}
				}
			}
		}
#endif
		// Catch up on public declarations this player has made

		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			PublicDeclarationTypes eDeclaration;
			int iData1;
			int iData2;
			PlayerTypes eMustHaveMetPlayer;
			bool bActive;

			for(int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
			{
				eDeclaration = GetDeclarationLogTypeForIndex(iLoop);

				// Does this entry in the log exist?
				if(eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
				{
					bActive = IsDeclarationLogForIndexActive(iLoop);

					iData1 = GetDeclarationLogData1ForIndex(iLoop);
					iData2 = GetDeclarationLogData2ForIndex(iLoop);

					// Validate active status - minors must be alive
					if(eDeclaration == PUBLIC_DECLARATION_PROTECT_MINOR)
					{
						CvAssert(((PlayerTypes) iData1) != NO_PLAYER);
						if(((PlayerTypes) iData1) != NO_PLAYER)
						{
							if(!GET_PLAYER((PlayerTypes) iData1).isAlive())
								bActive = false;
						}
					}
					else if(eDeclaration == PUBLIC_DECLARATION_ABANDON_MINOR)
					{
						CvAssert(((PlayerTypes) iData1) != NO_PLAYER);
						if(((PlayerTypes) iData1) != NO_PLAYER)
						{
							if(!GET_PLAYER((PlayerTypes) iData1).isAlive())
								bActive = false;
						}
					}

					// Is this still an active declaration?
					if(bActive)
					{
						eMustHaveMetPlayer = GetDeclarationLogMustHaveMetPlayerForIndex(iLoop);

						DoMakePublicDeclaration(eDeclaration, iData1, iData2, eMustHaveMetPlayer, ePlayer);
					}
				}
			}
		}
	}
}

/// Initiate relationship values towards a new player on first contact
void CvDiplomacyAI::DoFirstContactInitRelationship(PlayerTypes ePlayer)
{
	DoUpdateOnePlayerMilitaryStrength(ePlayer);
	DoUpdateOnePlayerEconomicStrength(ePlayer);

	DoUpdateOnePlayerMilitaryAggressivePosture(ePlayer);
	DoUpdateOnePlayerExpansionAggressivePosture(ePlayer);

	DoUpdateOnePlayerTargetValue(ePlayer);

	// Major Civ
	if(!GET_PLAYER(ePlayer).isMinorCiv())
	{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		SetDoFType(ePlayer, DOF_TYPE_NEW);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_NEW);
		for(int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			GetPlayer()->SetApproachScratchValue(ePlayer, (MajorCivApproachTypes)iApproachLoop, 0);
		}
#endif
		DoUpdateOnePlayerOpinion(ePlayer);

		/////////////////
		// APPROACH
		/////////////////

		int iHighestWeight;
		WarFaceTypes eWarFace;

		// See which Approach is best
		MajorCivApproachTypes eApproach = GetBestApproachTowardsMajorCiv(ePlayer, /*Passed by Ref, but we won't use it*/ iHighestWeight, /*bLookAtOtherPlayers*/ true, /*bLog*/ true, /*Passed by Ref, used below*/ eWarFace);
#if defined(MOD_BALANCE_CORE)
		//Let's not be hostile right off the bat -- neutral is fine, though.
		if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_GUARDED)
		{
			eApproach = MAJOR_CIV_APPROACH_NEUTRAL;
			SetWarFaceWithPlayer(ePlayer, WAR_FACE_NEUTRAL);
		}
#else
		// If we're going to war and we haven't picked a War Face yet choose one
		if(eApproach == MAJOR_CIV_APPROACH_WAR && GetWarFaceWithPlayer(ePlayer) == NO_WAR_FACE_TYPE)
			SetWarFaceWithPlayer(ePlayer, eWarFace);
#endif
		CvAssertMsg(eApproach >= 0, "DIPLOMACY_AI: Invalid MajorCivApproachType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		// Actually assign the (possibly) new Approach
		SetMajorCivApproach(ePlayer, eApproach);
	}

	// Minor civ
	else
	{
		SetMinorCivApproach(ePlayer, MINOR_CIV_APPROACH_IGNORE);
	}
}
//	-----------------------------------------------------------------------------------------------
/// Player killed us
void CvDiplomacyAI::DoKilledByPlayer(PlayerTypes ePlayer)
{
#if defined(MOD_ACTIVE_DIPLOMACY)
	if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if(ePlayer != NO_PLAYER && CvPreGame::isHuman(ePlayer))
		{
			const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
		}
	}
	else
	{
		if(ePlayer == GC.getGame().getActivePlayer() && !GC.getGame().isNetworkMultiPlayer())
		{
			const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
		}
#else
	if(ePlayer == GC.getGame().getActivePlayer() && !GC.getGame().isNetworkMultiPlayer())
	{
		const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFEATED);
		gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_DEFEATED);
#endif

#if !defined(NO_ACHIEVEMENTS)
		if(!GC.getGame().isGameMultiPlayer())
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_DESTROY_CIV);

			CvAchievementUnlocker::AlexanderConquest(ePlayer);
		}
#endif
	}
}
//	-------------------------------------------------------------------------------------------------------------------
/// Send a statement to another player
void CvDiplomacyAI::DoSendStatementToPlayer(PlayerTypes ePlayer, DiploStatementTypes eStatement, int iData1, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eStatement >= 0, "DIPLOMACY_AI: Invalid DiploStatementType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eStatement < NUM_DIPLO_LOG_STATEMENT_TYPES, "DIPLOMACY_AI: Invalid DiploStatementType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* szText;
	bool bHuman = GET_PLAYER(ePlayer).isHuman();

	// Aggressive Military warning
	if(eStatement == DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING)
	{
		if(bHuman)
		{
			if(IsActHostileTowardsHuman(ePlayer))
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_AGGRESSIVE_MILITARY_WARNING);
			else
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_AGGRESSIVE_MILITARY_WARNING);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AGGRESSIVE_MILITARY_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
#if defined(MOD_BALANCE_CORE)
		// AI resolution
		else
		{
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
			{
				SetPlayerMadeMilitaryPromise(ePlayer, true);
				SetPlayerMilitaryPromiseCounter(ePlayer, 0);
			}
			else
			{
				CvAIOperation* pOperation = GET_PLAYER(ePlayer).GetMilitaryAI()->GetShowOfForceOperation(GetPlayer()->GetID());
				if (!pOperation)
				{
					pOperation = GET_PLAYER(ePlayer).GetMilitaryAI()->GetSneakAttackOperation(GetPlayer()->GetID());
				}

				if ((pOperation != NULL && pOperation->PercentFromMusterPointToTarget() >= 75) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsArmyInPlaceForAttack(GetPlayer()->GetID()))
				{
					if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->DeclareWar(GetPlayer()->getTeam()))
					{
						SetPlayerMadeMilitaryPromise(ePlayer, true);
						SetPlayerMilitaryPromiseCounter(ePlayer, 0);
					}
					else
					{
						SetPlayerIgnoredMilitaryPromise(ePlayer, true);
					}
				}
				else
				{
					SetPlayerMadeMilitaryPromise(ePlayer, true);
					SetPlayerMilitaryPromiseCounter(ePlayer, 0);
				}
			}
		}
#endif
	}

	// Player killed a City-State we were protecting
	else if(eStatement == DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
	}

	// Player attacked a City-State we're protecting
	else if(eStatement == DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_ATTACKED_MINOR_CIV, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(eMinorCiv) == MINOR_CIV_APPROACH_CONQUEST)
				{
					SetPlayerIgnoredAttackCityStatePromise(ePlayer, true);
				}
				else
				{
					SetPlayerMadeAttackCityStatePromise(ePlayer, true);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMinorCivApproach(eMinorCiv, MINOR_CIV_APPROACH_IGNORE);
				}
			}
		}
#endif
	}

	// Player bullied a City-State we're protecting
	else if(eStatement == DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

				szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_PROTECTED_CITY_STATE, NO_PLAYER, strMinorCivKey);
				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_BULLIED_MINOR_CIV, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(eMinorCiv) == MINOR_CIV_APPROACH_BULLY)
				{
					SetPlayerIgnoredBullyCityStatePromise(ePlayer, true);
				}
				else
				{
					SetPlayerMadeBullyCityStatePromise(ePlayer, true);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMinorCivApproach(eMinorCiv, MINOR_CIV_APPROACH_IGNORE);
				}
			}
		}
#endif
	}

	// Serious Expansion warning
	else if(eStatement == DIPLO_STATEMENT_EXPANSION_SERIOUS_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_SERIOUS_WARNING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_EXPANSION_SERIOUS_WARNING, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Expansion warning
	else if(eStatement == DIPLO_STATEMENT_EXPANSION_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_WARNING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_EXPANSION_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			if(!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDontSettleMessageTooSoon(ePlayer))
			{
				SetPlayerNoSettleRequestCounter(ePlayer, 0);
				SetPlayerNoSettleRequestEverAsked(ePlayer, true);

				bool bAcceptable;
				bAcceptable = GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDontSettleAcceptable(GetPlayer()->GetID());

				if(bAcceptable)
				{
					SetPlayerNoSettleRequestAccepted(ePlayer, true);
					SetEverMadeExpansionPromise(ePlayer, true);
					SetNoExpansionPromiseClosestCities(ePlayer, GetClosestCityPair(ePlayer));
				}
				else
					SetIgnoredExpansionPromiseValue(ePlayer, GC.getOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
			}
		}
#endif
	}

	// Broken Expansion Promise
	else if(eStatement == DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXPANSION_BROKEN_PROMISE);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Serious Plot Buying warning
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_SERIOUS_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_SERIOUS_WARNING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_PLOT_BUYING_SERIOUS_WARNING, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Plot Buying warning
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_WARNING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_WARNING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_YOU_PLOT_BUYING_WARNING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() > 8)
			{
				if (!IsPlayerIgnoredBorderPromise(ePlayer))
				{
					SetIgnoredBorderPromiseValue(ePlayer, GC.getOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
				}
				SetPlayerIgnoredBorderPromise(ePlayer, true);
			}
			else
			{
				SetPlayerMadeBorderPromise(ePlayer, true);
				SetPlayerBorderPromiseData(ePlayer, GetPlotBuyingAggressivePosture(ePlayer));
				SetEverMadeBorderPromise(ePlayer, true);
			}
		}
#endif
	}

	// Broken Plot Buying Promise
	else if(eStatement == DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLOT_BUYING_BROKEN_PROMISE);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// We attacked a Minor someone has a PtP with
	else if(eStatement == DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();
				if(IsActHostileTowardsHuman(ePlayer))
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_WE_ATTACKED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);
				else
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_ATTACKED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);

				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_I_ATTACKED_YOUR_MINOR_CIV, szText, LEADERHEAD_ANIM_POSITIVE, eMinorCiv);

				// Extra flag, since diplo log does not save which minor civ the message was about
				SetSentAttackProtectedMinorTaunt(ePlayer, eMinorCiv, true);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE)
				{
					SetOtherPlayerTurnsSinceSidedWithProtectedMinor(ePlayer, 0);
					// For now the AI will always give in
					bool bValid = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 3);
						}
					}
				}
				else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivCompetitiveness() > 6)
				{
					SetOtherPlayerTurnsSinceSidedWithProtectedMinor(ePlayer, 0);
					// For now the AI will always give in
					bool bValid = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 3);
						}
					}
				}
				else
				{
					GC.getGame().DoMinorPledgeProtection(ePlayer, eMinorCiv, false, true); // Pledge is broken!	
				}
			}
		}
#endif
	}

	// We bullied a Minor someone has a PtP with
	else if(eStatement == 	DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if (eMinorCiv != NO_PLAYER)
			{
				const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();
				if(IsActHostileTowardsHuman(ePlayer))
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_WE_BULLIED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);
				else
					szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_BULLIED_YOUR_MINOR, NO_PLAYER, strMinorCivKey);

				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_I_BULLIED_YOUR_MINOR_CIV, szText, LEADERHEAD_ANIM_POSITIVE, eMinorCiv);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			CvAssert(eMinorCiv != NO_PLAYER);
			if(eMinorCiv != NO_PLAYER)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer) == MINOR_CIV_APPROACH_PROTECTIVE)
				{
					SetOtherPlayerTurnsSinceSidedWithProtectedMinor(ePlayer, 0);
					// For now the AI will always give in
					bool bValid = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 3);
						}
					}
				}
				else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMinorCivCompetitiveness() > 6)
				{
					SetOtherPlayerTurnsSinceSidedWithProtectedMinor(ePlayer, 0);
					// For now the AI will always give in
					bool bValid = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
					if (GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
					{
						if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GetWarmongerHate())
						{
							bValid = true;
						}
					}
					if (bValid && ((GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetBoldness() >  6) || GET_PLAYER(GetPlayer()->GetID()).GetDiplomacyAI()->GetMeanness() > 6))
					{
						if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
						{
							pDeal->ClearItems();
							GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 3);
						}
					}
				}
				else
				{
					GC.getGame().DoMinorPledgeProtection(ePlayer, eMinorCiv, false, true); // Pledge is broken!	
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE_DEALS)
	// We'd like a defense pact
	else if(eStatement == DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEFENSE_PACT_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;
				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a 3rd party war
	else if(eStatement == DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THIRDPARTY_WAR_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a peace trade
	else if(eStatement == DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THIRDPARTY_PEACE_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like a vote trade
	else if(eStatement == DIPLO_STATEMENT_VOTE_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VOTE_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	
	// We'd like to trade cities
	else if(eStatement == DIPLO_STATEMENT_TRADE_CITIES_REQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_CITIES_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like to exchange cities
	else if(eStatement == DIPLO_STATEMENT_EXCHANGE_CITIES)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EXCHANGE_CITIES_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
#endif
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_WORK_WITH_US)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			SetDoFCounter(ePlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), 0);

			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetPlayer()->GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), true);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				SetDoFType(ePlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_FRIENDS);	
#endif

				LogDoF(ePlayer);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_BB)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_BATTLE_BROTHERS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			SetDoFCounter(ePlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), 0);

			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetPlayer()->GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), true);

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_ALLIES)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_OLD_FRIENDS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			SetDoFCounter(ePlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), 0);

			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetPlayer()->GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), true);
				SetDoFType(ePlayer, DOF_TYPE_BATTLE_BROTHERS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_BATTLE_BROTHERS);	

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_FRIENDS)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_FRIENDS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			SetDoFCounter(ePlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), 0);

			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetPlayer()->GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), true);
				SetDoFType(ePlayer, DOF_TYPE_ALLIES);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_ALLIES);	

				LogDoF(ePlayer);
			}
		}
	}
	// We'd like to work with a player
	else if(eStatement == DIPLO_STATEMENT_DOF_UNTRUSTWORTHY)
	{
		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_UNTRUSTWORTHY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_WORK_WITH_US, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI resolution
		else
		{
			SetDoFCounter(ePlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(GetPlayer()->GetID(), 0);

			// Accept - reject is assumed from the counter
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAcceptable(GetPlayer()->GetID()))
			{
				SetDoFAccepted(ePlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(GetPlayer()->GetID(), true);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				SetDoFType(ePlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_FRIENDS);		
#endif

				LogDoF(ePlayer);
			}
		}
	}
#endif
	// We no longer want to work with a player
	else if(eStatement == DIPLO_STATEMENT_END_WORK_WITH_US)
	{
		PlayerTypes eMyPlayer = GetPlayer()->GetID();
		
		SetDoFAccepted(ePlayer, false);
		SetDoFCounter(ePlayer, -666);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, -666);
		
		// End all coop war agreements with this player
		PlayerTypes eThirdParty;
		for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
		{
			eThirdParty = (PlayerTypes) iThirdPartyLoop;
			
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			// Did we break a coop war promise?
			if(GetCoopWarAcceptedState(ePlayer, eThirdParty) == COOP_WAR_STATE_SOON)
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBrokenCoopWarPromise(eMyPlayer, true);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBackstabCounter(eMyPlayer, 0);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumTimesCoopWarDenied(eMyPlayer, 2);
			}
#endif

			// WAS in or planning a coop war with the guy we've stopped working with
			if(GetCoopWarAcceptedState(ePlayer, eThirdParty) >= COOP_WAR_STATE_SOON)
			{
				SetCoopWarAcceptedState(ePlayer, eThirdParty, NO_COOP_WAR_STATE);
				SetCoopWarCounter(ePlayer, eThirdParty, -666);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(eMyPlayer, eThirdParty, NO_COOP_WAR_STATE);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(eMyPlayer, eThirdParty, -666);
			}
		}
		
		// End any Defensive Pact
		GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(ePlayer).getTeam(), false);
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);

		// If we had agreed to not settle near the player, break that off
		SetPlayerNoSettleRequestAccepted(ePlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeExpansionPromise(eMyPlayer, false);

		// If we had agreed to not spy on the player, break that off
		SetPlayerStopSpyingRequestAccepted(ePlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerMadeSpyPromise(eMyPlayer, false);
		
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)	
		SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(eMyPlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFBroken(eMyPlayer, true);
		LogBrokenDoF(ePlayer);
#endif

		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_END_WORK_WITH_US, ePlayer);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Denounce
	else if(eStatement == DIPLO_STATEMENT_DENOUNCE)
	{
		DoDenouncePlayer(ePlayer);
		LogDenounce(ePlayer);

		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, ePlayer);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Denounce Friend (backstab)
	else if(eStatement == DIPLO_STATEMENT_DENOUNCE_FRIEND)
	{
		DoDenouncePlayer(ePlayer);
		LogDenounce(ePlayer, /*bBackstab*/ true);

		// Send message to human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_AI_DOF_BACKSTAB, ePlayer);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Request Friend Denounce Someone
	else if(eStatement == DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE)
	{
		PlayerTypes eTarget = (PlayerTypes) iData1;
		CvAssert(eTarget != NO_PLAYER);
		if(eTarget != NO_PLAYER)
		{
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();

			// Send message to human
		if(bHuman)
			{
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_AI_DENOUNCE_REQUEST, ePlayer, strTargetCivKey);

				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AI_REQUEST_DENOUNCE, szText, LEADERHEAD_ANIM_POSITIVE, eTarget);
			}
			else
			{
				bool bAgree = IsDenounceAcceptable(eTarget, /*bBias*/ true);

				LogFriendRequestDenounce(ePlayer, eTarget, bAgree);

				if(bAgree)
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->DoDenouncePlayer(eTarget);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->LogDenounce(eTarget);

					// Denounced a human?
#if defined(MOD_ACTIVE_DIPLOMACY)
					if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
					{
						if(GET_PLAYER(eTarget).isHuman())
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, eTarget);
							CvDiplomacyRequests::SendRequest(ePlayer, eTarget, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
						}
					}
					else
					{
						if(eTarget == GC.getGame().getActivePlayer())
#else
						if(eTarget == GC.getGame().getActivePlayer())
#endif
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_AGAINST_SOMEONE, eTarget);
							CvDiplomacyRequests::SendRequest(ePlayer, eTarget, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
						}
#if defined(MOD_ACTIVE_DIPLOMACY)
					}
#endif
				}
				else
				{
					// Oh, you're gonna say no, are you?
					if(IsFriendDenounceRefusalUnacceptable(ePlayer, eTarget))
					{
						DoDenouncePlayer(ePlayer);
						LogDenounce(ePlayer, /*bBackstab*/ false, /*bRefusal*/ true);
					}
				}
			}
		}
	}

	// We no longer want to work with a player against someone else
	//else if (eStatement == DIPLO_STATEMENT_END_WORK_AGAINST_SOMEONE)
	//{
	//	PlayerTypes eAgainstPlayer = (PlayerTypes) iData1;

	//	SetWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayer, false);
	//	SetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer, -666);

	//	// Send message to human
	//	if (bShouldShowLeaderScene)
	//	{
	//		const char* strAgainstPlayerKey = GET_PLAYER(eAgainstPlayer).getNameKey();
	//		szText = GetDiploStringForMessage(DIPLO_MESSAGE_END_WORK_AGAINST_SOMEONE, ePlayer, strAgainstPlayerKey);

	//		gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
	//	}
	//	else if (!bHuman)
	//	{
	//		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetWorkingAgainstPlayerAccepted(GetPlayer()->GetID(), eAgainstPlayer, false);
	//		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetWorkingAgainstPlayerCounter(GetPlayer()->GetID(), eAgainstPlayer, -666);
	//	}
	//}

	// We'd like to declare war on someone
	else if(eStatement == DIPLO_STATEMENT_COOP_WAR_REQUEST)
	{
		PlayerTypes eAgainstPlayer = (PlayerTypes) iData1;
		CvAssert(eAgainstPlayer != NO_PLAYER);
		if(eAgainstPlayer != NO_PLAYER)
		{
			// Send message to human
			if(bHuman)
			{
				const char* strAgainstPlayerKey = GET_PLAYER(eAgainstPlayer).getNameKey();
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_REQUEST, ePlayer, strAgainstPlayerKey);

				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_COOP_WAR, szText, LEADERHEAD_ANIM_POSITIVE, eAgainstPlayer);
			}
			// AI resolution
			else
			{
				SetCoopWarCounter(ePlayer, eAgainstPlayer, 0);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(GetPlayer()->GetID(), eAgainstPlayer, 0);

				// Will they agree?
				CoopWarStates eAcceptedState = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWillingToAgreeToCoopWarState(GetPlayer()->GetID(), eAgainstPlayer);
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(GetPlayer()->GetID(), eAgainstPlayer, eAcceptedState);

				if(eAcceptedState == COOP_WAR_STATE_ACCEPTED)
				{
					if (DeclareWar(eAgainstPlayer))
					{
#if defined(MOD_BALANCE_CORE)
						GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 2);
						GetPlayer()->GetMilitaryAI()->RequestPureNavalAttack(eAgainstPlayer, 2);
#else
						GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 1);
#endif	

						if (GET_PLAYER(ePlayer).GetDiplomacyAI()->DeclareWar(eAgainstPlayer))						
						{
#if defined(MOD_BALANCE_CORE)
							GET_PLAYER(ePlayer).GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 2);
							GET_PLAYER(ePlayer).GetMilitaryAI()->RequestPureNavalAttack(eAgainstPlayer, 2);
#else
							GET_PLAYER(ePlayer).GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 1);
#endif

							int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
							GET_TEAM(GetPlayer()->getTeam()).ChangeNumTurnsLockedIntoWar(GET_PLAYER(eAgainstPlayer).getTeam(), iLockedTurns);
							GET_TEAM(GET_PLAYER(ePlayer).getTeam()).ChangeNumTurnsLockedIntoWar(GET_PLAYER(eAgainstPlayer).getTeam(), iLockedTurns);
						}
					}
				}

				LogCoopWar(ePlayer, eAgainstPlayer, eAcceptedState);
				
				// If the other player didn't agree then we don't need to change our state from what it was (NO_COOP_WAR_STATE)
				if(eAcceptedState != COOP_WAR_STATE_REJECTED)
				{
					SetCoopWarAcceptedState(ePlayer, eAgainstPlayer, eAcceptedState);
				}

#if defined(MOD_BALANCE_CORE)				
				if(eAcceptedState == COOP_WAR_STATE_REJECTED)
				{
					if(eAgainstPlayer != NO_PLAYER && ePlayer != NO_PLAYER)
					{
						// Should the asked AI warn the target?
						if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCoopWarRequestUnacceptable(GetPlayer()->GetID(), eAgainstPlayer))
						{
							ChangeRecentAssistValue(ePlayer, 300);
							ChangeNumTimesCoopWarDenied(ePlayer, 2);
							GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(ePlayer, -200);
							GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(ePlayer, 1);
							GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_WAR);
							GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);
							
							// Bump down the target player's opinion of the asker
							GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), 300);
							
							// Also warn the target player's teammates and DPs
							for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
							{
								PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
		
								if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).isHuman())
								{
									if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam() || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eAgainstPlayer).getTeam()))
									{
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(ePlayer, 1);
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_WAR);
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);
										
										// Penalty to opinion for the asker
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), 300);
										
										// Bonus to recent assistance based on proximity to the player planning war
										switch(GET_PLAYER(eLoopPlayer).GetProximityToPlayer(GetPlayer()->GetID()))
										{
										case PLAYER_PROXIMITY_NEIGHBORS:
											GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(ePlayer, -150);
											break;
										case PLAYER_PROXIMITY_CLOSE:
											GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(ePlayer, -100);
											break;
										case PLAYER_PROXIMITY_FAR:
											GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(ePlayer, -50);
											break;
										}
										
										// Extra -50 if teammate of the target
										if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam())
											GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(ePlayer, -50);
									}
								}
							}
						}
						else
						{
							ChangeRecentAssistValue(ePlayer, 200);
							ChangeNumTimesCoopWarDenied(ePlayer, 1);
						}
					}
					
				}
#endif
			}
		}
	}

	// We'd like to declare war on someone
	else if(eStatement == DIPLO_STATEMENT_COOP_WAR_TIME)
	{
		PlayerTypes eAgainstPlayer = (PlayerTypes) iData1;
		CvAssert(eAgainstPlayer != NO_PLAYER);
		if(eAgainstPlayer != NO_PLAYER)
		{
			// Send message to human
			if(bHuman)
			{
				const char* strAgainstPlayerKey = GET_PLAYER(eAgainstPlayer).getNameKey();
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_TIME, ePlayer, strAgainstPlayerKey);

				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_COOP_WAR_TIME, szText, LEADERHEAD_ANIM_POSITIVE, eAgainstPlayer);
			}
		}

		// No AI resolution! This is handled automatically in DoCounters() - no need for diplo exchange
	}

	// We're making a demand of this player
	else if(eStatement == DIPLO_STATEMENT_DEMAND)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_DEMAND);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_DEMAND, szText, LEADERHEAD_ANIM_DEMAND);
		}
		// AI player
		else
		{
			// For now the AI will always give in
#if defined(MOD_BALANCE_CORE)
			bool bValid = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(ePlayer).getTeam(), GetPlayer()->GetID()))
#else
			if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			{
				if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarmongerHate())
				{
					bValid = true;
				}
			}
#endif
#if defined(MOD_BALANCE_CORE)
			if (bValid && ((GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >  7) || GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMeanness() > 7))
			{
				if (m_pPlayer->GetDiplomacyAI()->DeclareWar(ePlayer))
				{
					pDeal->ClearItems();
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 3);
				}
			}
			else
			{
#endif
#if defined(MOD_ACTIVE_DIPLOMACY)
				if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
				}
				else
				{
					CvDeal kDeal = *pDeal;

					GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
					GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
				}
#else
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
#if defined(MOD_BALANCE_CORE)
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >= 8)
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->DoDenouncePlayer(GetPlayer()->GetID());
				}
			}
#endif
		}
	}

	// We're making a request of this player
	else if(eStatement == DIPLO_STATEMENT_REQUEST)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_REQUEST);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_REQUEST, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// AI player
		else
		{
			// For now the AI will always give in - may eventually write additional logic here

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// Player has a Luxury Resource we'd like to trade for
	else if(eStatement == DIPLO_STATEMENT_LUXURY_TRADE)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_LUXURY_TRADE);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like to exchange embassies with this player
	else if(eStatement == DIPLO_STATEMENT_EMBASSY_EXCHANGE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EMBASSY_EXCHANGE);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// We want an embassy in this player's capital
	else if(eStatement == DIPLO_STATEMENT_EMBASSY_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_EMBASSY_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like mutual Open Borders with this player
	else if(eStatement == DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE)
	{
		// Active human
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OPEN_BORDERS_EXCHANGE);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// We'd like this player to open their borders to us
	else if(eStatement == DIPLO_STATEMENT_OPEN_BORDERS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OPEN_BORDERS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// Offer plans to make Research Agreement
	else if(eStatement == DIPLO_STATEMENT_PLAN_RESEARCH_AGREEMENT)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PLAN_RESEARCH_AGREEMENT);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_PLAN_RESEARCH_AGREEMENT, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
			if(!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsWantsResearchAgreementWithPlayer(GetPlayer()->GetID()))
				GET_PLAYER(ePlayer).GetDiplomacyAI()->DoAddWantsResearchAgreementWithPlayer(GetPlayer()->GetID());	// just auto-reciprocate right now
		}
	}

	// Offer a Research Agreement
	else if(eStatement == DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_RESEARCH_AGREEMENT_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// Offer to renew an existing trade deal
	else if(eStatement == DIPLO_STATEMENT_RENEW_DEAL)
	{
		if(bHuman)
		{
			int iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer;
			DiploMessageTypes eMessageType = NUM_DIPLO_MESSAGE_TYPES;
			bool bCantMatchOffer;
#if defined(MOD_BALANCE_CORE)
			bool bDealAcceptable = m_pPlayer->GetDealAI()->IsDealWithHumanAcceptable(pDeal, ePlayer, iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, &bCantMatchOffer, false);
#else
			bool bDealAcceptable = m_pPlayer->GetDealAI()->IsDealWithHumanAcceptable(pDeal, ePlayer, iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, bCantMatchOffer);
#endif
			if(!bDealAcceptable)
			{
				if(iValueTheyreOffering > iValueImOffering)
				{
					bDealAcceptable = true;
				}
			}

			if(bDealAcceptable)
			{
				eMessageType = DIPLO_MESSAGE_RENEW_DEAL;
			}
			// We want more from this deal
			else if(iDealValueToMe > -75 &&
			        iValueImOffering < (iValueTheyreOffering * 5))	// The total value of the deal might not be that bad, but if he's asking for WAY more than he's offering (e.g. something for nothing) then it's not unacceptable, but insulting
			{
				eMessageType = DIPLO_MESSAGE_WANT_MORE_RENEW_DEAL;
			}
			else
			{
				CvDeal* pRenewDeal = GetDealToRenew(NULL, ePlayer);
				if (pRenewDeal)
				{
					pRenewDeal->m_bCheckedForRenewal = true;
				}
				ClearDealToRenew();
			}

			if(eMessageType != NUM_DIPLO_MESSAGE_TYPES)
			{
				CvDeal* pRenewDeal = GetDealToRenew(NULL, ePlayer);
				if (pRenewDeal)
				{
					pRenewDeal->m_bCheckedForRenewal = true;
				}
				szText = GetDiploStringForMessage(eMessageType);
				CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
			}
		}
		// Offer to an AI player
		else
		{
			CvDeal kDeal = *pDeal;
			int iDealType = -1;
			CvDeal* pRenewedDeal = m_pPlayer->GetDiplomacyAI()->GetDealToRenew(&iDealType, ePlayer);
			if(pRenewedDeal)
			{
				if (iDealType != 0) // this is not a historic deal, so don't change the resource allocations
				{
					CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(NULL, ePlayer), &kDeal);
				}
				pRenewedDeal->m_bCheckedForRenewal = true;
				m_pPlayer->GetDiplomacyAI()->ClearDealToRenew();
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(kDeal, true);
			}
			else
			{
				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}

	// Our Opinion of them is now Unforgivable
	else if(eStatement == DIPLO_STATEMENT_NOW_UNFORGIVABLE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_UNFORGIVABLE);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Our Opinion of them is now Enemy
	else if(eStatement == DIPLO_STATEMENT_NOW_ENEMY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_ENEMY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// They caught one of our spies
	else if(eStatement == DIPLO_STATEMENT_CAUGHT_YOUR_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_CAUGHT_YOUR_SPY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_CAUGHT_YOUR_SPY, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// They killed one of our spies
	else if(eStatement == DIPLO_STATEMENT_KILLED_YOUR_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_KILLED_YOUR_SPY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_KILLED_YOUR_SPY, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// We killed one of their spies
	else if(eStatement == DIPLO_STATEMENT_KILLED_MY_SPY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_KILLED_MY_SPY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_KILLED_MY_SPY, szText, LEADERHEAD_ANIM_DEFEATED);
		}
	}

	// We (the AI) have intrigue information to share with them
	else if(eStatement == DIPLO_STATEMENT_SHARE_INTRIGUE)
	{
		IntrigueNotificationMessage* pNotificationMessage = GetPlayer()->GetEspionage()->GetRecentIntrigueInfo(ePlayer);
		CvAssertMsg(pNotificationMessage, "pNotificationMessage is null. Whut?");
		if (pNotificationMessage)
		{
			CvAssertMsg(pNotificationMessage->m_eSourcePlayer != NO_PLAYER, "There is no plotter! What's going on");
			PlayerTypes ePlotterPlayer = pNotificationMessage->m_eSourcePlayer;
			CvIntrigueType eIntrigueType = (CvIntrigueType)pNotificationMessage->m_iIntrigueType;
			// don't share intrigue about two parties if they are already at war
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlotterPlayer).getTeam()))
			{
				CvCity* pCity = NULL;
				if(pNotificationMessage->m_iCityX != -1 && pNotificationMessage->m_iCityY != -1)
				{
					CvPlot* pPlot = GC.getMap().plot(pNotificationMessage->m_iCityX, pNotificationMessage->m_iCityY);
					if(pPlot)
					{
						pCity = pPlot->getPlotCity();
					}
				}

				// add the notification to the player
				GET_PLAYER(ePlayer).GetEspionage()->AddIntrigueMessage(m_pPlayer->GetID(), ePlotterPlayer, ePlayer, NO_BUILDING, NO_PROJECT, eIntrigueType, 0, pCity, false);

				if(bHuman)
				{
					const char* szPlayerName;
					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlotterPlayer).isHuman())
					{
						szPlayerName = GET_PLAYER(ePlotterPlayer).getNickName();
					}
					else
					{
						szPlayerName = GET_PLAYER(ePlotterPlayer).getNameKey();
					}

					szText = "";

					switch(eIntrigueType)
					{
					case INTRIGUE_TYPE_ARMY_SNEAK_ATTACK:
						if(pCity)
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY, NO_PLAYER, szPlayerName, pCity->getNameKey());
						}
						else
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY, NO_PLAYER, szPlayerName);
						}
						break;
					case INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK:
						if(pCity)
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY, NO_PLAYER, szPlayerName, pCity->getNameKey());
						}
						else
						{
							szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY, NO_PLAYER, szPlayerName);
						}
						break;
					case INTRIGUE_TYPE_DECEPTION:
						szText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_INTRIGUE, NO_PLAYER, szPlayerName);
						break;
					default:
						CvAssertMsg(false, "Unknown intrigue type");
						break;
					}

					CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
				}
#if defined(MOD_BALANCE_CORE)
				else
				{
					switch (eIntrigueType)
					{
					case INTRIGUE_TYPE_ARMY_SNEAK_ATTACK:
					case INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK:
					case INTRIGUE_TYPE_DECEPTION:
						GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumTimesTheyPlottedAgainstUs(ePlotterPlayer, 1);
						break;
					default:
						CvAssertMsg(false, "Unknown intrigue type");
						break;
					}
				}
#endif
			}

			// mark the messages as shared so the player isn't told the same thing repeatedly
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)ui;
				GET_PLAYER(eLoopPlayer).GetEspionage()->MarkRecentIntrigueAsShared(ePlayer, ePlotterPlayer, eIntrigueType);
			}
		}
	}

	// Stop converting our cities
	else if(eStatement == DIPLO_STATEMENT_STOP_CONVERSIONS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_STOP_CONVERSIONS, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Stop digging up our yard
	else if(eStatement == DIPLO_STATEMENT_STOP_DIGGING)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_STOP_DIGGING, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Insult
	else if(eStatement == DIPLO_STATEMENT_INSULT)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_HOSTILE);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_INSULT_ROOT);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Compliment
	else if(eStatement == DIPLO_STATEMENT_COMPLIMENT)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_FRIENDLY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_COMPLIMENT);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Boot-kissing of a stronger power
	else if(eStatement == DIPLO_STATEMENT_BOOT_KISSING)
	{
		// Change other players' guess as to our Approach (right now it falls in line exactly with the Approach...)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_AFRAID);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);

		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_BOOT_KISSING);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// We're warning a player that his warmongering behavior is attracting attention
	else if(eStatement == DIPLO_STATEMENT_WARMONGER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WARMONGER);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// We're warning a player that his interactions with City-States are not to our liking
	else if(eStatement == DIPLO_STATEMENT_MINOR_CIV_COMPETITION)
	{
		if(bHuman)
		{
			PlayerTypes eMinorCiv = (PlayerTypes) iData1;
			const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

			szText = GetDiploStringForMessage(DIPLO_MESSAGE_MINOR_CIV_COMPETITION, NO_PLAYER, strMinorCivKey);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	// Human befriended an enemy of this AI!
	else if(eStatement == DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOFED_ENEMY, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Human denounced a friend of this AI!
	else if(eStatement == DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCED_FRIEND, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// Human denounced an enemy of this AI!
	else if(eStatement == DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCED_ENEMY, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Human befriended a friend of this AI!
	else if(eStatement == DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOFED_FRIEND, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI befriended an enemy of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DOF, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// AI denounced a friend of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DENOUNCE, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_HATE_NEGATIVE);
		}
	}

	// AI denounced an enemy of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DENOUNCE, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI befriended a friend of the human!
	else if(eStatement == DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND)
	{
		if(bHuman)
		{
			PlayerTypes eTarget = (PlayerTypes) iData1;
			const char* strTargetCivKey = GET_PLAYER(eTarget).getCivilizationShortDescriptionKey();
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DOF, ePlayer, strTargetCivKey);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// AI chose same late game policy tree as the human!
	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_ORDER);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SAME_POLICIES_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_LIKED_THEIR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_WE_DISLIKED_THEIR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_SUPPORTED_OUR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_FOILED_OUR_PROPOSAL, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}

	else if(eStatement == DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING)
	{
		if(bHuman)
		{
			Localization::String sLeagueName = Localization::Lookup("TXT_KEY_LEAGUE_WORLD_CONGRESS_GENERIC");
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				sLeagueName = pLeague->GetName();
			}
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_THEY_SUPPORTED_OUR_HOSTING, ePlayer, sLeagueName);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}

	// Ideological statements
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}	
	else if(eStatement == DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_FREEDOM);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_ORDER);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_AUTOCRACY);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_YOUR_CULTURE_INFLUENTIAL);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_OUR_CULTURE_INFLUENTIAL);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
	}
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
	// Player has a Strategic Resource we'd like
	else if(eStatement == DIPLO_STATEMENT_STRATEGIC_TRADE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_STRATEGIC_TRADE);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	
	// Announce to the human that this AI is competing with them for the same victory condition
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	
	// Announce to the human that this AI wants to block them from achieving victory
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
	else if(eStatement == DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
	}
#endif

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// We'd like to purchase this player's World Map
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_MAPS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_MAPS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We'd like to purchase a technology from this player
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_TECH_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_TECH_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// We're making a generous offer to this player
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_GENEROUS_OFFER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_GENEROUS_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_GENEROUS_OFFER, szText, LEADERHEAD_ANIM_REQUEST);
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				// For now the AI will always accept - may eventually write additional logic here
				CvDeal kDeal = *pDeal;

				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			// For now the AI will always accept - may eventually write additional logic here
			CvDeal kDeal = *pDeal;

			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	//We want to declare independence from our master
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_REVOKE_VASSALAGE)
	{
		if(bHuman)
		{
			if(IsActHostileTowardsHuman(ePlayer))
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSALAGE_HOSTILE);
			else
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSALAGE);

			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_DISCUSS_AI_REVOKE_VASSALAGE, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		// AI resolution
		else
		{
			// Do we accept or make war?
			// How do we think war with ePlayer will go?

			////War will go well? We should get free peacefully!
			//if(GetWarProjection(ePlayer) > WAR_PROJECTION_UNKNOWN)
			//{
			//	bPeaceful = true;
			//}
			//// For stalemates, we do a 50/50 roll
			//else if(GetWarProjection(ePlayer) == WAR_PROJECTION_STALEMATE || GetWarProjection(ePlayer) == WAR_PROJECTION_UNKNOWN)
			//{
			//	int iChance = GC.getGame().getJonRandNum(2, "Diplomacy AI: Is AI request to end vassalage acceptable?");
			//	if(iChance == 1)
			//		bPeaceful = true;
			//	else
			//		bPeaceful = false;
			//}
			//// War Projection was bad, so our master isn't letting go without a fight.
			//else
			//{
			//	bPeaceful = false;
			//}

			CvPlayer& kVassalPlayer = GET_PLAYER(GetPlayer()->GetID());
			CvPlayer& kMasterPlayer = GET_PLAYER(ePlayer);

			// AIs now use same evaluation as humans (for some reason I didn't do this before???)
			bool bPeaceful = kMasterPlayer.GetDiplomacyAI()->IsEndVassalageRequestAcceptable(kVassalPlayer.GetID());
			GET_TEAM(kVassalPlayer.getTeam()).DoEndVassal(kMasterPlayer.getTeam(), bPeaceful, false);
		}
	}
	//We want this player to liberate their vassals
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_REVOKE_VASSAL_THIRD_OFFER);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// AI offers to make ePlayer his voluntary vassal
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_BECOME_MY_VASSAL)
	{
		if(bHuman)
		{
			CvAssertMsg(false, "Don't send vassalage statement to human!");
		}
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif
		}
	}
	// AI is happy that they were liberated from vassalage
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_LIBERATE_VASSAL)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATE_VASSAL);
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}

		// Liberate this vassal
		GET_TEAM(GetPlayer()->getTeam()).DoLiberateVassal(GET_PLAYER(ePlayer).getTeam());
	}
	// AI is upset that their taxes were raised
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_RAISED_HUMAN_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI is happy that their taxes were lowered
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_HUMAN_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI notifies human that their taxes were RAISED
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_RAISED_AI_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_NEGATIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}
	// AI notifies human that their taxes were LOWERED
	else if(MOD_DIPLOMACY_CIV4_FEATURES && eStatement == DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER)
	{
		if(bHuman)
		{
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_AI_MASTER, ePlayer);
			CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		else
		{
			CvAssertMsg(false, "Don't send this message to AI!");
		}
	}

#endif

	// Do we want peace with ePlayer?
	else if (eStatement == DIPLO_STATEMENT_REQUEST_PEACE)
	{
		if(bHuman)
		{
#if defined(MOD_BALANCE_CORE)
			int iOurWarScore = GetWarScore(ePlayer);
			int iTheirWarScore = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarScore(GetPlayer()->GetID());
			if(iOurWarScore > (iTheirWarScore + 10))
			{
				szText = GetDiploStringForMessage(DIPLO_MESSAGE_WINNER_PEACE_OFFER);
			}
			else
			{
#endif
			szText = GetDiploStringForMessage(DIPLO_MESSAGE_PEACE_OFFER);
#if defined(MOD_BALANCE_CORE)
			}
#endif
			CvDiplomacyRequests::SendDealRequest(GetPlayer()->GetID(), ePlayer, pDeal, DIPLO_UI_STATE_TRADE_AI_MAKES_OFFER, szText, LEADERHEAD_ANIM_POSITIVE);
		}
		// Offer to an AI player
		else
		{
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				GC.getGame().GetGameDeals().FinalizeMPDeal(*pDeal, true);
			}
			else
			{
				CvDeal kDeal = *pDeal;

				// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
				GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
				GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
			}
#else
			CvDeal kDeal = *pDeal;

			// Don't need to call DoOffer because we check to see if the deal works for both sides BEFORE sending
			GC.getGame().GetGameDeals().AddProposedDeal(kDeal);
			GC.getGame().GetGameDeals().FinalizeDeal(GetPlayer()->GetID(), ePlayer, true);
#endif

			LogPeaceMade(ePlayer);
		}
	}
}
//	-------------------------------------------------------------------------------------------------------------------
/// Does this AI have something to say to the world this turn?
void CvDiplomacyAI::DoMakePublicDeclaration(PublicDeclarationTypes eDeclaration, int iData1, int iData2, PlayerTypes eMustHaveMetPlayer, PlayerTypes eForSpecificPlayer)
{
	// Don't give Public Declarations if we're a human
	if(GetPlayer()->isHuman())
	{
		// TODO: jdh, check if we do want public declarations from humans
		return;
	}

	CvAssertMsg(eDeclaration >= 0, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeclaration < NUM_PUBLIC_DECLARATION_TYPES, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eForSpecificPlayer >= NO_PLAYER, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// We can be sending to no specific player
	CvAssertMsg(eForSpecificPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "";
	//LeaderheadAnimationTypes eAnimation;
	//DiploUIStateTypes eDiploState = DIPLO_UI_STATE_DEFAULT_ROOT;

	bool bActive = true;

	// We're protecting a Minor Civ, so watch out!
	if(eDeclaration == PUBLIC_DECLARATION_PROTECT_MINOR)
	{
		PlayerTypes eMinorCiv = (PlayerTypes) iData1;
		const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

		strText = GetDiploStringForMessage(DIPLO_MESSAGE_DECLARATION_PROTECT_CITY_STATE, NO_PLAYER, strMinorCivKey);
		//eAnimation = LEADERHEAD_ANIM_POSITIVE;
		//eDiploState = DIPLO_UI_STATE_DISCUSS_PROTECT_MINOR_CIV;

		DoMakeDeclarationInactive(PUBLIC_DECLARATION_PROTECT_MINOR, iData1, iData2);
	}

	// We're no longer protecting a Minor Civ, sorry...
	if(eDeclaration == PUBLIC_DECLARATION_ABANDON_MINOR)
	{
		// Make previous declarations to protect this Minor inactive
		DoMakeDeclarationInactive(PUBLIC_DECLARATION_PROTECT_MINOR, iData1, iData2);

		// No point in telling new people we JUST meet we're not protecting someone any more...
		bActive = false;

		PlayerTypes eMinorCiv = (PlayerTypes) iData1;
		const char* strMinorCivKey = GET_PLAYER(eMinorCiv).getNameKey();

		strText = GetDiploStringForMessage(DIPLO_MESSAGE_DECLARATION_ABANDON_CITY_STATE, NO_PLAYER, strMinorCivKey);
		//eAnimation = LEADERHEAD_ANIM_POSITIVE;
	}



	// Should also send to the other AIs here somehow



	// If our declaration is only for a specific player (e.g. we just met them) take that into account
	if(eForSpecificPlayer != NO_PLAYER)
	{
	}

	// Only add this declaration to the log if it's for everyone, as announcements to specific people are only for catching them up after meeting them later
	if(eForSpecificPlayer == NO_PLAYER)
	{
		DoAddNewDeclarationToLog(eDeclaration, iData1, iData2, eMustHaveMetPlayer, bActive);

		//Send notification to everyone that can get it.
		for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
			PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
			CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
			if(IsPlayerValid(eCurPlayer) 
				&& (eMustHaveMetPlayer == NO_PLAYER || GET_TEAM(kCurPlayer.getTeam()).isHasMet(GET_PLAYER(eMustHaveMetPlayer).getTeam()))){
				CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
				if(pNotifications){
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMACY_DECLARATION");
					strSummary << GetPlayer()->getCivilizationShortDescriptionKey();
					pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText, strSummary.toUTF8(), -1, -1, -1);
				}
			}
		}
	}
	else
	{
		//send notification to the specific player.
		CvPlayerAI& kSpecificPlayer = GET_PLAYER(eForSpecificPlayer);
		if(IsPlayerValid(eForSpecificPlayer) 
			&& (eMustHaveMetPlayer == NO_PLAYER || GET_TEAM(kSpecificPlayer.getTeam()).isHasMet(GET_PLAYER(eMustHaveMetPlayer).getTeam()))){	
			CvNotifications* pNotifications = kSpecificPlayer.GetNotifications();
			if(pNotifications){
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMACY_DECLARATION");
				strSummary << GetPlayer()->getCivilizationShortDescriptionKey();
				pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText, strSummary.toUTF8(), -1, -1, -1);
			}
		}
	}

	LogPublicDeclaration(eDeclaration, iData1, eForSpecificPlayer);
}

/// Any Major Civs we want to chat with?
void CvDiplomacyAI::DoContactMajorCivs()
{
	// NOTE: This function is broken up into two sections: AI contact opportunities, and then human contact opportunities
	// This is to prevent a nasty bug where the AI will continue making decisions as the diplo screen is firing up. Making humans
	// handled at the end prevents the Diplo AI from having this problem

	// Loop through AI Players
	PlayerTypes eLoopPlayer;
	int iPlayerLoop;

#if defined(MOD_ACTIVE_DIPLOMACY)
	if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
	{
		if (m_eTargetPlayer >= DIPLO_FIRST_PLAYER)
		{
			DoContactPlayer((PlayerTypes)m_eTargetPlayer);
		}
		else if (m_eTargetPlayer == DIPLO_ALL_PLAYERS || m_eTargetPlayer == DIPLO_AI_PLAYERS)
		{
			for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes)iPlayerLoop;

				if (!IsPlayerValid(eLoopPlayer))
					continue;

				// No humans
				if (GET_PLAYER(eLoopPlayer).isHuman())
					continue;

				DoContactPlayer(eLoopPlayer);
			}
		}
		if (m_eTargetPlayer == DIPLO_ALL_PLAYERS || m_eTargetPlayer == DIPLO_HUMAN_PLAYERS)
		{
			// JdH => contact humans by priority, but use a notification system instead of pop up the diplo screen
			// every AI can only talk to one human a time (as a human can only talk to one human a time
			// TODO: the one to one restriction should be removed in favor of a trade resource pool allocation
			if (!CvDiplomacyRequests::HasActiveDiploRequestWithHuman(m_pPlayer->GetID()))
			{
				vector<PlayerTypes> aeHumansByPriority;
				vector<PlayerTypes>::const_iterator priorityIter, humanIter;
				// bring players in priority order
				for (humanIter = CvDiplomacyRequests::s_aDiploHumans.begin(); humanIter != CvDiplomacyRequests::s_aDiploHumans.end(); ++humanIter)
				{
					eLoopPlayer = *humanIter;

					CvAssert(CvPreGame::isHuman(eLoopPlayer));
					CvAssert(GET_PLAYER(eLoopPlayer).isTurnActive());

					if (!IsPlayerValid(eLoopPlayer))
						continue;

					// No AI
					if (!GET_PLAYER(eLoopPlayer).isHuman())
						continue;

					// Only active Players
					if (!GET_PLAYER(eLoopPlayer).isTurnActive())
						continue;

					for (priorityIter = aeHumansByPriority.begin(); priorityIter != aeHumansByPriority.end(); ++priorityIter)
					{
						if (m_pDiploData->m_aTradePriority[*priorityIter] < m_pDiploData->m_aTradePriority[eLoopPlayer])
						{
							aeHumansByPriority.insert(priorityIter, eLoopPlayer);
							break;
						}
					}
					if (priorityIter == aeHumansByPriority.end())
					{
						aeHumansByPriority.push_back(eLoopPlayer);
					}
				}

				for (humanIter = aeHumansByPriority.begin(); humanIter != aeHumansByPriority.end(); ++humanIter)
				{
					DoContactPlayer(*humanIter);
					if (GET_PLAYER(*humanIter).GetDiplomacyRequests()->HasActiveRequestFrom(GetPlayer()->GetID()))
					{
						// we actually found someone worth talking with, the others must wait...
						break;
					}
				}
			}
		}
	}
	else
	{
		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(!IsPlayerValid(eLoopPlayer))
				continue;

			// No humans
			if(GET_PLAYER(eLoopPlayer).isHuman())
				continue;

			DoContactPlayer(eLoopPlayer);
		}

		// Loop through HUMAN Players - if we're not in MP
		if(!CvPreGame::isNetworkMultiplayerGame())
		{
			for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(!IsPlayerValid(eLoopPlayer))
					continue;

				// No AI
				if(!GET_PLAYER(eLoopPlayer).isHuman())
					continue;

				DoContactPlayer(eLoopPlayer);
			}
		}
	}
#else
	for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(!IsPlayerValid(eLoopPlayer))
			continue;

		// No humans
		if(GET_PLAYER(eLoopPlayer).isHuman())
			continue;

		DoContactPlayer(eLoopPlayer);
	}

	// Loop through HUMAN Players - if we're not in MP
	if(!CvPreGame::isNetworkMultiplayerGame())
	{
		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(!IsPlayerValid(eLoopPlayer))
				continue;

			// No AI
			if(!GET_PLAYER(eLoopPlayer).isHuman())
				continue;

			DoContactPlayer(eLoopPlayer);
		}
	}
#endif
}

/// Individual contact opportunity
void CvDiplomacyAI::DoContactPlayer(PlayerTypes ePlayer)
{
	if(!IsValidUIDiplomacyTarget(ePlayer))
		return;		// Can't contact the this player at the moment.

	int iDiploLogStatement;
	DiploStatementTypes eStatement;

	// We can use this deal pointer to form a trade offer
	CvDeal* pDeal = GC.getGame().GetGameDeals().GetTempDeal();

	// These can be used for info about deal items, e.g. what Minor Civ we're telling the guy to stay away from, etc.
	int iData1;
	int iData2;

	// If this is the same turn we've met a player, don't send anything his way quite yet - wait until we've said hello at least
	if(GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) == 0)
		return;

	// Clear out the scratch pad
	for(int iLoop = 0; iLoop < NUM_DIPLO_LOG_STATEMENT_TYPES; iLoop++)
	{
		m_paDiploLogStatementTurnCountScratchPad[iLoop] = MAX_TURNS_SAFE_ESTIMATE;
	}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		//End the gift exchange at the start of each round.
		GetPlayer()->GetDiplomacyAI()->SetOfferingGift(ePlayer, false);
		GetPlayer()->GetDiplomacyAI()->SetOfferedGift(ePlayer, false);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	pDeal->SetRequestingPlayer(NO_PLAYER);
#endif
#if defined(MOD_BALANCE_CORE)
	//Clear this data out before any deals are offered.
	SetCantMatchDeal(ePlayer, false);
#endif
	// Make a scratch pad keeping track of the last time we sent each message.  This way we can know what we've said in the past already - this member array will be used in the function calls below
	for(iDiploLogStatement = 0; iDiploLogStatement < MAX_DIPLO_LOG_STATEMENTS; iDiploLogStatement++)
	{
		eStatement = GetDiploLogStatementTypeForIndex(ePlayer, iDiploLogStatement);

		if(eStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			CvAssert(eStatement < NUM_DIPLO_LOG_STATEMENT_TYPES);

			m_paDiploLogStatementTurnCountScratchPad[eStatement] = GetDiploLogStatementTurnForIndex(ePlayer, iDiploLogStatement);
		}
	}

	eStatement = NO_DIPLO_STATEMENT_TYPE;

	iData1 = -1;
	iData2 = -1;

	pDeal->ClearItems();
	pDeal->SetFromPlayer(GetPlayer()->GetID());
	pDeal->SetToPlayer(ePlayer);

	// JON: Add in some randomization here?
	// How predictable do we want the AI to be with regards to what state they're in?

	// Note that the order in which the following functions are called is very important to how the AI behaves - first come, first served

	// AT PEACE
	if(!IsAtWar(ePlayer))
	{
		DoCoopWarTimeStatement(ePlayer, eStatement, iData1);
		DoCoopWarStatement(ePlayer, eStatement, iData1);

		// Some things we don't say to teammates
		if(GetPlayer()->getTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			// STATEMENTS - all members but ePlayer passed by address

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) 
			{
				// Some things we only say to our masters
				if(GET_TEAM(GetPlayer()->getTeam()).GetMaster() == GET_PLAYER(ePlayer).getTeam())
				{
					DoEndVassalageStatement(ePlayer, eStatement);
				}
			}
#endif

			DoAggressiveMilitaryStatement(ePlayer, eStatement);
			DoKilledCityStateStatement(ePlayer, eStatement, iData1);
			DoAttackedCityStateStatement(ePlayer, eStatement, iData1);
			DoBulliedCityStateStatement(ePlayer, eStatement, iData1);
			//DoSeriousExpansionWarningStatement(ePlayer, eStatement);
			DoExpansionWarningStatement(ePlayer, eStatement);
			DoExpansionBrokenPromiseStatement(ePlayer, eStatement);
			//DoSeriousPlotBuyingWarningStatement(ePlayer, eStatement);
			DoPlotBuyingWarningStatement(ePlayer, eStatement);
			DoPlotBuyingBrokenPromiseStatement(ePlayer, eStatement);

			DoWeAttackedYourMinorStatement(ePlayer, eStatement, iData1);
			DoWeBulliedYourMinorStatement(ePlayer, eStatement, iData1);

			DoKilledYourSpyStatement(ePlayer, eStatement);
			DoKilledMySpyStatement(ePlayer, eStatement);
			DoCaughtYourSpyStatement(ePlayer, eStatement);

			DoTheySupportedOurHosting(ePlayer, eStatement);
			DoWeLikedTheirProposal(ePlayer, eStatement);
			DoWeDislikedTheirProposal(ePlayer, eStatement);
			DoTheySupportedOurProposal(ePlayer, eStatement);
			DoTheyFoiledOurProposal(ePlayer, eStatement);

			DoConvertedMyCityStatement(ePlayer, eStatement);

			DoDugUpMyYardStatement(ePlayer, eStatement);

			DoDoFStatement(ePlayer, eStatement);
			DoDenounceFriendStatement(ePlayer, eStatement);
			DoDenounceStatement(ePlayer, eStatement);
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
			DoEndDoFStatement(ePlayer, eStatement);
#endif
#if !defined(MOD_BALANCE_CORE)
			DoRequestFriendDenounceStatement(ePlayer, eStatement, iData1);
#endif
			//DoWorkAgainstSomeoneStatement(ePlayer, eStatement, iData1);
			//DoEndWorkAgainstSomeoneStatement(ePlayer, eStatement, iData1);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) 
			{
				DoMapsOffer(ePlayer,eStatement,pDeal);
				DoTechOffer(ePlayer,eStatement,pDeal);

				DoRevokeVassalageStatement(ePlayer, eStatement, pDeal);
				DoMakeVassalageStatement(ePlayer, eStatement, pDeal);

				DoLiberateMyVassalStatement(ePlayer, eStatement);

				DoVassalTaxesRaisedStatement(ePlayer, eStatement);
				DoVassalTaxesLoweredStatement(ePlayer, eStatement);
			}
#endif
		}

		//	OFFERS - all members but ePlayer passed by address
		DoLuxuryTrade(ePlayer, eStatement, pDeal);
		DoEmbassyExchange(ePlayer, eStatement, pDeal);
		DoEmbassyOffer(ePlayer, eStatement, pDeal);
		DoOpenBordersExchange(ePlayer, eStatement, pDeal);
		DoOpenBordersOffer(ePlayer, eStatement, pDeal);
		DoResearchAgreementOffer(ePlayer, eStatement, pDeal);
#if defined(MOD_BALANCE_CORE_DEALS)
		if(MOD_BALANCE_CORE_DEALS)
		{
			DoStrategicTrade(ePlayer, eStatement, pDeal);
			DoDefensivePactOffer(ePlayer, eStatement, pDeal);
			DoCityTrade(ePlayer, eStatement, pDeal);
			DoCityExchange(ePlayer, eStatement, pDeal);
			DoThirdPartyWarTrade(ePlayer, eStatement, pDeal);
			DoThirdPartyPeaceTrade(ePlayer, eStatement, pDeal);
			DoVoteTrade(ePlayer, eStatement, pDeal);
		}
#endif
		DoRenewExpiredDeal(ePlayer, eStatement, pDeal);
		DoShareIntrigueStatement(ePlayer, eStatement);
		//DoResearchAgreementPlan(ePlayer, eStatement);

		DoRequest(ePlayer, eStatement, pDeal);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES) {
			DoGenerousOffer(ePlayer, eStatement, pDeal);
		}
#endif

		// Second set of things we don't say to teammates
		if(GetPlayer()->getTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			//DoNowUnforgivableStatement(ePlayer, eStatement);
			//DoNowEnemyStatement(ePlayer, eStatement);
			//DoFriendlyStatement(ePlayer, eStatement);

			DoAfraidStatement(ePlayer, eStatement);
			
			// Don't say this if they resurrected us, either
			if(!WasResurrectedBy(ePlayer))
			{
				DoHostileStatement(ePlayer, eStatement);
				DoWarmongerStatement(ePlayer, eStatement);
				DoMinorCivCompetitionStatement(ePlayer, eStatement, iData1);
			}

			// Don't bother with this fluff stuff it's just AI on AI stuff
			if(GET_PLAYER(ePlayer).isHuman())
			{
				if(!WasResurrectedBy(ePlayer))
				{
					DoAngryBefriendedEnemy(ePlayer, eStatement, iData1);
					DoAngryDenouncedFriend(ePlayer, eStatement, iData1);
				}
				
				DoHappyDenouncedEnemy(ePlayer, eStatement, iData1);
				DoHappyBefriendedFriend(ePlayer, eStatement, iData1);
				
				if(!WasResurrectedBy(ePlayer))
				{				
					DoFYIBefriendedHumanEnemy(ePlayer, eStatement, iData1);
					DoFYIDenouncedHumanFriend(ePlayer, eStatement, iData1);
				}
				
				DoFYIDenouncedHumanEnemy(ePlayer, eStatement, iData1);
				DoFYIBefriendedHumanFriend(ePlayer, eStatement, iData1);
				DoHappySamePolicyTree(ePlayer, eStatement);
				DoIdeologicalStatement(ePlayer, eStatement);
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
				DoVictoryCompetitionStatement(ePlayer, eStatement);
#endif
			}
		}
	}

	// AT WAR
	else if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		//	OFFERS - all members but ePlayer passed by address
		DoPeaceOffer(ePlayer, eStatement, pDeal);
	}

#if !defined(FINAL_RELEASE)
	// Check for an optional message injection from the Tuner
	if(eStatement == NO_DIPLO_STATEMENT_TYPE && m_eTestStatement != NO_DIPLO_STATEMENT_TYPE && ePlayer == m_eTestToPlayer)
	{
		eStatement = m_eTestStatement;
		iData1 = m_iTestStatementArg1;

		m_eTestStatement = NO_DIPLO_STATEMENT_TYPE;
	}
#endif

	// Now see if it's a valid time to send this message (we may have already sent it)
	if(eStatement != NO_DIPLO_STATEMENT_TYPE)
	{
		//if (bSendStatement)
		{
			LogStatementToPlayer(ePlayer, eStatement);

			DoSendStatementToPlayer(ePlayer, eStatement, iData1, pDeal);
			DoAddNewStatementToDiploLog(ePlayer, eStatement);
		}
	}
}

/// Any Minor Civs we want to chat with?
void CvDiplomacyAI::DoContactMinorCivs()
{
	// If the player has deleted the DIPLOMACY Flavor we have to account for that
	int iDiplomacyFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iGoldFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iTileImprovementFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iExpansionFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_DIPLOMACY")
		{
			iDiplomacyFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_GOLD")
		{
			iGoldFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_TILE_IMPROVEMENT")
		{
			iTileImprovementFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
		else if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")
		{
			iExpansionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		}
	}
	EconomicAIStrategyTypes eFoundCity = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_FOUND_CITY");
	EconomicAIStrategyTypes eExpandLikeCrazy = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_LIKE_CRAZY");
	EconomicAIStrategyTypes eExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	EconomicAIStrategyTypes eNeedHappiness = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS");
	EconomicAIStrategyTypes eNeedHappinessCritical = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL");
	EconomicAIStrategyTypes eLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");
	bool bFoundCity = (eFoundCity != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eFoundCity) : false;
	bool bExpandLikeCrazy = (eExpandLikeCrazy != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eExpandLikeCrazy) : false;
	bool bExpandToOtherContinents = (eExpandToOtherContinents != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eExpandToOtherContinents) : false;
	bool bNeedHappiness = (eNeedHappiness != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eNeedHappiness) : false;
	bool bNeedHappinessCritical = (eNeedHappinessCritical != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eNeedHappinessCritical) : false;
	bool bLosingMoney = (eLosingMoney != NO_ECONOMICAISTRATEGY) ? GetPlayer()->GetEconomicAI()->IsUsingStrategy(eLosingMoney) : false;

	// **************************
	// Would we like to buyout a minor this turn?  (Venice / Austria UA)
	// **************************
	bool bWantsToBuyout = false;
	if(GetPlayer()->IsAbleToAnnexCityStates())
	{
		if(bFoundCity || bExpandLikeCrazy || bExpandToOtherContinents ||
		        GetStateAllWars() == STATE_ALL_WARS_LOSING ||
		        IsGoingForWorldConquest() ||
		        m_pPlayer->calculateGoldRate() > 100)
		{
			bWantsToBuyout = true;
		}
		else
		{
			int iThreshold = iExpansionFlavor; //antonjs: todo: xml
			int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iExpansionFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			if(iRandRoll < iThreshold)
				bWantsToBuyout = true;
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayer()->IsDiplomaticMarriage())
	{
		//Always yes please
		bWantsToBuyout = true;
	}
#endif

	// **************************
	// Would we like to give a gold gift this turn?
	// **************************
	bool bWantsToMakeGoldGift = false;

	// If we're a highly diplomatic leader, then always look for an opportunity
	if(iDiplomacyFlavor >= /*4*/ GC.getMC_ALWAYS_GIFT_DIPLO_THRESHOLD() ||
	        IsGoingForDiploVictory() ||
	        IsGoingForCultureVictory() ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT) ||
	        IsHasActiveGoldQuest() ||
	        m_pPlayer->calculateGoldRate() > 100) // if we are very wealthy always do this
	{
		bWantsToMakeGoldGift = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iDiplomacyFlavor;
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iDiplomacyFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		// Threshold will be 15 for a player (3 flavor * 5)
		// Threshold will be 5 for non-diplomatic player (2 flavor * 5)

		if(iRandRoll < iThreshold)
			bWantsToMakeGoldGift = true;
	}

	// **************************
	// Would we like to get a unit by bullying this turn?
	// **************************
	bool bWantsToBullyUnit = false;
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	// Would we like to get Heavy Tribute by bullying this turn?
	if(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	{
		int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_GROWTH"));
		int iScienceFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_SCIENCE"));
		int iCultureFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_CULTURE"));
		int iFaithFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_RELIGION"));
		int iProductionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_PRODUCTION"));

		// Loop through all (known) Minors
		PlayerTypes eMinor;
		int iValue = 0;
		for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			eMinor = (PlayerTypes) iMinorLoop;

			if(GET_PLAYER(eMinor).isMinorCiv())
			{
				if((iScienceFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_SCIENCE));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
					}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iScienceFlavor + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

					if(iRandRoll < iThreshold)
						bWantsToBullyUnit = true;
						break;
				}
				else if((iProductionFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_PRODUCTION));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
					}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iProductionFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

					if(iRandRoll < iThreshold)
						bWantsToBullyUnit = true;
						break;
				}
				else if((iCultureFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_CULTURE));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
					}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iCultureFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

					if(iRandRoll < iThreshold)
						bWantsToBullyUnit = true;
						break;
				}
				else if((iFaithFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_FAITH));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
					}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iFaithFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

					if(iRandRoll < iThreshold)
						bWantsToBullyUnit = true;
						break;
				}
				else if((iGrowthFlavor >  6) && GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
				{
					iValue = (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_FOOD));
					int iThreshold = (iValue / 100);
					if (iThreshold <= 10)
					{
						iThreshold = 10;
					}
					int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iGrowthFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

					if(iRandRoll < iThreshold)
						bWantsToBullyUnit = true;
						break;
				}
				else
				{
					if(GetPlayer()->GetEconomicAI()->GetWorkersToCitiesRatio() < 0.25 &&  //antonjs: todo: XML
			        GetPlayer()->GetEconomicAI()->GetImprovedToImprovablePlotsRatio() < 0.50) //antonjs: todo: XML
					{
						bWantsToBullyUnit = true;
					}
					// Otherwise, do a random roll
					else
					{
						int iThreshold = iTileImprovementFlavor; //antonjs: todo: XML
						int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iTileImprovementFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

						if(iRandRoll < iThreshold)
							bWantsToBullyUnit = true;
					}
				}
			}
		}
	}
	else
	{
#endif	
	if(GetPlayer()->GetEconomicAI()->GetWorkersToCitiesRatio() < 0.25 &&  //antonjs: todo: XML
	        GetPlayer()->GetEconomicAI()->GetImprovedToImprovablePlotsRatio() < 0.50) //antonjs: todo: XML
	{
		bWantsToBullyUnit = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iTileImprovementFlavor; //antonjs: todo: XML
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iTileImprovementFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		if(iRandRoll < iThreshold)
			bWantsToBullyUnit = true;
	}
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
	}
#endif

	//antonjs: todo: if too many workers then set to false (ex. want to disband workers you have)

	// **************************
	// Would we like to get some gold by bullying this turn?
	// **************************
	bool bWantsToBullyGold = false;

	if(iGoldFlavor >= 6 ||  //antonjs: todo: GC.getMC_ALWAYS_BULLY_GOLD_THRESHOLD()
	        IsGoingForWorldConquest() ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_UNIT) ||
	        GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_BUILDING) ||
	        bLosingMoney ||
	        m_pPlayer->calculateGoldRate() < 0) // if we are losing gold per turn
	{
		bWantsToBullyGold = true;
	}
	// Otherwise, do a random roll
	else
	{
		int iThreshold = iGoldFlavor; //antonjs: todo: XML
		int iRandRoll = GC.getGame().getSmallFakeRandNum(10, iGoldFlavor+ m_pPlayer->getGlobalAverage(YIELD_CULTURE));

		if(iRandRoll < iThreshold)
			bWantsToBullyGold = true;
	}

	if(BULLY_DEBUGGING)
	{
		//bWantsToMakeGoldGift = false;
		//bWantsToBullyGold = true;
		//bWantsToBullyUnit = true;
	}

	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBuyout; // Austria UA
	CvWeightedVector<MinorGoldGiftInfo, MAX_PLAYERS, true> veMinorsToGiveGold;
	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBullyGold;
	CvWeightedVector<PlayerTypes, MAX_PLAYERS, true> veMinorsToBullyUnit;

	int iLargeGift = /*1000*/ GC.getMINOR_GOLD_GIFT_LARGE();
	int iMediumGift = /*500*/ GC.getMINOR_GOLD_GIFT_MEDIUM();
	int iSmallGift = /*250*/ GC.getMINOR_GOLD_GIFT_SMALL();
	int iLargeGiftFriendship;
	int iMediumGiftFriendship;
	int iSmallGiftFriendship;
	bool bMediumGiftAllies;
	bool bSmallGiftAllies;

	PlayerTypes eID = GetPlayer()->GetID();

	CvMinorCivInfo* pMinorInfo;
	CvPlayer* pMinor;
	CvMinorCivAI* pMinorCivAI;

	bool bIntruding;

	int iOtherMajorLoop;
	PlayerTypes eOtherMajor;
	int iFriendshipWithMinor;
	int iOtherPlayerFriendshipWithMinor;

	bool bWantsToConnect;

	MinorCivApproachTypes eApproach;

	int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_GROWTH"));

#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
	if(MOD_BALANCE_CORE_AFRAID_ANNEX)
	{
		if (GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
		{
			if(!GetPlayer()->IsEmpireUnhappy())
			{
				bWantsToBullyUnit = true;
				bWantsToBullyGold = false;
				bWantsToMakeGoldGift = false;
			}
		}
		if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
		{
			if (!GetPlayer()->IsEmpireUnhappy())
			{
				bWantsToBullyUnit = true;
				bWantsToBullyGold = true;
				bWantsToMakeGoldGift = false;
			}
		}
	}

	if (GetPlayer()->IsCanBullyFriendlyCS())
	{
		bWantsToBullyUnit = true;
		bWantsToBullyGold = true;
		bWantsToMakeGoldGift = false;
	}
	else if (GetPlayer()->GetBullyGlobalCSReduction())
	{
		bWantsToBullyUnit = true;
		bWantsToBullyGold = true;
		bWantsToMakeGoldGift = false;
	}
#endif
	// Loop through all (known) Minors
	PlayerTypes eMinor;
	TeamTypes eMinorTeam;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;

		pMinor = &GET_PLAYER(eMinor);
		pMinorCivAI = pMinor->GetMinorCivAI();
		eMinorTeam = pMinor->getTeam();

		bWantsToConnect = false;
		bool bWantsToGiveGoldToThisMinor = false;
		bool bWantsToBullyUnitFromThisMinor = false;
		bool bWantsToBullyGoldFromThisMinor = false;
		bool bWantsToBuyoutThisMinor = false;

		if(IsPlayerValid(eMinor))
		{
			// Can't do anything with minors we're at war with, besides make peace (which isn't done here, but in DoMakePeaceWithMinors())
			if(IsAtWar(eMinor))
				continue;

			eApproach = GetMinorCivApproach(eMinor);

			// Do we want to change our protection of this minor?
			DoUpdateMinorCivProtection(eMinor, eApproach);

			// Do we want to connect to this player?
			if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_ROUTE))
			{
				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE ||
				        eApproach == MINOR_CIV_APPROACH_FRIENDLY)
				{
					if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						bWantsToConnect = true;
				}
			}

			bIntruding = true;

			// We have open borders so we're definitely not intruding
			if(pMinorCivAI->IsPlayerHasOpenBorders(eID))
				bIntruding = false;

			else
			{
				// Cares and doesn't yet have enough friendship for Open Borders
				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE || eApproach == MINOR_CIV_APPROACH_FRIENDLY)
					bIntruding = false;
			}

			pMinorCivAI->SetMajorIntruding(eID, bIntruding);

			// Calculate desirability to buyout this minor
			if(bWantsToBuyout)
			{
				int iValue = 100; //antonjs: todo: xml
				// Only bother if we actually can buyout
				CvCity* pMinorCapital = pMinor->getCapitalCity();
				if(GetPlayer()->IsAbleToAnnexCityStates() && pMinorCivAI->CanMajorBuyout(eID) && pMinorCapital != NULL)
				{
					// Determine presence of player cities on this continent
					int iMinorArea = pMinorCapital->getArea();
					CvArea* pMinorArea = GC.getMap().getArea(iMinorArea);
					bool bPresenceInArea = false;
					int iMajorCapitalsInArea = 0;
					if(pMinorArea)
					{
						// Do we have a city here?
						if(pMinorArea->getCitiesPerPlayer(eID) > 0)
							bPresenceInArea = true;

						// Does another major civ have their capital here? (must be visible)
						for(int iMajorRivalLoop = 0; iMajorRivalLoop < MAX_MAJOR_CIVS; iMajorRivalLoop++)
						{
							PlayerTypes eMajorRivalLoop = (PlayerTypes) iMajorRivalLoop;
							if(eMajorRivalLoop == eID)
								continue;

							if(GET_PLAYER(eMajorRivalLoop).isAlive())
							{
								CvCity* pCapital = GET_PLAYER(eMajorRivalLoop).getCapitalCity();
								if(pCapital && pCapital->plot())
								{
									CvPlot* pPlot = pCapital->plot();
									if(pPlot->isVisible(GetPlayer()->getTeam()))
										iMajorCapitalsInArea++;
								}
							}
						}
					}
					else
					{
						CvAssertMsg(false, "Could not lookup minor civ's area! Please send Anton your save file and version.");
					}

					// How many units does the city-state have?
					int iMinorMilitaryUnits = 0;
					int iMinorUnits = 0;
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = pMinor->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pMinor->nextUnit(&iLoop))
					{
						if(pLoopUnit->IsCanAttack() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)
						{
							iMinorMilitaryUnits++;
						}
						iMinorUnits++;
					}

					// Foreign continent
					if(!bPresenceInArea)
					{
						// Military foothold to attack other majors
						if(IsGoingForWorldConquest() && iMajorCapitalsInArea > 0)
						{
							iValue += 100; //antonjs: todo: xml
						}
						// Expansion
						else if(bExpandToOtherContinents)
						{
							iValue += 60; //antonjs: todo: xml
						}
						else
						{
							iValue += -50; //antonjs: todo: xml
						}
					}
					// Continent we have presence on
					else
					{
						// Proximity plays a large factor, since we don't want a remote, isolated city
						if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						{
							iValue += 100; //antonjs: todo: xml
							// Military units could come to our rescue quickly
							if(GetStateAllWars() == STATE_ALL_WARS_LOSING)
							{
								if(iMinorMilitaryUnits > 0)  //antonjs: todo: xml
								{
									iValue += (iMinorMilitaryUnits) * 10; //antonjs: todo: xml
								}
								else
								{
									iValue -= 50; //antonjs: todo: xml
								}
							}
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
						{
							iValue += 10; //antonjs: todo: xml
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
						{
							iValue += -50; //antonjs: todo: xml
						}
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_DISTANT)
						{
							iValue += -100; //antonjs: todo: xml
						}
					}

					// Military units - How many, and can we support them?
					if(GetPlayer()->GetNumUnitsSupplied() >= GetPlayer()->getNumUnits() + iMinorUnits)
					{
						iValue += (iMinorMilitaryUnits) * 5;
					}

					// Happiness
					if(bNeedHappiness)
						iValue += -50; //antonjs: todo: xml
					if(bNeedHappinessCritical)
						iValue += -150; //antonjs: todo: xml

					// Potential bonuses lost
					MinorCivTraitTypes eTrait = pMinorCivAI->GetTrait();
					if(eTrait == MINOR_CIV_TRAIT_CULTURED && IsGoingForCultureVictory())
					{
						iValue += -70; //antonjs: todo: xml
					}
					else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)
					{
						if(bNeedHappiness)
							iValue += -100; //antonjs: todo: xml
						if(bNeedHappinessCritical)
							iValue += -150; //antonjs: todo: xml
					}

					// Time to decide - Do we want it enough?
					if(iValue > 100)  //antonjs: todo: xml
					{
						veMinorsToBuyout.push_back(eMinor, iValue);
						bWantsToBuyoutThisMinor = true;
					}
				}
#if defined(MOD_BALANCE_CORE)
				// Only bother if we actually can buyout
				if(GetPlayer()->IsDiplomaticMarriage() && pMinorCivAI->CanMajorDiploMarriage(eID))
				{
					veMinorsToBuyout.push_back(eMinor, 1000);
						bWantsToBuyoutThisMinor = true;
				}	
#endif
			}

			// Calculate desirability to give this minor gold
			if(bWantsToMakeGoldGift && !bWantsToBuyoutThisMinor)
			{
#if defined(MOD_DIPLOMACY_CITYSTATES)
				if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly())
				{
					continue;
				}
				if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == GetPlayer()->GetID())
				{
					continue;
				}
#endif
				int iValue = /*100*/ GC.getMC_GIFT_WEIGHT_THRESHOLD();
				// If we're not protective or friendly, then don't bother with minor diplo
				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE || eApproach == MINOR_CIV_APPROACH_FRIENDLY)
				{
					MinorGoldGiftInfo sGiftInfo;
					sGiftInfo.eMinor = eMinor;
					sGiftInfo.eMajorRival = NO_PLAYER;
					sGiftInfo.bQuickBoost = false;
					sGiftInfo.iGoldAmount = 0;

					// if we are rich we are more likely to, conversely if we are poor...
					iValue += min(max(0, m_pPlayer->calculateGoldRate() - 50),100);

					pMinorInfo = GC.getMinorCivInfo(pMinorCivAI->GetMinorCivType());

					// Diplo victory makes us more likely to spend gold
					if(IsGoingForDiploVictory())
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					// double up if this is the home stretch
					if(GC.getGame().IsUnitedNationsActive())
					{
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					}
					// Going for Culture victory, focus on Cultural city states
					else if(IsGoingForCultureVictory())
					{
						if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_CULTURED)
							iValue += /*100*/ GC.getMC_GIFT_WEIGHT_CULTURE_VICTORY();
					}
					// Going for Conquest victory, focus on Militaristic city states
					else if(IsGoingForWorldConquest())
					{
						if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
							iValue += /*100*/ GC.getMC_GIFT_WEIGHT_CONQUEST_VICTORY();
					}

					//antonjs: todo: work extra gold quest INF potential into the friends/allies/passing logic as well
					// Gold gift quest is active, so we would get more bang for our bucks
					if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_GIVE_GOLD))
					{
						iValue += 150; //antonjs: todo: constant/XML
					}

					// Invest quest is active, so we would get more bang for our bucks
					if(pMinorCivAI->IsActiveQuestForPlayer(eID, MINOR_CIV_QUEST_INVEST))
					{
						iValue += 100; //antonjs: todo: constant/XML
					}

					// having traits that give us bonuses also make us want to spend gold
					if(m_pPlayer->GetPlayerTraits()->GetCityStateFriendshipModifier() > 0 || m_pPlayer->GetPlayerTraits()->GetCityStateBonusModifier())
					{
						iValue += /*100*/ GC.getMC_GIFT_WEIGHT_DIPLO_VICTORY();
					}

					// Nearly everyone likes to grow
					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME && !GetPlayer()->IsEmpireUnhappy())
					{
						iValue += /*20*/ GC.getMC_GIFT_WEIGHT_MARITIME_GROWTH() * iGrowthFlavor * max(1, GetPlayer()->getNumCities() / 3);
					}

					// Slight negative weight towards militaristic
					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MILITARISTIC && !IsGoingForWorldConquest())
						iValue += /*-50*/ GC.getMC_GIFT_WEIGHT_MILITARISTIC();

					// If they have a resource we don't have, add extra weight
					int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(eID);
					if(iResourcesWeLack > 0)
						iValue += (iResourcesWeLack* /*80*/ GC.getMC_GIFT_WEIGHT_RESOURCE_WE_NEED());

					// If we're protective this is worth more than if we're friendly
					if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE)
						iValue += /*10*/ GC.getMC_GIFT_WEIGHT_PROTECTIVE();

					// If the minor is hostile, then reduce the weighting
					if(pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)
						iValue += /*-20*/ GC.getMC_GIFT_WEIGHT_HOSTILE();

					// The closer we are the better
					if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
						iValue += /*5*/ GC.getMC_GIFT_WEIGHT_NEIGHBORS();
					else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
						iValue += /*4*/ GC.getMC_GIFT_WEIGHT_CLOSE();
					else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
						iValue += /*3*/ GC.getMC_GIFT_WEIGHT_FAR();

					iLargeGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iLargeGift);
					iMediumGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iMediumGift);
					iSmallGiftFriendship = pMinorCivAI->GetFriendshipFromGoldGift(eID, iSmallGift);

					iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eID);

					// Only care if we'll actually be Allies or better
					bMediumGiftAllies = iFriendshipWithMinor + iMediumGiftFriendship >= pMinorCivAI->GetAlliesThreshold(eID);
					bSmallGiftAllies = iFriendshipWithMinor + iSmallGiftFriendship >= pMinorCivAI->GetAlliesThreshold(eID);

					// Loop through other players to see if we can pass them
					for(iOtherMajorLoop = 0; iOtherMajorLoop < MAX_MAJOR_CIVS; iOtherMajorLoop++)
					{
						eOtherMajor = (PlayerTypes) iOtherMajorLoop;

						// Player must be alive
						if(!GET_PLAYER(eOtherMajor).isAlive())
							continue;

						iOtherPlayerFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eOtherMajor);

						// Player must have friendship with this major
						if(iOtherPlayerFriendshipWithMinor <= 0)
							continue;

						// They must have more friendship with this guy than us
						if(iFriendshipWithMinor <= iOtherPlayerFriendshipWithMinor)
							continue;

						// If we can pass them with a small gift, great
						if(bSmallGiftAllies && iOtherPlayerFriendshipWithMinor - iFriendshipWithMinor < iSmallGiftFriendship)
						{
							iValue += /*15*/ GC.getMC_SMALL_GIFT_WEIGHT_PASS_OTHER_PLAYER();
							sGiftInfo.bQuickBoost = true;
							sGiftInfo.eMajorRival = eOtherMajor;
						}
						// If a medium gift passes them up, that's good too
						else if(bMediumGiftAllies && iOtherPlayerFriendshipWithMinor - iFriendshipWithMinor < iMediumGiftFriendship)
						{
							iValue += /*10*/ GC.getMC_GIFT_WEIGHT_PASS_OTHER_PLAYER();
							sGiftInfo.eMajorRival = eOtherMajor;
						}
						// We're behind and we can't catch up right now, so zero-out the value
						else
							iValue = 0;
					}

					// Are we already allies?
					if(pMinorCivAI->IsAllies(eID))
					{
						// Are we close to losing our status?
						if(pMinorCivAI->IsCloseToNotBeingAllies(eID))
						{
							iValue += /*150*/ GC.getMC_GIFT_WEIGHT_ALMOST_NOT_ALLIES();
							sGiftInfo.bQuickBoost = true;
						}
						// Not going to lose status, so not worth going after this guy
						else
							iValue = 0;
					}
					// Are we already Friends?
					else if(pMinorCivAI->IsFriends(eID))
					{
						// Are we close to losing our status?
						if(pMinorCivAI->IsCloseToNotBeingFriends(eID))
						{
							iValue += /*125*/ GC.getMC_GIFT_WEIGHT_ALMOST_NOT_FRIENDS();
							sGiftInfo.bQuickBoost = true;
						}
						// Not going to lose status, so not worth going after this guy
						else if(!IsGoingForDiploVictory() || !GC.getGame().IsUnitedNationsActive())
							iValue = 0;
					}

					// Did we bully you recently?  If so, giving you gold now would be very odd.
					if(pMinorCivAI->IsRecentlyBulliedByMajor(eID))
					{
						iValue -= 100; //antonjs: todo: constant/XML
					}

					//antonjs: consider: different behavior to CS that have been bullied by others, bullied by rival, etc.

					// Do we want it enough?
					if(iValue > GC.getMC_GIFT_WEIGHT_THRESHOLD())
					{
						veMinorsToGiveGold.push_back(sGiftInfo, iValue);
						bWantsToGiveGoldToThisMinor = true;
					}
				}
			}

			// Calculate desirability to bully a unit from this minor
			if (bWantsToBullyUnit && !bWantsToBuyoutThisMinor && !bWantsToGiveGoldToThisMinor)  //antonjs: todo: xml
			{
				int iValue = 100; //antonjs: todo: XML, bully threshold
				if(eApproach == MINOR_CIV_APPROACH_BULLY)
				{
					// Only bother if we can successfully bully
					if(pMinor->GetMinorCivAI()->CanMajorBullyUnit(eID))
					{
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						if (MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						{
							int iGrowthFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH")) / 2;
							int iScienceFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SCIENCE")) / 2;
							int iCultureFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE")) / 2;
							int iFaithFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION")) / 2;
							int iProductionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_PRODUCTION")) / 2;

							if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_SCIENCE) * iScienceFlavor);
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_PRODUCTION) * iProductionFlavor);
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_CULTURE) * iCultureFlavor);
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_FAITH) * iFaithFlavor);
							}
							else if (GET_PLAYER(eMinor).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
							{
								iValue += (GET_PLAYER(eMinor).GetMinorCivAI()->GetYieldTheftAmount(GetPlayer()->GetID(), YIELD_FOOD) * iGrowthFlavor);
							}
							iValue += GC.getGame().getSmallFakeRandNum(GetBoldness(), eID+m_pPlayer->getGlobalAverage(YIELD_CULTURE));
						}
						else
						{
#endif
						// The closer we are the better, because the unit travels less distance to get home
						if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
							iValue += 50;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
							iValue += 30;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_FAR)
							iValue += -30;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_DISTANT)
							iValue += -50;
						//antonjs: consider: knock it down if is there a chance the worker will get captured by a nearby rival
#if defined(MOD_BALANCE_CORE_MINOR_VARIABLE_BULLYING)
						}
#endif
						//antonjs: consider: if military unit, it would be a good thing to get it near a rival or ongoing war

						// If this minor has a PtP from someone, bullying it could have big consequences
						if(pMinor->GetMinorCivAI()->IsProtectedByAnyMajor())
						{
							iValue += -20;
							//antonjs: consider: scale based on which major is protecting it
						}
						else
						{
							iValue += 20;
						}
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if(MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
							{
								if(!GetPlayer()->IsEmpireUnhappy())
								{
									iValue += 100;
								}
								else
								{
									iValue -= 50;
								}
							}
						}
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if (MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
							{
								iValue += 100;
							}
						}
#endif
						//antonjs: consider: allies or friends with another major
						//antonjs: consider: distance to other majors
						// If we are getting a bonus, don't mess that up!
						if(pMinor->GetMinorCivAI()->IsAllies(eID) || pMinor->GetMinorCivAI()->IsFriends(eID))
						{
							iValue = 0;
						}
						// Do we want it enough?
						if(iValue > 100)  //antonjs: todo: XML for threshold
						{
							veMinorsToBullyUnit.push_back(eMinor, iValue);
							bWantsToBullyUnitFromThisMinor = true;
						}
					}
				}
			}

			// Calculate desirability to bully gold from this minor
			if(bWantsToBullyGold && !bWantsToBuyoutThisMinor && !bWantsToGiveGoldToThisMinor && !bWantsToBullyUnitFromThisMinor)
			{
				int iValue = 100; //antonjs: todo: XML, bully threshold
				if(eApproach == MINOR_CIV_APPROACH_BULLY)
				{
					// Only bother if we can successfully bully
					if(pMinor->GetMinorCivAI()->CanMajorBullyGold(eID))
					{

						// The closer we are the better
						if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_NEIGHBORS)
							iValue += 40;
						else if(GetPlayer()->GetProximityToPlayer(eMinor) == PLAYER_PROXIMITY_CLOSE)
							iValue += 20;

						// We like to keep bullying the same minor
						if(pMinor->GetMinorCivAI()->IsEverBulliedByMajor(eID))
						{
							iValue += 20;
						}

						// If we have not bullied this minor recently, but someone else has, it might be good to wait for an opportunity to gain a lot of INF
						if(!pMinor->GetMinorCivAI()->IsRecentlyBulliedByMajor(eID) && pMinor->GetMinorCivAI()->IsRecentlyBulliedByAnyMajor())
						{
							iValue += -10;
							//antonjs: consider: but if everyone near the minor has bullied it, then there is nobody to come to its rescue, so we can bully safely
						}

						// If this minor has a PtP from someone, bullying it could have big consequences
						if(pMinor->GetMinorCivAI()->IsProtectedByAnyMajor())
						{
							iValue += -10;
							//antonjs: consider: scale based on which major is protecting it
						}
						else
						{
							iValue += 10;
						}
						//antonjs: consider: allies or friends another major
						//antonjs: consider: distance to other majors

#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
						//Do we get a bonus from this?
						if (MOD_BALANCE_CORE_AFRAID_ANNEX)
						{
							if (GetPlayer()->GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0 || GetPlayer()->GetPlayerTraits()->GetBullyValueModifier() != 0)
							{
								iValue += 100;
							}
						}
#endif

						// If we are getting a bonus, don't mess that up!
						if(pMinor->GetMinorCivAI()->IsAllies(eID) || pMinor->GetMinorCivAI()->IsFriends(eID))
						{
							iValue = 0;
						}

						// Do we want it enough?
						if(iValue > 100)  //antonjs: todo: XML for threshold
						{
							veMinorsToBullyGold.push_back(eMinor, iValue);
							bWantsToBullyGoldFromThisMinor = true;
						}
					}
				}
			}

		}

		SetWantToRouteConnectToMinor(eMinor, bWantsToConnect);
	}

	int iGoldReserve = GetPlayer()->GetTreasury()->GetGold();

	// Do we want to buyout a minor?
	if(veMinorsToBuyout.size() > 0)
	{
		veMinorsToBuyout.SortItems();
		int iGoldLeft = GetPlayer()->GetTreasury()->GetGold();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBuyout.size(); i++)
		{
			eLoopMinor = veMinorsToBuyout.GetElement(i);
			int iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetBuyoutCost(eID);
			if(iGoldLeft >= iBuyoutCost)
			{
				if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBuyout(eID))
				{
					GC.getGame().DoMinorBuyout(eID, eLoopMinor);
					iGoldLeft -= iBuyoutCost;
					break; // Don't buyout more than once in a single turn
				}
				else
				{
					CvAssertMsg(false, "Chose a minor to buyout that cannot actually be bought! Please send Anton your save file and version.");
				}
			}
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					LogMinorCivBuyout(eLoopMinor, iBuyoutCost, /*bSaving*/ true);

					int iPriority = GC.getAI_GOLD_PRIORITY_BUYOUT_CITY_STATE();
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iBuyoutCost, iPriority);
				}
			}
#if defined(MOD_BALANCE_CORE)
			iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetMarriageCost(eID);
			if(iGoldLeft >= iBuyoutCost)
			{
				if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorDiploMarriage(eID))
				{
					GET_PLAYER(eLoopMinor).GetMinorCivAI()->DoMarriage(eID);
					iBuyoutCost = GET_PLAYER(eLoopMinor).GetMinorCivAI()->GetMarriageCost(eID);
					iGoldLeft -= iBuyoutCost;
				}
				else
				{
					CvAssertMsg(false, "Chose a minor to buyout that cannot actually be bought! Please send Anton your save file and version.");
				}
			}
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					LogMinorCivBuyout(eLoopMinor, iBuyoutCost, /*bSaving*/ true);

					int iPriority = GC.getAI_GOLD_PRIORITY_BUYOUT_CITY_STATE();
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iBuyoutCost, iPriority);
				}
			}
#endif
		}
	}

	// Do we want to give someone Gold enough to actually do it?
	if(veMinorsToGiveGold.size() > 0)
	{
		veMinorsToGiveGold.SortItems(); // Sort from highest desirability to lowest
		for(int i = 0; i < veMinorsToGiveGold.size(); i++)
		{
			int iGoldLeft = GetPlayer()->GetTreasury()->GetGold();
			MinorGoldGiftInfo sGift = veMinorsToGiveGold.GetElement(i);
#if defined(MOD_BALANCE_CORE)
			//Interception! Let's do a tile improvement if we can (and we'll benefit from it)
			if (sGift.eMinor != NO_PLAYER && GET_PLAYER(sGift.eMinor).GetMinorCivAI()->IsFriends(GetPlayer()->GetID()))
			{
				CvPlot* pImprovementPlot = GET_PLAYER(sGift.eMinor).GetMinorCivAI()->GetMajorGiftTileImprovement(GetPlayer()->GetID());
				if (pImprovementPlot != NULL)
				{
					GET_PLAYER(sGift.eMinor).GetMinorCivAI()->DoTileImprovementGiftFromMajor(GetPlayer()->GetID(), pImprovementPlot->getX(), pImprovementPlot->getY());
					LogMinorCivGiftTile(sGift.eMinor);
				}
			}
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
			//Default is 1 - this will prevent the AI from trying to spam gold gifts of zero gold.
			if (MOD_DIPLOMACY_CITYSTATES && GC.getCSD_GOLD_GIFT_DISABLED() > 0)
			{
				continue;
			}
#endif			
			sGift.iGoldAmount = 0;

			if(iGoldLeft >= iSmallGift && sGift.bQuickBoost)
				sGift.iGoldAmount = iSmallGift;
			else if(iGoldLeft >= iLargeGift)
				sGift.iGoldAmount = iLargeGift;
			else if(iGoldLeft >= iMediumGift)
				sGift.iGoldAmount = iMediumGift;

			int iOldFriendship = GET_PLAYER(sGift.eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eID);

			// Able to give a gift?  Don't gift more than half of the gold we have in one turn
			if(sGift.iGoldAmount > 0 && iGoldLeft >= (iGoldReserve / 2))
			{
				GET_PLAYER(sGift.eMinor).GetMinorCivAI()->DoGoldGiftFromMajor(GetPlayer()->GetID(), sGift.iGoldAmount); //antonjs: todo: go through CvGame instead?

				LogMinorCivGiftGold(sGift.eMinor, iOldFriendship, sGift.iGoldAmount, /*bSaving*/ false, sGift.bQuickBoost, sGift.eMajorRival);

				if(GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
					GetPlayer()->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT);
			}
			// Can't afford gift yet, so start saving
			else
			{
				if(!GetPlayer()->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT))
				{
					int iAmountToSaveFor = iMediumGift;

					if(sGift.bQuickBoost)
						iAmountToSaveFor = iSmallGift;

					LogMinorCivGiftGold(sGift.eMinor, iOldFriendship, iAmountToSaveFor, /*bSaving*/ true, sGift.bQuickBoost, sGift.eMajorRival);

					int iPriority = GC.getAI_GOLD_PRIORITY_DIPLOMACY_BASE();
					iPriority += GC.getAI_GOLD_PRIORITY_DIPLOMACY_PER_FLAVOR_POINT() * iDiplomacyFlavor;
					GetPlayer()->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_MINOR_CIV_GIFT, iAmountToSaveFor, iPriority);
				}
			}
		}
	}

	// Do we want a unit enough to bully someone?
	if(veMinorsToBullyUnit.size() > 0)
	{
		veMinorsToBullyUnit.SortItems();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBullyUnit.size(); i++)
		{
			eLoopMinor = veMinorsToBullyUnit.GetElement(i);
			CvAssertMsg(eLoopMinor != NO_PLAYER, "Trying to bully a unit from NO_PLAYER! Please send Anton your save file and version.");
			if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBullyUnit(eID))
			{
				GC.getGame().DoMinorBullyUnit(eID, eLoopMinor);
				break; // Don't bully a unit more than once in a single turn
			}
			else
			{
				CvAssertMsg(false, "Chose a minor to bully unit from that cannot actually be bullied! Please send Anton your save file and version.");
			}
		}
	}

	// Do we want gold enough to bully someone?
	if(veMinorsToBullyGold.size() > 0)
	{
		veMinorsToBullyGold.SortItems();
		PlayerTypes eLoopMinor = NO_PLAYER;
		for(int i = 0; i < veMinorsToBullyGold.size(); i++)
		{
			eLoopMinor = veMinorsToBullyGold.GetElement(i);
			CvAssertMsg(eLoopMinor != NO_PLAYER, "Trying to bully gold from NO_PLAYER! Please send Anton your save file and version.");
			if(GET_PLAYER(eLoopMinor).GetMinorCivAI()->CanMajorBullyGold(eID))
			{
				GC.getGame().DoMinorBullyGold(eID, eLoopMinor);
			}
			else
			{
				CvAssertMsg(false, "Chose a minor to bully gold from that cannot actually be bullied! Please send Anton your save file and version.");
			}
		}
	}
}

void CvDiplomacyAI::DoUpdateMinorCivProtection(PlayerTypes eMinor, MinorCivApproachTypes eApproach)
{
	// Only change protection if this player is not human controlled!
	if(!GetPlayer()->isHuman())
	{
#if defined(MOD_BALANCE_CORE)
		if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE || GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetPlayer()->GetID())
#else
		if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE)
#endif
		{
			// We are protective, so do a PtP if we are able to and haven't already
			if(GET_PLAYER(eMinor).GetMinorCivAI()->CanMajorStartProtection(GetPlayer()->GetID()))
			{
				GC.getGame().DoMinorPledgeProtection(GetPlayer()->GetID(), eMinor, true);
				DoMakePublicDeclaration(PUBLIC_DECLARATION_PROTECT_MINOR, eMinor, -1, eMinor);
			}
		}
		else
		{
			// We are not protective, so revoke PtP if we can
			if(GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()) && GET_PLAYER(eMinor).GetMinorCivAI()->CanMajorWithdrawProtection(GetPlayer()->GetID()))
			{
				GC.getGame().DoMinorPledgeProtection(GetPlayer()->GetID(), eMinor, false);
				DoMakePublicDeclaration(PUBLIC_DECLARATION_ABANDON_MINOR, eMinor, -1, eMinor);
			}
		}
	}
}

/// Possible Contact Statement - Notify human it's time for a coop war they agreed to
void CvDiplomacyAI::DoCoopWarTimeStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Don't send this to AI players - coop war timer is automatically handled in DoCounters()
		if(!GET_PLAYER(ePlayer).isHuman())
			return;

		CvTeam* pTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());

		PlayerTypes eTargetPlayer;
		TeamTypes eTargetTeam;

		for(int iTargetLoop = 0; iTargetLoop < MAX_MAJOR_CIVS; iTargetLoop++)
		{
			eTargetPlayer = (PlayerTypes) iTargetLoop;

			bool bInvalid = false;
			if (!IsPlayerValid(eTargetPlayer))
			{
				bInvalid = true;
			}

			if (!GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eTargetPlayer).getTeam(), GetPlayer()->GetID()))
			{
				bInvalid = true;
			}

			if (bInvalid)
			{
				if (GetCoopWarAcceptedState(ePlayer, eTargetPlayer) == COOP_WAR_STATE_SOON)
				{
					SetCoopWarAcceptedState(ePlayer, eTargetPlayer, NO_COOP_WAR_STATE);
					SetCoopWarCounter(ePlayer, eTargetPlayer, -666);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(GetPlayer()->GetID(), eTargetPlayer, NO_COOP_WAR_STATE);
					GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(GetPlayer()->GetID(), eTargetPlayer, -666);
				}
				continue;
			}

			// Agreed to go to war soon... what's the counter at?
			if(GetCoopWarAcceptedState(ePlayer, eTargetPlayer) == COOP_WAR_STATE_SOON)
			{
				if(GetCoopWarCounter(ePlayer, eTargetPlayer) == /*10*/ GC.getCOOP_WAR_SOON_COUNTER())
				{
					eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();

					// If we're already at war, don't bother
					if(!pTeam->isAtWar(eTargetTeam) && GET_PLAYER(eTargetPlayer).isAlive())
					{
						eStatement = DIPLO_STATEMENT_COOP_WAR_TIME;
						iData1 = eTargetPlayer;

						// Don't evaluate other players
						break;
					}
					// Human is already at war - process what we would have if he'd agreed at this point
					else
					{
						SetCoopWarAcceptedState(ePlayer, eTargetPlayer, COOP_WAR_STATE_ACCEPTED);

						// AI declaration
						if(!IsAtWar(eTargetPlayer) && GET_PLAYER(eTargetPlayer).isAlive())
						{
							if (DeclareWar(eTargetPlayer))
							{
								GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eTargetPlayer, 1);
							}
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Coop War Request
void CvDiplomacyAI::DoCoopWarStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (IsWarDisallowedGlobal())
		{
			return;
		}
		
		// Don't ask humans for war if AI is set to passive mode, that's weird
		if (IsWarDisallowedHuman() && GET_PLAYER(ePlayer).isHuman())
		{
			return;
		}
		
		// slewis - added so that a player already at war wouldn't try to start another war with another player. The AI should try to only have one war going at a time if possible.
		if (GET_TEAM(GetTeam()).getAtWarCount(true) == 0)
		{
			PlayerTypes eTargetPlayer;
			if(DoTestCoopWarDesire(ePlayer, /*passed by address*/ eTargetPlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_COOP_WAR_REQUEST;
				int iTurnsBetweenStatements = 10;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					bool bSendStatement = true;

					//// 1 in 2 chance we don't actually send the message (don't want full predictability)
					//if (50 < GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to work with a player"))
					//	bSendStatement = false;

					if(bSendStatement)
					{
						eStatement = eTempStatement;
						iData1 = eTargetPlayer;
					}

					// Add this statement to the log so we don't evaluate it again until time has passed
					else
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
				}
			}	
		}
	}
}

/// Possible Contact Statement - Demand
void CvDiplomacyAI::DoMakeDemand(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetDemandTargetPlayer() == ePlayer)
		{
			if(IsDemandReady())
			{
				if(GetPlayer()->GetDealAI()->IsMakeDemand(ePlayer, /*pDeal can be modified in this function*/ pDeal))
				{
					DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DEMAND;
					int iTurnsBetweenStatements = 40;

					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
						eStatement = eTempStatement;

					DoSendStatementToPlayer(ePlayer, eStatement, -1, pDeal);
					LogStatementToPlayer(ePlayer, eStatement);
					DoAddNewStatementToDiploLog(ePlayer, eStatement);
				}
				else
				{
					// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
					pDeal->ClearItems();
					DoCancelHaltDemandProcess();
					//DeclareWar(ePlayer);
				}
			}
		}
	}
}

/// Possible Contact Statement - guy has his military positioned aggressively near us
void CvDiplomacyAI::DoAggressiveMilitaryStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;

		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;

		// Don't threaten if this person resurrected us
		if (WasResurrectedBy(ePlayer))
		{
			return;
		}

		// They're HIGH this turn and weren't last turn
		if(GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_HIGH && GetLastTurnMilitaryAggressivePosture(ePlayer) < AGGRESSIVE_POSTURE_HIGH)
			bSendStatement = true;

		// They're MEDIUM this turn and were NONE last turn
		else if(GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM && GetLastTurnMilitaryAggressivePosture(ePlayer) <= AGGRESSIVE_POSTURE_NONE)
			bSendStatement = true;

		// We're working together, so don't worry about it
		if(IsDoFAccepted(ePlayer))
			return;

#if defined(MOD_BALANCE_CORE)
		//We're allowing them Open Borders? We shouldn't care.
		if(GET_TEAM(GetPlayer()->getTeam()).IsAllowsOpenBordersToTeam(GET_PLAYER(ePlayer).getTeam()))
			return;
#endif

		// Check other player status
		PlayerTypes eThirdParty;
		for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
		{
			eThirdParty = (PlayerTypes) iThirdPartyLoop;

			// Are we at war with the same player?
			if(IsAtWar(eThirdParty) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(eThirdParty).getTeam()))
				return;

			// Are they at war with anyone we're neighbors with?
			if(GetPlayer()->GetProximityToPlayer(eThirdParty) == PLAYER_PROXIMITY_NEIGHBORS && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(eThirdParty).getTeam()))
				return;
		}

		if(bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING;
			int iTurnsBetweenStatements = 40;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Killed a City-State we're protective towards
void CvDiplomacyAI::DoKilledCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;

		if(IsPlayerMadeAttackCityStatePromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorKilled(ePlayer);
				if(eMinorCiv != NO_PLAYER)
				{
					CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
					CvAssert(eMinorCiv < MAX_CIV_PLAYERS);

					eStatement = eTempStatement;

					iData1 = eMinorCiv;
				}
			}
		}
	}
}

/// Possible Contact Statement - Attacked a City-State we're protective towards
void CvDiplomacyAI::DoAttackedCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;
		if(GetTurnsSincePlayerAttackedProtectedMinor(ePlayer) == 0)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE;
			int iTurnsBetweenStatements = 1;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorAttacked(ePlayer);
				if(eMinorCiv != NO_PLAYER)
				{
					CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
					CvAssert(eMinorCiv < MAX_CIV_PLAYERS);
					// Minor civ must still be alive!
					if(GET_PLAYER(eMinorCiv).isAlive())
					{	
						eStatement = eTempStatement;
						iData1 = eMinorCiv;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Bullied a City-State we're protective towards
void CvDiplomacyAI::DoBulliedCityStateStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;

		// Bullied a City State we're protective towards
		if(GetTurnsSincePlayerBulliedProtectedMinor(ePlayer) == 0)
		{
			// Have we asked you to make a promise before?
			if(IsPlayerBrokenBullyCityStatePromise(ePlayer) ||
			        IsPlayerIgnoredBullyCityStatePromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
#if defined(MOD_DIPLOMACY_CITYSTATES)
				if (MOD_DIPLOMACY_CITYSTATES && (GetMajorCivApproach(ePlayer, false) <= MAJOR_CIV_APPROACH_HOSTILE))
				{
					const char* strText;
					bool bActivePlayer = GC.getGame().getActivePlayer() == ePlayer;
					if (DeclareWar(ePlayer))
					{
						GetPlayer()->GetMilitaryAI()->RequestBasicAttack(ePlayer, 1);
					}

					if(bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WARMONGER);
						gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
					}
				}
#endif
			}
			else if(IsPlayerMadeBullyCityStatePromise(ePlayer))
			{
				// You broke the promise you made!
				SetPlayerBrokenBullyCityStatePromise(ePlayer, true);
				SetPlayerMadeBullyCityStatePromise(ePlayer, false);
#if defined(MOD_BALANCE_CORE)
				SetPlayerBackstabCounter(ePlayer, 0);
#endif
			}
			// Otherwise, ask you to make a promise
			else
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE;
				int iTurnsBetweenStatements = 1;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					PlayerTypes eMinorCiv = GetOtherPlayerProtectedMinorBullied(ePlayer);
					if(eMinorCiv != NO_PLAYER)
					{
						CvAssert(eMinorCiv >= MAX_MAJOR_CIVS);
						CvAssert(eMinorCiv < MAX_CIV_PLAYERS);
						// Minor civ must still be alive!
						if(GET_PLAYER(eMinorCiv).isAlive())
						{
							eStatement = eTempStatement;
							iData1 = eMinorCiv;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Comment on aggressive expansion by this player
void CvDiplomacyAI::DoExpansionWarningStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;
		if (GET_PLAYER(ePlayer).GetTurnsSinceSettledLastCity() < GC.getEXPANSION_BICKER_TIMEOUT() && !EverMadeExpansionPromise(ePlayer) && !IsPlayerMadeExpansionPromise(ePlayer) && !IsPlayerIgnoredExpansionPromise(ePlayer) && !IsPlayerBrokenExpansionPromise(ePlayer))
		{
			// We're fiercely opposed to their expansion
			if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_FIERCE)
				bSendStatement = true;

			// Have a strong dispute over land now, and didn't last turn
			else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetLastTurnLandDisputeLevel(ePlayer) < DISPUTE_LEVEL_STRONG)
			{
				if(GetExpansionAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM)
					bSendStatement = true;
			}
		}

		if(bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXPANSION_WARNING;
			int iTurnsBetweenStatements = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Tell the player he broke his expansion promise
void CvDiplomacyAI::DoExpansionBrokenPromiseStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsPlayerBrokenExpansionPromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Comment on aggressive Plot Buying by this player
void CvDiplomacyAI::DoPlotBuyingWarningStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bSendStatement = false;
		if (!EverMadeBorderPromise(ePlayer) && !IsPlayerMadeBorderPromise(ePlayer) && !IsPlayerBrokenBorderPromise(ePlayer) && !IsPlayerIgnoredBorderPromise(ePlayer))
		{
			if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			{
				// We've spotten them buying up Plots
				if(GetPlotBuyingAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_LOW)
					bSendStatement = true;
			}
		}

		if(bSendStatement)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_PLOT_BUYING_WARNING;
			int iTurnsBetweenStatements = (GC.getBORDER_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}

	}
}

/// Possible Contact Statement - Tell the player he broke his Plot Buying promise
void CvDiplomacyAI::DoPlotBuyingBrokenPromiseStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsPlayerBrokenBorderPromise(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - We attacked a minor that is protected by someone
void CvDiplomacyAI::DoWeAttackedYourMinorStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;
		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			PlayerTypes eMinor = (PlayerTypes) iMinorCivLoop;
			if(GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(ePlayer))
			{
				if(IsAtWar(eMinor))
				{
					// Did we deal them damage last turn?
					if(GetOtherPlayerWarValueLost(eMinor, GetPlayer()->GetID()) > GetOtherPlayerLastRoundWarValueLost(eMinor, GetPlayer()->GetID()))
					{
						// Has this message not yet been sent during this war?
						if(!HasSentAttackProtectedMinorTaunt(ePlayer, eMinor))
						{
							DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR;
							int iTurnsBetweenStatements = 1;
							if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
							{
								CvAssert(eMinor >= MAX_MAJOR_CIVS);
								CvAssert(eMinor < MAX_CIV_PLAYERS);

								eStatement = eTempStatement;
								iData1 = eMinor;
							}
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - We bullied a minor that is protected by someone
void CvDiplomacyAI::DoWeBulliedYourMinorStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;
		PlayerTypes eMinor;
		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)
		{
			eMinor = (PlayerTypes) iMinorCivLoop;

			// Minor must be alive
			if(!GET_PLAYER(eMinor).isAlive())
				continue;

			// Did we bully this minor last turn?
			if(GET_PLAYER(eMinor).GetMinorCivAI()->IsEverBulliedByMajor(GetPlayer()->GetID()))
			{
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetTurnLastBulliedByMajor(GetPlayer()->GetID()) == (GC.getGame().getGameTurn() - 1))
				{
					// Is this minor protected by this player?
					if(GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(ePlayer))
					{
						DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR;

						int iTurnsBetweenStatements = 1;

						if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
						{
							CvAssert(eMinor >= MAX_MAJOR_CIVS);
							CvAssert(eMinor < MAX_CIV_PLAYERS);

							eStatement = eTempStatement;
							iData1 = eMinor;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - We caught this player spying on us
void CvDiplomacyAI::DoCaughtYourSpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[ePlayer] == GC.getGame().getGameTurn())
		{
			// Have we asked you to make a promise before?
			if(IsPlayerBrokenSpyPromise(ePlayer) || IsPlayerIgnoredSpyPromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
			}
			else if(IsPlayerMadeSpyPromise(ePlayer))
			{
				// You broke the promise you made!
				SetPlayerBrokenSpyPromise(ePlayer, true);
				SetPlayerMadeSpyPromise(ePlayer, false);
#if defined(MOD_BALANCE_CORE)
				SetPlayerBackstabCounter(ePlayer, 0);
#endif
			}
			// Otherwise, ask you to make a promise
			else
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_CAUGHT_YOUR_SPY;
#if defined(MOD_BALANCE_CORE_SPIES)
				int iTurnsBetweenStatements = 40;
#else
				int iTurnsBetweenStatements = 1;
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We killed this player's spy
void CvDiplomacyAI::DoKilledYourSpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(m_pPlayer->GetEspionageAI()->m_aiNumSpiesKilled[ePlayer] > 0)
		{
			if(m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyKilled[ePlayer] == GC.getGame().getGameTurn())
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_YOUR_SPY;
#if defined(MOD_BALANCE_CORE_SPIES)
				int iTurnsBetweenStatements = 40;
#else
				int iTurnsBetweenStatements = 1;
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - This player killed our spy
void CvDiplomacyAI::DoKilledMySpyStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyDied[ePlayer] == GC.getGame().getGameTurn() - 1)
		{
			// Have we asked you to make a promise before?
			if(IsPlayerBrokenSpyPromise(ePlayer) || IsPlayerIgnoredSpyPromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
			}
			else if(IsPlayerMadeSpyPromise(ePlayer))
			{
				// You broke the promise you made!
				SetPlayerBrokenSpyPromise(ePlayer, true);
				SetPlayerMadeSpyPromise(ePlayer, false);
#if defined(MOD_BALANCE_CORE)
				SetPlayerBackstabCounter(ePlayer, 0);
#endif
			}
			// Otherwise, ask you to make a promise
			else
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_KILLED_MY_SPY;
#if defined(MOD_BALANCE_CORE_SPIES)
				int iTurnsBetweenStatements = 40;
#else
				int iTurnsBetweenStatements = 1;
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - Share intrigue with this player
void CvDiplomacyAI::DoShareIntrigueStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		IntrigueNotificationMessage* pNotificationMessage = m_pPlayer->GetEspionage()->GetRecentIntrigueInfo(ePlayer);
		if (pNotificationMessage)
		{
			// if this player has an untold plot against a player
			if(pNotificationMessage->m_eSourcePlayer != NO_PLAYER)
			{
				bool bIsNewIntrigue = true;
				// has any other player told the player about this plot?
				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes eOtherPlayer = (PlayerTypes)ui;
					// don't evalute the plotting player
					if(eOtherPlayer == pNotificationMessage->m_eSourcePlayer)
					{
						continue;
					}

					if(GET_PLAYER(eOtherPlayer).GetEspionage()->HasSharedIntrigue(ePlayer, pNotificationMessage->m_eSourcePlayer, (CvIntrigueType)(pNotificationMessage->m_iIntrigueType)))
					{
						bIsNewIntrigue = false;
						break;
					}
				}

				if(bIsNewIntrigue)
				{
					MajorCivApproachTypes eApproachType = m_pPlayer->GetDiplomacyAI()->GetMajorCivApproach(ePlayer, false);
					if (eApproachType != MAJOR_CIV_APPROACH_GUARDED && eApproachType != MAJOR_CIV_APPROACH_HOSTILE && eApproachType != MAJOR_CIV_APPROACH_WAR)
					{
						DiploStatementTypes eTempStatement = DIPLO_STATEMENT_SHARE_INTRIGUE;
						int iTurnsBetweenStatements = 1;
						if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) > iTurnsBetweenStatements)
						{
							eStatement = eTempStatement;
						}
					}
				}
				else
				{
					// mark this as shared so it doesn't try to interrupt the player
					m_pPlayer->GetEspionage()->MarkRecentIntrigueAsShared(ePlayer, pNotificationMessage->m_eSourcePlayer, (CvIntrigueType)(pNotificationMessage->m_iIntrigueType));
				}
			}
		}
	}
}

/// Possible Contact Statement - They converted one of our cities, and we want them to stop that
void CvDiplomacyAI::DoConvertedMyCityStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetNegativeReligiousConversionPoints(ePlayer) >= GC.getRELIGION_DIPLO_HIT_THRESHOLD())
		{
			// Have we asked you to make a promise before?
			if(IsPlayerBrokenNoConvertPromise(ePlayer) ||
			        IsPlayerIgnoredNoConvertPromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
			}
			else if(IsPlayerMadeNoConvertPromise(ePlayer))
			{
				// You broke the promise you made!
				SetPlayerBrokenNoConvertPromise(ePlayer, true);
				SetPlayerMadeNoConvertPromise(ePlayer, false);
#if defined(MOD_BALANCE_CORE)
				SetPlayerBackstabCounter(ePlayer, 0);
#endif
			}
			// Otherwise, ask you to make a promise
			else
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STOP_CONVERSIONS;
				int iTurnsBetweenStatements = 1;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - They dug up one of our artifacts, and we want them to stop that
void CvDiplomacyAI::DoDugUpMyYardStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");

	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (GetNegativeArchaeologyPoints(ePlayer) > 0) // TODO: arch
		{
			// Have we asked you to make a promise before?
			if (IsPlayerBrokenNoDiggingPromise(ePlayer) ||
				IsPlayerIgnoredNoDiggingPromise(ePlayer) ||
				IsPlayerMadeNoDiggingPromise(ePlayer))
			{
				// We don't even want to bother with you again, so do nothing
			}
			// Otherwise, ask you to make a promise
			else
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STOP_DIGGING;
#if defined(MOD_BALANCE_CORE)
				int iTurnsBetweenStatements = 30;
#else
				int iTurnsBetweenStatements = 1;
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We want to make a Declaration of Friendship with them
void CvDiplomacyAI::DoDoFStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Have we already made the agreement?
		if(!IsDoFAccepted(ePlayer))
		{
			if(IsDoFAcceptable(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WORK_WITH_US;
#if defined(MOD_BALANCE_CORE)
				if(GetDoFType(ePlayer) == DOF_TYPE_BATTLE_BROTHERS)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_BB;
				}
				else if(GetDoFType(ePlayer) == DOF_TYPE_ALLIES)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_ALLIES;
				}
				else if(GetDoFType(ePlayer) == DOF_TYPE_FRIENDS)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_FRIENDS;
				}
				else if(GetDoFType(ePlayer) == DOF_TYPE_UNTRUSTWORTHY)
				{
					eTempStatement = DIPLO_STATEMENT_DOF_UNTRUSTWORTHY;
				}
#endif

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
				        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_WORK_WITH_US_RANDFAILED) >= 10)
				{
					bool bSendStatement = true;

					// Chance we don't actually send the message (don't want full predictability)
					//if (GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to work with a player") < 50)
					//	bSendStatement = false;

					if(bSendStatement)
						eStatement = eTempStatement;

					// Add this statement to the log so we don't evaluate it again until 10 turns has come back around
					else
						DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_WORK_WITH_US_RANDFAILED);
				}
			}
		}
	}
}

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Possible Contact Statement - We're ending our Declaration of Friendship with them
void CvDiplomacyAI::DoEndDoFStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Have we already made the agreement?
		if(IsDoFAccepted(ePlayer))
		{
			//If we want to denounce, let's channel it into this instead.
			if(IsDenounceFriendAcceptable(ePlayer))
			{
				eStatement = DIPLO_STATEMENT_END_WORK_WITH_US;
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_END_WORK_WITH_US);
			}
		}
	}
}
#endif

/// Possible Contact Statement - We're denouncing one of our friends (backstabbing)
void CvDiplomacyAI::DoDenounceFriendStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Must have already made the agreement
		if(IsDoFAccepted(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DENOUNCE_FRIEND;
			int iTurnsBetweenStatements = 1;

			// Done working with this guy?
			if(IsDenounceFriendAcceptable(ePlayer))
			{
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
				//We have to be really treacherous to do this, otherwise we'll just break up our friendship.
				if(((GetMeanness() > 8) || (GetDenounceWillingness() > 8) || (GetLoyalty() < 3)))
				{
#endif
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					eStatement = eTempStatement;
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
				}
#endif
			}

			// Add this statement to the log so we don't evaluate it again until 20 turns has come back around
			//else
			//	DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
		}
	}
}

/// Possible Contact Statement - We're denouncing a player
void CvDiplomacyAI::DoDenounceStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsDenounceAcceptable(ePlayer, /*bBias*/ false))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DENOUNCE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
			        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED) >= 10)
			{
				bool bSendStatement = true;

				// 1 in 2 chance we don't actually send the message (don't want full predictability)
				//if (50 < GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to work with a player"))
				//	bSendStatement = false;

				if(bSendStatement)
				{
					eStatement = eTempStatement;
				}

				// Add this statement to the log so we don't evaluate it again until time has passed
				else
					DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED);
			}
		}
	}
}

/// Possible Contact Statement - We're requesting that a player denounce someone
void CvDiplomacyAI::DoRequestFriendDenounceStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		bool bRandFailed;

		PlayerTypes eTarget = GetRequestFriendToDenounce(ePlayer, bRandFailed);
		if(eTarget != NO_PLAYER)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
			        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE_RANDFAILED) >= 10)
			{
				if(!bRandFailed)
				{
					eStatement = eTempStatement;
					iData1 = eTarget;
				}
				// Add this statement to the log so we don't evaluate it again until time has passed
				else
				{
					DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED);
				}
			}
		}
	}
}

/// Possible Contact Statement
//void CvDiplomacyAI::DoWorkAgainstSomeoneStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement, int &iData1)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		PlayerTypes eTargetPlayer;
//
//		if (DoTestWorkingAgainstPlayersDesire(ePlayer, eTargetPlayer))
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DENOUNCE;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
//				GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED) >= 10)
//			{
//				bool bSendStatement = true;
//
//				// 1 in 2 chance we don't actually send the message (don't want full predictability)
//				//if (50 < GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to work with a player"))
//				//	bSendStatement = false;
//
//				if (bSendStatement)
//				{
//					eStatement = eTempStatement;
//					iData1 = eTargetPlayer;
//				}
//
//				// Add this statement to the log so we don't evaluate it again until time has passed
//				else
//					DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_DENOUNCE_RANDFAILED);
//			}
//		}
//	}
//}

/// Possible Contact Statement
//void CvDiplomacyAI::DoEndWorkAgainstSomeoneStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement, int &iData1)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		PlayerTypes eTargetPlayer;
//
//		if (!DoTestContinueWorkingAgainstPlayersDesire(ePlayer, eTargetPlayer))
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_END_WORK_AGAINST_SOMEONE;
//			int iTurnsBetweenStatements = 1;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//			{
//				eStatement = eTempStatement;
//				iData1 = eTargetPlayer;
//			}
//
//			// Add this statement to the log so we don't evaluate it again until time has passed
//			//else
//			//	DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
//		}
//	}
//}

/// Possible Contact Statement - Luxury Trade
void CvDiplomacyAI::DoLuxuryTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForLuxuryResource(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_LUXURY_TRADE;
			int iTurnsBetweenStatements = 10;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possibile Contact Statement - Embassy Exchange
void CvDiplomacyAI::DoEmbassyExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can both sides open an embassy
		if(pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), ePlayer, TRADE_ITEM_ALLOW_EMBASSY) &&
		        pDeal->IsPossibleToTradeItem(ePlayer, GetPlayer()->GetID(), TRADE_ITEM_ALLOW_EMBASSY))
		{
			// Does this guy want to exchange embassies?
			if(IsEmbassyExchangeAcceptable(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EMBASSY_EXCHANGE;
				int iTurnsBetweenStatements = 15;
#if defined(MOD_BALANCE_CORE)
				if(GetNeediness() > 7)
				{
					iTurnsBetweenStatements /= 2;
				}
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_OFFER) >= 10)
#else
				if ((GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_OFFER) >= 10)
#endif			
				{
					bool bSendStatement = false;

					// AI
					if(!GET_PLAYER(ePlayer).isHuman())
					{
						if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsEmbassyExchangeAcceptable(GetPlayer()->GetID()))
							bSendStatement = true;
					}
					// Human
					else
						bSendStatement = true;

					// 1 in 2 chance we don't actually send the message (don't want full predictability)
					if (5 < GC.getGame().getSmallFakeRandNum(10, ePlayer+m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
						bSendStatement = false;

					if(bSendStatement)
					{
						pDeal->AddAllowEmbassy(GetPlayer()->GetID());
						pDeal->AddAllowEmbassy(ePlayer);

						eStatement = eTempStatement;
					}
					else
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
#if defined(MOD_BALANCE_CORE)
					if(!bSendStatement)
					{
						pDeal->ClearItems();
					}
#endif
				}
			}
		}
	}
}

/// Possible Contact Statement - Embassy
void CvDiplomacyAI::DoEmbassyOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->MakeOfferForEmbassy(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EMBASSY_OFFER;
			int iTurnsBetweenStatements = 15;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_EXCHANGE) >= 10)
#else
			if ((GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements) && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_EMBASSY_EXCHANGE) >= 10)
#endif		
			{
				eStatement = eTempStatement;
			}
#if defined(MOD_BALANCE_CORE)
			else
			{
				pDeal->ClearItems();
			}
#endif
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Open Borders Exchange
void CvDiplomacyAI::DoOpenBordersExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		int iDuration = GC.getGame().GetDealDuration();

		// Can both sides trade OB?
		if(pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), ePlayer, TRADE_ITEM_OPEN_BORDERS, iDuration) &&
		        pDeal->IsPossibleToTradeItem(ePlayer, GetPlayer()->GetID(), TRADE_ITEM_OPEN_BORDERS, iDuration))
		{
			// Does this guy want to exchange OB?
			if(IsOpenBordersExchangeAcceptable(ePlayer))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE;
				int iTurnsBetweenStatements = 25;
#if defined(MOD_BALANCE_CORE)
				if(GetNeediness() > 7)
				{
					iTurnsBetweenStatements /= 2;
				}
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
				{
#if defined(MOD_BALANCE_CORE)				
					// OB on each side
					pDeal->AddOpenBorders(GetPlayer()->GetID(), iDuration);
					pDeal->AddOpenBorders(ePlayer, iDuration);

					bool bDealAcceptable = false;

					// AI evaluation
					if(!GET_PLAYER(ePlayer).isHuman())
					{
						bDealAcceptable = GetPlayer()->GetDealAI()->DoEqualizeDealWithAI(pDeal, ePlayer);	// Change the deal as necessary to make it work
					}
					else
					{
						bool bUselessReferenceVariable;
						bool bCantMatchOffer;
						bDealAcceptable = GetPlayer()->GetDealAI()->DoEqualizeDealWithHuman(pDeal, ePlayer, false, false, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work
					}
					if(bDealAcceptable)
					{
						eStatement = eTempStatement;
					}
					// Add this statement to the log so we don't evaluate it again until 20 turns has come back around
					else
					{
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
					}
					if(!bDealAcceptable)
					{
						pDeal->ClearItems();
					}
#else
					bool bSendStatement = false;
					// AI
					if(!GET_PLAYER(ePlayer).isHuman())
					{
						if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsOpenBordersExchangeAcceptable(GetPlayer()->GetID()))
							bSendStatement = true;
					}
					// Human
					else
						bSendStatement = true;

					// 1 in 2 chance we don't actually send the message (don't want full predictability)
					if(50 < GC.getGame().getJonRandNum(100, "Diplomacy AI: rand roll to see if we ask to exchange open borders"))
						bSendStatement = false;

					if(bSendStatement)
					{
						// OB on each side
						pDeal->AddOpenBorders(GetPlayer()->GetID(), iDuration);
						pDeal->AddOpenBorders(ePlayer, iDuration);

						eStatement = eTempStatement;
					}
					// Add this statement to the log so we don't evaluate it again until 20 turns has come back around
					else
						DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
#endif
				}
			}
		}
	}
}

/// Possible Contact Statement - Open Borders
void CvDiplomacyAI::DoOpenBordersOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForOpenBorders(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_OPEN_BORDERS_OFFER;
			int iTurnsBetweenStatements = 25;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Research Agreement Offer
void CvDiplomacyAI::DoResearchAgreementOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsCanMakeResearchAgreementRightNow(ePlayer))
		{
			if(GetPlayer()->GetDealAI()->IsMakeOfferForResearchAgreement(ePlayer, /*pDeal can be modified in this function*/ pDeal))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER;
				int iTurnsBetweenStatements = 20;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
				else
				{
					pDeal->ClearItems();
				}
			}
			else
			{
				// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
				pDeal->ClearItems();
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE_DEALS)
/// Possible Contact Statement - Strategic Resource Offer
void CvDiplomacyAI::DoStrategicTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForStrategicResource(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_STRATEGIC_TRADE;
			int iTurnsBetweenStatements = 20;
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Defensive Pact Offer
void CvDiplomacyAI::DoDefensivePactOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(IsCanMakeDefensivePactRightNow(ePlayer))
		{
			if(GetPlayer()->GetDealAI()->IsMakeOfferForDefensivePact(ePlayer, /*pDeal can be modified in this function*/ pDeal))
			{
				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST;
				int iTurnsBetweenStatements = 30;

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
				}
				else
				{
					pDeal->ClearItems();
				}
			}
			else
			{
				// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
				pDeal->ClearItems();
			}
		}
	}
}
/// Possible Contact Statement - City Trade
void CvDiplomacyAI::DoCityTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForCity(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_TRADE_CITIES_REQUEST;
			int iTurnsBetweenStatements = 30;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - City Exchange
void CvDiplomacyAI::DoCityExchange(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForCityExchange(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_EXCHANGE_CITIES;
			int iTurnsBetweenStatements = 30;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Third Party War Trade
void CvDiplomacyAI::DoThirdPartyWarTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForThirdPartyWar(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST;
			int iTurnsBetweenStatements = 20;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Peace Trade
void CvDiplomacyAI::DoThirdPartyPeaceTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForThirdPartyPeace(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST;
			int iTurnsBetweenStatements = 15;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Vote Trade
void CvDiplomacyAI::DoVoteTrade(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForVote(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_VOTE_REQUEST;
			int iTurnsBetweenStatements = 15;
#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

#endif

/// Possible Contact Statement - Renew Recently Expired Deal
void CvDiplomacyAI::DoRenewExpiredDeal(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if (GetGlobalCoopWarAcceptedState(ePlayer) >= COOP_WAR_STATE_SOON)
		{
			return;
		}

		CvDeal* pTargetDeal = NULL;
		CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();

		int iNumDeals = kGameDeals.GetNumHistoricDealsWithPlayer(ePlayer, GetPlayer()->GetID(), 12);

		for(int iDeal = 0; iDeal < iNumDeals; iDeal++)
		{
			CvDeal* pCurrentDeal = kGameDeals.GetHistoricDealWithPlayer(ePlayer, GetPlayer()->GetID(), iDeal);

			// if this deal has already been renewed or cancelled, then move along
			if (pCurrentDeal->m_bConsideringForRenewal || pCurrentDeal->m_bDealCancelled || pCurrentDeal->m_bCheckedForRenewal || pCurrentDeal->m_bIsGift)
			{
				continue;
			}

			// if they don't involve the player, bail
			if(!(pCurrentDeal->m_eFromPlayer == m_pPlayer->GetID() || pCurrentDeal->m_eToPlayer == m_pPlayer->GetID()))
			{
				continue;
			}

			// if the deal can be renewed (no peace treaties, etc)
			if(!pCurrentDeal->IsPotentiallyRenewable())
			{
				continue;
			}

			// Check to see if the deal is still active
			if(pCurrentDeal->m_iFinalTurn > GC.getGame().getElapsedGameTurns())
			{
				continue;
			}

			//If historic, only look at turns that expired less than 20 turns earlier.
			if ((pCurrentDeal->m_iFinalTurn + 20) < GC.getGame().getElapsedGameTurns())
			{
				continue;
			}

			bool bCanTradeItems = true;

			// if the deal can be fully renewed
			TradedItemList::iterator it;
			CvDeal kTempDeal;

			pCurrentDeal->m_bConsideringForRenewal = true;

			for(it = pCurrentDeal->m_TradedItems.begin(); it != pCurrentDeal->m_TradedItems.end(); ++it)
			{
				PlayerTypes eOtherPlayer;
				if (it->m_eFromPlayer == pCurrentDeal->m_eFromPlayer)
				{
					eOtherPlayer = pCurrentDeal->m_eToPlayer;
				}
				else
				{
					eOtherPlayer = pCurrentDeal->m_eFromPlayer;
				}

				if(!kTempDeal.IsPossibleToTradeItem(it->m_eFromPlayer, eOtherPlayer, it->m_eItemType, it->m_iData1, it->m_iData2, it->m_iData3, it->m_bFlag1))
				{
					bCanTradeItems = false;
					break;
				}
			}

			pCurrentDeal->m_bConsideringForRenewal = false;

			if(!bCanTradeItems)
			{
				continue;
			}

			//We are considering the deal? Cool.
			pTargetDeal = pCurrentDeal;
			break;
		}

		if (pTargetDeal)
		{
			// copy the target deal into the new deal
			*pDeal = *pTargetDeal;

			//Set as considered for renewal.
			pTargetDeal->m_bConsideringForRenewal = true;
			pDeal->m_bConsideringForRenewal = true;
			pDeal->m_iFinalTurn = -1;
			
			bool bAbleToEqualize = false;
			if(!GET_PLAYER(ePlayer).isHuman())
			{
				bAbleToEqualize = m_pPlayer->GetDealAI()->DoEqualizeDealWithAI(pDeal, ePlayer);
			}
			else
			{
				bool bUselessReferenceVariable;
				bool bCantMatchOffer;
				bAbleToEqualize = m_pPlayer->GetDealAI()->DoEqualizeDealWithHuman(pDeal, ePlayer, false, true, bUselessReferenceVariable, bCantMatchOffer);
			}

			if(!bAbleToEqualize)
			{
				pDeal->ClearItems();
				pTargetDeal->ClearItems();
				ClearDealToRenew();
				return;
			}
			else
				eStatement = DIPLO_STATEMENT_RENEW_DEAL;
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Plan Research Agreement
//void CvDiplomacyAI::DoResearchAgreementPlan(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		// AI must want RA
//		if (IsWantsResearchAgreementWithPlayer(ePlayer))
//		{
//			// We can't make a RA RIGHT NOW (otherwise we'd use the offer in the function above this one)
//			if (!IsCanMakeResearchAgreementRightNow(ePlayer))
//			{
//				// Can't ALREADY have a RA
//				if (!GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(ePlayer).getTeam()))
//				{
//					DiploStatementTypes eTempStatement = DIPLO_STATEMENT_PLAN_RESEARCH_AGREEMENT;
//					int iTurnsBetweenStatements = 20;
//
//					if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//					{
//						eStatement = eTempStatement;
//					}
//				}
//			}
//		}
//	}
//}

/// Possible Contact Statement - Request Help
void CvDiplomacyAI::DoRequest(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST;

		// If a request was accepted or rejected, wait 60 turns. If we rolled for rand and failed, wait 15 turns before we try again
		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED) >= 15 &&
				// If we just sent out a generous offer, don't ask for a request until some time has passed
				(MOD_DIPLOMACY_CIV4_FEATURES && GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER) >= 25))
#else
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED) >= 15)
#endif
		{
			bool bRandPassed;	// This is used to see if we WOULD have made a request, but the rand roll failed (so add an entry to the log)
			bool bMakeRequest = IsMakeRequest(ePlayer, pDeal, bRandPassed);

			// Want to make a request of ePlayer? Pass pDeal in to see if there's actually anything we want
			if(bMakeRequest)
			{
				eStatement = eTempStatement;
				pDeal->SetRequestingPlayer(GetPlayer()->GetID());
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				pDeal->m_bIsGift = true;
#endif
			}

			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			else
				pDeal->ClearItems();

			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
			{
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_REQUEST_RANDFAILED);
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement - Gift
void CvDiplomacyAI::DoGift(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_GIFT;

		// If a request was accepted or rejected, wait 60 turns. If we rolled for rand and failed, wait 15 turns before we try again
		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GIFT_RANDFAILED) >= 15)
		{
			bool bRandPassed = false;	// This is used to see if we WOULD have made a gift, but the rand roll failed (so add an entry to the log)
			bool bMakeGift = false;//IsMakeGift(ePlayer, pDeal, bRandPassed);

			// Want to make a request of ePlayer? Pass pDeal in to see if there's actually anything we want
			if(bMakeGift)
			{
				eStatement = eTempStatement;
				pDeal->SetRequestingPlayer(GetPlayer()->GetID());
			}

			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			else
				pDeal->ClearItems();

			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
			{
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_GIFT_RANDFAILED);
				pDeal->ClearItems();
			}
		}
	}
}

/// Possible Contact Statement
//void CvDiplomacyAI::DoNowUnforgivableStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		bool bSendStatement = false;
//
//		// Unforgivable!
//		if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)
//		{
//			// Our approach (real or fake) can't be Friendly
//			if (GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) != MAJOR_CIV_APPROACH_FRIENDLY)
//			{
//				bSendStatement = true;
//			}
//		}
//
//		if (bSendStatement)
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_NOW_UNFORGIVABLE;
//			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//			{
//				eStatement = eTempStatement;
//			}
//		}
//	}
//}

/// Possible Contact Statement
//void CvDiplomacyAI::DoNowEnemyStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		bool bSendStatement = false;
//
//		// Don't show this message if we've already given a more severe one
//		if (m_paDiploLogStatementTurnCountScratchPad[DIPLO_STATEMENT_NOW_UNFORGIVABLE] == MAX_TURNS_SAFE_ESTIMATE)
//		{
//			// An enemy
//			if (GetMajorCivOpinion(ePlayer) == MAJOR_CIV_OPINION_ENEMY)
//			{
//				// Our approach (real or fake) can't be Friendly
//				if (GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) != MAJOR_CIV_APPROACH_FRIENDLY)
//				{
//					bSendStatement = true;
//				}
//			}
//
//			if (bSendStatement)
//			{
//				DiploStatementTypes eTempStatement = DIPLO_STATEMENT_NOW_ENEMY;
//				int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;
//
//				if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//				{
//					eStatement = eTempStatement;
//				}
//			}
//		}
//	}
//}

/// Possible Contact Statement - Approach towards player is now HOSTILE
void CvDiplomacyAI::DoHostileStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
#if defined(MOD_BALANCE_CORE)
		if(!IsTooEarlyForDoF(ePlayer) && (eApproach == MAJOR_CIV_APPROACH_HOSTILE) && (GetMeanness() > 6))
#else
		if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
#endif
		{
			TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

			// If we've made peace recently, don't go mouthing off right away
			int iPeaceTreatyTurn = GET_TEAM(GetTeam()).GetTurnMadePeaceTreatyWithTeam(eTeam);
			if(iPeaceTreatyTurn != -1)
			{
				int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;
				if(iTurnsSincePeace < /*25*/ GC.getTURNS_SINCE_PEACE_WEIGHT_DAMPENER())
					return;
			}

			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_INSULT;
#if defined(MOD_BALANCE_CORE)
			int iTurnsBetweenStatements = 75;
#else
			int iTurnsBetweenStatements = 35;
#endif

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement
//void CvDiplomacyAI::DoFriendlyStatement(PlayerTypes ePlayer, DiploStatementTypes &eStatement)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
//
//	if (eStatement == NO_DIPLO_STATEMENT_TYPE)
//	{
//		if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
//		{
//			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_COMPLIMENT;
//			int iTurnsBetweenStatements = 35;
//
//			if (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
//			{
//				eStatement = eTempStatement;
//			}
//		}
//	}
//}

/// Possible Contact Statement - Approach towards player is now AFRAID
void CvDiplomacyAI::DoAfraidStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BOOT_KISSING;
			int iTurnsBetweenStatements = 35;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				eStatement = eTempStatement;
		}
	}
}

/// Possible Contact Statement - Warning the player about their warmongering
void CvDiplomacyAI::DoWarmongerStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
		{
			bool bSendStatement = true;

			// Don't send statement if we're going for conquest ourselves
			if(IsGoingForWorldConquest())
				bSendStatement = false;

			// 2 in 3 chance we don't actually send the message (don't want to bombard the player from all sides)
			if (4 < GC.getGame().getSmallFakeRandNum(10, ePlayer + m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
				bSendStatement = false;

			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_WARMONGER;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(bSendStatement)
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					eStatement = eTempStatement;
			}
			// Add this statement to the log so we don't evaluate it again next turn
			else
				DoAddNewStatementToDiploLog(ePlayer, eTempStatement);
		}
	}
}

/// Possible Contact Statement - Warning the player that we don't like their interactions with "our" City-States
void CvDiplomacyAI::DoMinorCivCompetitionStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1, bool bIgnoreTurnsBetweenLimit)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// They must be able to declare war on us
#if defined(MOD_EVENTS_WAR_AND_PEACE)
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam(), ePlayer))
#else
		if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(GetPlayer()->getTeam()))
#endif
			return;

		if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_MINOR_CIV_COMPETITION;
			int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements || bIgnoreTurnsBetweenLimit)
			{
				// Find a city state we're upset over
				PlayerTypes eMinor;
				for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
				{
					eMinor = (PlayerTypes) iMinorLoop;
					
					// Don't evaluate City-States that are unmet/dead
					if (!IsPlayerValid(eMinor))
						continue;

#if defined(MOD_BALANCE_CORE)
					// Ignore if League resolutions make it irrelevant
					if (GET_PLAYER(eMinor).GetMinorCivAI()->IsNoAlly() || GET_PLAYER(eMinor).GetMinorCivAI()->GetPermanentAlly() == GetPlayer()->GetID())
						continue;
#endif
					// We have a PtP with this minor
					if(GET_PLAYER(eMinor).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
					{
						if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(ePlayer))
						{
							iData1 = eMinor;
							break;
						}
						else if(GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(ePlayer))
						{
							iData1 = eMinor;
							break;
						}
					}
				}

				// Don't change the statement unless we found a minor to complain about
				if(iData1 != NO_PLAYER)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Possible Contact Statement - We're angry that they befriended a player we denounced
void CvDiplomacyAI::DoAngryBefriendedEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We denounced the leader we're talking to - no use whining at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our enemy, that ePlayer befriended
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if(!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetDoFCounter(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're angry that they denounced one of our friends
void CvDiplomacyAI::DoAngryDenouncedFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We denounced the leader we're talking to - no use whining at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our friend, that ePlayer denounced
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetDenouncedPlayerCounter(eLoopPlayer) > 1)
					continue;

				// Found a match!
				int iWeight = GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy that they denounced a player we denounced
void CvDiplomacyAI::DoHappyDenouncedEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We denounced the leader we're talking to - no use talking at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our enemy, that ePlayer denounced
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if(!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetDenouncedPlayerCounter(eLoopPlayer) > 1)
					continue;

				// Found a match!

				int iWeight = GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're chatty enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy they befriended one of our friends
void CvDiplomacyAI::DoHappyBefriendedFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We denounced the leader we're talking to - no use talking at this point
	if(IsDenouncedPlayer(ePlayer) || IsAtWar(ePlayer) || GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
		return;

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			// Loop through all players until we find one that is our friend, that ePlayer DoFed
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't DoFed this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't DoFed this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(pTheirDiploAI->GetDoFCounter(eLoopPlayer) > 1)
					continue;

				// Found a match!

				int iWeight = GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're chatty enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - Peace
void CvDiplomacyAI::DoPeaceOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (!IsAtWar(ePlayer))
	{
		return;
	}
	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
#if !defined(MOD_BALANCE_CORE)
		CvTeam* pOurTeam = &GET_TEAM(GetPlayer()->getTeam());
		TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();
#endif

		// Have to have been at war for at least a little while
#if defined(MOD_BALANCE_CORE)
		GetPlayer()->SetCachedValueOfPeaceWithHuman(0);
#endif
		if(IsWantsPeaceWithPlayer(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REQUEST_PEACE;
			int iTurnsBetweenStatements = 5;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				if(GetPlayer()->GetDealAI()->IsOfferPeace(ePlayer, /*pDeal can be modified in this function*/ pDeal, false /*bEqualizingDeals*/) && pDeal->GetNumItems() > 0)
				{
					eStatement = eTempStatement;
				}
				else
				{
					// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
					pDeal->ClearItems();
				}
			}
		}
	}
}

/// Possible Contact Statement - We befriended one of the human's enemies and we're letting them know
void CvDiplomacyAI::DoFYIBefriendedHumanEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			int iWeight;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;

			// Loop through all players until we find one that we just made friends with, that ePlayer denounced
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetDoFCounter(eLoopPlayer) > 1)
					continue;

				eOpinion = GetMajorCivOpinion(ePlayer);
				eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

				// Don't say mean things if we like ePlayer
				if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
					continue;

				iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
					iWeight += 10;

				iWeight += GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We denounced one of the human's friends and we're letting them know
void CvDiplomacyAI::DoFYIDenouncedHumanFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			int iWeight;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;

			// Loop through all players until we find one that we just denoucned, that ePlayer has befriended
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if(!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetDenouncedPlayerCounter(eLoopPlayer) > 1)
					continue;

				eOpinion = GetMajorCivOpinion(ePlayer);
				eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

				// Don't say mean things if we like ePlayer
				if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
					continue;

				iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
					iWeight += 10;

				iWeight += GetMeanness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We denounced someone the human has denounced and we're letting them know
void CvDiplomacyAI::DoFYIDenouncedHumanEnemy(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED) >= 20)
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			int iWeight;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;

			// Loop through all players until we find one that we just denounced, that ePlayer has denounced
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't denounced this guy
				if(!IsDenouncedPlayer(eLoopPlayer))
					continue;

				// They haven't denounced this guy
				if(!pTheirDiploAI->IsDenouncedPlayer(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetDenouncedPlayerCounter(eLoopPlayer) > 1)
					continue;

				eOpinion = GetMajorCivOpinion(ePlayer);
				eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

				// Don't say nice things if we dislike ePlayer
				if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
					continue;

				iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
					iWeight += 10;

				if(eOpinion == MAJOR_CIV_APPROACH_FRIENDLY)
					iWeight += 2;

				// Add weight if they're strong
				if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) > STRENGTH_AVERAGE)
					iWeight += 3;

				iWeight += GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We befriended one of the human's friends, and we're letting them know
void CvDiplomacyAI::DoFYIBefriendedHumanFriend(PlayerTypes ePlayer, DiploStatementTypes& eStatement, int& iData1)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND;

#if defined(MOD_BALANCE_CORE)
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= 40 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED) >= 20)
#else
		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 50 &&
		        GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED) >= 20)
#endif
		{
			CvDiplomacyAI* pTheirDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();

			int iWeight;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;

			// Loop through all players until we find one that we just befriended, that ePlayer has befriended
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				// Must be alive
				if(!GET_PLAYER(eLoopPlayer).isAlive())
					continue;

				// Can't be either of us
				if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
					continue;

				// We haven't befriended this guy
				if(!IsDoFAccepted(eLoopPlayer))
					continue;

				// They haven't befriended this guy
				if(!pTheirDiploAI->IsDoFAccepted(eLoopPlayer))
					continue;

				// Too much time has passed (or maybe we already sent a message recently)
				if(GetDoFCounter(eLoopPlayer) > 1)
					continue;

				eOpinion = GetMajorCivOpinion(ePlayer);
				eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

				// Don't say nice things if we dislike ePlayer
				if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
					continue;
				if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
					continue;

				iWeight = 0;

				if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
					iWeight += 2;
				else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
					iWeight += 5;
				else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
					iWeight += 10;

				if(eOpinion == MAJOR_CIV_APPROACH_FRIENDLY)
					iWeight += 2;

				iWeight += GetChattiness();		// Usually ranges from 3 to 7
				iWeight += GC.getGame().getSmallFakeRandNum(10, iWeight + m_pPlayer->getGlobalAverage(YIELD_CULTURE));

				// We're mean enough to say something
				if(iWeight >= 10)
				{
					eStatement = eTempStatement;
					iData1 = eLoopPlayer;
				}
				// We're going to be nice!
				else
				{
					eStatement = DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED;
				}

				// We're done in here
				break;
			}
		}
	}
}

/// Possible Contact Statement - We're happy we're following the same ideology as the human
void CvDiplomacyAI::DoHappySamePolicyTree(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;

		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch && GET_PLAYER(ePlayer).GetCulture()->GetTurnIdeologySwitch() < 0)
		{
			// Don't say nice things if we dislike ePlayer
			bool bSkip = false;
			MajorCivApproachTypes eApproach;
			MajorCivOpinionTypes eOpinion;
			eOpinion = GetMajorCivOpinion(ePlayer);
			eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;

			// Check chattiness to see if we send the message this turn
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				DiploStatementTypes eOtherStatementToCheck = NO_DIPLO_STATEMENT_TYPE;

				if(eMyBranch == GC.getPOLICY_BRANCH_FREEDOM())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_FREEDOM;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM;
				}
				else if(eMyBranch == GC.getPOLICY_BRANCH_ORDER())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_ORDER;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER;
				}
				else if(eMyBranch == GC.getPOLICY_BRANCH_AUTOCRACY())
				{
					eTempStatement = DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY;
					eOtherStatementToCheck = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY;
				}

				if(eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						// Also check the statement for joining the ideology.  Don't want to send messages like this on back-to-back turns
						if(GetNumTurnsSinceStatementSent(ePlayer, eOtherStatementToCheck) >= iTurnsBetweenStatements)
						{
							eStatement = eTempStatement;
						}
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Either AI or human has switched ideologies due to the other's pressure
void CvDiplomacyAI::DoIdeologicalStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PolicyBranchTypes eFreedom = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
	PolicyBranchTypes eOrder = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();
	int iTurnsBetweenStatements = MAX_TURNS_SAFE_ESTIMATE;

	CvPlayer &kTheirPlayer = GET_PLAYER(ePlayer);

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement;

		if (m_pPlayer->GetCulture()->GetInfluenceLevel(ePlayer) >= INFLUENCE_LEVEL_INFLUENTIAL)
		{
			eTempStatement = DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
				return;
			}
		}

		if (kTheirPlayer.GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) >= INFLUENCE_LEVEL_INFLUENTIAL)
		{
			eTempStatement = DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
			{
				eStatement = eTempStatement;
				return;
			}
		}

		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = kTheirPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

		if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
		{
			PublicOpinionTypes eOpinionInMyCiv = m_pPlayer->GetCulture()->GetPublicOpinionType();
			PlayerTypes eMyGreatestInfluence = m_pPlayer->GetCulture()->GetPublicOpinionBiggestInfluence();
			PublicOpinionTypes eOpinionInTheirCiv = kTheirPlayer.GetCulture()->GetPublicOpinionType();
			PlayerTypes eTheirGreatestInfluence = kTheirPlayer.GetCulture()->GetPublicOpinionBiggestInfluence();

			// Did this player recently switch ideology due to our pressure?
			int iIdeologySwitchTurn = kTheirPlayer.GetCulture()->GetTurnIdeologySwitch();
			if (iIdeologySwitchTurn > 0 && iIdeologySwitchTurn + 10 > GC.getGame().getGameTurn())
			{
				kTheirPlayer.GetCulture()->SetTurnIdeologySwitch(-1);  // Reset so they only get 1 popup
				if (eTheirBranch == eFreedom)
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM;
				}
				else if (eTheirBranch == eOrder)
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER;
				}
				else
				{
					eStatement = DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY;
				}
				return;
			}

			if (eOpinionInMyCiv >= PUBLIC_OPINION_CIVIL_RESISTANCE && eMyGreatestInfluence == ePlayer)
			{
				if (eTheirBranch == eFreedom)
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM;
				}
				else if (eTheirBranch == eOrder)
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER;
				}
				else
				{
					eTempStatement = DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY;
				}
				if (eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
			if (eOpinionInTheirCiv >= PUBLIC_OPINION_CIVIL_RESISTANCE && eTheirGreatestInfluence == m_pPlayer->GetID())
			{
				if (eMyBranch == eFreedom)
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM;
				}
				else if (eMyBranch == eOrder)
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER;
				}
				else
				{
					eTempStatement = DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY;
				}
				if (eTempStatement != NO_DIPLO_STATEMENT_TYPE)
				{
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Possible Contact Statement - Message to human if the AI thinks they are getting close to the victory they're also going for.
void CvDiplomacyAI::DoVictoryCompetitionStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iTurnsBetweenStatements = 50;
	AIGrandStrategyTypes eMyGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();
	if(eMyGrandStrategy == NO_AIGRANDSTRATEGY)
	{
		return;
	}
	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		EraTypes eModern = (EraTypes) GC.getInfoTypeForString("ERA_MODERN", true);
		DisputeLevelTypes eDispute = GetVictoryDisputeLevel(ePlayer);
		if(eDispute < DISPUTE_LEVEL_STRONG)
		{
			return;
		}
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
		{
			return;
		}
		bool bLeagueCompetitor = false;
		bool bSpaceRace = false;
		bool bCulture = false;
		bool bWar = false;
		int iVotes = 0;
		int iNeededVotes = 0;
		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
		if(pLeague != NULL)
		{
			iVotes = pLeague->CalculateStartingVotesForMember(ePlayer);
			iNeededVotes = GC.getGame().GetVotesNeededForDiploVictory();
			if(iNeededVotes > 0)
			{
				// 33% there? Close!
				if(iVotes >= (iNeededVotes / 3))
				{
					bLeagueCompetitor = true;
				}
			}
		}
		int iProjectCount = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetSSProjectCount();
		if (iProjectCount > 1)
		{
			bSpaceRace = true;
		}
		else
		{
			int iTheirTechNum = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

			int iNumOtherPlayers = 0;
			int iNumPlayersAheadInTech = 0;
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes)ui;
				if(!GET_PLAYER(eOtherPlayer).isAlive())
				{
					continue;
				}

				if (eOtherPlayer == ePlayer)
				{
					continue;
				}

				iNumOtherPlayers++;
				int iNumTechs = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
				if (iTheirTechNum > iNumTechs )
				{
					iNumPlayersAheadInTech++;
				}
			}
			if(iNumPlayersAheadInTech >= iNumOtherPlayers)
			{
				bSpaceRace = true;
			}
		}
		if(GetWarmongerThreat(ePlayer) >= THREAT_SEVERE && GET_PLAYER(ePlayer).GetNumCapitalCities() > 1 && GetPlayer()->GetNumCapitalCities() > 1)
		{
			bWar = true;
		}
		//More than double our influence, and we both have some?
		if(GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn() > 1 && GetPlayer()->GetCulture()->GetNumCivsInfluentialOn() > 0 && (GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn() > (GetPlayer()->GetCulture()->GetNumCivsInfluentialOn() * 2)))
		{
			bCulture = true;
		}
		DiploStatementTypes eTempStatement;

		if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer) == eMyGrandStrategy)
		{
			if(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(ePlayer) >= GUESS_CONFIDENCE_LIKELY)
			{					
				//Conquered a capital? You are in our way!
				if(IsGoingForWorldConquest() && bWar)
				{			
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForDiploVictory() && bLeagueCompetitor)
				{				
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForCultureVictory() && bCulture)
				{
					//We've both influenced someone? Competitor!
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				else if(IsGoingForSpaceshipVictory() && bSpaceRace)
				{
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
				//Don't have it figured out, but we're competitive? Grr!
				else if(GetPlayer()->GetCurrentEra() > eModern)
				{
					eTempStatement = DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED;
					if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					{
						eStatement = eTempStatement;
						return;
					}
				}
			}
		}
	}
}

/// Possible Contact Statement - Message to human if the AI thinks they are getting close to a victory that they're not going for.
void CvDiplomacyAI::DoVictoryBlockStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iTurnsBetweenStatements = 50;
	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");
	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");
	AIGrandStrategyTypes eUNGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");
	AIGrandStrategyTypes eSpaceshipGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");
	EraTypes eAtomic = (EraTypes) GC.getInfoTypeForString("ERA_POSTMODERN", true);
	bool bSkip = false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
	{
		bSkip = true;
	}
	//Let's not send this before the Atomic Era, okay?
	if(GetPlayer()->GetCurrentEra() < eAtomic)
	{
		bSkip = true;
	}
	if(eStatement == NO_DIPLO_STATEMENT_TYPE && !bSkip)
	{
		DiploStatementTypes eTempStatement;

		if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		{
			AIGrandStrategyTypes eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(ePlayer);
			if(eGrandStrategy == eConquestGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eUNGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eCultureGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
			else if(eGrandStrategy == eSpaceshipGrandStrategy)
			{
				eTempStatement = DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP;
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
				{
					eStatement = eTempStatement;
					return;
				}
			}
		}
	}
}
#endif

/// Possible Contact Statement - We liked the human's proposal to the World Congress
void CvDiplomacyAI::DoWeLikedTheirProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetLikedTheirProposalScore(ePlayer) != 0;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				eTempStatement = DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS();
#if defined(MOD_BALANCE_CORE)
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - We disliked the human's proposal to the World Congress
void CvDiplomacyAI::DoWeDislikedTheirProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetDislikedTheirProposalScore(ePlayer) != 0;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
				bSkip = true;
			if (!bSkip && GetChattiness() > GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)))
			{
				eTempStatement = DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS();

#if defined(MOD_BALANCE_CORE)
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped our proposal pass in the World Congress
void CvDiplomacyAI::DoTheySupportedOurProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetSupportedMyProposalScore(ePlayer) != 0;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS();

#if defined(MOD_BALANCE_CORE)
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped our proposal fail in the World Congress
void CvDiplomacyAI::DoTheyFoiledOurProposal(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetFoiledMyProposalScore(ePlayer) != 0;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS();

#if defined(MOD_BALANCE_CORE)
				int iMessage = 0;
				int iMessageMax = MAX_INT;
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;

					if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
					{
						iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
						if(iMessage < iMessageMax)
						{
							iMessageMax = iMessage;
						}
					}
				}
				if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - The human helped relocate the World Congress to our lands
void CvDiplomacyAI::DoTheySupportedOurHosting(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = NO_DIPLO_STATEMENT_TYPE;
		bool bEffect = GetSupportedMyHostingScore(ePlayer) != 0;
		if (bEffect)
		{
			bool bSkip = false;
			MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
				bSkip = true;
			if(eApproach == MAJOR_CIV_APPROACH_WAR || eApproach == MAJOR_CIV_APPROACH_HOSTILE)
				bSkip = true;
			if (!bSkip)
			{
				eTempStatement = DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING;
				int iTurnsBetweenStatements = GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS();

				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
					eStatement = eTempStatement;
			}
		}
	}
}

/////////////////////////////////////////////////////////
// Diplo stuff relating to UI
/////////////////////////////////////////////////////////


/// Initiate diplo screen with default state
void CvDiplomacyAI::DoBeginDiploWithHuman()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
#if defined(MOD_BALANCE_CORE)
		PlayerTypes ePlayer = GC.getGame().getActivePlayer();
		if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isHuman() && IsAtWar(ePlayer))
		{
			DoUpdatePeaceTreatyWillingness();
			DoUpdateWarDamageLevel();
		}
#endif
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			// JdH => go into the deal, if there is anything proposed
			PlayerTypes eTo = GC.getGame().getActivePlayer();
			CvPlayer& kTo = GET_PLAYER(eTo);
			CvDiplomacyRequests* pRequests = kTo.GetDiplomacyRequests();
			pRequests->ActivateAllFrom(GetPlayer()->GetID());
			if (!pRequests->HasActiveRequest())
			{
				LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
				const char* szText = GetGreetHumanMessage(eAnimation);

				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
			}
		}
		else
		{
			LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
			const char* szText = GetGreetHumanMessage(eAnimation);

			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
		}
#else
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetGreetHumanMessage(eAnimation);

		gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_DEFAULT_ROOT, szText, eAnimation);
#endif
	}
}

/// Initiate diplo screen after the player has clicked on the notification to threaten the thief.
void CvDiplomacyAI::DoBeginDiploWithHumanEspionageResult()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) && !IsAtWar(GC.getGame().getActivePlayer()))
	{
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetDiploStringForMessage(DIPLO_MESSAGE_CONFRONT_YOU_KILLED_MY_SPY, GC.getGame().getActivePlayer());
		gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_CONFRONT_YOU_KILLED_MY_SPY, szText, eAnimation);
	}
}

/// Initiate diplo screen after the player has clicked on the notification that involves intrigue
void CvDiplomacyAI::DoBeginDiploWithHumanInDiscuss()
{
	if(!GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		LeaderheadAnimationTypes eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;
		const char* szText = GetGreetHumanMessage(eAnimation);
		gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, szText, eAnimation);
	}
}

/// What should an AI leader say for a particular situation?
const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer)
{
	return GetDiploStringForMessage(eDiploMessage, eForPlayer, Localization::String::Empty, Localization::String::Empty);
}

/// What should an AI leader say for a particular situation?
const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer, const Localization::String& strOptionalKey1)
{
	return GetDiploStringForMessage(eDiploMessage, eForPlayer, strOptionalKey1, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploStringForMessage(DiploMessageTypes eDiploMessage, PlayerTypes eForPlayer, const Localization::String& strOptionalKey1, const Localization::String& strOptionalKey2)
{
	CvAssertMsg(eDiploMessage >= 0, "DIPLOMACY_AI: Invalid DiploMessageType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDiploMessage < NUM_DIPLO_MESSAGE_TYPES, "DIPLOMACY_AI: Invalid DiploMessageType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eForPlayer >= NO_PLAYER, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because eForPlayer is used when we need specific data (e.g. for declaring war)
	CvAssertMsg(eForPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	EraTypes eCurrentEra = GC.getGame().getCurrentEra();
	int iMessage = 0;
#endif
	const char* strText;
	switch(eDiploMessage)
	{
		//////////////////////////////////////////////////////////////
		// AI greeting messages
		//////////////////////////////////////////////////////////////

		// Intro
	case DIPLO_MESSAGE_INTRO:
		strText = GetDiploTextFromTag("RESPONSE_FIRST_GREETING");
		break;

		// Defeated
	case DIPLO_MESSAGE_DEFEATED:
		strText = GetDiploTextFromTag("RESPONSE_DEFEATED");
		break;

		// Repeat Hello (after the player has gone into the screen too many times)
	case DIPLO_MESSAGE_GREETING_REPEAT_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_REPEAT_TOO_MUCH");
		break;

		// Repeat Hello
	case DIPLO_MESSAGE_GREETING_REPEAT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_REPEAT");
		break;

		// Repeat Hello Hostile
	case DIPLO_MESSAGE_GREETING_HOSTILE_REPEAT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_REPEAT");
		break;

		// Polite Hello
	case DIPLO_MESSAGE_GREETING_FRIENDLY_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_POLITE_HELLO");
		break;

		// Neutral Hello
	case DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_NEUTRAL_HELLO");
		break;

		// Hostile Hello
	case DIPLO_MESSAGE_GREETING_HOSTILE_HELLO:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HELLO");
		break;

		// Greeting: Human is crushing this AI
	case DIPLO_MESSAGE_GREETING_DESTRUCTION_LOOMS:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DESTRUCTION_LOOMS");
		break;

		// Greeting: At War with human but wants peace
	case DIPLO_MESSAGE_GREETING_AT_WAR_WANTS_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AT_WAR_WANTS_PEACE");
		break;

		// Greeting: At War with human and is being hostile
	case DIPLO_MESSAGE_GREETING_AT_WAR_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AT_WAR_HOSTILE");
		break;

		// Greeting: At War with human and now ready to accept surrender
	case DIPLO_MESSAGE_GREETING_WILL_ACCEPT_SURRENDER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WILL_ACCEPT_SURRENDER");
		break;

		// Greeting: Research Agreement
	case DIPLO_MESSAGE_GREETING_RESEARCH_AGREEMENT:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_RESEARCH_AGREEMENT");
		break;

		// Greeting: Human has broken military promises
	case DIPLO_MESSAGE_GREETING_BROKEN_MILITARY_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_BROKEN_MILITARY_PROMISE");
		break;

		// Greeting: Players are working together
	case DIPLO_MESSAGE_GREETING_WORKING_WITH:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WORKING_WITH");
		break;

		// Greeting: Players are working together
	case DIPLO_MESSAGE_GREETING_WORKING_AGAINST:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_WORKING_AGAINST", strOptionalKey1);
		break;

		// Greeting: Players in (or planning) a coop war against a third player
	case DIPLO_MESSAGE_GREETING_COOP_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_COOP_WAR", strOptionalKey1);
		break;

		// Greeting: Human at war Hostile
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_AT_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_AT_WAR");
		break;

		// Greeting: Human at war
	case DIPLO_MESSAGE_GREETING_HUMAN_AT_WAR:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HUMAN_AT_WAR");
		break;

		// Greeting: Human aggressive military (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_MILITARY");
		break;

		// Greeting: Human aggressive military
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_MILITARY");
		break;

		// Greeting: Human aggressive expansion (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION");
		break;

		// Greeting: Human aggressive expansion
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_EXPANSION:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_EXPANSION");
		break;

		// Greeting: Human aggressive plot buying (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING");
		break;

		// Greeting: Human aggressive plot buying
	case DIPLO_MESSAGE_GREETING_AGGRESSIVE_PLOT_BUYING:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_AGGRESSIVE_PLOT_BUYING");
		break;

		// Greeting: Human has a strong military
	case DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_FRIENDLY_STRONG_MILITARY");
		break;

		// Greeting: Human has a strong economy
	case DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_ECONOMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_FRIENDLY_STRONG_ECONOMY");
		break;

		// Greeting: Human has few Cities
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_FEW_CITIES:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_FEW_CITIES");
		break;

		// Greeting: Human has a small army
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_SMALL_ARMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_SMALL_ARMY");
		break;

		// Greeting: Human beats up people
	case DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_IS_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_HUMAN_IS_WARMONGER");
		break;

		//////////////////////////////////////////////////////////////
		// AI has a trade offer for the human
		//////////////////////////////////////////////////////////////

		// AI asks the player what deal he's offering
	case DIPLO_MESSAGE_DOT_DOT_DOT:
		strText = GetDiploTextFromTag("RESPONSE_DOT_DOT_DOT");
		break;

		// AI asks the player what deal he's offering
	case DIPLO_MESSAGE_LETS_HEAR_IT:
		strText = GetDiploTextFromTag("RESPONSE_LETS_HEAR_IT");
		break;

		// AI asking the Human to make peace
	case DIPLO_MESSAGE_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_OFFER");
		break;

#if defined(MOD_BALANCE_CORE)
	case DIPLO_MESSAGE_WINNER_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_WINNER_PEACE_OFFER");
		break;
#endif

		// AI is making a demand
	case DIPLO_MESSAGE_DEMAND:
		strText = GetDiploTextFromTag("RESPONSE_DEMAND");
		break;

		// AI is making a request
	case DIPLO_MESSAGE_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_REQUEST");
		break;

		// AI wants a Luxury someone has
	case DIPLO_MESSAGE_LUXURY_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_LUXURY_TRADE");
		break;

		// AI offers equal embassy exchange agreement
	case DIPLO_MESSAGE_EMBASSY_EXCHANGE:
		strText = GetDiploTextFromTag("RESPONSE_EMBASSY_EXCHANGE");
		break;

        // AI asks for an embassy
	case DIPLO_MESSAGE_EMBASSY_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_EMBASSY_OFFER");
		break;

		// AI offers equal Open Borders agreement
	case DIPLO_MESSAGE_OPEN_BORDERS_EXCHANGE:
		strText = GetDiploTextFromTag("RESPONSE_OPEN_BORDERS_EXCHANGE");
		break;

		// AI asks for Open Borders
	case DIPLO_MESSAGE_OPEN_BORDERS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_OPEN_BORDERS_OFFER");
		break;

		// AI wants to make RA agreement with this player at some point soon
	case DIPLO_MESSAGE_PLAN_RESEARCH_AGREEMENT:
		strText = GetDiploTextFromTag("RESPONSE_PLAN_RESEARCH_AGREEMENT");
		break;

		// AI wants RA with player
	case DIPLO_MESSAGE_RESEARCH_AGREEMENT_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_RESEARCH_AGREEMENT_OFFER");
		break;

        // AI wants to renew an expired deal with player
	case DIPLO_MESSAGE_RENEW_DEAL:
		strText = GetDiploTextFromTag("RESPONSE_RENEW_DEAL");
		break;

        // AI wants to renew an expired deal with player, but they need more in exchange
	case DIPLO_MESSAGE_WANT_MORE_RENEW_DEAL:
		strText = GetDiploTextFromTag("RESPONSE_WANT_MORE_RENEW_DEAL");
		break;

		//////////////////////////////////////////////////////////////
		// Generic AI messages to another player; some friendship, some warnings, etc.
		//////////////////////////////////////////////////////////////

		// AI is warning player about his military placement
	case DIPLO_MESSAGE_HOSTILE_AGGRESSIVE_MILITARY_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING");
		break;

		// AI is warning player about his military placement
	case DIPLO_MESSAGE_AGGRESSIVE_MILITARY_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING");
		break;

		// AI is SERIOUSLY warning player about his expansion
	case DIPLO_MESSAGE_EXPANSION_SERIOUS_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_SERIOUS_WARNING");
		break;

		// AI is warning player about his expansion
	case DIPLO_MESSAGE_EXPANSION_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_WARNING");
		break;

		// AI is telling the player he broke a promise
	case DIPLO_MESSAGE_EXPANSION_BROKEN_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_EXPANSION_BROKEN_PROMISE");
		break;

		// AI is SERIOUSLY warning player about his plot buying
	case DIPLO_MESSAGE_PLOT_BUYING_SERIOUS_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_SERIOUS_WARNING");
		break;

		// AI is warning player about his plot buying
	case DIPLO_MESSAGE_PLOT_BUYING_WARNING:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_WARNING");
		break;

		// AI is telling the player he broke a promise
	case DIPLO_MESSAGE_PLOT_BUYING_BROKEN_PROMISE:
		strText = GetDiploTextFromTag("RESPONSE_PLOT_BUYING_BROKEN_PROMISE");
		break;

		// AI attacked a Minor the human has Friendship with (hostile)
	case DIPLO_MESSAGE_HOSTILE_WE_ATTACKED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI attacked a Minor the human has Friendship with
	case DIPLO_MESSAGE_WE_ATTACKED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI bullied a Minor the human has a PtP with (hostile)
	case DIPLO_MESSAGE_HOSTILE_WE_BULLIED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI bullied a Minor the human has a PtP with
	case DIPLO_MESSAGE_WE_BULLIED_YOUR_MINOR:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_YOUR_MINOR", strOptionalKey1);
		break;

		// AI would like to work with a player
	case DIPLO_MESSAGE_WORK_WITH_US:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US");
		break;
#if defined(MOD_BALANCE_CORE)
	// AI wants a Strategic Resource that someone has
	case DIPLO_MESSAGE_STRATEGIC_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_STRATEGIC_TRADE");
		break;
		// AI would like to work with a player they do not trust
	case DIPLO_MESSAGE_DOF_UNTRUSTWORTHY:
		strText = GetDiploTextFromTag("RESPONSE_DOF_UNTRUSTWORTHY");
		break;
		// AI would like to work with a player they've been friends with
	case DIPLO_MESSAGE_DOF_FRIENDS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_FRIENDS");
		break;
		// AI would like to work with a player they've been good friends with
	case DIPLO_MESSAGE_DOF_OLD_FRIENDS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_ALLIES");
		break;
		// AI would like to work with a player they went on a coop war with
	case DIPLO_MESSAGE_DOF_BATTLE_BROTHERS:
		strText = GetDiploTextFromTag("RESPONSE_DOF_BATTLE_BROTHERS");
		break;
#endif

		// AI is done working with a player
	case DIPLO_MESSAGE_END_WORK_WITH_US:
		strText = GetEndDoFMessage(eForPlayer);
		break;

		// AI would like to work against someone with a player
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE:
#if defined(MOD_BALANCE_CORE)
		iMessage = GetDenounceMessage(eForPlayer);
		strText = GetDenounceMessageValue(iMessage);
#else
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE", strOptionalKey1);
#endif
		break;

		// AI is done working with a player against someone
	case DIPLO_MESSAGE_END_WORK_AGAINST_SOMEONE:
		strText = GetEndWorkAgainstSomeoneMessage(eForPlayer, strOptionalKey1);
		break;

		// AI would like to declare war on someone with a player
	case DIPLO_MESSAGE_COOP_WAR_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_REQUEST", strOptionalKey1);
		break;

		// AI calls up and says it's time to declare war on someone with a player
	case DIPLO_MESSAGE_COOP_WAR_TIME:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_TIME", strOptionalKey1);
		break;

		// AI is telling player he's unforgivable
	case DIPLO_MESSAGE_NOW_UNFORGIVABLE:
		strText = GetDiploTextFromTag("RESPONSE_NOW_UNFORGIVABLE");
		break;

		// AI is telling player he's an enemy
	case DIPLO_MESSAGE_NOW_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_NOW_ENEMY");
		break;

		// AI is making fun of the player
	case DIPLO_MESSAGE_INSULT_ROOT:
		strText = GetInsultHumanMessage();
		break;

		// AI is making fun of the player
	case DIPLO_MESSAGE_INSULT_GENERIC:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_GENERIC");
		break;

		// AI is making fun of the player because of his military
	case DIPLO_MESSAGE_INSULT_MILITARY:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_MILITARY");
		break;

		// AI is making fun of the player because of his lack of nukes
	case DIPLO_MESSAGE_INSULT_NUKE:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_NUKE");
		break;

		// AI is making fun of the player because he picks on minors
	case DIPLO_MESSAGE_INSULT_BULLY:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_BULLY");
		break;

		// AI is making fun of the player because his people are unhappy
	case DIPLO_MESSAGE_INSULT_UNHAPPINESS:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_UNHAPPINESS");
		break;

		// AI is making fun of the player because he doesn't have many Cities
	case DIPLO_MESSAGE_INSULT_CITIES:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_CITIES");
		break;

		// AI is making fun of the player because of his population
	case DIPLO_MESSAGE_INSULT_POPULATION:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_POPULATION");
		break;

		// AI is making fun of the player because of his Culture
	case DIPLO_MESSAGE_INSULT_CULTURE:
		strText = GetDiploTextFromTag("RESPONSE_INSULT_CULTURE");
		break;

		// AI is being nice to the player
	case DIPLO_MESSAGE_COMPLIMENT:
		strText = GetDiploTextFromTag("RESPONSE_COMPLIMENT");
		break;

		// AI is afraid of the player
	case DIPLO_MESSAGE_BOOT_KISSING:
		strText = GetDiploTextFromTag("RESPONSE_BOOT_KISSING");
		break;

		// AI is warning player about being a warmonger
	case DIPLO_MESSAGE_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_WARMONGER");
		break;

		// AI is warning player about getting too cozy with a minor
	case DIPLO_MESSAGE_MINOR_CIV_COMPETITION:
		strText = GetDiploTextFromTag("RESPONSE_MINOR_CIV_COMPETITION", strOptionalKey1);
		break;

		// AI is pleased with the human
	case DIPLO_MESSAGE_PLEASED:
		strText = GetDiploTextFromTag("RESPONSE_PLEASED");
		break;

		// AI is thankful towards the human
	case DIPLO_MESSAGE_THANKFUL:
		strText = GetDiploTextFromTag("RESPONSE_THANKFUL");
		break;

		// AI is disappointed in the human
	case DIPLO_MESSAGE_DISAPPOINTED:
		strText = GetDiploTextFromTag("RESPONSE_DISAPPOINTED");
		break;

		// Human has done something bad, and now we're gonna show 'em
	case DIPLO_MESSAGE_SO_BE_IT:
		strText = GetDiploTextFromTag("RESPONSE_SO_BE_IT");
		break;

		// Human returned a captured civilian to us!
	case DIPLO_MESSAGE_RETURNED_CIVILIAN:
		strText = GetDiploTextFromTag("RESPONSE_RETURNED_CIVILIAN");
		break;

		// Human Culture Bombed us!
	case DIPLO_MESSAGE_CULTURE_BOMBED:
		strText = GetDiploTextFromTag("RESPONSE_CULTURE_BOMBED");
		break;

		//////////////////////////////////////////////////////////////
		// AI has a public declaration to make to the world
		//////////////////////////////////////////////////////////////

		// AI is protecting a City-State
	case DIPLO_MESSAGE_DECLARATION_PROTECT_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_DECLARATION_PROTECT_CITY_STATE", strOptionalKey1, GetPlayer()->getCivilizationShortDescriptionKey());
		break;

		// AI is no longer protecting a City-State
	case DIPLO_MESSAGE_DECLARATION_ABANDON_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_DECLARATION_ABANDON_CITY_STATE", strOptionalKey1, GetPlayer()->getCivilizationShortDescriptionKey());
		break;

		//////////////////////////////////////////////////////////////
		// Human is asking the AI for something
		//////////////////////////////////////////////////////////////

		// Human has asked us about something recently, and we still say no
	case DIPLO_MESSAGE_REPEAT_NO:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_NO");
		break;

		// Human asks us not to settle near him, and we say yes
	case DIPLO_MESSAGE_DONT_SETTLE_YES:
		strText = GetDiploTextFromTag("RESPONSE_DONT_SETTLE_YES");
		break;

		// Human asks us not to settle near him, but we say no
	case DIPLO_MESSAGE_DONT_SETTLE_NO:
		strText = GetDiploTextFromTag("RESPONSE_DONT_SETTLE_NO");
		break;

		// Human asks us to work with him, and we say yes
	case DIPLO_MESSAGE_WORK_WITH_US_YES:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US_YES");
		break;

		// Human asks us to work with him, but we say no
	case DIPLO_MESSAGE_WORK_WITH_US_NO:
		strText = GetDiploTextFromTag("RESPONSE_WORK_WITH_US_NO");
		break;

		// Human asks us to work against someone, and we say yes
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE_YES:
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE_YES");
		break;

		// Human asks us to work against someone, but we say no
	case DIPLO_MESSAGE_WORK_AGAINST_SOMEONE_NO:
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE_NO");
		break;

		// Human asks us to declare war on someone, and we say yes
	case DIPLO_MESSAGE_COOP_WAR_YES:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_YES");
		break;

		// Human asks us to declare war on someone, but we say no
	case DIPLO_MESSAGE_COOP_WAR_NO:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_NO");
		break;

		// Human asks us to declare war someone, and we say soon
	case DIPLO_MESSAGE_COOP_WAR_SOON:
		strText = GetDiploTextFromTag("RESPONSE_COOP_WAR_SOON");
		break;

		// Human makes demand of us, and we say yes
	case DIPLO_MESSAGE_HUMAN_DEMAND_YES:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_YES");
		break;

		// Human makes demand of us, and we say no because they're too weak
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_WEAK:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_WEAK");
		break;

		// Human makes demand of us, and we say no because we hate them
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_HOSTILE");
		break;

		// Human makes demand of us, and we tell him he's asking for too much
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_TOO_MUCH");
		break;

		// Human makes demand of us, and we say it's been too soon since last time
	case DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_SOON:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DEMAND_REFUSE_TOO_SOON");
		break;

		//////////////////////////////////////////////////////////////
		// AI popped up to tell the human something, human responded and now we're responding back
		//////////////////////////////////////////////////////////////

		// We noticed human military buildup and he said he was going to kill us now (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD");
		break;

		// We noticed human military buildup and he said betsu ni (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD");
		break;

		// We noticed human military buildup and he said he was going to kill us now :(
	case DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING_BAD");
		break;

		// We noticed human military buildup and he said betsu ni
	case DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_AGGRESSIVE_MILITARY_WARNING_GOOD");
		break;

		// AI attacked human's Minor, human vows revenge, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_MINOR_BAD");
		break;

		// AI attacked human's Minor, human forgives us, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_ATTACKED_MINOR_GOOD");
		break;

		// AI attacked human's Minor, human vows revenge, our response
	case DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_MINOR_BAD");
		break;

		// AI attacked human's Minor, human forgives us, our response
	case DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_WE_ATTACKED_MINOR_GOOD");
		break;

		// AI bullied human's Minor, human vows revenge, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_MINOR_BAD");
		break;

		// AI bullied human's Minor, human forgives us, our response (hostile)
	case DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_WE_BULLIED_MINOR_GOOD");
		break;

		// AI bullied human's Minor, human vows revenge, our response
	case DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_MINOR_BAD");
		break;

		// AI bullied human's Minor, human forgives us, our response
	case DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_WE_BULLIED_MINOR_GOOD");
		break;

		// Other player attacked a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_ATTACKED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human won't stop attacking a Minor
	case DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_ATTACKED_MINOR_BAD");
		break;

		// AI is happy that human says he'll stop attacking a Minor
	case DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_ATTACKED_MINOR_GOOD");
		break;

		// Other player killed a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_KILLED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human killed a Minor
	case DIPLO_MESSAGE_HUMAN_KILLED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MINOR_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after killing a protected Minor
	case DIPLO_MESSAGE_HUMAN_KILLED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MINOR_GOOD");
		break;

		// Other player bullied a City-State this AI is protective of
	case DIPLO_MESSAGE_HUMAN_BULLIED_PROTECTED_CITY_STATE:
		strText = GetDiploTextFromTag("RESPONSE_BULLIED_PROTECTED_CITY_STATE", strOptionalKey1);
		break;

		// AI is upset that human won't stop bullying a Minor
	case DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_BULLIED_MINOR_BAD");
		break;

		// AI is happy that human says he'll stop bullying a Minor
	case DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_BULLIED_MINOR_GOOD");
		break;

		// AI mad at human because he won't heed our serious expansion warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_EXPANSION_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_EXPANSION_WARNING_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after serious expansion warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_EXPANSION_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_EXPANSION_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our expansion warning
	case DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_EXPANSION_WARNING_BAD");
		break;

		// AI is happy human has said he won't expand near him in the future
	case DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_EXPANSION_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our serious plot buying warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_BAD");
		break;

		// AI is willing to receive gift from human to ease relations after serious plot buying warning
	case DIPLO_MESSAGE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SERIOUS_PLOT_BUYING_WARNING_GOOD");
		break;

		// AI mad at human because he won't heed our plot buying warning
	case DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_PLOT_BUYING_WARNING_BAD");
		break;

		// AI is happy human has said he won't buy plots near him in the future
	case DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_PLOT_BUYING_WARNING_GOOD");
		break;

		//////////////////////////////////////////////////////////////
		// Peace messages - DEPRECATED???
		//////////////////////////////////////////////////////////////

		// Player requests peace from AI, AI is is curious what the offer will be
	case DIPLO_MESSAGE_PEACE_WHAT_WILL_HUMAN_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_WHAT_WILL_HUMAN_OFFER");
		break;

		// Player requests peace from AI, AI is happy
	case DIPLO_MESSAGE_PEACE_MADE_BY_HUMAN_GRACIOUS:
		strText = GetDiploTextFromTag("RESPONSE_PEACE_MADE_BY_HUMAN_GRACIOUS");
		break;

		// Player requests peace from AI but it says no
	case DIPLO_MESSAGE_NO_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_NO_PEACE");
		break;

		// Player requests peace from AI on the same turn it attacked...
	case DIPLO_MESSAGE_TOO_SOON_NO_PEACE:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_NO_PEACE");
		break;

		//////////////////////////////////////////////////////////////
		// Trade responses
		//////////////////////////////////////////////////////////////

		// Human asks the AI to accept a bad deal too many times
	case DIPLO_MESSAGE_REPEAT_TRADE_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_TRADE_TOO_MUCH");
		break;

		// Human asks the AI to accept a bad deal again
	case DIPLO_MESSAGE_REPEAT_TRADE:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_TRADE");
		break;

		// AI accepts a generous trade offer
	case DIPLO_MESSAGE_TRADE_ACCEPT_GENEROUS:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_GENEROUS");
		break;

		// AI accepts a reasonable trade offer
	case DIPLO_MESSAGE_TRADE_ACCEPT_ACCEPTABLE:
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if(MOD_DIPLOMACY_CIV4_FEATURES && IsOfferedGift(eForPlayer))
		{
			SetOfferedGift(eForPlayer, false);
			SetOfferingGift(eForPlayer, false);
			strText = GetDiploTextFromTag("RESPONSE_PLEASED");
		}
		else
		{
#endif
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_ACCEPTABLE");
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		}
#endif
		break;

		// Human gave in to AI demand
	case DIPLO_MESSAGE_TRADE_ACCEPT_AI_DEMAND:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_AI_DEMAND");
		break;

		// AI accepts concessions from the human
	case DIPLO_MESSAGE_TRADE_ACCEPT_HUMAN_CONCESSIONS:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_ACCEPT_HUMAN_CONCESSIONS");
		break;

		// AI rejects an unreasonable trade offer
	case DIPLO_MESSAGE_TRADE_REJECT_UNACCEPTABLE:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_REJECT_UNACCEPTABLE");
		break;

		// AI rejects an insulting trade offer
	case DIPLO_MESSAGE_TRADE_REJECT_INSULTING:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_REJECT_INSULTING");
		break;

		// AI sees a good deal it doesn't need to change
	case DIPLO_MESSAGE_TRADE_DEAL_UNCHANGED:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_DEAL_UNCHANGED");
		break;

		// AI offers a counter-deal
	case DIPLO_MESSAGE_TRADE_AI_MAKES_OFFER:
#if defined(MOD_BALANCE_CORE)
		strText = GetOfferText(eForPlayer);
#else
		strText = GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
#endif
		break;

		// AI doesn't see a way to make proposed deal work
	case DIPLO_MESSAGE_TRADE_NO_DEAL_POSSIBLE:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_NO_DEAL_POSSIBLE");
		break;

       // AI can't fairly match human's trade offer
	case DIPLO_MESSAGE_TRADE_CANT_MATCH_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
		break;

		//////////////////////////////////////////////////////////////
		// Human declared war on AI, what is the AI's response?
		//////////////////////////////////////////////////////////////

		// AI attacked by human player
	case DIPLO_MESSAGE_ATTACKED_ROOT:
		strText = GetAttackedByHumanMessage();
		break;

		// Attacked: Hostile response
	case DIPLO_MESSAGE_ATTACKED_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_HOSTILE");
		break;

		// Attacked: Hostile response (Weak player)
	case DIPLO_MESSAGE_ATTACKED_WEAK_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_HOSTILE");
		break;

		// Attacked: Hostile response (Strong player)
	case DIPLO_MESSAGE_ATTACKED_STRONG_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_HOSTILE");
		break;

		// Attacked: Excited response
	case DIPLO_MESSAGE_ATTACKED_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_EXCITED");
		break;

		// Attacked: Excited response (Weak Player)
	case DIPLO_MESSAGE_ATTACKED_WEAK_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_EXCITED");
		break;

		// Attacked: Excited response (Strong player)
	case DIPLO_MESSAGE_ATTACKED_STRONG_EXCITED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_EXCITED");
		break;

		// Attacked: Sad response
	case DIPLO_MESSAGE_ATTACKED_SAD:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_SAD");
		break;

		// Attacked: Betrayed response
	case DIPLO_MESSAGE_ATTACKED_BETRAYED:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_BETRAYED");
		break;

		// Attacked: Broken military promise response
	case DIPLO_MESSAGE_ATTACKED_MILITARY_PROMISE_BROKEN:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_MILITARY_PROMISE_BROKEN");
		break;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		// Attacked: Human is warmonger and AI is stronger
	case DIPLO_MESSAGE_ATTACKED_STRONG_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_STRONG_WARMONGER");
		break;

		// Attacked: Human is warmonger and AI is weaker
	case DIPLO_MESSAGE_ATTACKED_WEAK_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WEAK_WARMONGER");
		break;

		// Attacked: Human is warmonger
	case DIPLO_MESSAGE_ATTACKED_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_WARMONGER");
		break;

		// Attacked: Human and AI have different ideologies
	case DIPLO_MESSAGE_ATTACKED_IDEOLOGY_DIFFERENCE:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_IDEOLOGY_DIFFERENCE");
		break;

		// Attacked: Human and AI have the same ideology
	case DIPLO_MESSAGE_ATTACKED_IDEOLOGY_SAME:
		strText = GetDiploTextFromTag("RESPONSE_ATTACKED_IDEOLOGY_SAME");
		break;	
#endif
#if defined(MOD_BALANCE_CORE_DEALS)
		// AI DP request
	case DIPLO_MESSAGE_DEFENSE_PACT_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_DEFENSIVE_PACT_REQUEST");
		break;

		// Trade Cities request
	case DIPLO_MESSAGE_TRADE_CITIES_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TRADE_CITIES_REQUEST");
		break;

		// Exchange Cities request		
	case DIPLO_MESSAGE_EXCHANGE_CITIES_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_EXCHANGE_CITIES_REQUEST");
		break;	

		// Third party peace
	case DIPLO_MESSAGE_THIRDPARTY_PEACE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_THIRD_PARTY_PEACE_REQUEST");
		break;

		// Third party war
	case DIPLO_MESSAGE_THIRDPARTY_WAR_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_THIRD_PARTY_WAR_REQUEST");
		break;

		// World Congress vote
	case DIPLO_MESSAGE_VOTE_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_VOTE_COMMITMENT_REQUEST");
		break;
		
#endif

		//////////////////////////////////////////////////////////////
		// AI is declaring war on human, what does he say?
		//////////////////////////////////////////////////////////////

		// AI declaring war on human
	case DIPLO_MESSAGE_DOW_ROOT:
		strText = GetWarMessage(eForPlayer);
		break;

		// AI DoW: Generic declaration
	case DIPLO_MESSAGE_DOW_GENERIC:
		strText = GetDiploTextFromTag("RESPONSE_DOW_GENERIC");
		break;

		// AI DoW: Declared war over land dispute
	case DIPLO_MESSAGE_DOW_LAND:
		strText = GetDiploTextFromTag("RESPONSE_DOW_LAND");
		break;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	// AI DoW: AI and human have gone to war several times
	case DIPLO_MESSAGE_DOW_OLD_ENEMIES:
		strText = GetDiploTextFromTag("RESPONSE_DOW_OLD_ENEMIES");
		break;

	// AI DoW: AI is putting an end to the human's warmongering
	case DIPLO_MESSAGE_DOW_WARMONGER:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WARMONGER");
		break;

	// AI DoW: AI and human have different ideologies
	case DIPLO_MESSAGE_DOW_IDEOLOGY_DIFFERENCE:
		strText = GetDiploTextFromTag("RESPONSE_DOW_IDEOLOGY_DIFFERENCE");
		break;

	// AI DoW: AI and human have the same ideology
	case DIPLO_MESSAGE_DOW_IDEOLOGY_SAME:
		strText = GetDiploTextFromTag("RESPONSE_DOW_IDEOLOGY_SAME");
		break;
#endif

		// AI DoW: AI is going for world conquest
	case DIPLO_MESSAGE_DOW_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WORLD_CONQUEST");
		break;

		// AI DoW: AI is attacking because the player is weak
	case DIPLO_MESSAGE_DOW_OPPORTUNITY:
		strText = GetDiploTextFromTag("RESPONSE_DOW_OPPORTUNITY");
		break;

		// AI DoW: AI is attacking out of desperation
	case DIPLO_MESSAGE_DOW_DESPERATE:
		strText = GetDiploTextFromTag("RESPONSE_DOW_DESPERATE");
		break;

		// AI DoW: AI was pretending to be friendly beforehand
	case DIPLO_MESSAGE_DOW_BETRAYAL:
		strText = GetDiploTextFromTag("RESPONSE_DOW_BETRAYAL");
		break;

		// AI DoW: AI was pretending to be friendly beforehand AND human is weaker
	case DIPLO_MESSAGE_DOW_WEAK_BETRAYAL:
		strText = GetDiploTextFromTag("RESPONSE_DOW_WEAK_BETRAYAL");
		break;

		// AI DoW: AI regrets declaring war
	case DIPLO_MESSAGE_DOW_REGRET:
		strText = GetDiploTextFromTag("RESPONSE_DOW_REGRET");
		break;

		// AI declares war because human refused to give in to a demand
	case DIPLO_MESSAGE_WAR_DEMAND_REFUSED:
		strText = GetDiploTextFromTag("RESPONSE_WAR_DEMAND_REFUSED");
		break;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	// AI declares war because human insulted them.
	case DIPLO_MESSAGE_WAR_RUDE_INSULT:
		strText = GetDiploTextFromTag("RESPONSE_WAR_DEMAND_INSULTED");
		break;
#endif
		/////////////////////////////////
		// Post Civ 5 Release Mish-Mash of stuff
		/////////////////////////////////

		// AI asks a friend to denounce another player
	case DIPLO_MESSAGE_DOF_AI_DENOUNCE_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOF_AI_DENOUNCE_REQUEST", strOptionalKey1);
		break;

		// AI asks a friend to declare war on another player
	case DIPLO_MESSAGE_DOF_AI_WAR_REQUEST:
		strText = GetDiploTextFromTag("RESPONSE_DOF_AI_WAR_REQUEST", strOptionalKey1);
		break;

		// AI asked a friend to do something, but they didn't and now the AI is pissed
	case DIPLO_MESSAGE_DOF_NOT_HONORED:
		strText = GetDiploTextFromTag("RESPONSE_DOF_NOT_HONORED");
		break;

		// AI is denouncing the human, who had been a friend
	case DIPLO_MESSAGE_AI_DOF_BACKSTAB:
		strText = GetDiploTextFromTag("RESPONSE_AI_DOF_BACKSTAB");
		break;

		// AI response to being denounced by the human
	case DIPLO_MESSAGE_RESPONSE_TO_BEING_DENOUNCED:
		strText = GetDiploTextFromTag("RESPONSE_RESPONSE_TO_BEING_DENOUNCED");
		break;

		// AI response to human DoFing a friend
	case DIPLO_MESSAGE_HUMAN_DOFED_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOFED_FRIEND", strOptionalKey1);
		break;

		// AI response to human DoFing an enemy
	case DIPLO_MESSAGE_HUMAN_DOFED_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOFED_ENEMY", strOptionalKey1);
		break;

		// AI response to human denouncing a friend
	case DIPLO_MESSAGE_HUMAN_DENOUNCED_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCED_FRIEND", strOptionalKey1);
		break;

		// AI response to human denouncing an enemy
	case DIPLO_MESSAGE_HUMAN_DENOUNCED_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCED_ENEMY", strOptionalKey1);
		break;

		// AI DoFed someone because the human DoFed them (nice)
	case DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DOF:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOF_SO_AI_DOF", strOptionalKey1);
		break;

		// AI denounced someone because the human denounced them (nice)
	case DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DENOUNCE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCE_SO_AI_DENOUNCE", strOptionalKey1);
		break;

		// AI denounced someone because the human DoFed them (mean)
	case DIPLO_MESSAGE_HUMAN_DOF_SO_AI_DENOUNCE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DOF_SO_AI_DENOUNCE", strOptionalKey1);
		break;

		// AI DoFed someone because the human denounced them (mean)
	case DIPLO_MESSAGE_HUMAN_DENOUNCE_SO_AI_DOF:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_DENOUNCE_SO_AI_DOF", strOptionalKey1);
		break;

		// Saying hello - AI denounced the human
	case DIPLO_MESSAGE_GREETING_DENOUNCED_BY_AI:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_BY_AI");
		break;

		// Saying hello - human denounced the AI
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_AI");
		break;

		// Saying hello - Human has a DoF with an enemy of the AI's
	case DIPLO_MESSAGE_GREETING_OUR_DOF_WITH_AI_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_OUR_DOF_WITH_ENEMY_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has a DoF with a friend of the AI's
	case DIPLO_MESSAGE_GREETING_OUR_DOF_WITH_AI_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_OUR_DOF_WITH_FRIEND_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has denounced a friend of the AI's
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI_FRIEND:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_FRIEND_OF_AI", strOptionalKey1);
		break;

		// Saying hello - Human has denounced an enemy of the AI's
	case DIPLO_MESSAGE_GREETING_DENOUNCED_AI_ENEMY:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_DENOUNCED_ENEMY_OF_AI", strOptionalKey1);
		break;

		// Human asked for a DoF, but the AI hasn't known him for long enough
	case DIPLO_MESSAGE_TOO_SOON_FOR_DOF:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_FOR_DOF");
		break;

		// Same late game policy tree
	case DIPLO_MESSAGE_SAME_POLICIES_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_FREEDOM");
		break;
	case DIPLO_MESSAGE_SAME_POLICIES_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_ORDER");
		break;
	case DIPLO_MESSAGE_SAME_POLICIES_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_SAME_POLICIES_AUTOCRACY");
		break;

		/////////////////////////////////
		// Espionage messages
		/////////////////////////////////

		// AI response to catching one of human's spies
	case DIPLO_MESSAGE_CAUGHT_YOUR_SPY:
		strText = GetDiploTextFromTag("RESPONSE_CAUGHT_YOUR_SPY");
		break;

		// AI response to killing one of human's spies
	case DIPLO_MESSAGE_KILLED_YOUR_SPY:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_YOUR_SPY");
		break;

		// AI response to human killing one of their spies
	case DIPLO_MESSAGE_KILLED_MY_SPY:
		strText = GetDiploTextFromTag("RESPONSE_KILLED_MY_SPY");
		break;

        // Human confronts AI about having killed their spy through the notification
	case DIPLO_MESSAGE_CONFRONT_YOU_KILLED_MY_SPY:
		strText = GetDiploTextFromTag("RESPONSE_CONFRONT_YOU_KILLED_MY_SPY");
		break;

		// AI asks human to stop sending missionaries and prophets
	case DIPLO_MESSAGE_STOP_CONVERSIONS:
		strText = GetDiploTextFromTag("RESPONSE_STOP_CONVERSIONS");
		break;

        // Human agreed to stop spying on AI
	case DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_CAUGHT_YOUR_SPY_GOOD");
		break;

        // Human did not agree to stop spying on AI
	case DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_CAUGHT_YOUR_SPY_BAD");
		break;

		// Human asks us not to spy on him, and we say yes
	case DIPLO_MESSAGE_STOP_SPYING_YES:
		strText = GetDiploTextFromTag("RESPONSE_STOP_SPYING_YES");
		break;

		// Human asks us not to spy on him, but we say no
	case DIPLO_MESSAGE_STOP_SPYING_NO:
		strText = GetDiploTextFromTag("RESPONSE_STOP_SPYING_NO");
		break;

       // Human warns AI about another civ's war plans/deception towards them
	case DIPLO_MESSAGE_WARNED_ABOUT_INTRIGUE:
		strText = GetDiploTextFromTag("RESPONSE_WARNED_ABOUT_INTRIGUE", strOptionalKey1);
		break;

      // AI warns human that another leader is plotting against them
	case DIPLO_MESSAGE_SHARE_INTRIGUE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_DECEPTION", strOptionalKey1);
		break;

      // AI warns human that another civ is planning a sneak attack against a specific city of theirs
	case DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_KNOWN_CITY", strOptionalKey1, strOptionalKey2);
		break;

      // AI warns human that another civ is planning a sneak attack against them, but don't know which city
	case DIPLO_MESSAGE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_ARMY_SNEAK_ATTACK_UNKNOWN_CITY", strOptionalKey1);
		break;

      // AI warns human that another civ is planning a sneak attack against a specific city of theirs (amphibious)
	case DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_KNOWN_CITY", strOptionalKey1, strOptionalKey2);
		break;

      // AI warns human that another civ is planning a sneak attack against them, but don't know which city (amphibious)
	case DIPLO_MESSAGE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_INTRIGUE_AMPHIBIOUS_SNEAK_ATTACK_UNKNOWN_CITY", strOptionalKey1);
		break;

		// Human catches enemy spy and does not forgive the thief
	case DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_UNFORGIVEN:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MY_SPY_UNFORGIVEN");
		break;

		// Human catches enemy spy and forgives the thief
	case DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_FORGIVEN:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_KILLED_MY_SPY_FORGIVEN");
		break;

        // AI asks human to stop sending missionaries and prophets. The human agrees.
	case DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_GOOD");
		break;

        // AI asks human to stop sending missionaries and prophets. The human disagrees.
	case DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_BAD");
		break;

	   // Human asks AI to stop sending missionaries and prophets. The AI player agrees.
	case DIPLO_MESSAGE_STOP_CONVERSIONS_AGREE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_AGREE");
		break;

	   // Human asks AI to stop sending missionaries and prophets. The AI player disagrees.
	case DIPLO_MESSAGE_STOP_CONVERSIONS_DISAGREE:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_CONVERSIONS_DISAGREE");
		break;

       // AI asks human to stop digging up their artifacts.
	case DIPLO_MESSAGE_STOP_DIGGING:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING");
		break;

       // Human asks AI to stop digging up their artifacts. The AI player agrees.
	case DIPLO_MESSAGE_STOP_DIGGING_AGREE:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING_AGREE");
		break;

       // Human asks AI to stop digging up their artifacts. The AI player disagrees.
	case DIPLO_MESSAGE_STOP_DIGGING_DISAGREE:
		strText = GetDiploTextFromTag("RESPONSE_STOP_DIGGING_DISAGREE");
		break;

       // AI asks human to stop digging up their artifacts. The human disagrees.
	case DIPLO_MESSAGE_HUMAN_STOP_DIGGING_BAD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_DIGGING_BAD");
		break;

      // AI asks human to stop digging up their artifacts. The human agrees.
	case DIPLO_MESSAGE_HUMAN_STOP_DIGGING_GOOD:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_STOP_DIGGING_GOOD");
		break;

		/////////////////////////////////
		// League messages
		/////////////////////////////////

       // AI tells human they liked human's proposal to the World Congress
	case DIPLO_MESSAGE_WE_LIKED_THEIR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_WE_LIKE_HUMAN_PROPOSAL", strOptionalKey1);
		break;

       // AI tells human they disliked human's proposal to the World Congress
	case DIPLO_MESSAGE_WE_DISLIKED_THEIR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_WE_DISLIKE_HUMAN_PROPOSAL", strOptionalKey1);
		break;

       // AI thanks human for supporting their proposal to the World Congress
	case DIPLO_MESSAGE_THEY_SUPPORTED_OUR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SUPPORTED_OUR_PROPOSAL", strOptionalKey1);
		break;

       // AI is angry at human for helping their proposal fail in the World Congress
	case DIPLO_MESSAGE_THEY_FOILED_OUR_PROPOSAL:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_FOILED_OUR_PROPOSAL", strOptionalKey1);
		break;

       // AI thanks human for helping make the AI host of the World Congress
	case DIPLO_MESSAGE_THEY_SUPPORTED_OUR_HOSTING:
		strText = GetDiploTextFromTag("RESPONSE_HUMAN_SUPPORTED_OUR_HOSTING", strOptionalKey1);
		break;

	  // Ideological messages
	  // Human has Freedom, AI does not and AI's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_FREEDOM");
		break;
	  // Human has Order, AI does not and AI's people are unhappy with their choice of ideology	
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_ORDER");
		break;
	  // Human has Autocracy, AI does not and AI's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_AI_BY_AUTOCRACY");
		break;
	  // AI has Freedom, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_FREEDOM");
		break;
	  // AI has Order, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_ORDER");
		break;
	  // AI has Autocracy, human does not and human's people are unhappy with their choice of ideology
	case DIPLO_MESSAGE_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_CIVIL_RESISTANCE_ON_HUMAN_BY_AUTOCRACY");
		break;
	  // Human switched to Freedom and AI has Freedom
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_FREEDOM:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_FREEDOM");
		break;
	  // Human switched to Order and AI has Order
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_ORDER:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_ORDER");
		break;
	  // Human switched to Autocracy and AI has Autocracy
	case DIPLO_MESSAGE_SWITCH_OUR_IDEOLOGY_AUTOCRACY:
		strText = GetDiploTextFromTag("RESPONSE_SWITCHED_TO_AUTOCRACY");
		break;
		
	// Human is influential over the AI - defeat message based on era
	case DIPLO_MESSAGE_YOUR_CULTURE_INFLUENTIAL:
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(MOD_BALANCE_CORE_DIPLOMACY_ERA_INFLUENCE && eCurrentEra <= 1)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_CLASSICAL");
		}
		else if(MOD_BALANCE_CORE_DIPLOMACY_ERA_INFLUENCE  && eCurrentEra >= 2 && eCurrentEra < 4)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_RENAISSANCE");
		}
		else if(MOD_BALANCE_CORE_DIPLOMACY_ERA_INFLUENCE  && eCurrentEra >= 4 && eCurrentEra < 6)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI_MODERN");
		}
		else
		{
#endif
		strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_AI");
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		}
#endif
		break;
	
	// AI is influential over human - victory message based on era
	case DIPLO_MESSAGE_OUR_CULTURE_INFLUENTIAL:
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(eCurrentEra <= 1)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_CLASSICAL");
		}
		else if(eCurrentEra >= 2 && eCurrentEra < 4)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_RENAISSANCE");
		}
		else if(eCurrentEra >= 4 && eCurrentEra < 6)
		{
			strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN_MODERN");
		}
		else
		{
#endif
		strText = GetDiploTextFromTag("RESPONSE_INFLUENTIAL_ON_HUMAN");
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		}
#endif
		break;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	// AI announces that they're competing with human over Domination Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST");
		break;
	// AI announces that they're competing with human over Diplomatic Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS");
		break;
	// AI announces that they're competing with human over Cultural Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CULTURE");
		break;
	// AI announces that they're competing with human over Science Victory
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP");
		break;
	// AI announces that they're competing with human but doesn't know what victory human is going for
	case DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_COMPETITION_ANNOUNCE_CONFUSED");
		break;
	// AI announces that they want to stop the human's Domination Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST");
		break;
	// AI announces that they want to stop the human's Diplomatic Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS");
		break;
	// AI announces that they want to stop the human's Cultural Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_CULTURE");
		break;
	// AI announces that they want to stop the human's Science Victory plans (and aren't also going for that victory)
	case DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP:
		strText = GetDiploTextFromTag("DIPLO_MESSAGE_VICTORY_BLOCK_ANNOUNCE_SPACESHIP");
		break;
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Human repeatedly asks AI for opinion of another player after they said no (hostile)
	case DIPLO_MESSAGE_HOSTILE_REPEAT_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_REPEAT_SHARE_OPINION_NO");
		break;
	// Human repeatedly asks AI for opinion of another player after they said no
	case DIPLO_MESSAGE_REPEAT_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_REPEAT_SHARE_OPINION_NO");
		break;
	// Human asks AI for their opinion of another player. The AI refuses. (hostile)
	case DIPLO_MESSAGE_HOSTILE_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_HOSTILE_SHARE_OPINION_NO");
		break;
    // Human asks AI for their opinion of another player. The AI refuses.
	case DIPLO_MESSAGE_SHARE_OPINION_NO:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_NO");
		break;
    // AI tells human its approach towards another player (FRIENDLY)
	case DIPLO_MESSAGE_SHARE_OPINION_FRIENDLY:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_FRIENDLY", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (NEUTRAL)
	case DIPLO_MESSAGE_SHARE_OPINION_NEUTRAL:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_NEUTRAL", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (GUARDED)
	case DIPLO_MESSAGE_SHARE_OPINION_GUARDED:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_GUARDED", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (HOSTILE)
	case DIPLO_MESSAGE_SHARE_OPINION_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_HOSTILE", strOptionalKey1);
		break;
    // AI tells human it is at war with another player
	case DIPLO_MESSAGE_SHARE_OPINION_WAR:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_WAR", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (AFRAID)
	case DIPLO_MESSAGE_SHARE_OPINION_AFRAID:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_AFRAID", strOptionalKey1);
		break;
    // AI tells human it is planning war against another player
	case DIPLO_MESSAGE_SHARE_OPINION_PLANNING_WAR:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_PLANNING_WAR", strOptionalKey1);
		break;
    // AI tells human its approach towards another player (DECEPTIVE)
	case DIPLO_MESSAGE_SHARE_OPINION_DECEPTIVE:
		strText = GetDiploTextFromTag("RESPONSE_SHARE_OPINION_DECEPTIVE", strOptionalKey1);
		break;
    // AI tells human it hasn't known them long enough to share its opinion of others
	case DIPLO_MESSAGE_TOO_SOON_FOR_SHARE_OPINION:
		strText = GetDiploTextFromTag("RESPONSE_TOO_SOON_FOR_SHARE_OPINION");
		break;
    // AI wants to trade for the player's World Map
	case DIPLO_MESSAGE_MAPS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_MAPS_OFFER");
		break;
    // AI wants to trade for one of the player's technologies
	case DIPLO_MESSAGE_TECH_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_TECH_OFFER");
		break;
    // AI is making a generous offer towards the player
	case DIPLO_MESSAGE_GENEROUS_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_GENEROUS_OFFER");
		break;
    // AI accepts a human's request for help
	case DIPLO_MESSAGE_HUMAN_REQUEST_YES:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_YES");
		break;
    // AI refuses a human's request for help (too much)
	case DIPLO_MESSAGE_HUMAN_REQUEST_TOO_MUCH:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_REFUSE_TOO_MUCH");
		break;
    // AI refuses a human's request for help (too soon since last request)
	case DIPLO_MESSAGE_HUMAN_REQUEST_TOO_SOON:
		strText = GetDiploTextFromTag("RESPONSE_HELP_REQUEST_REFUSE_TOO_SOON");
		break;
    // Human attacked his AI vassal
	case DIPLO_MESSAGE_VASSALAGE_ATTACKED_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_ATTACKED_VASSAL");
		break;

	// AI vassal greets his human master (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_VASSALAGE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_VASSAL_HOSTILE");
		break;

	// AI vassal greets his human master
	case DIPLO_MESSAGE_GREETING_VASSALAGE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_VASSAL");
		break;

	// AI master greets his human vassal (hostile)
	case DIPLO_MESSAGE_GREETING_HOSTILE_VASSALAGE_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_HOSTILE_VASSALAGE_MASTER");
		break;

	// AI master greets his human vassal
	case DIPLO_MESSAGE_GREETING_VASSALAGE_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_GREETING_VASSALAGE_MASTER");
		break;

	// Ai wants the player to liberate his vassals (trade offer)
	case DIPLO_MESSAGE_REVOKE_VASSAL_THIRD_OFFER:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_TRADE_REVOKE");
		break;

	// AI asks human to revoke his vassalage of them (hostile)
	case DIPLO_MESSAGE_REVOKE_VASSALAGE_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKE_VASSALAGE_HOSTILE");
		break;

    // AI asks human to revoke his vassalage of them
	case DIPLO_MESSAGE_REVOKE_VASSALAGE:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKE_VASSALAGE");
		break;

	// Human revokes AI vassalage peacefully
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_PEACEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_HUMAN_PEACEFUL");
		break;

	// Human tells AI to die
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_WAR:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_HUMAN_WAR");
		break;

	// AI grants human independence
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_PEACEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_PEACEFUL");
		break;

	// AI tells human to die
	case DIPLO_MESSAGE_VASSALAGE_REVOKED_FORCEFUL:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_REVOKED_FORCEFUL");
		break;

    // AI agrees to remove their troops from human's borders
	case DIPLO_MESSAGE_MOVE_TROOPS_ACCEPT:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_ACCEPT");
		break;
    // AI promises their troops are not on human's borders for war
	case DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_NEUTRAL");
		break;
    // AI promises their troops are not on human's borders for war (hostile)
	case DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_NEUTRAL_HOSTILE");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_CONQUEST:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_CONQUEST");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_DECEPTIVE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_DECEPTIVE");
		break;
    // AI declares war on human after human requested they move their troops
	case DIPLO_MESSAGE_MOVE_TROOPS_REJECT_HOSTILE:
		strText = GetDiploTextFromTag("RESPONSE_MOVE_TROOPS_REJECT_HOSTILE");
		break;
	// AI liberates human vassal without being asked
	case DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN:
		strText = GetDiploTextFromTag("RESPONSE_VASSALAGE_LIBERATED_HUMAN");
		break;
	// AI vassal is unhappy that human raised their taxes
	case DIPLO_MESSAGE_VASSAL_TAXES_RAISED_HUMAN_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_RAISED_HUMAN_MASTER");
		break;
	// AI tells human vassal their taxes are now raised
	case DIPLO_MESSAGE_VASSAL_TAXES_RAISED_AI_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_RAISED_AI_MASTER");
		break;
	// AI vassal is happy that human lowered their taxes
	case DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_HUMAN_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_LOWERED_HUMAN_MASTER");
		break;
	// AI tells human vassal their taxes are now lowered
	case DIPLO_MESSAGE_VASSAL_TAXES_LOWERED_AI_MASTER:
		strText = GetDiploTextFromTag("RESPONSE_VASSAL_TAXES_LOWERED_AI_MASTER");
		break;
	// Human liberates AI vassal without being asked
	case DIPLO_MESSAGE_VASSALAGE_LIBERATE_VASSAL:
		strText = GetDiploTextFromTag("RESPONSE_LIBERATE_VASSAL");
		break;
#endif

		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////

		// Should always have a state we're handling
	default:
		strText = "NO MESSAGE. Trying to get Diplo string.  Something has gone wrong, somehow.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.";
		CvAssert(false);
		break;
	}

	return strText;
}


/// Message from UI to gameplay about something that should happen with regards to diplomacy
void CvDiplomacyAI::DoFromUIDiploEvent(PlayerTypes eFromPlayer, FromUIDiploEventTypes eEvent, int iArg1, int iArg2)
{
	CvAssertMsg(eEvent >= 0, "DIPLOMACY_AI: Invalid FromUIDiploEventType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eEvent < NUM_FROM_UI_DIPLO_EVENTS, "DIPLOMACY_AI: Invalid FromUIDiploEventType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "";

	TeamTypes eFromTeam = GET_PLAYER(eFromPlayer).getTeam();

	// Are we processing this message on the active player's computer?
	bool bActivePlayer = GC.getGame().getActivePlayer() == eFromPlayer;

	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	switch(eEvent)
	{
		// *********************************************
		// Player declares war on the AI
		// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DECLARES_WAR:
	{
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// Changed some logic around so player can see the special declared war on vassal logic
		if(!(MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(eFromPlayer)))
		{
#endif

#if defined(MOD_EVENTS_WAR_AND_PEACE)
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam());
#else
			GET_TEAM(eFromTeam).declareWar(GetTeam());
#endif

		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_ROOT);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_WAR_DECLARED_BY_HUMAN, strText, LEADERHEAD_ANIM_ATTACKED, iArg1);
		}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		}
		if(MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(eFromPlayer))
		{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam());
#else
			GET_TEAM(eFromTeam).declareWar(GetTeam());
#endif
		}
#endif

		break;
	}

	// *********************************************
	// Player requests peace
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_NEGOTIATE_PEACE:
	{
		if(bActivePlayer)
		{
			PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eFromPlayer);
			PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eFromPlayer);

			// Does the AI actually want peace?
			if(IsWillingToMakePeaceWithHuman(eFromPlayer) &&
			        ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE && ePeaceTreatyImWillingToAccept >= PEACE_TREATY_WHITE_PEACE)
			{
				// This is essentially the same as the human opening the trade screen
				GetPlayer()->GetDealAI()->DoTradeScreenOpened();

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PEACE_WHAT_WILL_HUMAN_OFFER);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_TRADE, strText, LEADERHEAD_ANIM_LETS_HEAR_IT);
			}
			else
			{
				// Player declared war and wants peace right away.  Uh huh, right.
#if defined(MOD_BALANCE_CORE)
				if((GetPlayerNumTurnsAtWar(eFromPlayer) <= 1) && (GetPlayerNumTurnsSinceCityCapture(eFromPlayer) <= 1))
#else
				if(GetPlayerNumTurnsAtWar(eFromPlayer) < 1)
#endif
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_NO_PEACE);
				// Don't want peace for some other reason
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_NO_PEACE);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_WAR_DECLARED_BY_HUMAN, strText, LEADERHEAD_ANIM_NO);
			}
		}

		break;
	}

	// *********************************************
	// Player wants to discuss something with the AI
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_WANTS_DISCUSSION:
	{
		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_LETS_HEAR_IT);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_LETS_HEAR_IT);
		}

		break;
	}

	// *********************************************
	// Player told the AI to not settle near him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_DONT_SETTLE:
	{
		// Player has asked this before
		if(IsDontSettleMessageTooSoon(eFromPlayer))
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// AI gives a new answer
		else
		{
			SetPlayerNoSettleRequestCounter(eFromPlayer, 0);
#if defined(MOD_BALANCE_CORE)
			SetPlayerNoSettleRequestEverAsked(eFromPlayer, true);
#endif
			bool bAcceptable;
			bAcceptable = IsDontSettleAcceptable(eFromPlayer);

			if(bAcceptable)
			{
				SetPlayerNoSettleRequestAccepted(eFromPlayer, true);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMadeExpansionPromise(GetPlayer()->GetID(), true);
			}

			if(bActivePlayer)
			{
				if(bAcceptable)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DONT_SETTLE_YES);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NEGATIVE);
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DONT_SETTLE_NO);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
				}
			}
		}

		break;
	}

	// *********************************************
	// Player told the AI to not spy on him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_SPYING:
	{
		// Player has asked this before
		if(IsStopSpyingMessageTooSoon(eFromPlayer))
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// AI gives a new answer
		else
		{
			SetPlayerStopSpyingRequestCounter(eFromPlayer, 0);
#if defined(MOD_BALANCE_CORE)
			SetPlayerStopSpyingRequestEverAsked(eFromPlayer, true);
#endif

			bool bAcceptable;
			bAcceptable = IsStopSpyingAcceptable(eFromPlayer);

			if(bAcceptable)
			{
				SetPlayerStopSpyingRequestAccepted(eFromPlayer, true);
				m_pPlayer->GetEspionageAI()->EvaluateSpiesAssignedToTargetPlayer(eFromPlayer);
			}

			if(bActivePlayer)
			{
				DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
				if(iArg1 == 1)
				{
					eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
				}

				LeaderheadAnimationTypes eAnimType;

				if(bAcceptable)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_SPYING_YES);
					eAnimType = LEADERHEAD_ANIM_NEGATIVE;
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_SPYING_NO);
					eAnimType = LEADERHEAD_ANIM_NO;
				}

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
			}
		}

		break;
	}

	// *********************************************
	// Player told the AI to not spread their religion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_SPREADING_RELIGION:
	{
		if (bActivePlayer)
		{	
			SetPlayerAskedNotToConvert(eFromPlayer, true);
			DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
			if(iArg1 == 1)
			{
				eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
			}

			LeaderheadAnimationTypes eAnimType;

			bool bIsYes = IsStopSpreadingReligionAcceptable(eFromPlayer);
			if (bIsYes)
			{					
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS_AGREE);
				eAnimType = LEADERHEAD_ANIM_NEGATIVE;
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_CONVERSIONS_DISAGREE);
				eAnimType = LEADERHEAD_ANIM_NO;
			}

			SetPlayerAgreeNotToConvert(eFromPlayer, bIsYes);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
		}
		break;
	}

		// *********************************************
		// Player told the AI to not dig up their yard (artifacts)
		// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_STOP_DIGGING:
	{
		if (bActivePlayer)
		{	
			SetPlayerAskedNotToDig(eFromPlayer, true);
			DiploUIStateTypes eStateType = DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED;
			if(iArg1 == 1)
			{
				eStateType = DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT;
			}

			LeaderheadAnimationTypes eAnimType;

			bool bIsYes = IsStopDiggingAcceptable(eFromPlayer);
			if (bIsYes)
			{					
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING_AGREE);
				eAnimType = LEADERHEAD_ANIM_NEGATIVE;
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_STOP_DIGGING_DISAGREE);
				eAnimType = LEADERHEAD_ANIM_NO;
			}

			SetPlayerAgreeNotToDig(eFromPlayer, bIsYes);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, eStateType, strText, eAnimType);
		}
		break;
	}

	// *********************************************
	// Player asked if the AI will work with him
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_WORK_WITH_US:
	{
		// AI hasn't known the human for long enough yet
		if(IsTooEarlyForDoF(eFromPlayer))
		{
			SetDoFCounter(eFromPlayer, 0);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, 0);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_FOR_DOF);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// Player has asked this before
		else if(IsDoFMessageTooSoon(eFromPlayer))
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
			}
		}
		// AI gives a new answer
		else
		{
			SetDoFCounter(eFromPlayer, 0);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, 0);

			bool bAcceptable = IsDoFAcceptable(eFromPlayer);
			if(bAcceptable)
			{
				SetDoFAccepted(eFromPlayer, true);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, true);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
				if(GetDoFType(eFromPlayer) == DOF_TYPE_ALLIES || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_ALLIES)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_BATTLE_BROTHERS);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_BATTLE_BROTHERS);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_FRIENDS || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_FRIENDS)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_ALLIES);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_ALLIES);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_NEW || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_NEW)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_FRIENDS);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_FRIENDS);
				}
				else if(GetDoFType(eFromPlayer) == DOF_TYPE_UNTRUSTWORTHY || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_UNTRUSTWORTHY)
				{
					SetDoFType(eFromPlayer, DOF_TYPE_NEW);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_NEW);
				}		
#endif
			}

			if(bActivePlayer)
			{
				if(bAcceptable)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US_YES);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WORK_WITH_US_NO);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
				}
			}
		}

		break;
	}

	// *********************************************
	// Player said he's done working with the AI
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_END_WORK_WITH_US:
	{
		SetDoFAccepted(eFromPlayer, false);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
		SetDoFCounter(eFromPlayer, -666);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, -666);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		SetDoFType(eFromPlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_UNTRUSTWORTHY);
#endif

		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// Human refused to give in to demand
	// *********************************************
	case FROM_UI_DIPLO_EVENT_DEMAND_HUMAN_REFUSAL:
	{
		// Does the AI declare war?
		bool bDeclareWar = false;
		
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < ((GetMeanness() + GetBoldness()) / 2))
#else
		if(GC.getGame().getJonRandNum(100, "Human demand refusal war rand.") < 50)
#endif
		{
			bDeclareWar = true;
		}
		
		// If we're stronger than them, declare war!
		if (GetPlayerMilitaryStrengthComparedToUs(eFromPlayer) < STRENGTH_AVERAGE && GetPlayerEconomicStrengthComparedToUs(eFromPlayer) < STRENGTH_AVERAGE)
		{
			bDeclareWar = true;
		}
		
		if (bDeclareWar)
		{
			// Disallowed by game options
			if (IsWarDisallowed(eFromPlayer))
			{
				bDeclareWar = false;
			}
			// Would this war cause us or our teammates to backstab a friend/ally? Don't do it!
			else if (IsWarWouldBackstabFriendTeamCheck(eFromPlayer))
			{
				bDeclareWar = false;
			}
		}
		
		// Sanity check - avoid going bankrupt
		int iAdjustedGoldPerTurn = GetPlayer()->calculateGoldRate() - CalculateGoldPerTurnLostFromWar(eFromPlayer, false, false);
		if (iAdjustedGoldPerTurn < 0)
			bDeclareWar = false;
		
		// Sanity check - who else would we go to war with?
		if (bDeclareWar)
		{
			PlayerTypes eLoopPlayer;
			bool bCheckPlayer = false;
			
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;
				if (IsPlayerValid(eLoopPlayer) && eLoopPlayer != eFromPlayer)
				{
					// Teammate?
					if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eFromPlayer).getTeam())
						bCheckPlayer = true;
					
					// Defensive Pact?
					else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eFromPlayer).getTeam()))
						bCheckPlayer = true;
					
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
					else if (MOD_DIPLOMACY_CIV4_FEATURES)
					{
						// Master/vassal?
						if (GET_TEAM(GET_PLAYER(eFromPlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(eFromPlayer).getTeam()))
							bCheckPlayer = true;
					}
#endif
					if (bCheckPlayer)
					{
						// Would we be declaring war on a powerful neighbor?
						if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) >= PLAYER_PROXIMITY_CLOSE)
						{
							if (GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_AFRAID)
							{
								bDeclareWar = false;
								break;
							}
							
							// If we're already planning a war/demand against them, then we don't care.
							else if (GetMajorCivApproach(eLoopPlayer) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(eLoopPlayer) != WAR_GOAL_DEMAND)
							{
								// Bold AIs will take more risks.
								if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) > STRENGTH_POWERFUL)
								{
									bDeclareWar = false;
									break;
								}
								else if (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) > STRENGTH_AVERAGE)
								{
									bDeclareWar = false;
									break;
								}
							}
						}
						
						bCheckPlayer = false;
					}
				}
			}
		}
			
		if (bDeclareWar)
		{
			if (DeclareWar(eFromPlayer))
			{
				GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eFromPlayer, 3);
			}
		}

		if(bActivePlayer)
		{
			if(bDeclareWar)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_WAR_DEMAND_REFUSED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
			else
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_SO_BE_IT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human refused to give in to a request
	// *********************************************
	case FROM_UI_DIPLO_EVENT_REQUEST_HUMAN_REFUSAL:
	{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		//If player is offended, AI should take note as penalty to assistance.
		CvFlavorManager* pFlavorManager = GetPlayer()->GetFlavorManager();
		int iFlavorOffense = pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));
		GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, (iFlavorOffense * 50));
#else
		GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, iArg1);
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			//End the gift exchange after this.
			GetPlayer()->GetDiplomacyAI()->SetOfferingGift(eFromPlayer, false);
			GetPlayer()->GetDiplomacyAI()->SetOfferedGift(eFromPlayer, false);
		}
#endif
		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_HUMAN, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// AI is telling us he sees our military buildup on his borders
	// *********************************************
	case FROM_UI_DIPLO_EVENT_AGGRESSIVE_MILITARY_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human says he means no harm
		if(iArg1 == 1)
		{
			SetPlayerMadeMilitaryPromise(eFromPlayer, true);
			SetPlayerMilitaryPromiseCounter(eFromPlayer, 0);

			if(bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human told the AI to die
		else if(iArg1 == 2)
		{
			if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(GetTeam()))
			{
				SetPlayerIgnoredMilitaryPromise(eFromPlayer, true);

				if (bActivePlayer)
				{
					if (IsActHostileTowardsHuman(eFromPlayer))
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_AGGRESSIVE_MILITARY_WARNING_BAD);
					else
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_AGGRESSIVE_MILITARY_WARNING_BAD);

					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
			}
		}

		break;
	}

	// *********************************************
	// AI has attacked a Minor the human is friends with, what did the human say in response?
	// *********************************************
	case FROM_UI_DIPLO_EVENT_I_ATTACKED_YOUR_MINOR_CIV_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID,  iArg2 is MINOR ID from DiscussionDialog.lua
		PlayerTypes eMinor = (PlayerTypes) iArg2;
		CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		if (!(eMinor >= MAX_MAJOR_CIVS && eMinor < MAX_CIV_PLAYERS))
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}

		CvPlayer* pMinor = &GET_PLAYER(eMinor);
		CvAssertMsg(pMinor, "Error triggering gameplay effects for diplomacy event involving a Protected city-state. Please send Anton your save file and version.");
		if (!pMinor)
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvAssertMsg(pMinor->GetMinorCivAI()->IsProtectedByMajor(eFromPlayer), "Diplomacy event involving a Protected city-state when there was no Pledge active. Please send Anton your save file and Version.");

		// Human says he forgives the AI
		if(iArg1 == 1)
		{
			GC.getGame().DoMinorPledgeProtection(eFromPlayer, eMinor, false, true); // Pledge is broken!
			
			if (bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human said he'd get revenge
		else if(iArg1 == 2)
		{
			SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eFromPlayer, 0);

			// Does the AI declare war?
			bool bDeclareWar = false;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < ((GetMeanness() + GetBoldness()) / 2))
#else
			if (GC.getGame().getJonRandNum(100, "Human demand refusal war rand.") < 50)
#endif
			{
				if (bDeclareWar)
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eFromPlayer, 3);
			}

			if (bActivePlayer)
			{
				if (bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
				else if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_ATTACKED_MINOR_BAD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI has bullied a Minor the human has a PtP with, what did the human say in response?
	// *********************************************
	case FROM_UI_DIPLO_EVENT_I_BULLIED_YOUR_MINOR_CIV_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID,  iArg2 is MINOR ID from DiscussionDialog.lua
		PlayerTypes eMinor = (PlayerTypes) iArg2;
		CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
		if (!(eMinor >= MAX_MAJOR_CIVS && eMinor < MAX_CIV_PLAYERS))
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvPlayer* pMinor = &GET_PLAYER(eMinor);
		CvAssertMsg(pMinor, "Error triggering gameplay effects for breaking a Pledge to Protect a city-state. Please send Anton your save file and version.");
		if (!pMinor)
		{
			// Fail gracefully, allow UI to continue
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_ATTACKED_MINOR_BAD);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			break;
		}
		
		CvAssertMsg(pMinor->GetMinorCivAI()->IsProtectedByMajor(eFromPlayer), "Diplomacy event involving a Protected city-state when there was no Pledge active. Please send Anton your save file and Version.");

		// Human says he forgives the AI
		if(iArg1 == 1)
		{
			GC.getGame().DoMinorPledgeProtection(eFromPlayer, eMinor, false, true); // Pledge is broken!
		
			if (bActivePlayer)
			{
				if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_GOOD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_GOOD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human said he'd get revenge
		else if(iArg1 == 2)
		{
			SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eFromPlayer, 0);

			// Does the AI declare war?
			bool bDeclareWar = false;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) < ((GetMeanness() + GetBoldness()) / 2))
#else
			if (GC.getGame().getJonRandNum(100, "Human demand refusal war rand.") < 50)
#endif
			{
				if (bDeclareWar)
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eFromPlayer, 3);
			}

			if (bActivePlayer)
			{
				if (bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
				else if(IsActHostileTowardsHuman(eFromPlayer))
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_HOSTILE_WE_BULLIED_MINOR_BAD);
				else
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_WE_BULLIED_MINOR_BAD);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI warned human about attacking a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_ATTACKED_MINOR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			SetPlayerIgnoredAttackCityStatePromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if(iArg1 == 2)
		{
			SetPlayerMadeAttackCityStatePromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_ATTACKED_MINOR_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is mad at human for killing a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_KILLED_MINOR_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about bullying a protected Minor
	// *********************************************
	case FROM_UI_DIPLO_EVENT_BULLIED_MINOR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			SetPlayerIgnoredBullyCityStatePromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if(iArg1 == 2)
		{
			SetPlayerMadeBullyCityStatePromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_BULLIED_MINOR_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is seriously warning the human about his expansion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_EXPANSION_SERIOUS_WARNING_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about his expansion
	// *********************************************
	case FROM_UI_DIPLO_EVENT_EXPANSION_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			if (!IsPlayerIgnoredExpansionPromise(eFromPlayer))
			{
				SetIgnoredExpansionPromiseValue(eFromPlayer, GC.getOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
			}
			SetPlayerIgnoredExpansionPromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he wouldn't settle near us again
		else if(iArg1 == 2)
		{
			SetPlayerMadeExpansionPromise(eFromPlayer, true);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_EXPANSION_WARNING_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI is seriously warning the human about his plot buying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLOT_BUYING_SERIOUS_WARNING_RESPONSE:
	{
		break;
	}

	// *********************************************
	// AI warned human about his plot buying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLOT_BUYING_WARNING_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			if (!IsPlayerIgnoredBorderPromise(eFromPlayer))
			{
				SetIgnoredBorderPromiseValue(eFromPlayer, GC.getOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
			}
			SetPlayerIgnoredBorderPromise(eFromPlayer, true);
#if defined(MOD_BALANCE_CORE)
			//Reset city tile numbers so that this can't fire again immediately after the plot warning is up.
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					int iTilesBought = pLoopCity->AI_GetNumPlotsAcquiredByOtherPlayer(eFromPlayer);
					if(iTilesBought > 0)
					{
						pLoopCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(eFromPlayer, -iTilesBought);
					}
				}
			}			
#endif

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he wouldn't buy land near us again
		else if(iArg1 == 2)
		{
			SetPlayerMadeBorderPromise(eFromPlayer, true);
			SetPlayerBorderPromiseData(eFromPlayer, GetPlotBuyingAggressivePosture(eFromPlayer));
#if defined(MOD_BALANCE_CORE)
			SetEverMadeBorderPromise(eFromPlayer, true);
#endif

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_PLOT_BUYING_WARNING_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd like to work together
	// *********************************************
	case FROM_UI_DIPLO_EVENT_WORK_WITH_US_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua
		SetDoFCounter(eFromPlayer, 0);
		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, 0);

		// Human agrees
		if(iArg1 == 1)
		{
			SetDoFAccepted(eFromPlayer, true);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, true);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			if(GetDoFType(eFromPlayer) == DOF_TYPE_ALLIES || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_ALLIES)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_BATTLE_BROTHERS);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_BATTLE_BROTHERS);
			}
			else if(GetDoFType(eFromPlayer) == DOF_TYPE_FRIENDS || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_FRIENDS)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_ALLIES);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_ALLIES);
			}
			else if(GetDoFType(eFromPlayer) == DOF_TYPE_NEW || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_NEW)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_FRIENDS);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_FRIENDS);
			}
			else if(GetDoFType(eFromPlayer) == DOF_TYPE_UNTRUSTWORTHY || GET_PLAYER(eFromPlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID()) == DOF_TYPE_UNTRUSTWORTHY)
			{
				SetDoFType(eFromPlayer, DOF_TYPE_NEW);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_NEW);
			}		
#endif
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if(iArg1 == 2)
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
	// *********************************************
	// Human ends AI cooperation
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_END_WORK_WITH_US_RESPONSE:
	{
		if((IsDoFAccepted(eMyPlayer) || GET_PLAYER(eMyPlayer).GetDiplomacyAI()->IsDoFAccepted(eFromPlayer)))
		{
			SetDoFCounter(eFromPlayer, -666);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, -666);

			SetDoFAccepted(eFromPlayer, false);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);

			ChangeRecentAssistValue(eFromPlayer, 300);

			SetDoFType(eFromPlayer, DOF_TYPE_UNTRUSTWORTHY);
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_UNTRUSTWORTHY);

			SetDoFBroken(eFromPlayer, true);

			GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eFromPlayer).getTeam(), false);
			GET_TEAM(GET_PLAYER(eFromPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);
			
			// End all coop war agreements with this player
			PlayerTypes eThirdParty;
			for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
			{
				eThirdParty = (PlayerTypes) iThirdPartyLoop;
				
				// Did they break a coop war promise?
				if(GetCoopWarAcceptedState(eFromPlayer, eThirdParty) == COOP_WAR_STATE_SOON)
				{
					SetPlayerBrokenCoopWarPromise(eFromPlayer, true);
					SetPlayerBackstabCounter(eFromPlayer, 0);
					ChangeNumTimesCoopWarDenied(eFromPlayer, 2);
				}

				// WAS in or planning a coop war with the guy we've stopped working with
				if(GetCoopWarAcceptedState(eFromPlayer, eThirdParty) >= COOP_WAR_STATE_SOON)
				{
					SetCoopWarAcceptedState(eFromPlayer, eThirdParty, NO_COOP_WAR_STATE);
					SetCoopWarCounter(eFromPlayer, eThirdParty, -666);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(GetPlayer()->GetID(), eThirdParty, NO_COOP_WAR_STATE);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetCoopWarCounter(GetPlayer()->GetID(), eThirdParty, -666);
				}
			}
			
			DoUpdateOpinions();
			DoUpdateMajorCivApproaches();
			
			if(GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR)
			{
				if (GetWarFaceWithPlayer(eFromPlayer) != WAR_FACE_HOSTILE)
				{
					SetWarFaceWithPlayer(eFromPlayer, WAR_FACE_GUARDED);
				}
			}
			else if (GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ false) != MAJOR_CIV_APPROACH_HOSTILE)
			{
				SetMajorCivApproach(eFromPlayer, MAJOR_CIV_APPROACH_GUARDED);
			}

			// AI message
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_NOW_UNFORGIVABLE);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}
		else
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOT_DOT_DOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
			}
		}
		break;
	}
	// *********************************************
	// Human responds to AI action in a positive or negative way.
	// *********************************************
	case FROM_UI_DIPLO_EVENT_MEAN_RESPONSE:
	{		
		if(!IsAtWar(eFromPlayer))
		{
			// Does the AI declare war?
			bool bDeclareWar = false;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetPlayer()->GetID()))
#else
			if(GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetPlayer()->GetID()))
#endif
			{
				int iChance = 20;
				if (GetMajorCivOpinion(eFromPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
				{
					iChance = 40;
				}
				if (GetMajorCivApproach(eFromPlayer) == MAJOR_CIV_APPROACH_AFRAID)
				{
					iChance += 20;
				}
				if (GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE)) > (iChance - GetMeanness() - GetBoldness()))
				{
					bDeclareWar = true;
				}
				if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
				{
					bDeclareWar = false;
				}
				
				if (bDeclareWar)
				{
					// Disallowed by game options
					if (IsWarDisallowed(eFromPlayer))
					{
						bDeclareWar = false;
					}
					// Would this war cause us or our teammates to backstab a friend/ally? Don't do it!
					else if (IsWarWouldBackstabFriendTeamCheck(eFromPlayer))
					{
						bDeclareWar = false;
					}
				}
				
				// Sanity check - avoid going bankrupt
				int iAdjustedGoldPerTurn = GetPlayer()->calculateGoldRate() - CalculateGoldPerTurnLostFromWar(eFromPlayer, false, false);
				if (iAdjustedGoldPerTurn < 0)
					bDeclareWar = false;
				
				// Sanity check - who else would we go to war with?
				if (bDeclareWar)
				{
					PlayerTypes eLoopPlayer;
					bool bCheckPlayer = false;
					
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						eLoopPlayer = (PlayerTypes) iPlayerLoop;
						if (IsPlayerValid(eLoopPlayer) && eLoopPlayer != eFromPlayer)
						{
							// Teammate?
							if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eFromPlayer).getTeam())
								bCheckPlayer = true;
							
							// Defensive Pact?
							else if (GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eFromPlayer).getTeam()))
								bCheckPlayer = true;
							
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
							else if (MOD_DIPLOMACY_CIV4_FEATURES)
							{
								// Master/vassal?
								if (GET_TEAM(GET_PLAYER(eFromPlayer).getTeam()).IsVassal(GET_PLAYER(eLoopPlayer).getTeam()) || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsVassal(GET_PLAYER(eFromPlayer).getTeam()))
									bCheckPlayer = true;
							}
#endif
							if (bCheckPlayer)
							{
								// Would we be declaring war on a powerful neighbor?
								if (GetPlayer()->GetProximityToPlayer(eLoopPlayer) >= PLAYER_PROXIMITY_CLOSE)
								{
									if (GetMajorCivApproach(eLoopPlayer) == MAJOR_CIV_APPROACH_AFRAID)
									{
										bDeclareWar = false;
										break;
									}
									
									// If we're already planning a war/demand against them, then we don't care.
									else if (GetMajorCivApproach(eLoopPlayer) != MAJOR_CIV_APPROACH_WAR && GetWarGoal(eLoopPlayer) != WAR_GOAL_DEMAND)
									{
										// Bold AIs will take more risks.
										if (GetBoldness() > 6 && GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) > STRENGTH_POWERFUL)
										{
											bDeclareWar = false;
											break;
										}
										else if (GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) > STRENGTH_AVERAGE)
										{
											bDeclareWar = false;
											break;
										}
									}
								}
								
								bCheckPlayer = false;
							}
						}
					}
				}
			}
			if(bDeclareWar)
			{
				bDeclareWar = DeclareWar(GET_PLAYER(eFromPlayer).getTeam());
				if (bDeclareWar)
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eFromPlayer, 3);
			}
			//check again, might have failed.
			if (!bDeclareWar)
			{
				SetMajorCivApproach(eFromPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
				
				// If approach towards us isn't already guessed to be WAR, assume it's HOSTILE
				if(GetTrueApproachTowardsUsGuess(eFromPlayer) != MAJOR_CIV_APPROACH_WAR)
				{
					SetApproachTowardsUsGuess(eFromPlayer, MAJOR_CIV_APPROACH_HOSTILE);
					SetApproachTowardsUsGuessCounter(eFromPlayer, 0);
				}
				
				//If player is offended, AI should take note as penalty to assistance.
				CvFlavorManager* pFlavorManager = GetPlayer()->GetFlavorManager();
				int iFlavorOffense = pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));
				GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, (iFlavorOffense * 50));
			}
			if(bActivePlayer)
			{
				if(bDeclareWar)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_WAR_RUDE_INSULT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_DECLARE_WAR);
				}
				else
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_SO_BE_IT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
				}
			}
		}
		else
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOT_DOT_DOT);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEUTRAL_IDLE);
			}
		}
		break;
	}
#endif

	// *********************************************
	// AI asked human if he'd like to work against someone
	// *********************************************
	//case FROM_UI_DIPLO_EVENT_WORK_AGAINST_SOMEONE_RESPONSE:
	//	{
	//		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

	//		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

	//		SetWorkingAgainstPlayerCounter(eFromPlayer, eAgainstPlayer, 0);
	//		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetWorkingAgainstPlayerCounter(eMyPlayer, eAgainstPlayer, 0);

	//		// Human says sorry, no
	//		if (iArg1 == 1 || iArg1 == 2)
	//		{
	//			if (bActivePlayer)
	//			{
	//				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
	//				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
	//			}
	//		}
	//		// Human agrees
	//		else if (iArg1 == 3)
	//		{
	//			SetWorkingAgainstPlayerAccepted(eFromPlayer, eAgainstPlayer, true);
	//			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetWorkingAgainstPlayerAccepted(eMyPlayer, eAgainstPlayer, true);

	//			if (bActivePlayer)
	//			{
	//				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
	//				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
	//			}
	//		}

	//		break;
	//	}

	// *********************************************
	// Human denounced us!
	// *********************************************
	case FROM_UI_DIPLO_EVENT_DENOUNCE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DoDenouncePlayer(eMyPlayer);

		if(bActivePlayer)
		{
			strText = GetDiploStringForMessage(DIPLO_MESSAGE_RESPONSE_TO_BEING_DENOUNCED);
			gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
		}

		break;
	}

	// *********************************************
	// Human asked AI to go to war against someone
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_OFFER:
	{
		// **** NOTE **** - iArg1 is Player ID from DiscussionDialog.lua

		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg1;

		// Too soon?
		if(IsCoopWarMessageTooSoon(eFromPlayer, eAgainstPlayer))
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_NO);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}
		else
		{
			// Set the counter (this will handle rejection as well)
			SetCoopWarCounter(eFromPlayer, eAgainstPlayer, 0);

			CoopWarStates eAcceptableState;

			// Teammates
			if(GetPlayer()->getTeam() == GET_PLAYER(eFromPlayer).getTeam())
			{
				if(GetPlayerTargetValue(eAgainstPlayer) >= TARGET_VALUE_FAVORABLE && GetBoldness() > 6)
				{
					eAcceptableState = COOP_WAR_STATE_ACCEPTED;
				}
				else
				{
					eAcceptableState = COOP_WAR_STATE_SOON;
				}
			}
			// Not teammates
			else
			{
				eAcceptableState = GetWillingToAgreeToCoopWarState(eFromPlayer, eAgainstPlayer);
			}

			SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, eAcceptableState);

			// Accepted
			if(eAcceptableState == COOP_WAR_STATE_ACCEPTED)
			{
				// AI declaration
				if(DeclareWar(eAgainstPlayer))
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 1);

				// Human declaration
				TeamTypes eAgainstTeam = GET_PLAYER(eAgainstPlayer).getTeam();
				if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(eAgainstPlayer))
				{
					int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
					GET_TEAM(GetPlayer()->getTeam()).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
					GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);

					if (bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_YES);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
					}
				}
			}
			// Soon
			else if(eAcceptableState == COOP_WAR_STATE_SOON)
			{
				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_SOON);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
			// Rejected
			else
			{
#if defined(MOD_BALANCE_CORE)
				if (eAgainstPlayer != NO_PLAYER && eFromPlayer != NO_PLAYER)
				{
					// Should the asked AI warn the target?
					if (IsCoopWarRequestUnacceptable(eFromPlayer, eAgainstPlayer))
					{
						GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), -200);
						GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(GetPlayer()->GetID(), 1);
						GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(eFromPlayer, MAJOR_CIV_APPROACH_WAR);
						GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(eFromPlayer, 0);
						
						// Bump down the target player's opinion of the asker
						GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
						
						// Also warn the target player's teammates and DPs
						for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
						{
							PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
	
							if (IsPlayerValid(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).isHuman())
							{
								if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam() || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eAgainstPlayer).getTeam()))
								{
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(GetPlayer()->GetID(), 1);
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(eFromPlayer, MAJOR_CIV_APPROACH_WAR);
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(eFromPlayer, 0);
									
									// Penalty to opinion for the asker
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, 300);
									
									// Bonus to recent assistance based on proximity to the player planning war
									switch (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eFromPlayer))
									{
									case PLAYER_PROXIMITY_NEIGHBORS:
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), -150);
										break;
									case PLAYER_PROXIMITY_CLOSE:
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), -100);
										break;
									case PLAYER_PROXIMITY_FAR:
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), -50);
										break;
									}
									
									// Extra -50 if teammate of the target
									if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam())
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), -50);
								}
							}
						}
					}
				}
#endif
				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_COOP_WAR_NO);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
				}
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd declare war against someone
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

		SetCoopWarCounter(eFromPlayer, eAgainstPlayer, 0);

		// Human says sorry, no
		if(iArg1 == 1 || iArg1 == 2)
		{
			// TODO: diplo penalty if we were friends
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			//If player is offended, AI should take note as penalty to assistance.
			// Human told AI they've gone too far and warned the target
			if(iArg1 == 2)
			{
				if(eAgainstPlayer != NO_PLAYER && eFromPlayer != NO_PLAYER)
				{
					ChangeRecentAssistValue(eFromPlayer, 300);
					ChangeNumTimesCoopWarDenied(eFromPlayer, 2);
					GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -200);
					GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(eFromPlayer, 1);
					GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_WAR);
					GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);
					
					// Bump down the target player's opinion of the asker
					GET_PLAYER(eAgainstPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), 300);
					
					// Also warn the target player's teammates and DPs
					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

						if(GET_PLAYER(eFromPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).isHuman())
						{
							if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam() || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eAgainstPlayer).getTeam()))
							{
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeNumTimesIntrigueSharedBy(eFromPlayer, 1);
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(eFromPlayer, MAJOR_CIV_APPROACH_WAR);
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(eFromPlayer, 0);
								
								// Penalty to opinion for the asker
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(GetPlayer()->GetID(), 300);
								
								// Bonus to recent assistance based on proximity to the player planning war
								switch (GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eFromPlayer))
								{
								case PLAYER_PROXIMITY_NEIGHBORS:
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -150);
									break;
								case PLAYER_PROXIMITY_CLOSE:
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -100);
									break;
								case PLAYER_PROXIMITY_FAR:
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -50);
									break;
								}
								
								// Extra -50 if teammate of the target
								if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAgainstPlayer).getTeam())
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -50);
							}
						}
					}
				}	
			}
			// Human told AI sorry, but no
			if(iArg1 == 1)
			{
				if(eAgainstPlayer != NO_PLAYER && eFromPlayer != NO_PLAYER)
				{
					ChangeRecentAssistValue(eFromPlayer, 200);
					ChangeNumTimesCoopWarDenied(eFromPlayer, 1);
				}
			}
#endif
		}
		// Human says "soon"
		if(iArg1 == 3)
		{
			SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, COOP_WAR_STATE_SOON);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human agrees
		else if(iArg1 == 4)
		{
			if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(eAgainstPlayer))
			{
				SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, COOP_WAR_STATE_ACCEPTED);

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}

				// AI declaration
				if (DeclareWar(eAgainstPlayer))
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 1);

				// Human declaration
				TeamTypes eAgainstTeam = GET_PLAYER(eAgainstPlayer).getTeam();

				int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
				GET_TEAM(GetPlayer()->getTeam()).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
				GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd declare war against someone earlier, and now it's time to put your money where your mouth is
	// *********************************************
	case FROM_UI_DIPLO_EVENT_COOP_WAR_NOW_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

		SetCoopWarCounter(eFromPlayer, eAgainstPlayer, 0);

		// Human agrees
		if(iArg1 == 1)
		{
			if (GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DeclareWar(eAgainstPlayer))
			{
				SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, COOP_WAR_STATE_ACCEPTED);

				if (bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}

				// AI declaration
				if (DeclareWar(eAgainstPlayer))
				{
					GetPlayer()->GetMilitaryAI()->RequestBasicAttack(eAgainstPlayer, 3);
				}
				// Human declaration
				TeamTypes eAgainstTeam = GET_PLAYER(eAgainstPlayer).getTeam();
				int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();
				GET_TEAM(GetPlayer()->getTeam()).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
				GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eAgainstTeam, iLockedTurns);
			}
		}
		// Human says no
		if(iArg1 == 2)
		{
			SetCoopWarAcceptedState(eFromPlayer, eAgainstPlayer, NO_COOP_WAR_STATE);
			
			// No penalty for teammates; otherwise, the AI gets mad
			if(GetPlayer()->getTeam() != GET_PLAYER(eFromPlayer).getTeam())
			{
				SetPlayerBrokenCoopWarPromise(eFromPlayer, true);
#if defined(MOD_BALANCE_CORE)
				SetPlayerBackstabCounter(eFromPlayer, 0);
				ChangeRecentAssistValue(eFromPlayer, 300);
				ChangeNumTimesCoopWarDenied(eFromPlayer, 2);
#endif
			}

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human made a demand. NOTE: Unlike the other messages in here, this one is actually triggered from inside CvDealAI on a player's local machine
	// *********************************************
	case FROM_UI_DIPLO_EVENT_HUMAN_DEMAND:
	{
		// **** NOTE **** - iArg1 is RESPONSE TYPE from CvDealAI::DoHumanDemand()
		DemandResponseTypes eResponse = (DemandResponseTypes) iArg1;

		// THIS is the important part of the message - it seeds the demand timer on all players' machines
		DoDemandMade(eFromPlayer, eResponse);

		if(bActivePlayer)
		{
			// Demand agreed to
			if(eResponse == DEMAND_RESPONSE_ACCEPT)
			{
				strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_YES);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_YES);
			}
			// Demand rebuffed
			else
			{
				if(eResponse == DEMAND_RESPONSE_REFUSE_WEAK)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_WEAK);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_HOSTILE)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_HOSTILE);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_TOO_MUCH)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_MUCH);

				else if(eResponse == DEMAND_RESPONSE_REFUSE_TOO_SOON)
					strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_DEMAND_REFUSE_TOO_SOON);

				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_NO);
			}
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd like to make a Research Agreement in the future
	// *********************************************
	case FROM_UI_DIPLO_EVENT_PLAN_RA_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human agrees
		if(iArg1 == 1)
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if(iArg1 == 2)
		{
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}

			DoCancelWantsResearchAgreementWithPlayer(eFromPlayer);
		}

		break;
	}

	// *********************************************
	// AI asked human if he'd denounce a third party
	// *********************************************
	case FROM_UI_DIPLO_EVENT_AI_REQUEST_DENOUNCE_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua
		PlayerTypes eAgainstPlayer = (PlayerTypes) iArg2;

		// Human agrees
		if(iArg1 == 1)
		{
			GET_PLAYER(eFromPlayer).GetDiplomacyAI()->DoDenouncePlayer(eAgainstPlayer);

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_PLEASED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		// Human says sorry, no
		else if(iArg1 == 2)
		{
			// Oh, you're gonna say no, are you?
			if(IsFriendDenounceRefusalUnacceptable(eFromPlayer, eAgainstPlayer))
			{
				DoDenouncePlayer(eFromPlayer);
				LogDenounce(eFromPlayer, /*bBackstab*/ false, /*bRefusal*/ true);

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DOF_NOT_HONORED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
			else if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_DISAPPOINTED);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}

		break;
	}

	// *********************************************
	// AI warned human about spying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_CAUGHT_YOUR_SPY_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			SetPlayerIgnoredSpyPromise(eFromPlayer, true);
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if(iArg1 == 2)
		{
			SetPlayerMadeSpyPromise(eFromPlayer, true);
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_CAUGHT_YOUR_SPY_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	// *********************************************
	// Human warn AI about spying
	// *********************************************
	case FROM_UI_DIPLO_EVENT_KILLED_MY_SPY_RESPONSE:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human did not forgive AI player
		if(iArg1 == 1)
		{
			SetPlayerForgaveForSpying(eFromPlayer, false);
			SetPlayerStopSpyingRequestEverAsked(eFromPlayer, true);

			m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[eFromPlayer] = 0;

			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_UNFORGIVEN);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_NEGATIVE);
			}
		}
		// Human forgave AI player
		else if(iArg1 == 2)
		{
			SetPlayerForgaveForSpying(eFromPlayer, true);
#if defined(MOD_BALANCE_CORE)
			SetForgaveForSpyingTurn(eFromPlayer, GC.getGame().getGameTurn());
#endif
			m_pPlayer->GetEspionageAI()->m_aiTurnLastSpyCaught[eFromPlayer] = 0;
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_KILLED_MY_SPY_FORGIVEN);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}

	case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_SHARE_INTRIGUE:
	{
		PlayerTypes ePlottingPlayer = (PlayerTypes)iArg1;
		CvIntrigueType eIntrigueType = (CvIntrigueType)iArg2;
		CvAssert(CvPlayerAI::IsValid(ePlottingPlayer));
		if (CvPlayerAI::IsValid(ePlottingPlayer))
		{
			ChangeNumTimesIntrigueSharedBy(eFromPlayer, 1);
			GET_PLAYER(eFromPlayer).GetEspionage()->MarkRecentIntrigueAsShared(eMyPlayer, ePlottingPlayer, eIntrigueType);
#if defined(MOD_BALANCE_CORE)
			if(eIntrigueType == INTRIGUE_TYPE_BUILDING_ARMY || eIntrigueType == INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY || eIntrigueType == INTRIGUE_TYPE_ARMY_SNEAK_ATTACK || eIntrigueType == INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK)
			{
				SetApproachTowardsUsGuess(ePlottingPlayer, MAJOR_CIV_APPROACH_WAR);
				SetApproachTowardsUsGuessCounter(ePlottingPlayer, 0);
			}
			else if(eIntrigueType == INTRIGUE_TYPE_DECEPTION)
			{
				SetApproachTowardsUsGuess(ePlottingPlayer, MAJOR_CIV_APPROACH_DECEPTIVE);
				SetApproachTowardsUsGuessCounter(ePlottingPlayer, 0);
			}
#endif
			if (bActivePlayer)
			{
#if !defined(NO_ACHIEVEMENTS)
				if(GET_PLAYER(eFromPlayer).GetEspionage()->HasSharedIntrigueAboutMe(eMyPlayer))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_37);
				}

				bool bUsingXP1Scenario3 = gDLL->IsModActivated(CIV5_XP1_SCENARIO3_MODID);
				if(bUsingXP1Scenario3)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_45);
				}
#endif

				strText = GetDiploStringForMessage(DIPLO_MESSAGE_WARNED_ABOUT_INTRIGUE, NO_PLAYER, GET_PLAYER(ePlottingPlayer).getCivilizationAdjectiveKey());
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}
		break;
	}

	// *********************************************
	// AI warned about religious conversions
	// *********************************************
	case FROM_UI_DIPLO_EVENT_STOP_CONVERSIONS:
	{
		// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

		// Human told the AI it's none of his business
		if(iArg1 == 1)
		{
			SetPlayerIgnoredNoConvertPromise(eFromPlayer, true);
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_BAD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
		// Human said he'd withdraw
		else if(iArg1 == 2)
		{
			SetPlayerMadeNoConvertPromise(eFromPlayer, true);
			int iAdjustmentToJustBelowThreshold = GC.getRELIGION_DIPLO_HIT_THRESHOLD() - GetNegativeReligiousConversionPoints(eFromPlayer) - 1;
			ChangeNegativeReligiousConversionPoints(eFromPlayer, iAdjustmentToJustBelowThreshold);
			if(bActivePlayer)
			{
				strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_CONVERSIONS_GOOD);
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
		}

		break;
	}


	// *********************************************
	// AI warned about Digging on my turf
	// *********************************************
	case FROM_UI_DIPLO_EVENT_STOP_DIGGING:
		{
			// **** NOTE **** - iArg1 is BUTTON ID from DiscussionDialog.lua

			// Human told the AI it's none of his business
			if(iArg1 == 1)
			{
				SetPlayerIgnoredNoDiggingPromise(eFromPlayer, true);
				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_DIGGING_BAD);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
				}
			}
			// Human said he'd withdraw
			else if(iArg1 == 2)
			{
				SetPlayerMadeNoDiggingPromise(eFromPlayer, true);
				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_STOP_DIGGING_GOOD);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}

			break;
		}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// *********************************************
		// Player asked the AI about other civilizations
		// *********************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_DISCUSSION_SHARE_OPINION:
		{
			bool bVassal = IsVassal(eFromPlayer);
			// AI hasn't known the human for long enough yet
			if(IsTooEarlyForShareOpinion(eFromPlayer) && !bVassal)
			{
				SetShareOpinionCounter(eFromPlayer, 0);
				GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetShareOpinionCounter(eMyPlayer, 0);

				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_TOO_SOON_FOR_SHARE_OPINION);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
				}
			}
			// Player has asked this before
			else if(IsShareOpinionTooSoon(eFromPlayer) && !IsVassal(eFromPlayer))
			{
				if(bActivePlayer)
				{
					if(IsActHostileTowardsHuman(eFromPlayer))
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_REPEAT_SHARE_OPINION_NO);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_SHARE_OPINION_NO);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
					}
				}
			}
			//AI gives a new answer
			else
			{
				bool bAcceptable = false;

				// Already accepted the ability to share opinion? Good, then continue onward.
				if(IsShareOpinionAccepted(eFromPlayer) && !IsActHostileTowardsHuman(eFromPlayer))
				{
					bAcceptable = true;
				}
				//Evaluate the ability to share opinion.
				else
				{
					//AI has to evaluate a new opinion, so reset the counter. Otherwise, let it count!
					SetShareOpinionCounter(eFromPlayer, 0);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetShareOpinionCounter(eMyPlayer, 0);
					bAcceptable = IsShareOpinionAcceptable(eFromPlayer);
				}
				
				// We've accepted
				if(bAcceptable)
				{
					PlayerTypes eTargetPlayer = (PlayerTypes) iArg1;
					MajorCivApproachTypes eOurApproachWithOtherCiv;

					eOurApproachWithOtherCiv = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ true);

					// True friends will tell us some more information
					if(GetMajorCivOpinion(eFromPlayer) == MAJOR_CIV_OPINION_ALLY &&
						GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_FRIENDLY)
					{
						eOurApproachWithOtherCiv = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ false);
					}

					SetShareOpinionAccepted(eFromPlayer, true);
					GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetShareOpinionAccepted(eMyPlayer, true);

					if(bActivePlayer)
					{
						if(IsAtWar(eTargetPlayer))
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_WAR, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
						}
						else
						{
							switch(eOurApproachWithOtherCiv)
							{
							case MAJOR_CIV_APPROACH_FRIENDLY:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_FRIENDLY, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_NEUTRAL:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_NEUTRAL, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_GUARDED:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_GUARDED, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_HOSTILE:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_HOSTILE, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_AFRAID:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_AFRAID, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_WAR:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_PLANNING_WAR, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							case MAJOR_CIV_APPROACH_DECEPTIVE:
								strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_DECEPTIVE, NO_PLAYER, GET_PLAYER(eTargetPlayer).getNameKey());
								break;
							}
						}
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_POSITIVE);
					}
				}
				// We've declined, tell them no.
				else
				{
					SetShareOpinionAccepted(eFromPlayer, false);
					if(bActivePlayer)
					{
						if(IsActHostileTowardsHuman(eFromPlayer))
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_HOSTILE_SHARE_OPINION_NO);
							gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
						}
						else
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_SHARE_OPINION_NO);
							gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_DISCUSS_HUMAN_INVOKED, strText, LEADERHEAD_ANIM_NO);
						}
					}
				}
			}

			break;
		}
		// *********************************************
		// Human asked for or received a generous offer. NOTE: Unlike the other messages in here, this one is actually triggered from inside CvDealAI on a player's local machine
		// *********************************************
		// NOTE: This is going to be called for both AI offering a generous offer and human requesting help
		// Done this way because AI offering is actually treated as a fake human "demand"
		case FROM_UI_DIPLO_EVENT_HUMAN_REQUEST:
		{
			// **** NOTE **** - iArg1 is RESPONSE TYPE from CvDealAI::DoHumanDemand()
			DemandResponseTypes eResponse = (DemandResponseTypes) iArg1;

			// THIS is the important part of the message - it seeds the help request timer on all players' machines
			if (eResponse != DEMAND_RESPONSE_REFUSE_WEAK)
			{
				DoHelpRequestMade(eFromPlayer, eResponse);

				if (bActivePlayer)
				{
					// Help Request agreed to
					if (eResponse == DEMAND_RESPONSE_GIFT_ACCEPT)
					{
						strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_YES);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_POSITIVE);
					}
					// Help Request rebuffed
					else
					{
						if (eResponse == DEMAND_RESPONSE_GIFT_REFUSE_TOO_MUCH)
							strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_TOO_MUCH);

						else if (eResponse == DEMAND_RESPONSE_GIFT_REFUSE_TOO_SOON)
							strText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_HUMAN_REQUEST_TOO_SOON);

						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_NEGATIVE);
					}
				}
			}
			else
				gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_NEGATIVE);

			break;
		}
		// *********************************************
		// Player revokes Vassalage with AI
		// *********************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_ENDS_VASSALAGE:
		{
			bool bPeaceful = false;
			bool bHumanWasMyVassal = false;
			bool bAcceptable = false;

			// Human told AI to die
			if(iArg1 == 1)
			{
				bPeaceful = false;
			}
			// Human allows AI to leave vassalage
			else if(iArg1 == 2)
			{
				bPeaceful = true;
			}
		
			// Who is revoking?
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(GET_PLAYER(eLoopPlayer).isAlive())
				{
					// On the same team as AI?
					if(GET_PLAYER(eLoopPlayer).getTeam() == GetTeam())
					{
						// Is this player the vassal of eFromPlayer?
						if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsVassal(eFromPlayer))
						{
							// Player peacefully revoked our vassalage! Happy AI! :)
							if(bPeaceful)
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetTurnsSinceVassalagePeacefullyRevoked(eFromPlayer, 0);
							else
								GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetTurnsSinceVassalageForcefullyRevoked(eFromPlayer, 0);
						}
					}
				}
			}

			// AI team no longer vassal of human. If it's forcefully, bPeaceful = false
			if(GET_TEAM(GetTeam()).IsVassal(eFromTeam))
			{
				GET_TEAM(GetTeam()).DoEndVassal(eFromTeam, bPeaceful, false);
			}
			// Human was our vassal - what is our response?
			else if(GET_TEAM(eFromTeam).IsVassal(GetTeam()))
			{
				bHumanWasMyVassal = true;

				bAcceptable = IsEndVassalageRequestAcceptable(eFromPlayer);

				GET_TEAM(eFromTeam).DoEndVassal(GetTeam(), bAcceptable, false);
			}

			// AI message
			if(bActivePlayer)
			{
				// Human revoking AI vassalage
				if(!bHumanWasMyVassal)
				{
					if(bPeaceful)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_PEACEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_YES);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_HUMAN_WAR);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION_RETURN_TO_ROOT, strText, LEADERHEAD_ANIM_ATTACKED);
					}
				}
				// Human requests AI to end vassalage
				else
				{
					if(bAcceptable)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_PEACEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_YES);
					}
					else
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_REVOKED_FORCEFUL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_ATTACKED); // Anim attacked correct. Not ideal, but otherwise leader won't react to your request
					}
				}
			}

			break;
		}
		// **********************************************************
		case FROM_UI_DIPLO_EVENT_HUMAN_MOVE_TROOPS_RESPONSE:
		{
			int iResponse;

			// 0 = Accept, 1 = Neutral, 2 = Refuse
			iResponse = IsMoveTroopsRequestAcceptable(eFromPlayer, /*bJustChecking*/ false);

			if (iResponse == 2 && !GET_TEAM(GetTeam()).canDeclareWar(GET_PLAYER(eFromPlayer).getTeam(), GetPlayer()->GetID()))
				iResponse = 1;

			// AI says yes, they will move their troops, and even better, they will leave the human alone
			if(iResponse == 0)
			{
				// AI accepts move troops request
				// Make sure all players on this team get this check, so that teammates don't screw each other over.
				TeamTypes eLoopTeam;
				for(int iI=0; iI < MAX_MAJOR_CIVS; iI++)
				{
					eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
					if(eLoopTeam == GetPlayer()->getTeam())
					{
						GET_PLAYER((PlayerTypes)iI).GetDiplomacyAI()->SetPlayerMoveTroopsRequestAccepted(eFromPlayer, true);
						GET_PLAYER((PlayerTypes)iI).GetDiplomacyAI()->SetPlayerMoveTroopsRequestCounter(eFromPlayer, 0);

						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMadeMilitaryPromise((PlayerTypes)iI, true);
						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseCounter((PlayerTypes)iI, 0);
					}
				}

				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_ACCEPT);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}

				// lower weight for crossing tiles around this player's cities
				int iLoop;
				CvCity* pLoopCity;
				for(pLoopCity = GET_PLAYER(eFromPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eFromPlayer).nextCity(&iLoop))
				{
					//todo: mark cities for pathfinder
					//open question: when to unmark?? 
				}
			}
			// AI says they are just moving their troops through
			else if(iResponse == 1)
			{
				// AI agrees not to attack
				// Make sure all players on this team get this check, so that teammates don't screw each other over.
				TeamTypes eLoopTeam;
				for(int iI=0; iI < MAX_MAJOR_CIVS; iI++)
				{
					eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
					if(eLoopTeam == GetPlayer()->getTeam())
					{
						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMadeMilitaryPromise((PlayerTypes)iI, true);
						GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseCounter((PlayerTypes)iI, 0);
					}
				}

				if(bActivePlayer)
				{
					strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL);
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}
			}
			// AI tells human to die
			else if(iResponse == 2)
			{
				// Declare war on human!
				if (DeclareWar(eFromTeam))
				{
					if (bActivePlayer)
					{
						if (IsGoingForWorldConquest())
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_CONQUEST);
						}
						// Was deceptive
						else if (GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_DECEPTIVE);
						}
						// Default case
						else
						{
							strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_REJECT_HOSTILE);
						}

						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_AI_DECLARED_WAR, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
					}
				}
				else
				{
					// AI accepts move troops request
					// Make sure all players on this team get this check, so that teammates don't screw each other over.
					TeamTypes eLoopTeam;
					for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
					{
						eLoopTeam = GET_PLAYER((PlayerTypes)iI).getTeam();
						if (eLoopTeam == GetPlayer()->getTeam())
						{
							GET_PLAYER((PlayerTypes)iI).GetDiplomacyAI()->SetPlayerMoveTroopsRequestAccepted(eFromPlayer, true);
							GET_PLAYER((PlayerTypes)iI).GetDiplomacyAI()->SetPlayerMoveTroopsRequestCounter(eFromPlayer, 0);

							GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMadeMilitaryPromise((PlayerTypes)iI, true);
							GET_PLAYER(eFromPlayer).GetDiplomacyAI()->SetPlayerMilitaryPromiseCounter((PlayerTypes)iI, 0);
						}
					}

					if (bActivePlayer)
					{
						strText = GetDiploStringForMessage(DIPLO_MESSAGE_MOVE_TROOPS_NEUTRAL);
						gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
					}
				}
			}
			// Something happened! (will generate an error message)
			else
			{
				CvAssert(false);

				if(bActivePlayer)
				{
					gDLL->GameplayDiplomacyAILeaderMessage(eMyPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_YES);
				}
			}

			break;
		}
#endif


	// Should always have a state we're handling
	default:
		CvAssert(false);
		break;
	}
}

/// Is the AI acting mean to the active human player?
bool CvDiplomacyAI::IsActHostileTowardsHuman(PlayerTypes eHuman)
{
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(eHuman);
	MajorCivApproachTypes eVisibleApproach = GetMajorCivApproach(eHuman, /*bHideTrueFeelings*/ true);

	bool bAtWar = IsAtWar(eHuman);
	bool bAtWarButWantsPeace = bAtWar &&					// Have to be at war
	                           GetTreatyWillingToOffer(eHuman) >= PEACE_TREATY_WHITE_PEACE && GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_WHITE_PEACE &&		// High-level AI has to want peace
	                           IsWillingToMakePeaceWithHuman(eHuman);						// Special rules for peace with human (turn count) have to be met

	if(eVisibleApproach == MAJOR_CIV_APPROACH_HOSTILE)	// Hostile Approach
		return true;
	else if(bAtWar && !bAtWarButWantsPeace)		// At war and don't want peace
		return true;
	else if(eOpinion <= MAJOR_CIV_OPINION_ENEMY && eVisibleApproach != MAJOR_CIV_APPROACH_FRIENDLY)	// Enemy or worse, and not pretending to be friendly
		return true;

	return false;
}

/// AI is greeting the human - what does he say?
const char* CvDiplomacyAI::GetGreetHumanMessage(LeaderheadAnimationTypes& eAnimation)
{
	PlayerTypes eHuman = GC.getGame().getActivePlayer();
	CvPlayer* pHuman = &GET_PLAYER(eHuman);
	TeamTypes eHumanTeam = pHuman->getTeam();
	CvTeam* pHumanTeam = &GET_TEAM(eHumanTeam);
#if defined(MOD_BALANCE_CORE)
	DoUpdateWarDamageLevel();
#endif
	MajorCivApproachTypes eVisibleApproach = GetMajorCivApproach(eHuman, /*bHideTrueFeelings*/ true);
	WarProjectionTypes eWarProjection = GetWarProjection(eHuman);
	DisputeLevelTypes eLandDispute = GetLandDisputeLevel(eHuman);
	AggressivePostureTypes eMilitaryPosture = GetMilitaryAggressivePosture(eHuman);
	AggressivePostureTypes eExpansionPosture = GetExpansionAggressivePosture(eHuman);
	AggressivePostureTypes ePlotBuyingPosture = GetPlotBuyingAggressivePosture(eHuman);
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(eHuman);
	StrengthTypes eEconomicStrength = GetPlayerEconomicStrengthComparedToUs(eHuman);
	int iNumPlayersAttacked = GetOtherPlayerNumMinorsAttacked(eHuman) + GetOtherPlayerNumMajorsAttacked(eHuman);
	int iNumPlayersKilled = GetOtherPlayerNumMinorsConquered(eHuman) + GetOtherPlayerNumMajorsConquered(eHuman);

	bool bAtWar = IsAtWar(eHuman);
	bool bAtWarButWantsPeace = bAtWar &&					// Have to be at war
	                           GetTreatyWillingToOffer(eHuman) >= PEACE_TREATY_WHITE_PEACE && GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_WHITE_PEACE &&		// High-level AI has to want peace
	                           IsWillingToMakePeaceWithHuman(eHuman);						// Special rules for peace with human (turn count) have to be met

	// Most Greetings are added to a vector to be picked from randomly
	// However, some are returned immediately, as they "fit" well enough that we DEFINITELY want to use that specific greeting
	FStaticVector<DiploMessageTypes, NUM_DIPLO_MESSAGE_TYPES, true, c_eCiv5GameplayDLL, 0> veValidGreetings;

	// Determine of the AI is being hostile to the player

	bool bHostile = IsActHostileTowardsHuman(eHuman);

	////////////////////////////////////////////
	// Pick Greeting Animation
	////////////////////////////////////////////

	if(bHostile)
		eAnimation = LEADERHEAD_ANIM_HATE_HELLO;
	else
		eAnimation = LEADERHEAD_ANIM_NEUTRAL_HELLO;

	////////////////////////////////////////////
	// Repeated Greetings
	////////////////////////////////////////////

	int iTimesScreenOpened = GC.GetEngineUserInterface()->GetStartDiploRepeatCount();

	if(iTimesScreenOpened > 4)
		return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_REPEAT_TOO_MUCH);

	else if(iTimesScreenOpened > 2)
	{
		if(bHostile)
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_HOSTILE_REPEAT);
		else
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_REPEAT);
	}

	////////////////////////////////////////////
	// War Greetings
	////////////////////////////////////////////

	// At war but wants peace
	if(bAtWarButWantsPeace)
	{
		if (eWarProjection == WAR_PROJECTION_DESTRUCTION)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_DESTRUCTION_LOOMS);
		}
		else if (GetTreatyWillingToAccept(eHuman) >= PEACE_TREATY_CAPITULATION)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_WILL_ACCEPT_SURRENDER);
		}
		else
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_AT_WAR_WANTS_PEACE);
		}
	}
	else if(bAtWar)
		return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_AT_WAR_HOSTILE);

	////////////////////////////////////////////
	// Situational Greetings
	////////////////////////////////////////////

	// Working on a Research Agreement - JON: Disabled because this could be invoked if the AI wanted one without the human's knowledge
	//if (IsWantsResearchAgreementWithPlayer(eHuman))
	//	return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_RESEARCH_AGREEMENT);

	// Player has broken promises about playing nice militarily
	if(eVisibleApproach != MAJOR_CIV_APPROACH_FRIENDLY)
	{
		if(pHumanTeam->IsBrokenMilitaryPromise())
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_BROKEN_MILITARY_PROMISE);
	}

	// Players are working together
	if(IsDoFAccepted(eHuman))
		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_WORKING_WITH);

	// Working against anyone?
	//for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
	//{
	//	// Must be alive
	//	if (!GET_PLAYER((PlayerTypes) iThirdPartyLoop).isAlive())
	//		continue;

	//	if (IsWorkingAgainstPlayerAccepted(eHuman, (PlayerTypes) iThirdPartyLoop))
	//		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_WORKING_AGAINST);
	//}

	// Coop War against anyone?
	for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
	{
		// Must be alive
		if(!GET_PLAYER((PlayerTypes) iThirdPartyLoop).isAlive())
			continue;

		if(GetCoopWarAcceptedState(eHuman, (PlayerTypes) iThirdPartyLoop) >= COOP_WAR_STATE_SOON)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_COOP_WAR);
	}

	// Human at war with someone?
	if(pHumanTeam->getAtWarCount(true) > 0)
	{
		if(bHostile)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_AT_WAR);
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HUMAN_AT_WAR);
	}

	// Military Aggressive Posture
	if(eMilitaryPosture >= AGGRESSIVE_POSTURE_MEDIUM)
		if(bHostile)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_MILITARY);
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_MILITARY);

	// Land Dispute
	if(eLandDispute >= DISPUTE_LEVEL_STRONG)
	{
		// Expansion
		if(eExpansionPosture >= AGGRESSIVE_POSTURE_MEDIUM)
			if(bHostile)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_EXPANSION);
			else
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_EXPANSION);

		// Plot buying
		if(ePlotBuyingPosture >= AGGRESSIVE_POSTURE_MEDIUM)
			if(bHostile)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_AGGRESSIVE_PLOT_BUYING);
			else
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_AGGRESSIVE_PLOT_BUYING);
	}

	////////////////////////////////////////////
	// Friendly Greetings
	////////////////////////////////////////////

	if(!bHostile)
	{
		if(eVisibleApproach == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_HELLO);

			// Military Strength
			if(eMilitaryStrength >= STRENGTH_STRONG)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_MILITARY);

			// Economic Strength
			if(eEconomicStrength >= STRENGTH_STRONG)
				veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_FRIENDLY_STRONG_ECONOMY);
		}
		else
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO);
	}

	////////////////////////////////////////////
	// Hostile Greetings
	////////////////////////////////////////////

	else
	{
		veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HELLO);

		// Human has at least 1 fewer City
		if(pHuman->getNumCities() < GetPlayer()->getNumCities())
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_FEW_CITIES);

		// Human's military is weak
		if(eMilitaryStrength <= STRENGTH_POOR)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_SMALL_ARMY);

		// Human has attacked/killed some folks
		if(iNumPlayersAttacked >= 2 || iNumPlayersKilled >= 1)
			veValidGreetings.push_back(DIPLO_MESSAGE_GREETING_HOSTILE_HUMAN_IS_WARMONGER);
	}

	// Pick a random greeting from the valid ones (if there are any)
	if(veValidGreetings.size() > 0)
	{
		int iIndex = GC.getGame().getAsyncRandNum(veValidGreetings.size(), "Diplomacy AI: Picking random Greeting for AI to give to human.");

		DiploMessageTypes eGreetingType = veValidGreetings[iIndex];
		const char* strOptionalKey = "";
		bool bFoundPlayer = false;

		// Working against someone picked?
		//if (eGreetingType == DIPLO_MESSAGE_GREETING_WORKING_AGAINST)
		//{
		//	int iThirdPartyLoop = 0;

		//	// Loop until we've picked a random guy
		//	do
		//	{
		//		// Reset to beginning of list
		//		if (iThirdPartyLoop >= MAX_MAJOR_CIVS)
		//			iThirdPartyLoop = 0;

		//		if (IsWorkingAgainstPlayerAccepted(eHuman, (PlayerTypes) iThirdPartyLoop))
		//		{
		//			// Rand roll
		//			if (GC.getGame().getAsyncRandNum(100, "Diplomacy AI: Random against player greeting.") < 33)
		//			{
		//				strOptionalKey = GET_PLAYER((PlayerTypes) iThirdPartyLoop).getNameKey();
		//				bFoundPlayer = true;
		//			}
		//		}

		//		iThirdPartyLoop++;

		//	} while (!bFoundPlayer);
		//}

		// Coop War picked?
		if(eGreetingType == DIPLO_MESSAGE_GREETING_COOP_WAR)
		{
			int iThirdPartyLoop = 0;

			// Loop until we've picked a random guy
			do
			{
				// Reset to beginning of list
				if(iThirdPartyLoop >= MAX_MAJOR_CIVS)
					iThirdPartyLoop = 0;

				if(GetCoopWarAcceptedState(eHuman, (PlayerTypes) iThirdPartyLoop) >= COOP_WAR_STATE_SOON)
				{
					// Rand roll
					if(GC.getGame().getAsyncRandNum(100, "Diplomacy AI: Random coop war greeting.") < 33)
					{
						strOptionalKey = GET_PLAYER((PlayerTypes) iThirdPartyLoop).getNameKey();
						bFoundPlayer = true;
					}
				}

				iThirdPartyLoop++;

			}
			while(!bFoundPlayer);
		}

		return GetDiploStringForMessage(eGreetingType, NO_PLAYER, strOptionalKey);
	}

	// NOTHING else fits so use generic neutral greeting
	return GetDiploStringForMessage(DIPLO_MESSAGE_GREETING_NEUTRAL_HELLO);
}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Does this AI want to make a Defensive Pact with ePlayer?
bool CvDiplomacyAI::IsCantMatchDeal(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabCantMatchDeal[ePlayer];
}
/// Sets this AI want to want a Defensive Pact with ePlayer
void CvDiplomacyAI::SetCantMatchDeal(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabCantMatchDeal[ePlayer] = bValue;
}
/// AI cant match human deal.
const char* CvDiplomacyAI::GetOfferText(PlayerTypes ePlayer)
{
	if(ePlayer == NO_PLAYER)
	{
		ePlayer = GC.getGame().getActivePlayer();
		if(ePlayer != NO_PLAYER)
		{
			MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
			if(IsCantMatchDeal(ePlayer))
			{
				SetCantMatchDeal(ePlayer, false);
				if(eApproach >= MAJOR_CIV_APPROACH_AFRAID)
				{
					return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
				}
				else
				{
					return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER_NEGATIVE");
				}
			}
			else
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
			}
		}
		else
		{
			return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
		}
	}
	else
	{
		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
		if(IsCantMatchDeal(ePlayer))
		{
			SetCantMatchDeal(ePlayer, false);
			if(eApproach >= MAJOR_CIV_APPROACH_AFRAID)
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER");
			}
			else
			{
				return GetDiploTextFromTag("RESPONSE_TRADE_CANT_MATCH_OFFER_NEGATIVE");
			}
		}
		else
		{
			return GetDiploTextFromTag("RESPONSE_TRADE_AI_MAKES_OFFER");
		}
	}
}
/// The AI is denouncing the human
int CvDiplomacyAI::GetDenounceMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iMessage = 0;
	if(GetPlayer()->isHuman())
	{
		return iMessage;
	}
	if(ePlayer == NO_PLAYER)
	{
		ePlayer = GC.getGame().getActivePlayer();
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		bool bDogpile = false;

		PlayerTypes eTargetPlayerLoop;
		for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
		{
			eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

			if(eTargetPlayerLoop == NO_PLAYER)
				continue;

			// Player must be valid
			if(!IsPlayerValid(eTargetPlayerLoop))
				continue;

			// Don't test player Target himself
			if(eTargetPlayerLoop == ePlayer)
			continue;

			if(GET_PLAYER(eTargetPlayerLoop).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer))
			{
				bDogpile = true;
				break;
			}
		}

		// Guy is a different ideology
		if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
			{
				return 1;
			}
			else if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
			{
				return 2;
			}
			else if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
			{
				return 3;
			}
		}
		else if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && m_pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology() == GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if(GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
			{
				return 4;
			}
			else if(GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
			{
				return 5;
			}
			else if(GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
			{
				return 6;
			}
		}
		else if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
		{
			return 7;
		}
		// Guy is a warmonger
		else if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR && GetDiploBalance() > 5)
		{
			return 8;
		}
		// Guy is getting too friendly with our minors
		else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetMinorCivCompetitiveness() > 5)
		{
			return 9;
		}
		// Guy is bullying our minors
		else if(GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 0 && GetMinorCivCompetitiveness() > 5)
		{
			return 10;
		}
		// Guy nuked us!
		else if(IsNukedBy(ePlayer))
		{
			return 11;
		}
		// Guy is a thief!
		else if(IsPlayerBrokenSpyPromise(ePlayer) && GetLoyalty() > 5)
		{
			return 12;
		}
		// Guy is settling near us and we don't like it
		else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
		{
			return 13;
		}
		// Guy has bad friends!
		else if(IsPlayerDoFwithAnyEnemy(ePlayer) && GetDenounceWillingness() > 5)
		{
			return 14;
		}
		// Is denounced already
		else if(bDogpile && GetDenounceWillingness() > 5)
		{
			return 15;
		}
		// Is untrustworthy
		else if(IsUntrustworthyFriend(ePlayer))
		{
			return 16;
		}
		// Previous wars
		else if(eOpinion < MAJOR_CIV_OPINION_NEUTRAL && GetNumWarsFought(ePlayer) > 0 && GetForgiveness() <= 5)
		{
			return 17;
		}
		// Guy is a different faith
		else if(GetMeanness() > 4 && m_pPlayer->GetReligions()->HasCreatedReligion(true) && GET_PLAYER(ePlayer).GetReligions()->HasCreatedReligion(true) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		{
			return 18;
		}
		// Artifacts
		else if(IsPlayerBrokenNoDiggingPromise(ePlayer) && GetForgiveness() <= 5)
		{
			return 19;
		}
		// Guy built wonders we wanted
		else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetWonderCompetitiveness() > 5)
		{
			return 20;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 21;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 22;
		}
	}
	else
	{
		MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
		
		bool bDogpile = false;

		PlayerTypes eTargetPlayerLoop;
		for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
		{
			eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

			if(eTargetPlayerLoop == NO_PLAYER)
				continue;

			// Player must be valid
			if(!IsPlayerValid(eTargetPlayerLoop))
				continue;

			// Don't test player Target himself
			if(eTargetPlayerLoop == ePlayer)
			continue;

			if(GET_PLAYER(eTargetPlayerLoop).GetDiplomacyAI()->IsDenouncedPlayer(ePlayer))
			{
				bDogpile = true;
			}
		}
		iMessage = 0;

		// Guy is a different ideology
		if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_AUTOCRACY())
			{
				return 1;
			}
			else if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_ORDER())
			{
				return 2;
			}
			else if(m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree() == GC.getPOLICY_BRANCH_FREEDOM())
			{
				return 3;
			}
		}
		else if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && m_pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology() == GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if(GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == GC.getPOLICY_BRANCH_AUTOCRACY())
			{
				return 4;
			}
			else if(GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == GC.getPOLICY_BRANCH_ORDER())
			{
				return 5;
			}
			else if(GET_PLAYER(ePlayer).GetCulture()->GetPublicOpinionPreferredIdeology() == GC.getPOLICY_BRANCH_FREEDOM())
			{
				return 6;
			}
		}
		else if(GetDiploBalance() > 5 && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
		{
			return 7;
		}
		// Guy is a warmonger
		else if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR && GetDiploBalance() > 5)
		{
			return 8;
		}
		// Guy is getting too friendly with our minors
		else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetMinorCivCompetitiveness() > 5)
		{
			return 9;
		}
		// Guy is getting too friendly with our minors
		else if(GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 0 && GetMinorCivCompetitiveness() > 5)
		{
			return 10;
		}
		// Guy nuked us!
		else if(IsNukedBy(ePlayer))
		{
			return 11;
		}
		// Guy is a thief!
		else if(IsPlayerBrokenSpyPromise(ePlayer) && GetLoyalty() > 5)
		{
			return 12;
		}
		// Guy is setting near us and we don't like it
		else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && eOpinion < MAJOR_CIV_OPINION_NEUTRAL)
		{
			return 13;
		}
		// Guy has bad friends!
		else if(IsPlayerDoFwithAnyEnemy(ePlayer) && GetDenounceWillingness() > 5)
		{
			return 14;
		}
		// Is denounced already
		else if(bDogpile && GetDenounceWillingness() > 5)
		{
			return 15;
		}
		//Is untrustworthy
		else if(IsUntrustworthyFriend(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(m_pPlayer->GetID()))
		{
			return 16;
		}
		//Previous wars
		else if(eOpinion < MAJOR_CIV_OPINION_NEUTRAL && GetNumWarsFought(ePlayer) > 0 && GetForgiveness() <= 5)
		{
			return 17;
		}
		// Guy is a different faith
		else if(GetMeanness() > 4 && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		{
			return 18;
		}
		//Artifacts
		else if(IsPlayerBrokenNoDiggingPromise(ePlayer) && GetForgiveness() <= 5)
		{
			return 19;
		}
		// Guy built wonders we wanted
		else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetWonderCompetitiveness() > 5)
		{
			return 20;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 21;
		}
		// Guy is pursuing victory too hard
		else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG && GetVictoryCompetitiveness() > 5)
		{
			return 22;
		}
	}

	return iMessage;
}
const char* CvDiplomacyAI::GetDenounceMessageValue(int iValue)
{
	const char* strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE");
	// Guy is a different ideology
	if(iValue == 1)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_AUTOCRACY");
	}
	else if(iValue == 2)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_ORDER");
	}
	else if(iValue == 3)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_FREEDOM");
	}
	else if(iValue == 4)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_AUTOCRACY_OTHER");
	}
	else if(iValue == 5)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_ORDER_OTHER");
	}
	else if(iValue == 6)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_FREEDOM_OTHER");
	}
	else if(iValue == 7)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_IDEOLOGY_GENERIC");
	}
	// Guy is a warmonger
	else if(iValue == 8)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_WARMONGER");
	}
	// Guy is getting too friendly with our minors
	else if(iValue == 9)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_MINORS");
	}
	// Guy is getting too friendly with our minors
	else if(iValue == 10)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_MINORS_BULLY");
	}
	// Guy nuked us!
	else if(iValue == 11)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_NUKED");
	}
	// Guy is a thief!
	else if(iValue == 12)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_SPIES");
	}
	// Guy is setting near us and we don't like it
	else if(iValue == 13)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_LAND");
	}
	// Guy has bad friends!
	else if(iValue == 14)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_ENEMY");
	}
	// Is denounced already
	else if(iValue == 15)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_DOGPILE");
	}
	//Is untrustworthy
	else if(iValue == 16)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DOF_UNTRUSTWORTHY");
	}
	//Previous wars
	else if(iValue == 17)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_UNFORGIVEABLE");
	}
	// Guy is a different faith
	else if(iValue == 18)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_FAITH");
	}
	//Artifacts
	else if(iValue == 19)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_DIGGING");
	}
	// Guy built wonders we wanted
	else if(iValue == 20)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_WONDERS");
	}
	// Guy is pursuing victory too hard
	else if(iValue == 21)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_VICTORY_DISPUTE");
	}
	// Guy is pursuing victory too hard
	else if(iValue == 22)
	{
		strText = GetDiploTextFromTag("RESPONSE_DENOUNCE_VICTORY_BLOCK");
	}
	else
	{
		strText = GetDiploTextFromTag("RESPONSE_WORK_AGAINST_SOMEONE");
	}

	return strText;
}
#endif
/// AI is insulting the human
const char* CvDiplomacyAI::GetInsultHumanMessage()
{
	PlayerTypes ePlayer = GC.getGame().getActivePlayer();
	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

	FStaticVector<DiploMessageTypes, NUM_DIPLO_MESSAGE_TYPES, true, c_eCiv5GameplayDLL, 0> veValidInsults;

	// They're weak militarily
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
#else
	if(eMilitaryStrengthComparedToUs < STRENGTH_AVERAGE)
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_MILITARY);

	// We have nukes and they don't
	if(kPlayer.getNumNukeUnits() == 0 && m_pPlayer->getNumNukeUnits() > 0)
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_NUKE);

	// They've attacked a lot of minor civs
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if(GetOtherPlayerNumMinorsAttacked(ePlayer) > 2)
#else
	else if(GetOtherPlayerNumMinorsAttacked(ePlayer) > 0)
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_BULLY);

	// Their empire is unhappy
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if(kPlayer.IsEmpireVeryUnhappy())
#else
	else if(kPlayer.IsEmpireUnhappy())
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_UNHAPPINESS);

	// They have fewer Cities than us
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if((kPlayer.getNumCities() * 2) < m_pPlayer->getNumCities() && m_pPlayer->getNumCities() > 4)
#else
	else if(kPlayer.getNumCities() < m_pPlayer->getNumCities())
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_CITIES);

	// They have a low population
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if((kPlayer.getTotalPopulation() * 2) <= m_pPlayer->getTotalPopulation())
#else
	else if(kPlayer.getTotalPopulation() < m_pPlayer->getTotalPopulation())
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_POPULATION);

	// They have less Culture us
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	else if((kPlayer.GetJONSCultureEverGenerated() * 2) <= m_pPlayer->GetJONSCultureEverGenerated())
#else
	else if(kPlayer.GetJONSCultureEverGenerated() < m_pPlayer->GetJONSCultureEverGenerated())
#endif
		veValidInsults.push_back(DIPLO_MESSAGE_INSULT_CULTURE);

	// Pick a random insult from the valid ones
	if(veValidInsults.size() > 0)
	{
		int iIndex = GC.getGame().getAsyncRandNum(veValidInsults.size(), "Picking random insult for AI to give to human.");

		return GetDiploStringForMessage(veValidInsults[iIndex]);
	}

	// Needed to fall back on generic insult
	return GetDiploStringForMessage(DIPLO_MESSAGE_INSULT_GENERIC);
}

/// The human declares war on the AI, how does he respond?
const char* CvDiplomacyAI::GetAttackedByHumanMessage()
{
	PlayerTypes ePlayer = GC.getGame().getActivePlayer();

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

	// Military Promise Broken
	// This player said he wasn't going to attack us but did anyways
	if(IsPlayerBrokenMilitaryPromise(ePlayer))
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_MILITARY_PROMISE_BROKEN);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Player broke our vassal agreement (declared war on vassal)
	if(MOD_DIPLOMACY_CIV4_FEATURES && IsPlayerBrokenVassalAgreement(ePlayer))
		return GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_ATTACKED_VASSAL);
#endif

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	//Warmonger
	//If this person is a major warmonger, we should not be surprised
	if(MOD_BALANCE_CORE_DIPLOMACY && GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
	{
		// They are WEAKER than us
		if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_WARMONGER);

		// They are STRONGER than us
		else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_WARMONGER);

		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WARMONGER);
	}

	//Ideology
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	if(MOD_BALANCE_CORE_DIPLOMACY && eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch != eTheirBranch)
	{
		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_IDEOLOGY_DIFFERENCE);
	}
	if(MOD_BALANCE_CORE_DIPLOMACY && eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
	{
		// Average strength
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_IDEOLOGY_SAME);
	}
#endif

	// Sad
	// If we felt the other player was an Ally or Friend then we're just plain sad that they attacked us
	if(eOpinion == MAJOR_CIV_OPINION_ALLY ||
	        eOpinion == MAJOR_CIV_OPINION_FRIEND)
	{
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_SAD);
	}

	// Betrayed	-	TBD
	// This should be related to active deals, e.g. Open Borders, luxuries, etc.
	if(false)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_BETRAYED);

	// Excited
	// A player with the Conquest Grand Strategy will be excited
	// May also look at Boldness or Offense flavor in here eventually
	{
		if(IsGoingForWorldConquest())
		{
			// They are WEAKER than us
			if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
				return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_EXCITED);

			// They are STRONGER than us
			else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
				return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_EXCITED);

			// Average strength
			return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_EXCITED);
		}
	}

	// Hostile
	// This is the default response to being attacked
	// We are STRONGER than the person who attacked us
	if(eMilitaryStrengthComparedToUs <= STRENGTH_WEAK)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_STRONG_HOSTILE);

	// We are WEAKER than the person who attacked us
	else if(eMilitaryStrengthComparedToUs >= STRENGTH_POWERFUL)
		return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_WEAK_HOSTILE);

	// Average strength
	return GetDiploStringForMessage(DIPLO_MESSAGE_ATTACKED_HOSTILE);
}

/// The AI is declaring war on a human, what does he say?
const char* CvDiplomacyAI::GetWarMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	// Only show the message for the active human
	if(GC.getGame().getActivePlayer() == ePlayer)
	{
		MajorCivApproachTypes eApproachHidingTrueFeelings = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
		StrengthTypes eMilitaryStrengthComparedToUs = GetPlayerMilitaryStrengthComparedToUs(ePlayer);

		// Betrayal
		// We were Friendly (either real or fake), so we can presume this AI is betraying
		if(eApproachHidingTrueFeelings == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			// Betrayal, and we're weak
			if(eMilitaryStrengthComparedToUs >= STRENGTH_STRONG)
				return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WEAK_BETRAYAL);

			// Normal betrayal
			else
				return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_BETRAYAL);
		}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		// Old Enemies
		// If we have gone to war in the past more than once, we're old enemies
		if(MOD_BALANCE_CORE_DIPLOMACY && GetNumWarsFought(ePlayer) > 1)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_OLD_ENEMIES);

		//Warmonger
		//If this person is a major warmonger, we should tell them about it
		if(MOD_BALANCE_CORE_DIPLOMACY && GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WARMONGER);

		//Ideology
		//If we're different ideologies, that's probably a big factor.
		PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
		PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
		if(MOD_BALANCE_CORE_DIPLOMACY && eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch != eTheirBranch)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_IDEOLOGY_DIFFERENCE);
		}
		if(MOD_BALANCE_CORE_DIPLOMACY && eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE && eMyBranch == eTheirBranch)
		{
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_IDEOLOGY_SAME);
		}
#endif

		// Land Dispute
		// If Land Dispute is Strong or higher then this is probably a strong contributor to the DoW
		if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_LAND);

		// Desperate
		// The AI is desperate at this point in the game, and views a DoW as one of its only ways to slow an opponent
		if(eMilitaryStrengthComparedToUs >= STRENGTH_STRONG)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_DESPERATE);

		// World Conquest
		// A player with the Conquest Grand Strategy brags about his goals
		if(IsGoingForWorldConquest())
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_WORLD_CONQUEST);

		// Opportunity
		// The AI sees an opportunity because the opponent is weak
		if(eMilitaryStrengthComparedToUs <= STRENGTH_POOR)
			return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_OPPORTUNITY);

		// Generic DoW... probably shouldn't ever really use this
		return GetDiploStringForMessage(DIPLO_MESSAGE_DOW_GENERIC);
	}

	return strText;
}

/// The AI is breaking up with the human
const char* CvDiplomacyAI::GetEndDoFMessage(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	// Guy is a warmonger
	if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_WARMONGER");
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	// Guy is a different ideology
	else if((GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree()) && (GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_IDEOLOGY");
	// Guy is a different faith
	else if((GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != GetPlayer()->GetReligions()->GetReligionInMostCities()) && (GetPlayer()->GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_FAITH");
#endif
	// Guy is getting too friendly with our minors
	else if(GetMinorCivDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_MINORS");
	// Guy is setting near us and we don't like it
	else if(GetLandDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_LAND");
	// Guy built wonders we wanted
	else if(GetWonderDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_WONDERS");
	// Guy built wonders we wanted
	else if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_VICTORY");
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	// Guy is pursuing victory too hard
	else if(GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_BLOCK_VICTORY");
#endif
	else
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_WITH_US_DEFAULT");

	return strText;
}

/// The AI is done working against someone
const char* CvDiplomacyAI::GetEndWorkAgainstSomeoneMessage(PlayerTypes ePlayer, const Localization::String& strAgainstPlayerKey)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	const char* strText = "OMG I HAVE NO DATA (DECLARING WAR) - Please send Jon this with your last 5 autosaves and what changelist # you're playing.";

	if(ePlayer >=0 && ePlayer < MAX_MAJOR_CIVS)
		strText = GetDiploTextFromTag("RESPONSE_END_WORK_AGAINST_SOMEONE_DEFAULT", strAgainstPlayerKey);

	return strText;
}

/// Wrapper function for getting text from the Diplo Text system
const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag)
{
	return GetDiploTextFromTag(strTag, Localization::String::Empty, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag, const Localization::String& strOptionalKey1)
{
	return GetDiploTextFromTag(strTag, strOptionalKey1, Localization::String::Empty);
}

const char* CvDiplomacyAI::GetDiploTextFromTag(const char* strTag, const Localization::String& strOptionalKey1, const Localization::String& strOptionalKey2)
{
	// This is the leader text tag from the XML
	const char* strLeaderTag = GetPlayer()->getLeaderInfo().GetType();

	// This has to be a member so that our strings don't go out of scope when we leave this function
	m_strDiploText = GC.getGame().GetDiploResponse(strLeaderTag, strTag, strOptionalKey1, strOptionalKey2);

	return m_strDiploText.toUTF8();
}



/////////////////////////////////////////////////////////
// Coop War Request
/////////////////////////////////////////////////////////



/// Do we want to declare war on anyone with ePlayer?
bool CvDiplomacyAI::DoTestCoopWarDesire(PlayerTypes ePlayer, PlayerTypes& eChosenTargetPlayer)
{
//	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// If either player is a vassal then always say no
		if(GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
			return false;
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
			return false;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	//Are we not friends? Then we aren't going to ask.
	if(!IsDoFAccepted(ePlayer))
	{
		return false;
	}
#else
	// If player is planning War, always say no
	if(eApproach == MAJOR_CIV_APPROACH_WAR)
		return false;
	// If player is Hostile, always say no
	else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// If player is unforgivable, always say no
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;
	// If player is an enemy, always say no
	//else if (eOpinion == MAJOR_CIV_OPINION_ENEMY)
	//	return false;
#endif
	PlayerTypes eBestPlayer = NO_PLAYER;
	int iBestPlayerScore = 0;

	int iTempScore;

	// Loop through all players to see if we can find a good target
	PlayerTypes eTargetPlayerLoop;
	for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
	{
		eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

		// Player must be valid
		if(!IsPlayerValid(eTargetPlayerLoop))
			continue;

		// Don't test player Target himself
		if(eTargetPlayerLoop == ePlayer)
			continue;

#if defined(MOD_BALANCE_CORE)
		if(GET_TEAM(GET_PLAYER(eTargetPlayerLoop).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))
			continue;

		if(GET_TEAM(GET_PLAYER(eTargetPlayerLoop).getTeam()).isForcePeace(GET_PLAYER(ePlayer).getTeam()))
			continue;

		if(GET_TEAM(GET_PLAYER(eTargetPlayerLoop).getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()))
			continue;

		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eTargetPlayerLoop).getTeam()))
			continue;
		
		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eTargetPlayerLoop))
			continue;

		if(GET_PLAYER(eTargetPlayerLoop).GetDiplomacyAI()->IsDoFAccepted(ePlayer))
			continue;
#endif

		// Have we already made the agreement?
		if(GetCoopWarAcceptedState(ePlayer, eTargetPlayerLoop) != NO_COOP_WAR_STATE)
			continue;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		// Can't declare war against a vassal
		if(MOD_DIPLOMACY_CIV4_FEATURES && IsVassal(eTargetPlayerLoop))
			continue;
#endif

		// 30 turn buffer if we've been rejected before
		if(GetCoopWarCounter(ePlayer, eTargetPlayerLoop) >= 0 && GetCoopWarCounter(ePlayer, eTargetPlayerLoop) < 30)
			continue;

		iTempScore = GetCoopWarScore(ePlayer, eTargetPlayerLoop, /*bAskedByPlayer*/ false);

		if(iTempScore > iBestPlayerScore)
		{
			iBestPlayerScore = iTempScore;
			eBestPlayer = eTargetPlayerLoop;
		}
	}

	// Found someone?
	if(eBestPlayer != NO_PLAYER)
	{
		eChosenTargetPlayer = eBestPlayer;
		return true;
	}

	return false;
}

/// Willing to agree to go to war with ePlayer against eTargetPlayer?
CoopWarStates CvDiplomacyAI::GetWillingToAgreeToCoopWarState(PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	// Player is willing to agree. War now, or soon?
	if(GetCoopWarScore(ePlayer, eTargetPlayer, /*bAskedByPlayer*/ true) >= 15)
	{
		if(GetPlayerTargetValue(eTargetPlayer) >= TARGET_VALUE_FAVORABLE && GetBoldness() > 6)
		{
			return COOP_WAR_STATE_ACCEPTED;
		}
		else
		{
			return COOP_WAR_STATE_SOON;
		}
	}

	return COOP_WAR_STATE_REJECTED;
}

/// Does this AI want to ask ePlayer to go to war with eTargetPlayer?
int CvDiplomacyAI::GetCoopWarScore(PlayerTypes ePlayer, PlayerTypes eTargetPlayer, bool bAskedByPlayer)
{
	MajorCivApproachTypes eApproachTowardsPlayer = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes eOpinionTowardsPlayer = GetMajorCivOpinion(ePlayer);
	MajorCivApproachTypes eApproachTowardsTarget = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes eOpinionTowardsTarget = GetMajorCivOpinion(eTargetPlayer);

	// Both players must be able to declare war
	TeamTypes eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if(!GET_TEAM(GetPlayer()->getTeam()).canDeclareWar(eTargetTeam, GetPlayer()->GetID()))
#else
	if(!GET_TEAM(GetPlayer()->getTeam()).canDeclareWar(eTargetTeam))
#endif
		return 0;
#if defined(MOD_EVENTS_WAR_AND_PEACE)
	if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(eTargetTeam, ePlayer))
#else
	if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).canDeclareWar(eTargetTeam))
#endif
		return 0;

	// If player is inquiring, he has to be planning a war already
	if(!bAskedByPlayer)
	{
		if ((GetBiggestCompetitor() != eTargetPlayer) && (eApproachTowardsTarget > MAJOR_CIV_APPROACH_DECEPTIVE))
		return 0;
	}
#if defined(MOD_BALANCE_CORE)
	//Are we not friends? Then we aren't going to ask.
	if (!IsDoFAccepted(ePlayer))
	{
		return 0;
	}
	// No vassals!
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		return 0;

	if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
		return 0;

	if (GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).IsVassalOfSomeone())
		return 0;
#endif
	// Only players we've met, are alive, etc.
	if(!IsPlayerValid(eTargetPlayer))
		return 0;
	
	// If we think our "friend" is planning something sneaky, don't fall for the bait.
	if (GetTrueApproachTowardsUsGuess(ePlayer) == MAJOR_CIV_APPROACH_WAR || GetTrueApproachTowardsUsGuess(ePlayer) == MAJOR_CIV_APPROACH_HOSTILE)
		return 0;
	
	// We agreed not to attack, don't be dumb.
	if(GET_PLAYER(eTargetPlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetPlayer()->GetID()))
		return 0;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if(MOD_DIPLOMACY_CIV4_FEATURES && IsPlayerMoveTroopsRequestAccepted(eTargetPlayer))
		return 0;
#endif

	// Let's not go to war if we're very unhappy or losing all our wars
	if (GetPlayer()->IsEmpireVeryUnhappy() || GetStateAllWars() == STATE_ALL_WARS_LOSING)
		return 0;

	// They betrayed us? Nope.
	if (IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer) || IsPlayerBrokenMilitaryPromise(ePlayer))
		return 0;
	
	// AI teammates of humans should never do this on their own.
	if (GetPlayer()->IsAITeammateOfHuman())
		return 0;
	
	// Disallowed by game options
	if (IsWarDisallowed(eTargetPlayer))
		return 0;
	
	// Would this war cause us or our teammates to backstab a friend/ally? Don't do it!
	if (IsWarWouldBackstabFriendTeamCheck(eTargetPlayer))
		return 0;

	int iWeight = 0;

	// ePlayer asked us, so if we like him we're more likely to accept
	if(bAskedByPlayer)
	{
		if (eApproachTowardsPlayer == MAJOR_CIV_APPROACH_FRIENDLY || eApproachTowardsPlayer == MAJOR_CIV_APPROACH_DECEPTIVE || eApproachTowardsPlayer == MAJOR_CIV_APPROACH_AFRAID)
			iWeight += 2;
		else if (eOpinionTowardsPlayer >= MAJOR_CIV_OPINION_FAVORABLE)
			iWeight += 2;
	}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	if(MOD_BALANCE_CORE_DIPLOMACY)
	{
		if(GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_NEIGHBORS)
		{
			iWeight += 6;
		}
		else if(GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_CLOSE)
		{
			iWeight += 3;
		}
		else if(GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_FAR)
		{
			iWeight -= 2;
		}
		else if(GetPlayer()->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_DISTANT)
		{
			iWeight -= 4;
		}
		
		if (GetBiggestCompetitor() == eTargetPlayer)
		{
			iWeight += 25;
		}
		else if (IsMajorCompetitor(eTargetPlayer))
		{
			iWeight += 8;
		}
		
		// Are they about to win the game?
		if (GET_PLAYER(eTargetPlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() && !IsNoVictoryCompetition())
		{
			if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition())
			{
				iWeight += 25;
			}
			if (IsCloseToAnyVictoryCondition())
			{
				iWeight += 25;
			}
		}
	}
#endif

	// Weight for Approach
	if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_WAR)
		iWeight += 5;
	else if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_HOSTILE)
		iWeight += 2;
	else if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_GUARDED)
		iWeight -= 1;
	else if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_DECEPTIVE)
		iWeight += 5;
	else if (eApproachTowardsTarget == MAJOR_CIV_APPROACH_FRIENDLY)
		return 0;

	if (IsGoingForWorldConquest())
	{
		iWeight += 3;
		if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_DECEPTIVE || eApproachTowardsTarget <= MAJOR_CIV_APPROACH_HOSTILE)
			iWeight += 2;
	}
	else if (IsGoingForDiploVictory())
	{
		iWeight -= 2;
	}
	
#if defined(MOD_BALANCE_CORE)
	if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		iWeight += 5;
#endif

	// Weight for Opinion
	switch (eOpinionTowardsTarget)
	{
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
		iWeight += 12;
		break;
	case MAJOR_CIV_OPINION_ENEMY:
		iWeight += 8;
		break;
	case MAJOR_CIV_OPINION_COMPETITOR:
		iWeight += 4;
		break;
	case MAJOR_CIV_OPINION_FAVORABLE:
		iWeight -= 1;
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		iWeight -= 5;
		break;
	case MAJOR_CIV_OPINION_ALLY:
		return 0;
		break;
	}
	
	// Bankrupt?
	if (GetPlayer()->GetTreasury()->GetGold() <= 0 && GetPlayer()->calculateGoldRate() <= 0)
	{
		iWeight -= 5;
	}

	// Are we getting money from trade with them?
	int iCurrentTradeValue = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, eTargetPlayer);
	int iTradeDealValue = GC.getGame().GetGameDeals().GetDealValueWithPlayer(GetPlayer()->GetID(), eTargetPlayer);
	if(iCurrentTradeValue > 0 || iTradeDealValue > 0)
	{
		iWeight -= 2;

		// Sanity check - avoid declaring war if we would go bankrupt!
		int iLostGoldPerTurn = CalculateGoldPerTurnLostFromWar(eTargetPlayer, false, false);
		int iAdjustedGoldPerTurn = GetPlayer()->calculateGoldRate() - iLostGoldPerTurn;
		
		if (iLostGoldPerTurn != 0)
		{
			if (!GET_PLAYER(eTargetPlayer).GetDiplomacyAI()->IsCloseToAnyVictoryCondition() || IsNoVictoryCompetition())
			{
#if defined(MOD_BALANCE_CORE)
				// Factor in instant yields into our income as well (average of recent turns)
				int iTurn = GC.getGame().getGameTurn();
				int iGoldAverage = 0;
				for (int iI = 0; iI < 10; iI++)
				{
					int iYieldTurn = iTurn - iI;
					if (iYieldTurn <= 0)
						continue;

					iGoldAverage += GetPlayer()->getInstantYieldValue(YIELD_GOLD, iYieldTurn);
				}

				iGoldAverage /= 10;

				iAdjustedGoldPerTurn += iGoldAverage;
#endif

				iAdjustedGoldPerTurn *= 100; // multiply x100 to avoid rounding errors

				if (iAdjustedGoldPerTurn < 0)
				{
					// Flip it!
					iAdjustedGoldPerTurn *= -1;

					int iTurnsUntilBankruptcy = GetPlayer()->GetTreasury()->GetGoldTimes100() / max(iAdjustedGoldPerTurn, 1);

					if (iTurnsUntilBankruptcy <= 30)
					{
						int iSanityMod = iAdjustedGoldPerTurn / 100;

						// Reduce weight by 1% for each turn it would take to go bankrupt
						iSanityMod *= (100 - iTurnsUntilBankruptcy);
						iSanityMod /= 100;

						iWeight -= iSanityMod;
					}
				}
			}
		}
	}

	// Weight for expanding too fast
	if(IsPlayerRecklessExpander(eTargetPlayer))
	{
		iWeight += 4;
	}

	// Weight for warmonger threat
	switch(GetWarmongerThreat(eTargetPlayer))
	{
	case THREAT_MINOR:
		iWeight += 1;
		break;
	case THREAT_MAJOR:
		iWeight += 3;
		break;
	case THREAT_SEVERE:
		iWeight += 5;
		break;
	case THREAT_CRITICAL:
		iWeight += 7;
		break;
	}
#if defined(MOD_BALANCE_CORE)
	// Weight for victory issues
	switch(GetVictoryDisputeLevel(eTargetPlayer))
	{
	case DISPUTE_LEVEL_WEAK:
		iWeight += 3;
		break;
	case DISPUTE_LEVEL_STRONG:
		iWeight += 6;
		break;
	case DISPUTE_LEVEL_FIERCE:
		iWeight += 9;
		break;
	}
	
	switch(GetVictoryBlockLevel(eTargetPlayer))
	{
	case BLOCK_LEVEL_WEAK:
		iWeight += 3;
		break;
	case BLOCK_LEVEL_STRONG:
		iWeight += 6;
		break;
	case BLOCK_LEVEL_FIERCE:
		iWeight += 9;
		break;
	}

	iWeight += (GET_PLAYER(eTargetPlayer).GetNumCapitalCities() * 5);
#endif

	// If we're working with ePlayer then increase weight (if we're already willing to work Target this guy)
	if(iWeight > 0 && IsDoFAccepted(ePlayer))
		iWeight += 5;

	// If we're working with ePlayer then increase weight (if we're already willing to work Target this guy)
	//if (iWeight > 0 && IsWorkingAgainstPlayer(eTargetPlayer))
	//	iWeight += 4;

	// Base Personality value; ranges from 0 to 10 (ish)
	//iWeight += GetWorkTargetWillingness();

	// Weight mod for target value
#if defined(MOD_BALANCE_CORE)
	//Fiercely competitive with this guy? Who cares if he's tough to kill?
	if(!IsMajorCompetitor(ePlayer))
	{
#endif

	switch (GetPlayerTargetValue(eTargetPlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
	case TARGET_VALUE_BAD:
		return 0;
		break;
	case TARGET_VALUE_AVERAGE:
		iWeight *= 75;
		iWeight /= 100;
		break;
	case TARGET_VALUE_FAVORABLE:
		iWeight *= 90;
		iWeight /= 100;
		break;
	case TARGET_VALUE_SOFT:
		iWeight *= 125;
		iWeight /= 100;
		break;
	}
#if defined(MOD_BALANCE_CORE)
	}
	else if (GetPlayerTargetValue(eTargetPlayer) == TARGET_VALUE_SOFT)
	{
		iWeight *= 125;
		iWeight /= 100;
	}
#endif

	// Weight must be high enough for us to return a true desire
#if defined(MOD_BALANCE_CORE)
	if(iWeight >= 18)
#else
	if(iWeight >= 15)
#endif
		return iWeight;

	return 0;
}

#if defined(MOD_BALANCE_CORE)
/// If we rejected eAskingPlayer's request to go to war with eTargetPlayer, should we warn the target?
bool CvDiplomacyAI::IsCoopWarRequestUnacceptable(PlayerTypes eAskingPlayer, PlayerTypes eTargetPlayer)
{
	// FAILSAFES
	// Invalid player/teammate?
	if (!IsPlayerValid(eAskingPlayer) || !IsPlayerValid(eTargetPlayer))
		return false;
	// At war with the asker?
	if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eAskingPlayer).getTeam()))
		return false;	
	// At war with the target?
	if (GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eTargetPlayer).getTeam()))
		return false;
	// No vassals!
	if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone())
		return false;
	if (GET_TEAM(GET_PLAYER(eAskingPlayer).getTeam()).IsVassalOfSomeone())
		return false;
	if (GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).IsVassalOfSomeone())
		return false;
	
	// If it's because war is disallowed by game options, don't give a penalty for it
	if (IsWarDisallowed(eTargetPlayer))
		return false;
		
	// If the target is a human, never warn them for now (no textkey/diplo statement)
	if(GET_PLAYER(eTargetPlayer).isHuman())
		return false;
		
	MajorCivApproachTypes eApproachTowardsAsker = GetMajorCivApproach(eAskingPlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes  eOpinionOfAsker = GetMajorCivOpinion(eAskingPlayer);
	MajorCivApproachTypes eApproachTowardsTarget = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes  eOpinionOfTarget = GetMajorCivOpinion(eTargetPlayer);
	
	// If we want war against the target, never warn them
	if (eApproachTowardsTarget == MAJOR_CIV_APPROACH_WAR || IsCapitalCapturedBy(eTargetPlayer) || IsHolyCityCapturedBy(eTargetPlayer) ||
		IsArmyInPlaceForAttack(eTargetPlayer) || IsWantsSneakAttack(eTargetPlayer) || GetWarGoal(eTargetPlayer) == WAR_GOAL_PREPARE || GetWarGoal(eTargetPlayer) == WAR_GOAL_DEMAND)
		return false;
	
	// If we want war against the asker, always warn them
	if (eApproachTowardsAsker == MAJOR_CIV_APPROACH_WAR || IsCapitalCapturedBy(eAskingPlayer) || IsHolyCityCapturedBy(eAskingPlayer) ||
		IsArmyInPlaceForAttack(eAskingPlayer) || IsWantsSneakAttack(eAskingPlayer) || GetWarGoal(eAskingPlayer) == WAR_GOAL_PREPARE || GetWarGoal(eAskingPlayer) == WAR_GOAL_DEMAND)
		return true;
	
	// DoF, DP, or ally with the target? Always warn them.
	if(IsDoFAccepted(eTargetPlayer) || GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(eTargetPlayer).getTeam()) || eOpinionOfTarget == MAJOR_CIV_OPINION_ALLY)
		return true;
	
	// DoF, DP or ally with the asker? Never warn them.
	if(IsDoFAccepted(eAskingPlayer) || GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(eAskingPlayer).getTeam()) || eOpinionOfAsker == MAJOR_CIV_OPINION_ALLY)
		return false;
	
	// If we're afraid of the asker or hate the target, never warn them
	if(eApproachTowardsAsker == MAJOR_CIV_APPROACH_AFRAID || eApproachTowardsTarget == MAJOR_CIV_APPROACH_HOSTILE || eOpinionOfTarget == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;
	
	// If we're afraid of the target or hate the asker, always warn them
	if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_AFRAID || eApproachTowardsAsker == MAJOR_CIV_APPROACH_HOSTILE || eOpinionOfAsker == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return true;
	
	// Fiercely competitive with target? Never warn them.
	if(IsMajorCompetitor(eTargetPlayer))
		return false;
	
	// Fiercely competitive with asker? Always warn them.
	if(IsMajorCompetitor(eAskingPlayer))
		return true;
	
	// Any flavors that should influence the decision?
	if(GetLoyalty() >= 5 && eOpinionOfTarget >= MAJOR_CIV_OPINION_FRIEND)
		return true;
	if(GetDiploBalance() > 5 && eOpinionOfTarget >= MAJOR_CIV_OPINION_FAVORABLE)
		return true;
	
	// Otherwise, warn the target if we like them more than the asker, and our opinion of them is at least NEUTRAL
	if(eOpinionOfTarget > eOpinionOfAsker && eOpinionOfTarget >= MAJOR_CIV_OPINION_NEUTRAL)
		return true;
	
	return false;
}
#endif

/// Has ePlayer asked to start a coop war against eTargetPlayer lately?
bool CvDiplomacyAI::IsCoopWarMessageTooSoon(PlayerTypes ePlayer, PlayerTypes eTargetPlayer) const
{
	if(GetCoopWarCounter(ePlayer, eTargetPlayer) >= 0 &&
	        GetCoopWarCounter(ePlayer, eTargetPlayer) < 30)
		return true;

	return false;
}

/// Has ePlayer ever asked to start a coop war against us?
bool CvDiplomacyAI::IsCoopWarEverAsked(PlayerTypes ePlayer, PlayerTypes eTargetPlayer) const
{
	// Counter set to -1 at start. Gets reset to -666
	if(GetCoopWarCounter(ePlayer, eTargetPlayer) == -1)
		return false;

	return true;
}

CoopWarStates CvDiplomacyAI::GetCoopWarAcceptedState(PlayerTypes ePlayer, PlayerTypes eTargetPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (CoopWarStates) m_ppaacCoopWarAcceptedState[ePlayer][eTargetPlayer];
}

void CvDiplomacyAI::SetCoopWarAcceptedState(PlayerTypes ePlayer, PlayerTypes eTargetPlayer, CoopWarStates eValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eValue != GetCoopWarAcceptedState(ePlayer, eTargetPlayer))
	{
		m_ppaacCoopWarAcceptedState[ePlayer][eTargetPlayer] = eValue;
		
#if defined(MOD_BALANCE_CORE)
		// If accepted, reduce any diplo malus for refusing to go to war previously
		if(eValue == COOP_WAR_STATE_ACCEPTED)
		{
			ChangeNumTimesCoopWarDenied(ePlayer, -1);
		}
#endif
	}
}

short CvDiplomacyAI::GetCoopWarCounter(PlayerTypes ePlayer, PlayerTypes eTargetPlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_ppaaiCoopWarCounter[ePlayer][eTargetPlayer];
}

void CvDiplomacyAI::SetCoopWarCounter(PlayerTypes ePlayer, PlayerTypes eTargetPlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTargetPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaaiCoopWarCounter[ePlayer][eTargetPlayer] = iValue;
}

void CvDiplomacyAI::ChangeCoopWarCounter(PlayerTypes ePlayer, PlayerTypes eTargetPlayer, int iChange)
{
	SetCoopWarCounter(ePlayer, eTargetPlayer, GetCoopWarCounter(ePlayer, eTargetPlayer) + iChange);
}

/// Do we want to stop working against any players we're targeting in a coop war?
bool CvDiplomacyAI::DoTestContinueCoopWarsDesire(PlayerTypes ePlayer, PlayerTypes& eTargetPlayer)
{
	// Loop through all players to see if we can find a good target
	PlayerTypes eTargetPlayerLoop;
	for(int iTargetPlayerLoop = 0; iTargetPlayerLoop < MAX_MAJOR_CIVS; iTargetPlayerLoop++)
	{
		eTargetPlayerLoop = (PlayerTypes) iTargetPlayerLoop;

		if(GetCoopWarAcceptedState(ePlayer, eTargetPlayerLoop) == COOP_WAR_STATE_ACCEPTED)
		{
			if(!IsContinueCoopWar(ePlayer, eTargetPlayerLoop))
			{
				eTargetPlayer = eTargetPlayerLoop;
				return false;
			}
		}
	}

	return true;
}

/// Do we want to continue our coop war against Target ePlayer?
bool CvDiplomacyAI::IsContinueCoopWar(PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	CvAssertMsg(GetCoopWarAcceptedState(ePlayer, eTargetPlayer) == COOP_WAR_STATE_ACCEPTED, "Diplomacy AI: Testing whether we should continue working Target a player, but we aren't right now. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproachTowardsPlayer = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes eOpinionTowardsPlayer = GetMajorCivOpinion(ePlayer);
	MajorCivApproachTypes eApproachTowardsTarget = GetMajorCivApproach(eTargetPlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes eOpinionTowardsTarget = GetMajorCivOpinion(eTargetPlayer);

	// Changed our approach towards ePlayer
	if(eApproachTowardsPlayer == MAJOR_CIV_APPROACH_HOSTILE ||
	        GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	// If we're enemies or unforgivable then we're done working with this guy
	if(eOpinionTowardsPlayer <= MAJOR_CIV_OPINION_ENEMY)
		return false;

	// If we've decided we like the guy now, we're done
	if(eApproachTowardsTarget == MAJOR_CIV_APPROACH_FRIENDLY)
		return false;

	if(eOpinionTowardsTarget >= MAJOR_CIV_OPINION_FRIEND)
		return false;

#if defined(MOD_BALANCE_CORE)
	if(GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).isForcePeace(GET_PLAYER(ePlayer).getTeam()))
		return false;
#endif

	// If we've made a military promise, we're done
	if(GET_PLAYER(eTargetPlayer).GetDiplomacyAI()->IsPlayerMadeMilitaryPromise(GetPlayer()->GetID()))
		return false;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// If we've made the decision to move troops from borders, we're done
	if(MOD_DIPLOMACY_CIV4_FEATURES && IsPlayerMoveTroopsRequestAccepted(eTargetPlayer))
		return false;
#endif

	// If we've worked together for at least 20 turns, and are competitors, there's a chance we break things off
	//if (GetCoopWarCounter(ePlayer) > 20)
	//{
	//	if (eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
	//	{
	//		int iChance = 10 - GetWorkTargetWillingness();
	//		int iRand = GC.getGame().getJonRandNum(100, "Diplomacy AI: Rand for whether AI wants to work Target player");

	//		if (iRand < iChance)
	//			return false;
	//	}
	//}

	return true;
}

/// Check everyone we know to see if we're planning a coop war against them
CoopWarStates CvDiplomacyAI::GetGlobalCoopWarAcceptedState(PlayerTypes ePlayer)
{
	CoopWarStates eBestState = NO_COOP_WAR_STATE;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(GetCoopWarAcceptedState(eLoopPlayer, ePlayer) > eBestState)
				eBestState = GetCoopWarAcceptedState(eLoopPlayer, ePlayer);
		}
	}

	return eBestState;
}

/// What is the SHORTEST amount of time on any coop war counter?
int CvDiplomacyAI::GetGlobalCoopWarCounter(PlayerTypes ePlayer)
{
	int iBestCount = MAX_TURNS_SAFE_ESTIMATE;

	int iTempCount;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			iTempCount = GetCoopWarCounter(eLoopPlayer, ePlayer);

			// No valid count against this guy
			if(iTempCount < 0)
				continue;

			if(iTempCount < iBestCount)
				iBestCount = iTempCount;
		}
	}

	return iBestCount;
}

/// Are we locked into a war with ePlayer?
bool CvDiplomacyAI::IsLockedIntoCoopWar(PlayerTypes ePlayer)
{
	CoopWarStates eCoopWarState = GetGlobalCoopWarAcceptedState(ePlayer);

	if (eCoopWarState == COOP_WAR_STATE_ACCEPTED || eCoopWarState == COOP_WAR_STATE_SOON)
	{
		if (GetGlobalCoopWarCounter(ePlayer) <= /*20*/ GC.getCOOP_WAR_LOCKED_TURNS())
			return true;
	}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	//Vassals will never want peace with a player if their master is at war with a player.
	if (MOD_DIPLOMACY_CIV4_FEATURES)
	{
		if(GET_TEAM(m_pPlayer->getTeam()).IsVassalOfSomeone())
		{
			TeamTypes eMasterTeam = GET_TEAM(m_pPlayer->getTeam()).GetMaster();
			if (eMasterTeam != NO_TEAM)
			{
				if (GET_TEAM(eMasterTeam).isAtWar(GET_PLAYER(ePlayer).getTeam()))
				{
					return true;
				}
			}
		}
	}
#endif

	if ((GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsLockedIntoWar(GET_PLAYER(ePlayer).getTeam()) > 0))
		return true;

	return false;
}



/////////////////////////////////////////////////////////
// Human Demand
/////////////////////////////////////////////////////////


/// Human made a demand against this AI, handle everything that means
void CvDiplomacyAI::DoDemandMade(PlayerTypes ePlayer, DemandResponseTypes eDemand)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Reset counter
	SetDemandCounter(ePlayer, 0);
	if (eDemand != DEMAND_RESPONSE_REFUSE_TOO_SOON)
	{
#if defined(MOD_BALANCE_CORE)
		SetNumDemandEverMade(ePlayer, 1);
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (IsVassal(ePlayer))
		{
			ChangeNumTimesDemandedWhileVassal(ePlayer, 1);
		}
#endif
	}

	// Assume the human is HOSTILE only if we don't already think they want war OR if we gave them what they wanted
	if(GetTrueApproachTowardsUsGuess(ePlayer) != MAJOR_CIV_APPROACH_WAR || eDemand == DEMAND_RESPONSE_ACCEPT)
	{
		SetApproachTowardsUsGuess(ePlayer, MAJOR_CIV_APPROACH_HOSTILE);
		SetApproachTowardsUsGuessCounter(ePlayer, 0);
	}

	// See how long it'll be before we might agree to another demand

	int iNumTurns = /*20*/ GC.getDEMAND_TURN_LIMIT_MIN();
	int iRand = GC.getGame().getSmallFakeRandNum(GC.getDEMAND_TURN_LIMIT_RAND(), ePlayer);
	iNumTurns += iRand;

	m_paiDemandTooSoonNumTurns[ePlayer] = iNumTurns;
}

/// Has it been too soon since the last demand made?
bool CvDiplomacyAI::IsDemandTooSoon(PlayerTypes ePlayer) const
{
	int iDemandTooSoonNumTurns = GetDemandTooSoonNumTurns(ePlayer);

	// Haven't gotten a demand before
	if(iDemandTooSoonNumTurns == -1)
		return false;

	int iCounter = GetDemandCounter(ePlayer);

	if(iCounter > -1 && iCounter < iDemandTooSoonNumTurns)
		return true;

	return false;
}

/// Returns the amount of turns required between demands
short CvDiplomacyAI::GetDemandTooSoonNumTurns(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDemandTooSoonNumTurns[ePlayer];
}

/// Returns the number of demands ePlayer has ever made of us
int CvDiplomacyAI::GetNumDemandEverMade(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDemandEverMade[ePlayer];
}

/// Returns if ePlayer has ever made a demand of us
bool CvDiplomacyAI::IsDemandEverMade(PlayerTypes ePlayer) const
{
#if defined(MOD_BALANCE_CORE)
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDemandEverMade[ePlayer] > 0;
#else
	if(GetDemandCounter(ePlayer) == -1)
		return false;

	return true;
#endif
}

/// How many turns has it been since ePlayer last made a demand of us?
short CvDiplomacyAI::GetDemandCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDemandCounter[ePlayer];
}

/// Sets how many turns it has been since ePlayer last made a demand of us
void CvDiplomacyAI::SetDemandCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiDemandCounter[ePlayer] = iValue;

}

/// Changes how many turns it has been since ePlayer last made a demand of us
void CvDiplomacyAI::ChangeDemandCounter(PlayerTypes ePlayer, int iChange)
{
	SetDemandCounter(ePlayer, GetDemandCounter(ePlayer) + iChange);
	
	if (m_paiDemandCounter[ePlayer] > -1 && m_paiDemandCounter[ePlayer] > GetDemandTooSoonNumTurns(ePlayer) * 3)
	{
#if defined(MOD_BALANCE_CORE)
		SetNumDemandEverMade(ePlayer, -GetNumDemandEverMade(ePlayer));

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)	
		if (IsVassal(ePlayer))
		{
			ChangeNumTimesDemandedWhileVassal(ePlayer, -GetNumTimesDemandedWhileVassal(ePlayer));
		}
#endif
#endif
		SetDemandCounter(ePlayer, -1);
	}
}



/////////////////////////////////////////////////////////
// Don't Settle Request
/////////////////////////////////////////////////////////



/// Will this AI agree not to settle near ePlayer?
bool CvDiplomacyAI::IsDontSettleAcceptable(PlayerTypes ePlayer) const
{
	// Always acceptable for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return true;
	
	// Always acceptable if they resurrected us
	if(WasResurrectedBy(ePlayer))
		return true;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

	// If player is afraid, always say yes
	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// If player is Hostile, always say no
	else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// If player is unforgivable, always say no
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;

	// If the player has deleted the EXPANSION Flavor we have to account for that
	int iExpansionFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")
		{
			iExpansionFlavor = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
			break;
		}
	}

	// Default threshold
	// EX: 8 - 10 Expansion = -2 * 5 = -10%
	// EX: 8 - 7 Expansion = 1 * 5 = 5%
	// EX: 8 - 5 Expansion = 3 * 5 = 15%
	// EX: 8 - 2 Expansion = 6 * 5 = 30%
	int iThreshold = (/*8*/ GC.getDONT_SETTLE_FLAVOR_BASE() - iExpansionFlavor) * /*5*/ GC.getDONT_SETTLE_FLAVOR_MULTIPLIER();

	bool bFriendly = eApproach == MAJOR_CIV_APPROACH_FRIENDLY;

	// If player is Friendly, add weight
	if(bFriendly)
		iThreshold += /*30*/ GC.getDONT_SETTLE_FRIENDLY();

	int iMilitaryMod = 0;

	// Military Strength compared to us
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_PATHETIC:
		if(!bFriendly)
			iMilitaryMod += /*-30*/ GC.getDONT_SETTLE_STRENGTH_PATHETIC();
		break;
	case STRENGTH_WEAK:
		if(!bFriendly)
			iMilitaryMod += /*-20*/ GC.getDONT_SETTLE_STRENGTH_WEAK();
		break;
	case STRENGTH_POOR:
		if(!bFriendly)
			iMilitaryMod += /*-10*/ GC.getDONT_SETTLE_STRENGTH_POOR();
		break;
	case STRENGTH_AVERAGE:
		iMilitaryMod += /*0*/ GC.getDONT_SETTLE_STRENGTH_AVERAGE();
		break;
	case STRENGTH_STRONG:
		iMilitaryMod += /*25*/ GC.getDONT_SETTLE_STRENGTH_STRONG();
		break;
	case STRENGTH_POWERFUL:
		iMilitaryMod += /*40*/ GC.getDONT_SETTLE_STRENGTH_POWERFUL();
		break;
	case STRENGTH_IMMENSE:
		iMilitaryMod += /*60*/ GC.getDONT_SETTLE_STRENGTH_IMMENSE();
		break;
	}

	// Military Aggressive Posture - MULTIPLIER
	switch(GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		iMilitaryMod *= /*100*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_NONE();
		break;
	case AGGRESSIVE_POSTURE_LOW:
		iMilitaryMod *= /*100*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_LOW();
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		iMilitaryMod *= /*150*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_MEDIUM();
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		iMilitaryMod *= /*200*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_HIGH();
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		iMilitaryMod *= /*300*/ GC.getDONT_SETTLE_MOD_MILITARY_POSTURE_INCREDIBLE();
		break;
	}

	// Bring it out of hundreds
	iMilitaryMod /= 100;

	iThreshold += iMilitaryMod;

#if defined(MOD_BALANCE_CORE)
	//Base it on boldness.
	int iRand = (GetBoldness() * 10);
#else
	int iRand = GC.getGame().getJonRandNum(/*100*/ GC.getDONT_SETTLE_RAND(), "Diplomacy AI: will AI agree to not settle near a player?");
#endif

	// Passes the test?
	if(iRand < iThreshold)
		return true;

	return false;
}

/// Has ePlayer asked about us not settling near him lately?
bool CvDiplomacyAI::IsDontSettleMessageTooSoon(PlayerTypes ePlayer) const
{
	if(GetPlayerNoSettleRequestCounter(ePlayer) >= 0)
		return true;

	return false;
}

/// Has ePlayer ever asked about us not settling near him?
bool CvDiplomacyAI::IsPlayerNoSettleRequestEverAsked(PlayerTypes ePlayer) const
{
#if defined(MOD_BALANCE_CORE)
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerNoSettleRequestEverAsked[ePlayer];
#else
	// Counter set to -1 at start. Gets reset to -666
	if(GetPlayerNoSettleRequestCounter(ePlayer) == -1)
		return false;
	return true;
#endif
}

/// Has this AI rejected a request from ePlayer to not settle near them?
bool CvDiplomacyAI::IsPlayerNoSettleRequestRejected(PlayerTypes ePlayer) const
{
	// If the counter is -1, it means he hasn't asked
	if(GetPlayerNoSettleRequestCounter(ePlayer) < 0)
		return false;

	// Did the player actually accept?
	if(IsPlayerNoSettleRequestAccepted(ePlayer))
		return false;

	return true;
}

/// Has this AI accepted a request from ePlayer to not settle near them?
bool CvDiplomacyAI::IsPlayerNoSettleRequestAccepted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerNoSettleRequestAccepted[ePlayer];
}

/// Marks plots as blocked or not blocked for this AI's settlers depending on if they agreed not to settle near ePlayer
void CvDiplomacyAI::SetPlayerNoSettleRequestAccepted(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsPlayerNoSettleRequestAccepted(ePlayer))
	{
		m_pabPlayerNoSettleRequestAccepted[ePlayer] = bValue;

		int iPlotLoop;

		// Add blocker to plots nearby ePlayer
		if(bValue)
		{
			int iLoopX, iLoopY;
			CvPlot* pNearbyPlot;
			int iRange = 6;

			// Loop through all of this player's Cities and create a barrier around them
			CvCity* pLoopCity;
			int iCityLoop;
			for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				for(iLoopX = -(iRange); iLoopX <= iRange; iLoopX++)
				{
					for(iLoopY = -(iRange); iLoopY <= iRange; iLoopY++)
					{
						pNearbyPlot = plotXY(pLoopCity->getX(), pLoopCity->getY(), iLoopX, iLoopY);

						if(pNearbyPlot != NULL)
						{
							if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pLoopCity->getX(), pLoopCity->getY()) <= iRange)
							{
								GetPlayer()->SetNoSettling( pNearbyPlot->GetPlotIndex() );
							}
						}
					}
				}
			}
		}
		// Remove blocker from all plots
		else
		{
			int iNumPlots = GC.getMap().numPlots();
			for(iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)
			{
				GetPlayer()->ClearNoSettling();
			}
		}
	}
}

/// How many turns has it been since ePlayer asked us not to settle near them?
short CvDiplomacyAI::GetPlayerNoSettleRequestCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerNoSettleRequestCounter[ePlayer];
}

/// Sets how many turns it has been since ePlayer asked us not to settle near them
void CvDiplomacyAI::SetPlayerNoSettleRequestCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiPlayerNoSettleRequestCounter[ePlayer] = iValue;
}

/// Changes how many turns it has been since ePlayer asked us not to settle near them
void CvDiplomacyAI::ChangePlayerNoSettleRequestCounter(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNoSettleRequestCounter(ePlayer, GetPlayerNoSettleRequestCounter(ePlayer) + iChange);
}

/////////////////////////////////////////////////////////
// Stop Spying Request
/////////////////////////////////////////////////////////

/// Will this AI agree to stop spying on ePlayer?
bool CvDiplomacyAI::IsStopSpyingAcceptable(PlayerTypes ePlayer) const
{
	// Always acceptable for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return true;
	
	// Always acceptable if they resurrected us
	if(WasResurrectedBy(ePlayer))
		return true;
	
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);

	// If player is afraid, always say yes
	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// If player is Hostile, always say no
	else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// If player is unforgivable, always say no
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;

	return true;
}

/// Has ePlayer asked us not to spy on him lately?
bool CvDiplomacyAI::IsStopSpyingMessageTooSoon(PlayerTypes ePlayer) const
{
	if(GetPlayerStopSpyingRequestCounter(ePlayer) >= 0)
	{
		return true;
	}

	return false;
}

/// Has ePlayer ever asked us not to spy on him?
bool CvDiplomacyAI::IsPlayerStopSpyingRequestEverAsked(PlayerTypes ePlayer) const
{
#if defined(MOD_BALANCE_CORE)
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerStopSpyingRequestEverAsked[ePlayer];
#else
	// Counter set to -1 at start. Gets reset to -666
	if(GetPlayerStopSpyingRequestCounter(ePlayer) == -1)
	{
		return false;
	}
	return true;
#endif
}

/// Has this AI rejected a request from ePlayer to not spy on them?
bool CvDiplomacyAI::IsPlayerStopSpyingRequestRejected(PlayerTypes ePlayer) const
{
	// If the counter is -1, it means he hasn't asked
	if(GetPlayerStopSpyingRequestCounter(ePlayer) < 0)
		return false;

	// Did the player actually accept?
	if(IsPlayerStopSpyingRequestAccepted(ePlayer))
		return false;

	return true;
}

/// Has this AI accepted a request from ePlayer to not spy on them?
bool CvDiplomacyAI::IsPlayerStopSpyingRequestAccepted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerStopSpyingRequestAccepted[ePlayer];
}

/// Sets whether or not ePlayer's request not to spy on them has been accepted
void CvDiplomacyAI::SetPlayerStopSpyingRequestAccepted(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsPlayerStopSpyingRequestAccepted(ePlayer))
	{
		m_pabPlayerStopSpyingRequestAccepted[ePlayer] = bValue;
	}
}

/// How many turns has it been since ePlayer asked us not to spy on them?
short CvDiplomacyAI::GetPlayerStopSpyingRequestCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerStopSpyingRequestCounter[ePlayer];
}

/// Sets how many turns it has been since ePlayer asked us not to spy on them
void CvDiplomacyAI::SetPlayerStopSpyingRequestCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	m_paiPlayerStopSpyingRequestCounter[ePlayer] = iValue;
}

/// Changes how many turns it has been since ePlayer asked us not to spy on them
void CvDiplomacyAI::ChangePlayerStopSpyingRequestCounter(PlayerTypes ePlayer, int iChange)
{
	SetPlayerStopSpyingRequestCounter(ePlayer, GetPlayerStopSpyingRequestCounter(ePlayer) + iChange);
}

#if defined(MOD_BALANCE_CORE)
/// How many turns has it been since ePlayer backstabbed us?
short CvDiplomacyAI::GetPlayerBackstabCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerBackstabCounter[ePlayer];
}

/// Sets how many turns it has been since ePlayer backstabbed us
void CvDiplomacyAI::SetPlayerBackstabCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");

	//vassals can't backstab.
	if (iValue == 0 && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		return;

	m_paiPlayerBackstabCounter[ePlayer] = iValue;
}

/// Changes how many turns it has been since ePlayer backstabbed us
void CvDiplomacyAI::ChangePlayerBackstabCounter(PlayerTypes ePlayer, int iChange)
{
	SetPlayerBackstabCounter(ePlayer, GetPlayerBackstabCounter(ePlayer) + iChange);
}
#endif


///////////////////////////////
// Working With Player
///////////////////////////////



/// Is this AI willing to work with ePlayer?
bool CvDiplomacyAI::IsDoFAcceptable(PlayerTypes ePlayer)
{
	// Can't declare friendship with a civ you're at war with
	if(GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()) || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		return false;
	}

	// Haven't known this guy for long enough
	if(IsTooEarlyForDoF(ePlayer))
		return false;

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);

	// If player is planning War, always say no
	if(eApproach == MAJOR_CIV_APPROACH_WAR)
		return false;
	
	// If player is Hostile, always say no
	else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
#if defined(MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
	if(IsDoFBroken(ePlayer))
	{
		//If we've made amends, take away the DoF malus.
		if(eOpinion >= MAJOR_CIV_OPINION_FRIEND)
		{
			SetDoFBroken(ePlayer, false);
		}
		else
		{
			return false;
		}
	}
#endif
	// If player is unforgivable, always say no
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		return false;
	// If player is an enemy, always say no
	else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
		return false;

	// Has there been a denouncement in either direction?
	if(IsDenouncedPlayer(ePlayer))
		return false;
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
		return false;
	
	// If we're willing to denounce them, don't make friends with them!
	if(IsDenounceAcceptable(ePlayer) || IsDenounceFriendAcceptable(ePlayer))
		return false;

	// Are we working AGAINST ePlayer with someone else?
	//if (IsWorkingAgainstPlayer(ePlayer))
	//	return false;

	int iWeight = 0;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	iWeight = GetDoFValue(ePlayer);

	if (ePlayer == GetMostValuableDoF(false))
	{
		iWeight += 10;
	}
	else if (ePlayer == GetMostValuableDoF(true))
	{
		iWeight += 5;
	}
	else
		iWeight -= 5;
#endif

	if(iWeight >= /*32*/ GC.getDOF_THRESHOLD())
		return true;

	return false;
}

/// AI won't agree to a DoF until they've known a player for at least a few turns
bool CvDiplomacyAI::IsTooEarlyForDoF(PlayerTypes ePlayer)
{
	int iDoFBuffer = /*20*/ GC.getDOF_TURN_BUFFER();

	if(GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < iDoFBuffer)
		return true;

	return false;
}

/// Has ePlayer asked to work with us lately?
bool CvDiplomacyAI::IsDoFMessageTooSoon(PlayerTypes ePlayer) const
{
	if(GetDoFCounter(ePlayer) >= 0 &&
	        GetDoFCounter(ePlayer) < /*20*/ GC.getDOF_TURN_BUFFER())
		return true;

#if defined(MOD_BALANCE_CORE)
	if(IsDoFAccepted(ePlayer))
		return true;
#endif

	return false;
}

/// Has ePlayer ever asked about working with us?
bool CvDiplomacyAI::IsDoFEverAsked(PlayerTypes ePlayer) const
{
#if defined(MOD_BALANCE_CORE)
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabDoFEverAsked[ePlayer];
#else
	// Counter set to -1 at start. Gets reset to -666
	if(GetDoFCounter(ePlayer) == -1)
		return false;
	return true;
#endif
}

/// Have we rejected ePlayer's request to work with us?
bool CvDiplomacyAI::IsDoFRejected(PlayerTypes ePlayer) const
{
	// If the counter is -1, it means he hasn't asked
	if(GetDoFCounter(ePlayer) == -1)
		return false;

	// Did the player actually accept?
	if(IsDoFAccepted(ePlayer))
		return false;

	return true;
}

/// Have we accepted ePlayer's request to work with us?
bool CvDiplomacyAI::IsDoFAccepted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabDoFAccepted[ePlayer];
}

/// We made a Declaration of Friendship with someone, handle everything that means
void CvDiplomacyAI::SetDoFAccepted(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsDoFAccepted(ePlayer))
	{
		m_pabDoFAccepted[ePlayer] = bValue;

		m_pPlayer->recomputeGreatPeopleModifiers();

		if(bValue){
			// Someone made a DoF, send out notifications to everyone
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF");
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_S");
			for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
				PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
				CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
				CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
				if(iCurPlayer != ePlayer && iCurPlayer !=GetPlayer()->GetID() && pNotifications){
					const char* strThisPlayerName;
					const char* strOtherPlayerName;

					CvTeam* pCurTeam = &GET_TEAM(kCurPlayer.getTeam());

					// Have we met these guys yet?
					bool bHasMetThisTeam = pCurTeam->isHasMet(GetPlayer()->getTeam());
					if(bHasMetThisTeam)
						strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
					else
						strThisPlayerName = "TXT_KEY_UNMET_PLAYER";

					bool bHasMetOtherTeam = pCurTeam->isHasMet(GET_PLAYER(ePlayer).getTeam());
					if(bHasMetOtherTeam)
						strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
					else
						strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";

					//Only display notification if we've met one of the players.
					if(bHasMetThisTeam || bHasMetOtherTeam){
						Localization::String tempInfoStr = strText;
						tempInfoStr << strThisPlayerName << strOtherPlayerName;
						Localization::String tempSummaryStr = strSummary;
						tempSummaryStr << strThisPlayerName << strOtherPlayerName;
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, tempInfoStr.toUTF8(), tempSummaryStr.toUTF8(), -1, -1, GetPlayer()->GetID(), ePlayer);
					}
				}
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Returns the type of Declaration of Friendship that could potentially be made with this player (based on previous relationship)
DoFLevelTypes CvDiplomacyAI::GetDoFType(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (DoFLevelTypes) m_paeDoFType[ePlayer];
}

/// Sets the future type of Declaration of Friendship that could potentially be made with this player (based on previous relationship)
void CvDiplomacyAI::SetDoFType(PlayerTypes ePlayer, DoFLevelTypes eDoFLevel)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDoFLevel >= 0, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDoFLevel < NUM_DOF_TYPES, "DIPLOMACY_AI: Invalid DisputeLevelType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paeDoFType[ePlayer] = eDoFLevel;
}

/// Returns the number of times ePlayer has denied our requests to start a coop war against another player
int CvDiplomacyAI::GetNumTimesCoopWarDenied(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiNumTimesCoopWarDenied[ePlayer];
}

/// Sets the number of times ePlayer has denied our requests to start a coop war against another player
void CvDiplomacyAI::SetNumTimesCoopWarDenied(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiNumTimesCoopWarDenied[ePlayer] = iValue;
}

/// Changes how many times ePlayer has denied our requests to start a coop war against another player
void CvDiplomacyAI::ChangeNumTimesCoopWarDenied(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		SetNumTimesCoopWarDenied(ePlayer, GetNumTimesCoopWarDenied(ePlayer) + iChange);
	}
}

/// Returns if a Declaration of Friendship with ePlayer has been broken
bool CvDiplomacyAI::IsDoFBroken(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabDoFBroken[ePlayer];
}

/// Our Declaration of Friendship with ePlayer has been broken, handle everything that means
void CvDiplomacyAI::SetDoFBroken(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue)
	{
		m_pabDoFBroken[ePlayer] = bValue;

		// Someone broke a DoF, send out notifications to everyone
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_BROKEN");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DOF_S_BROKEN");
		for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
			PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
			CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
			CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
			if(iCurPlayer != ePlayer && iCurPlayer !=GetPlayer()->GetID() && pNotifications){
				const char* strThisPlayerName;
				const char* strOtherPlayerName;

				CvTeam* pCurTeam = &GET_TEAM(kCurPlayer.getTeam());

				// Have we met these guys yet?
				bool bHasMetThisTeam = pCurTeam->isHasMet(GetPlayer()->getTeam());
				if(bHasMetThisTeam)
					strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
				else
					strThisPlayerName = "TXT_KEY_UNMET_PLAYER";

				bool bHasMetOtherTeam = pCurTeam->isHasMet(GET_PLAYER(ePlayer).getTeam());
				if(bHasMetOtherTeam)
					strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
				else
					strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";

				//Only display notification if we've met one of the players.
				if(bHasMetThisTeam || bHasMetOtherTeam){
					Localization::String tempInfoStr = strText;
					tempInfoStr << strThisPlayerName << strOtherPlayerName;
					Localization::String tempSummaryStr = strSummary;
					tempSummaryStr << strThisPlayerName << strOtherPlayerName;
					pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, tempInfoStr.toUTF8(), tempSummaryStr.toUTF8(), -1, -1, GetPlayer()->GetID(), ePlayer);
				}
			}
		}
	}
}
#endif

/// Returns how many turns we've had a Declaration of Friendship with ePlayer for
short CvDiplomacyAI::GetDoFCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDoFCounter[ePlayer];
}

/// Sets how many turns we've had a Declaration of Friendship with ePlayer for
void CvDiplomacyAI::SetDoFCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiDoFCounter[ePlayer] = iValue;
}

/// Changes how many turns we've had a Declaration of Friendship with ePlayer for
void CvDiplomacyAI::ChangeDoFCounter(PlayerTypes ePlayer, int iChange)
{
	SetDoFCounter(ePlayer, GetDoFCounter(ePlayer) + iChange);
}

/// How many Declarations of Friendship do we currently have with other players?
int CvDiplomacyAI::GetNumDoF()
{
	int iRtnValue = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(IsDoFAccepted(eLoopPlayer))
			{
				iRtnValue++;
			}
		}
	}

	return iRtnValue;
}
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
/// How many Research Agreements do we currently have with other players?
int CvDiplomacyAI::GetNumRA()
{
	int iRtnValue = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				iRtnValue++;
			}
		}
	}

	return iRtnValue;
}

/// How many Defensive Pacts do we currently have with other players?
int CvDiplomacyAI::GetNumDefensePacts()
{
	int iRtnValue = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(eLoopPlayer).getTeam()))
			{
				iRtnValue++;
			}
		}
	}

	return iRtnValue;
}
#endif
#if defined(MOD_BALANCE_CORE)
void CvDiplomacyAI::SetNoExpansionPromiseClosestCities(PlayerTypes eOtherPlayer, pair<int,int> value)
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paNoExpansionPromise[eOtherPlayer] = value;
}
pair<int,int> CvDiplomacyAI::GetNoExpansionPromiseClosestCities(PlayerTypes eOtherPlayer)
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paNoExpansionPromise[eOtherPlayer];
}
void CvDiplomacyAI::SetLastTurnClosestCityPair(PlayerTypes eOtherPlayer, pair<int,int> value)
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paLastTurnEmpireDistance[eOtherPlayer] = value;
}
pair<int,int> CvDiplomacyAI::GetLastTurnClosestCityPair(PlayerTypes eOtherPlayer)
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paLastTurnEmpireDistance[eOtherPlayer];
}

/// How many players have we currently denounced?
int CvDiplomacyAI::GetNumDenouncements()
{
	//Let's get the total number of denouncements this player has made.
	int iRtnValue = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).isMinorCiv() && !GET_PLAYER(eLoopPlayer).isBarbarian() && m_pPlayer->GetID() != eLoopPlayer)
		{
			if(IsDenouncedPlayer(eLoopPlayer))
			{
				iRtnValue++;
			}
		}
	}

	return iRtnValue;
}

/// How many players have denounced US?
int CvDiplomacyAI::GetNumDenouncementsOfPlayer()
{
	//Let's get the total number of denouncements on this player.
	int iRtnValue = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer) && !GET_PLAYER(eLoopPlayer).isMinorCiv() && !GET_PLAYER(eLoopPlayer).isBarbarian() && m_pPlayer->GetID() != eLoopPlayer)
		{
			if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsDenouncedPlayer(m_pPlayer->GetID()))
			{
				iRtnValue++;
			}
		}
	}

	return iRtnValue;
}

/// Do we have similar or divergent Social Policies?
int CvDiplomacyAI::GetNumSamePolicies(PlayerTypes ePlayer)
{
	int iNumSame = 0;
	int iNumDifferent = 0;
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyBranchInfos(); iPolicyLoop++)
	{
		PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes)iPolicyLoop;
		if(ePolicyBranch != NO_POLICY_BRANCH_TYPE)
		{
			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);
			if(pkPolicyBranchInfo == NULL)
			{
				continue;
			}
			//No ideologies.
			if(pkPolicyBranchInfo->IsPurchaseByLevel())
			{
				continue;
			}

			//We have it and they don't?
			if(GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && !GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumDifferent++;
			}
			//They have it and we don't?
			else if(!GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumDifferent++;
			}
			//We both have it?
			else if(GetPlayer()->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch) && GET_PLAYER(ePlayer).GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))
			{
				iNumSame++;
			}
		}
	}
	return(iNumSame - iNumDifferent);
}
#endif

/// Are we done with ePlayer, and now want to Denounce him?
bool CvDiplomacyAI::IsDenounceFriendAcceptable(PlayerTypes ePlayer)
{
	// Changed our approach towards ePlayer
	MajorCivApproachTypes eTrueApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE || eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return true;

	// If we're enemies or unforgivable then we have no need to work with this guy any more
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
	if(eOpinion <= MAJOR_CIV_OPINION_ENEMY)
		return true;
	if(eOpinion >= MAJOR_CIV_OPINION_FAVORABLE)
		return false;

	int iChance = 10 + GetLoyalty();
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if(MOD_DIPLOMACY_CIV4_FEATURES && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(m_pPlayer->getTeam()))
	{
		return false;
	}
	if(MOD_DIPLOMACY_CIV4_FEATURES && GET_TEAM(m_pPlayer->getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
	{
		return false;
	}
#endif

	// If we've worked together for at least 30 turns, and are competitors, there's a chance we break things off (based on Loyalty)
	if(eOpinion <= MAJOR_CIV_OPINION_COMPETITOR)
	{
		iChance -= GetLoyalty();
	}
	if (GetWarmongerThreat(ePlayer) >= THREAT_SEVERE)
		iChance -= GetWarmongerHate();

	if (GetVictoryBlockLevel(ePlayer) >= BLOCK_LEVEL_STRONG)
		iChance -= GetVictoryCompetitiveness();

	if (GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
		iChance -= GetVictoryCompetitiveness();

	// Going for conquest, and they're weak and close
	if(IsGoingForWorldConquest())
	{
		if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_POOR)
		{
			if(GetPlayer()->GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE)
				iChance -= GetMeanness();
		}
	}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
	DoFLevelTypes eDoFLevel = GetDoFType(ePlayer);
	DoFLevelTypes eDoFLevel2 = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDoFType(GetPlayer()->GetID());
	if(eDoFLevel == DOF_TYPE_BATTLE_BROTHERS || eDoFLevel2 == DOF_TYPE_BATTLE_BROTHERS)
	{
		return false;
	}
	else if(eDoFLevel == DOF_TYPE_ALLIES || eDoFLevel2 == DOF_TYPE_ALLIES)
	{
		iChance += 5;
	}
	else if (eDoFLevel == DOF_TYPE_FRIENDS || eDoFLevel2 == DOF_TYPE_FRIENDS)
	{
		iChance += 2;
	}
#endif
	if (iChance <= 0)
		return true;

	return false;
}

/// Does ePlayer have a DoF with anyone we have a DoF with?
bool CvDiplomacyAI::IsPlayerDoFwithAnyFriend(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;		

		if(IsDoFAccepted(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
			return true;
	}

	return false;
}

/// Does ePlayer have a DoF with anyone we have denounced?
bool CvDiplomacyAI::IsPlayerDoFwithAnyEnemy(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;

		if(IsDenouncedPlayer(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
			return true;
	}

	return false;
}

/// Does ePlayer have a Defensive Pact with anyone we also have a DP with?
bool CvDiplomacyAI::IsPlayerDPWithAnyFriend(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;
		
		if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).IsHasDefensivePact(GetPlayer()->getTeam()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eLoopPlayer).getTeam()))
			return true;
	}
	
	return false;
}

/// Does ePlayer have a Defensive Pact with any enemy we have denounced?
bool CvDiplomacyAI::IsPlayerDPWithAnyEnemy(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;		
		
		if(IsDenouncedPlayer(eLoopPlayer) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GET_PLAYER(eLoopPlayer).getTeam()))
			return true;
	}
	
	return false;
}

///////////////////////////////
// Ideology
///////////////////////////////

/// Does ePlayer have the same ideology that we do?
bool CvDiplomacyAI::IsPlayerSameIdeology(PlayerTypes ePlayer) const
{
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE)
	{
		if(eMyBranch == eTheirBranch)
		{
			return true;
		}
	}
	
	return false;
}

/// Does ePlayer have an ideology that opposes ours?
bool CvDiplomacyAI::IsPlayerOpposingIdeology(PlayerTypes ePlayer) const
{
	PolicyBranchTypes eMyBranch = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirBranch = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree();
	if(eMyBranch != NO_POLICY_BRANCH_TYPE && eTheirBranch != NO_POLICY_BRANCH_TYPE)
	{
		if(eMyBranch != eTheirBranch)
		{
			return true;
		}
	}
	
	return false;
}


///////////////////////////////
// Denounce Player
///////////////////////////////

/// Denounces a player
void CvDiplomacyAI::DoDenouncePlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PlayerTypes eMyPlayer = GetPlayer()->GetID();
	TeamTypes eMyTeam = GetPlayer()->getTeam();
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();

	SetDenouncedPlayer(ePlayer, true);
	SetDenouncedPlayerCounter(ePlayer, 0);
	
	// If their guess of our approach towards them isn't already WAR, assume HOSTILE
	if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->GetTrueApproachTowardsUsGuess(eMyPlayer) != MAJOR_CIV_APPROACH_WAR)
	{
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(eMyPlayer, MAJOR_CIV_APPROACH_HOSTILE);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(eMyPlayer, 0);
	}

	// close both embassies
	GET_TEAM(eMyTeam).CloseEmbassyAtTeam(eTheirTeam);
	GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(eMyTeam);
	
	// End all coop war agreements with this player
	PlayerTypes eThirdParty;
	for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
	{
		eThirdParty = (PlayerTypes) iThirdPartyLoop;
		
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		// Did we break a coop war promise?
		if(GetCoopWarAcceptedState(ePlayer, eThirdParty) == COOP_WAR_STATE_SOON)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBrokenCoopWarPromise(eMyPlayer, true);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerBackstabCounter(eMyPlayer, 0);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumTimesCoopWarDenied(eMyPlayer, 2);
		}
#endif

		// WAS in or planning a coop war with the guy who's now denounced us
		if(GetCoopWarAcceptedState(ePlayer, eThirdParty) >= COOP_WAR_STATE_SOON)
		{
			SetCoopWarAcceptedState(ePlayer, eThirdParty, NO_COOP_WAR_STATE);
			SetCoopWarCounter(ePlayer, eThirdParty, -666);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarAcceptedState(eMyPlayer, eThirdParty, NO_COOP_WAR_STATE);
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetCoopWarCounter(eMyPlayer, eThirdParty, -666);
		}
	}

	// WAS working with this player
	if(IsDoFAccepted(ePlayer))
	{
		SetDoFAccepted(ePlayer, false);
		SetDoFCounter(ePlayer, -666);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFAccepted(eMyPlayer, false);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFCounter(eMyPlayer, -666);
		
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		SetDoFType(ePlayer, DOF_TYPE_UNTRUSTWORTHY);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFType(GetPlayer()->GetID(), DOF_TYPE_UNTRUSTWORTHY);
#endif

		// They now view us as a traitor!
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetFriendDenouncedUs(eMyPlayer, true);
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeRecentAssistValue(eMyPlayer, 300);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetDoFBroken(eMyPlayer, true);
#endif

		GET_TEAM(GET_PLAYER(eMyPlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(ePlayer).getTeam(), false);
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetHasDefensivePact(GET_PLAYER(eMyPlayer).getTeam(), false);
		
		DoUpdateOpinions();
		DoUpdateMajorCivApproaches();
		
		if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR)
		{
			if (GetWarFaceWithPlayer(ePlayer) != WAR_FACE_HOSTILE)
			{
				SetWarFaceWithPlayer(ePlayer, WAR_FACE_GUARDED);
			}
		}
		else if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) != MAJOR_CIV_APPROACH_HOSTILE)
		{
			SetMajorCivApproach(ePlayer, MAJOR_CIV_APPROACH_GUARDED);
		}
		
		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR)
		{
			if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarFaceWithPlayer(eMyPlayer) != WAR_FACE_HOSTILE)
			{
				GET_PLAYER(ePlayer).GetDiplomacyAI()->SetWarFaceWithPlayer(eMyPlayer, WAR_FACE_GUARDED);
			}
		}
		else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer, /*bHideTrueFeelings*/ false) != MAJOR_CIV_APPROACH_HOSTILE)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMajorCivApproach(eMyPlayer, MAJOR_CIV_APPROACH_GUARDED);
		}	
	}
	else
	{
		DoUpdateOpinions();
		DoUpdateMajorCivApproaches();
		
		// We shouldn't be too friendly with them
		if(GetWarFaceWithPlayer(ePlayer) == WAR_FACE_FRIENDLY)
		{
			SetWarFaceWithPlayer(ePlayer, WAR_FACE_NEUTRAL);
		}
		else if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)
		{
			SetMajorCivApproach(ePlayer, MAJOR_CIV_APPROACH_NEUTRAL);
		}
		else if(GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			SetMajorCivApproach(ePlayer, MAJOR_CIV_APPROACH_NEUTRAL);
		}
		
		// They shouldn't be too friendly with us, either
		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWarFaceWithPlayer(eMyPlayer) == WAR_FACE_FRIENDLY)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetWarFaceWithPlayer(eMyPlayer, WAR_FACE_NEUTRAL);
		}
		else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMajorCivApproach(eMyPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
		}
		else if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetMajorCivApproach(eMyPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_FRIENDLY)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetMajorCivApproach(eMyPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
		}
	}

	Localization::String someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE");
#if defined(MOD_BALANCE_CORE)
	int iMessage = GetDenounceMessage(ePlayer);
	if(iMessage > 0 && iMessage <= 7)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_IDEOLOGY");
	}
	else if(iMessage == 8)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_WARMONGER");
	}
	else if(iMessage == 9)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_MINORS");
	}
	else if(iMessage == 10)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_MINORS");
	}
	else if(iMessage == 11)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_NUKED");
	}
	else if(iMessage == 12)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_SPIES");
	}
	else if(iMessage == 13)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_LAND");
	}
	else if(iMessage == 14)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DOF");
	}
	else if(iMessage == 15)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DOGPILE");
	}
	else if(iMessage == 16)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_UNTRUSTWORTHY");
	}
	else if(iMessage == 17)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_UNFORGIVEABLE");
	}
	else if(iMessage == 18)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_FAITH");
	}
	else if(iMessage == 19)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_DIGGING");
	}
	else if(iMessage == 20)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_WONDERS");
	}
	else if(iMessage == 21)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_VICTORY");
	}
	else if(iMessage == 22)
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_VICTORY");
	}
	else
	{
		someoneDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE");
	}
#endif
	Localization::String someoneDenounceSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_S");
	Localization::String youDenounceInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_DENOUNCE");
	Localization::String youDenounceSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_DENOUNCE_S");
	Localization::String denounceYouInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCE_YOU");
	Localization::String denounceYouSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DENOUNCED_YOU_S");
	for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer){
		PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
		CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);
		CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();
		if(pNotifications)
		{
			const char* strThisPlayerName;
			const char* strOtherPlayerName;

			CvTeam* pNotifyTeam = &GET_TEAM(kCurPlayer.getTeam());

			bool bFromMe = GetPlayer()->getTeam() == kCurPlayer.getTeam();
			bool bAtMe = GET_PLAYER(ePlayer).getTeam() == kCurPlayer.getTeam();

			// Have we met these guys yet?
			if(!bFromMe)
			{
				if(pNotifyTeam->isHasMet(GetPlayer()->getTeam()))
					strThisPlayerName = GetPlayer()->getCivilizationShortDescriptionKey();
				else
					strThisPlayerName = "TXT_KEY_UNMET_PLAYER";
			}

			if(!bAtMe)
			{
				if(pNotifyTeam->isHasMet(GET_PLAYER(ePlayer).getTeam()))
					strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();
				else
					strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";
			}

			Localization::String strText;
			Localization::String strSummary;

			if(bFromMe)
			{
				strText = youDenounceInfo;
				strText << strOtherPlayerName;
				strSummary = youDenounceSummary;
				strSummary << strOtherPlayerName;
			}
			else if(bAtMe)
			{
				strText = denounceYouInfo;
				strText << strThisPlayerName;
				strSummary = denounceYouSummary;
				strSummary << strThisPlayerName;
			}
			else
			{
				bool bHasMetThisTeam = pNotifyTeam->isHasMet(GetPlayer()->getTeam());
				bool bHasMetOtherTeam = pNotifyTeam->isHasMet(GET_PLAYER(ePlayer).getTeam());

				//Only display notification if we've met either team.
				if(bHasMetThisTeam || bHasMetOtherTeam)
				{
					strText = someoneDenounceInfo;
					strText << strThisPlayerName << strOtherPlayerName;
					strSummary = someoneDenounceSummary;
					strSummary << strThisPlayerName << strOtherPlayerName;
				}
				else
				{
					continue;
				}
			}

			pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strText.toUTF8(), strSummary.toUTF8(), -1, -1, GetPlayer()->GetID(), ePlayer);
		}
	}
}

/// Does this player feel it's time to denounce ePlayer?
bool CvDiplomacyAI::IsDenounceAcceptable(PlayerTypes ePlayer, bool bBias)
{
	// Can't denounce with a civ you're at war with
	if(GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()) || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))
	{
		return false;
	}

	// If we've already denounced, it's no good
	if(IsDenouncedPlayer(ePlayer))
		return false;

	// If we're friends, return false - this is handled in IsDenounceFriendAcceptable
	if(IsDoFAccepted(ePlayer))
		return false;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if(MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// Do not denounce a vassal of ours 
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() == m_pPlayer->getTeam())
		{
			return false;
		}
	}
#endif

	int iWeight = GetDenounceWeight(ePlayer, bBias);

	if(iWeight > 25)
		return true;

	return false;
}

/// Returns the weight this AI has for denouncing ePlayer
int CvDiplomacyAI::GetDenounceWeight(PlayerTypes ePlayer, bool bBias)
{
	int iWeight = 0;

	// Base Personality value; ranges from 0 to 10 (ish)
	iWeight += GetDenounceWillingness();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Vassal treatment view
	if(MOD_DIPLOMACY_CIV4_FEATURES)
	{
		// This guy is our master
		if(GET_TEAM(m_pPlayer->getTeam()).GetMaster() == GET_PLAYER(ePlayer).getTeam())
		{
			if (GET_TEAM(m_pPlayer->getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam()))
			{
				iWeight += -50;
			}
			VassalTreatmentTypes eVassalTreatment = GetVassalTreatmentLevel(ePlayer);
			// Content vassals have a huge weight against denouncing
			if(eVassalTreatment == VASSAL_TREATMENT_CONTENT)
				iWeight += -50;
			// Disagree? Let's not upset things...
			else if(eVassalTreatment == VASSAL_TREATMENT_DISAGREE)
				iWeight += -15;
			// Mistreated: Small bonus
			else if(eVassalTreatment == VASSAL_TREATMENT_MISTREATED)
				iWeight += 2;
			// Unhappy: Medium bonus
			else if(eVassalTreatment == VASSAL_TREATMENT_UNHAPPY)
				iWeight += 5;
			// Enslaved: Big bonus
			else if(eVassalTreatment == VASSAL_TREATMENT_ENSLAVED)
				iWeight += 10;
		}
		// If this guy is a vassal of someone else, reduce the weight to make us less likely to denounce them
		else if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone() &&
			GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster() != m_pPlayer->getTeam())
		{
			iWeight -= 8;
		}
	}
#endif

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);

	// Hostile: Bonus
	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
		iWeight += 6;
	// Afraid: Penalty
	else if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
		iWeight += -10;
#if defined(MOD_BALANCE_CORE)
	// Let's not upset things
	else if(eApproach == MAJOR_CIV_APPROACH_NEUTRAL)
		iWeight += -8;
	else if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
		iWeight += -15;
	//Slight bump if guarded
	else if(eApproach == MAJOR_CIV_APPROACH_GUARDED)
		iWeight += +1;
	//Do NOT reveal if deceptive
	else if(eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
		iWeight += -25;
#endif

	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// Unforgivable: Big Bonus
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		iWeight += 10;
	// Enemy: Bonus
	else if(eOpinion == MAJOR_CIV_OPINION_ENEMY)
		iWeight += 5;
	// Competitor: Small Bonus
	else if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
		iWeight += 2;
	// Good Relations: Penalty
	else if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
		iWeight += -10;
	else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
		iWeight += -25;
	else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
		iWeight += -50;

	// We are at war
	if(IsAtWar(ePlayer))
		iWeight += 2;

#if defined(MOD_BALANCE_CORE)
	if(GetVictoryDisputeLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iWeight += 4;
	}
	if(GetVictoryBlockLevel(ePlayer) >= DISPUTE_LEVEL_STRONG)
	{
		iWeight += 4;
	}
	if (GetLandDisputeLevel(ePlayer) == DISPUTE_LEVEL_STRONG)
	{
		iWeight += 2;
	}
	else if (GetLandDisputeLevel(ePlayer) == DISPUTE_LEVEL_FIERCE)
	{
		iWeight += 5;
	}
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts() > 0)
	{
		iWeight -= GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumDefensePacts();
	}
	if (WasResurrectedBy(ePlayer))
	{
		iWeight += -20;
	}

	if (GetBiggestCompetitor() == ePlayer)
		iWeight += 10;
#endif

	MajorCivApproachTypes eThirdPartyApproach;

	// Look for other players we like or are strong, and add a bonus if they've denounced this guy, or are at war with him
	PlayerTypes eThirdParty;
	CvDiplomacyAI* pThirdPartyDiplo;
	for(int iThirdParty = 0; iThirdParty < MAX_MAJOR_CIVS; iThirdParty++)
	{
		eThirdParty = (PlayerTypes) iThirdParty;
		pThirdPartyDiplo = GET_PLAYER(eThirdParty).GetDiplomacyAI();

		// War or Denounced ePlayer, so we know eThirdParty doesn't like him
		if(!pThirdPartyDiplo->IsDenouncedPlayer(ePlayer)) // && !pThirdPartyDiplo->IsAtWar(ePlayer))
			continue;

		// We must not be on bad relations with eThirdParty
		if(GetMajorCivOpinion(eThirdParty) <= MAJOR_CIV_OPINION_COMPETITOR)
			continue;

		// If we're hostile or planning war, we don't care about this guy
		eThirdPartyApproach = GetMajorCivApproach(eThirdParty, /*bHideTrueFeelings*/ false);
		if(eThirdPartyApproach == MAJOR_CIV_APPROACH_HOSTILE || eThirdPartyApproach == MAJOR_CIV_APPROACH_WAR)
			continue;

		// We're close to this guy who's at war - want to gain favor
		if(GetPlayer()->GetProximityToPlayer(eThirdParty) == PLAYER_PROXIMITY_NEIGHBORS)
			iWeight += 1;

		// Are they strong?
		if(GetPlayerMilitaryStrengthComparedToUs(eThirdParty) > STRENGTH_AVERAGE)
			iWeight += (GetPlayerMilitaryStrengthComparedToUs(eThirdParty) - STRENGTH_AVERAGE);	// Ex: if they're immense, this will add 3 to the weight

		// Are we friends with them?
		if(IsDoFAccepted(eThirdParty))
			iWeight += 4;
#if defined(MOD_BALANCE_CORE)
		if(GET_TEAM(GET_PLAYER(eThirdParty).getTeam()).IsHasDefensivePact(GetPlayer()->getTeam()))
		{
			iWeight += 3;
		}
#endif
	}

	// Used when friends are asking us to denounce someone
	if(bBias)
		iWeight += 3;

	return iWeight;
}

/// Have we denounced ePlayer?
bool CvDiplomacyAI::IsDenouncedPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabDenouncedPlayer[ePlayer];
}

/// Sets whether we've denounced ePlayer
void CvDiplomacyAI::SetDenouncedPlayer(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsDenouncedPlayer(ePlayer))
	{
		m_pabDenouncedPlayer[ePlayer] = bValue;
#if defined(MOD_BALANCE_CORE)
		m_pPlayer->recomputeGreatPeopleModifiers();
#endif
	}
}

/// Denouncing this turn?
bool CvDiplomacyAI::IsDenouncingPlayer(PlayerTypes ePlayer) const
{
	return (IsDenouncedPlayer(ePlayer) && GetDenouncedPlayerCounter(ePlayer) == 1);
}

/// How many turns has it been since we denounced ePlayer?
short CvDiplomacyAI::GetDenouncedPlayerCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiDenouncedPlayerCounter[ePlayer];
}

/// Sets how many turns it has been since we denounced ePlayer
void CvDiplomacyAI::SetDenouncedPlayerCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiDenouncedPlayerCounter[ePlayer] = iValue;
}

/// Changes how many turns it has been since we denounced ePlayer
void CvDiplomacyAI::ChangeDenouncedPlayerCounter(PlayerTypes ePlayer, int iChange)
{
	SetDenouncedPlayerCounter(ePlayer, GetDenouncedPlayerCounter(ePlayer) + iChange);
}

/// Has this player denounced someone we have a DoF with?
bool CvDiplomacyAI::IsPlayerDenouncedFriend(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;

		if(IsDoFAccepted(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
			return true;
	}

	return false;
}

/// Has this player denounced someone we've also denounced?
bool CvDiplomacyAI::IsPlayerDenouncedEnemy(PlayerTypes ePlayer) const
{
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (!GET_PLAYER(ePlayer).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			continue;

		if(IsDenouncedPlayer(eLoopPlayer) && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer))
			return true;
	}

	return false;
}



///////////////////////////////
// Requests of Friends
///////////////////////////////


/// Does this AI want to request that ePlayer denounce someone?
PlayerTypes CvDiplomacyAI::GetRequestFriendToDenounce(PlayerTypes ePlayer, bool& bRandFailed)
{
	bRandFailed = false;

	// Must be friends with ePlayer
	if(!IsDoFAccepted(ePlayer))
		return NO_PLAYER;

	PlayerTypes eTarget = NO_PLAYER;

	int iWeight;

	int iBestWeight = -1;

	CvDiplomacyAI* pTheirAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
	CvTeam* pTheirTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	PlayerTypes eLoopPlayer;
	CvPlayer* pLoopPlayer;
	TeamTypes eLoopTeam;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		pLoopPlayer = &GET_PLAYER(eLoopPlayer);
		eLoopTeam = pLoopPlayer->getTeam();

		// Must be alive
		if(!pLoopPlayer->isAlive())
			continue;

		// Can't be either of us
		if(eLoopPlayer == GetPlayer()->GetID() || eLoopPlayer == ePlayer)
			continue;

		// Don't pick someone they haven't met
		if(!pTheirTeam->isHasMet(eLoopTeam))
			continue;

		// Don't pick someone they're at war with
		if(pTheirTeam->isAtWar(eLoopTeam))
			continue;

		// Don't pick someone they've already denounced
		if(pTheirAI->IsDenouncedPlayer(eLoopPlayer))
			continue;

		// Only look at players we've denounced, or at war with
		if(!IsAtWar(eLoopPlayer) && !IsDenouncedPlayer(eLoopPlayer))
			continue;

		// Rand roll
		iWeight = GetDenounceWeight(ePlayer, /*bBias*/ false);

		iWeight += GetNeediness();		// Generally ranges from 3 to 7

		if(iWeight >= 23 && iWeight > iBestWeight)
		{
			iBestWeight = iWeight;

			eTarget = eLoopPlayer;
			bRandFailed = false;		// Set this here as well, because we could have failed a roll on another player, and then succeeded on a later one
		}
		else
			bRandFailed = true;
	}

	return eTarget;
}

/// Are we upset that our friend ePlayer refused our request to denounce eAgainstPlayer?
bool CvDiplomacyAI::IsFriendDenounceRefusalUnacceptable(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer)
{
	ePlayer;
	eAgainstPlayer;

	// Rand roll
	int iDesire = GetDenounceWeight(eAgainstPlayer, /*bBias*/ false);
	iDesire += GetNeediness();		// Generally ranges from 3 to 7
	iDesire -= GetForgiveness();	// Generally ranges from 3 to 7

	if(iDesire >= 23)	//  Note: 23 is required to even ask (see function above this one)
		return true;

	return false;
}



///////////////////////////////
// Problems between Friends
///////////////////////////////



/// Has this guy had problems with too many of his friends? If so, then his word isn't worth much
bool CvDiplomacyAI::IsUntrustworthyFriend(PlayerTypes ePlayer) const
{
	// Vassals can't be untrustworthy, they have no rights.
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		return false;
	
	// Did you backstab US????
	if (IsFriendDenouncedUs(ePlayer) || IsFriendDeclaredWarOnUs(ePlayer) || IsPlayerBrokenMilitaryPromise(ePlayer) || IsPlayerBrokenAttackCityStatePromise(ePlayer))
		return true;
	
	// Stole our capital/Holy City? Unless we're your vassal, we don't care about anything you have to say...
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (!IsVassal(ePlayer) && (IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer)))
#else
	if (IsCapitalCapturedBy(ePlayer) || IsHolyCityCapturedBy(ePlayer))
#endif
	{
		return true;
	}

	// If you've DoWed any friends, you're a bad person
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWeDeclaredWarOnFriendCount() > 0)
		return true;

	// If you've denounced at least 2 of your friends, you're the problem
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWeDenouncedFriendCount() >= 2)
		return true;
	
#if defined(MOD_BALANCE_CORE)
	// We don't trust you if you broke our DoF (and we haven't made amends).
	if (IsDoFBroken(ePlayer))
		return true;
#endif

	return false;
}

/// How many former friends have denounced US???
int CvDiplomacyAI::GetNumFriendsDenouncedBy()
{
	int iNum = 0;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsFriendDenouncedUs(eLoopPlayer))
			iNum++;
	}

	return iNum;
}

/// Did this player denounce us while we had a DoF?
bool CvDiplomacyAI::IsFriendDenouncedUs(PlayerTypes ePlayer) const
{
	if (ePlayer == BARBARIAN_PLAYER || GetPlayer()->isBarbarian())
		return false;
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return false;

	//vassals can't be untrustworthy, they have no rights.
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		return false;

	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabFriendDenouncedUs[ePlayer];
}

/// Sets if this player denounced us while we had a DoF
void CvDiplomacyAI::SetFriendDenouncedUs(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return;

	if(bValue != IsFriendDenouncedUs(ePlayer))
	{
		m_pabFriendDenouncedUs[ePlayer] = bValue;
	}
}

/// How many friends have WE denounced?
int CvDiplomacyAI::GetWeDenouncedFriendCount()
{
	int iNum = 0;

	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDenouncedUs(eMyPlayer))
			iNum++;
	}

	return iNum;
}

/// Did this player declare war on us while we had a DoF?
bool CvDiplomacyAI::IsFriendDeclaredWarOnUs(PlayerTypes ePlayer) const
{
	if (ePlayer == BARBARIAN_PLAYER || GetPlayer()->isBarbarian())
		return false;
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return false;

	//vassals can't be untrustworthy, they have no rights.
	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
		return false;

	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabFriendDeclaredWarOnUs[ePlayer];
}

/// Sets if this player declared war on us while we had a DoF
void CvDiplomacyAI::SetFriendDeclaredWarOnUs(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return;

	if(bValue != IsFriendDeclaredWarOnUs(ePlayer))
	{
		m_pabFriendDeclaredWarOnUs[ePlayer] = bValue;
	}
}

/// How many friends have WE Declared War on?
int CvDiplomacyAI::GetWeDeclaredWarOnFriendCount()
{
	int iNum = 0;

	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDeclaredWarOnUs(eMyPlayer))
			iNum++;
	}

	return iNum;
}

///////////////////////////////
// Working Against Player
///////////////////////////////



/// Do we want to work against anyone with ePlayer?
//bool CvDiplomacyAI::DoTestWorkingAgainstPlayersDesire(PlayerTypes ePlayer, PlayerTypes &eChosenAgainstPlayer)
//{
//	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
//
//	// If player is planning War, always say no
//	if (eApproach == MAJOR_CIV_APPROACH_WAR)
//		return false;
//	// If player is Hostile, always say no
//	else if (eApproach == MAJOR_CIV_APPROACH_HOSTILE)
//		return false;
//
//	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);
//
//	// If player is unforgivable, always say no
//	if (eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
//		return false;
//	// If player is an enemy, always say no
//	//else if (eOpinion == MAJOR_CIV_OPINION_ENEMY)
//	//	return false;
//
//	PlayerTypes eBestPlayer = NO_PLAYER;
//	int iBestPlayerScore = 0;
//
//	CvTeam* pOtherTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());
//
//	int iTempScore;
//
//	// Loop through all players to see if we can find a good target
//	PlayerTypes eAgainstPlayerLoop;
//	for (int iAgainstPlayerLoop = 0; iAgainstPlayerLoop < MAX_MAJOR_CIVS; iAgainstPlayerLoop++)
//	{
//		eAgainstPlayerLoop = (PlayerTypes) iAgainstPlayerLoop;
//
//		// Player must be valid
//		if (!IsPlayerValid(eAgainstPlayerLoop))
//			continue;
//
//		// Don't test player against himself
//		if (eAgainstPlayerLoop == ePlayer)
//			continue;
//
//		// Players must have met one another
//		if (!pOtherTeam->isHasMet(GET_PLAYER(eAgainstPlayerLoop).getTeam()))
//			continue;
//
//		// Have we already made the agreement?
//		if (IsWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayerLoop))
//			continue;
//
//		// 15 turn buffer if we've been rejected before
//		if (GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayerLoop) >= 0 && GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayerLoop) < 15)
//			continue;
//
//		iTempScore = GetWorkingAgainstPlayerAcceptableScore(ePlayer, eAgainstPlayerLoop, /*bAskedByPlayer*/ false);
//
//		if (iTempScore > iBestPlayerScore)
//		{
//			iBestPlayerScore = iTempScore;
//			eBestPlayer = eAgainstPlayerLoop;
//		}
//	}
//
//	// Found someone?
//	if (eBestPlayer != NO_PLAYER)
//	{
//		eChosenAgainstPlayer = eBestPlayer;
//		return true;
//	}
//
//	return false;
//}
//
///// Is this AI willing to work Against ePlayer?
//int CvDiplomacyAI::GetWorkingAgainstPlayerAcceptableScore(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, bool bAskedByPlayer)
//{
//	MajorCivApproachTypes eApproachTowardsPlayer = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
//	MajorCivOpinionTypes eOpinionTowardsPlayer = GetMajorCivOpinion(ePlayer);
//	MajorCivOpinionTypes eOpinionTowardsAgainst = GetMajorCivOpinion(eAgainstPlayer);
//
//	// If player is planning War, always say no
//	if (eApproachTowardsPlayer == MAJOR_CIV_APPROACH_WAR)
//		return 0;
//	// If player is Hostile, always say no
//	else if (eApproachTowardsPlayer == MAJOR_CIV_APPROACH_HOSTILE)
//		return 0;
//
//	// If player is unforgivable, always say no
//	if (eOpinionTowardsPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)
//		return 0;
//	// If player is an enemy, always say no
//	else if (eOpinionTowardsPlayer == MAJOR_CIV_OPINION_ENEMY)
//		return 0;
//
//	// Are we working AGAINST ePlayer with someone else?
//	if (IsWorkingAgainstPlayer(ePlayer))
//		return 0;
//
//	// Only players we've met, are alive, etc.
//	if (!IsPlayerValid(eAgainstPlayer))
//		return 0;
//
//	// Don't work against people we're working WITH!
//	if (IsDoFAccepted(eAgainstPlayer))
//		return 0;
//
//	int iWeight = 0;
//
//	// ePlayer asked us, so if we like him we're more likely to accept
//	if (bAskedByPlayer)
//	{
//		if (eApproachTowardsPlayer == MAJOR_CIV_APPROACH_FRIENDLY)
//			iWeight += 2;
//		else if (eOpinionTowardsPlayer <= MAJOR_CIV_OPINION_FAVORABLE)
//			iWeight += 2;
//	}
//
//	// Weight for Approach
//	//if (eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
//	//	iWeight += 3;
//	//else if (eApproach == MAJOR_CIV_APPROACH_GUARDED)
//	//	iWeight += -1;
//	//else if (eApproach == MAJOR_CIV_APPROACH_FRIENDLY)
//	//	iWeight += 3;
//
//	// Weight for Opinion
//	if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_UNFORGIVABLE)
//		iWeight += 10;
//	else if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_ENEMY)
//		iWeight += 7;
//	else if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_COMPETITOR)
//		iWeight += 4;
//	else if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_FAVORABLE)
//		iWeight += -1;
//	else if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_FRIEND)
//		iWeight += -5;
//	else if (eOpinionTowardsAgainst == MAJOR_CIV_OPINION_ALLY)
//		iWeight += -10;
//
//	// If we're working with ePlayer then increase weight (if we're already willing to work against this guy)
//	if (iWeight > 0 && IsDoFAccepted(ePlayer))
//		iWeight += 2;
//
//	// Base Personality value; ranges from 0 to 10 (ish)
//	iWeight += GetDenounceWillingness();
//
//	// Rand
//	iWeight += GC.getGame().getJonRandNum(5, "Diplomacy AI: Rand for whether AI wants to work Against player");
//
//	// Weight must be high enough for us to return a true desire
//	if (iWeight >= 12)
//		return iWeight;
//
//	return 0;
//}
//
///// Has ePlayer asked to work Against eAgainstPlayer lately?
//bool CvDiplomacyAI::IsWorkingAgainstPlayerMessageTooSoon(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer) const
//{
//	if (GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) >= 0 &&
//		GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) < 30)
//		return true;
//
//	return false;
//}
//
///// Has ePlayer ever asked about working Against us?
//bool CvDiplomacyAI::IsWorkingAgainstPlayerEverAsked(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer) const
//{
//	// Counter set to -1 at start. Gets reset to -666
//	if (GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) == -1)
//		return false;
//
//	return true;
//}
//
//bool CvDiplomacyAI::IsWorkingAgainstPlayerRejected(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer) const
//{
//	// If the counter is -1, it means he hasn't asked
//	if (GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) == -1)
//		return false;
//
//	// Did the player actually accept?
//	if (IsWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayer))
//		return false;
//
//	return true;
//}
//
//bool CvDiplomacyAI::IsWorkingAgainstPlayerAccepted(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer) const
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	return m_ppaabWorkingAgainstPlayerAccepted[ePlayer][eAgainstPlayer];
//}
//
//void CvDiplomacyAI::SetWorkingAgainstPlayerAccepted(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, bool bValue)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	if (bValue != IsWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayer))
//	{
//		m_ppaabWorkingAgainstPlayerAccepted[ePlayer][eAgainstPlayer] = bValue;
//	}
//}
//
//short CvDiplomacyAI::GetWorkingAgainstPlayerCounter(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer) const
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	return m_ppaaiWorkingAgainstPlayerCounter[ePlayer][eAgainstPlayer];
//}
//
//void CvDiplomacyAI::SetWorkingAgainstPlayerCounter(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, int iValue)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eAgainstPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	m_ppaaiWorkingAgainstPlayerCounter[ePlayer][eAgainstPlayer] = iValue;
//}
//
//void CvDiplomacyAI::ChangeWorkingAgainstPlayerCounter(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, int iChange)
//{
//	SetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer, GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) + iChange);
//}
//
///// Are we done working with anyone against someone else?
//bool CvDiplomacyAI::DoTestContinueWorkingAgainstPlayersDesire(PlayerTypes ePlayer, PlayerTypes &eAgainstPlayer)
//{
//	// Loop through all players to see if we can find a good target
//	PlayerTypes eAgainstPlayerLoop;
//	for (int iAgainstPlayerLoop = 0; iAgainstPlayerLoop < MAX_MAJOR_CIVS; iAgainstPlayerLoop++)
//	{
//		eAgainstPlayerLoop = (PlayerTypes) iAgainstPlayerLoop;
//
//		if (IsWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayerLoop))
//		{
//			if (!IsContinueWorkingAgainstPlayer(ePlayer, eAgainstPlayerLoop))
//			{
//				eAgainstPlayer = eAgainstPlayerLoop;
//				return false;
//			}
//		}
//	}
//
//	return true;
//}
//
///// Do we want to continue working Against ePlayer?
//bool CvDiplomacyAI::IsContinueWorkingAgainstPlayer(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer)
//{
//	CvAssertMsg(IsWorkingAgainstPlayerAccepted(ePlayer, eAgainstPlayer), "Diplomacy AI: Testing whether we should continue working Against a player, but we aren't right now. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//
//	// If this guy is dead, don't get out of the agreement, as that looks weird
//	if (!GET_PLAYER(eAgainstPlayer).isAlive())
//		return true;
//
//	MajorCivApproachTypes eApproachTowardsPlayer = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
//	MajorCivOpinionTypes eOpinionTowardsPlayer = GetMajorCivOpinion(ePlayer);
//	MajorCivApproachTypes eApproachTowardsAgainst = GetMajorCivApproach(eAgainstPlayer, /*bHideTrueFeelings*/ false);
//	MajorCivOpinionTypes eOpinionTowardsAgainst = GetMajorCivOpinion(eAgainstPlayer);
//
//	// Locked in for at least 20 turns
//	if (GetWorkingAgainstPlayerCounter(ePlayer, eAgainstPlayer) < 20)
//		return true;
//
//	// If we're enemies or unforgivable then we're done working with this guy
//	if (eOpinionTowardsPlayer <= MAJOR_CIV_OPINION_ENEMY)
//		return false;
//
//	// Changed our approach towards ePlayer
//	if (eApproachTowardsPlayer == MAJOR_CIV_APPROACH_HOSTILE ||
//		GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_HOSTILE)
//		return false;
//
//	// If we've decided we like the guy now, we're done
//	if (eApproachTowardsAgainst == MAJOR_CIV_APPROACH_FRIENDLY)
//		return false;
//
//	if (eOpinionTowardsAgainst >= MAJOR_CIV_OPINION_FRIEND)
//		return false;
//
//	// If we've worked together for at least 20 turns, and are competitors, there's a chance we break things off
//	//if (GetWorkingAgainstPlayerCounter(ePlayer) > 20)
//	//{
//	//	if (eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
//	//	{
//	//		int iChance = 10 - GetDenounceWillingness();
//	//		int iRand = GC.getGame().getJonRandNum(100, "Diplomacy AI: Rand for whether AI wants to work Against player");
//
//	//		if (iRand < iChance)
//	//			return false;
//	//	}
//	//}
//
//	return true;
//}
//
///// Check everyone we know to see if we're working with them against ePlayer
//bool CvDiplomacyAI::IsWorkingAgainstPlayer(PlayerTypes ePlayer)
//{
//	PlayerTypes eLoopPlayer;
//	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
//	{
//		eLoopPlayer = (PlayerTypes) iPlayerLoop;
//
//		if (IsPlayerValid(eLoopPlayer))
//		{
//			if (IsWorkingAgainstPlayerAccepted(eLoopPlayer, ePlayer))
//				return true;
//		}
//	}
//
//	return false;
//}



/////////////////////////////////////////////////////////
// A Player's adherence to this AI's statements
/////////////////////////////////////////////////////////


/// Tests if any promises were broken or expired since last turn
void CvDiplomacyAI::DoTestPromises()
{
	AggressivePostureTypes eOldPosture;

	// Loop through all (known) Majors
	PlayerTypes eLoopPlayer;
	TeamTypes eLoopTeam;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

		if(IsPlayerValid(eLoopPlayer))
		{
			// Military Promise
			if(IsPlayerMadeMilitaryPromise(eLoopPlayer))
			{
				ChangePlayerMilitaryPromiseCounter(eLoopPlayer, 1);

				// Expired?
				if (GetPlayerMilitaryPromiseCounter(eLoopPlayer) >= /*20*/ GC.getMOVE_TROOPS_MEMORY_TURN_EXPIRATION())
				{
					SetPlayerMadeMilitaryPromise(eLoopPlayer, false);
					SetPlayerMilitaryPromiseCounter(eLoopPlayer, -1);
				}
			}

			// Expansion Promise
			if(IsPlayerMadeExpansionPromise(eLoopPlayer))
			{
				eOldPosture = GetPlayerExpansionPromiseData(eLoopPlayer);

				// Player has been up to no good since we last warned him
#if defined(MOD_BALANCE_CORE)
				if((eOldPosture != NO_AGGRESSIVE_POSTURE_TYPE) && (GetExpansionAggressivePosture(eLoopPlayer) > eOldPosture))
#else
				if(GetExpansionAggressivePosture(eLoopPlayer) > eOldPosture)
#endif
				{
					if (!IsPlayerBrokenExpansionPromise(eLoopPlayer))
					{
						SetBrokenExpansionPromiseValue(eLoopPlayer, GC.getOPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
						SetPlayerBrokenExpansionPromise(eLoopPlayer, true);
					}
				}
			}
			else if (IsPlayerMadeExpansionPromise(eLoopPlayer, GC.getGame().getGameTurn() - 1)) // if the expansion promise expired last turn, announce it
			{
				// fire off notification that promise has expired
				CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_EXPANSION_PROMISE_EXPIRED", GET_PLAYER(GetPlayer()->GetID()).getCivilizationShortDescriptionKey());
					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_EXPANSION_PROMISE_EXPIRED_S");
					pNotifications->Add(NOTIFICATION_EXPANSION_PROMISE_EXPIRED, strBuffer, strSummary, -1, -1, GetPlayer()->GetID(), eLoopPlayer);
				}
				SetPlayerMadeExpansionPromise(eLoopPlayer, false);
			}

			// Border Promise
			if(IsPlayerMadeBorderPromise(eLoopPlayer))
			{
				eOldPosture = GetPlayerBorderPromiseData(eLoopPlayer);

				// Player has been up to no good since we last warned him
#if defined(MOD_BALANCE_CORE)
				if((eOldPosture != NO_AGGRESSIVE_POSTURE_TYPE) && (GetPlotBuyingAggressivePosture(eLoopPlayer) > eOldPosture))
#else
				if(GetPlotBuyingAggressivePosture(eLoopPlayer) > eOldPosture)
#endif
				{
					if (!IsPlayerBrokenBorderPromise(eLoopPlayer))
					{
						SetBrokenBorderPromiseValue(eLoopPlayer, GC.getOPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
						SetPlayerBrokenBorderPromise(eLoopPlayer, true);
					}
				}
			}
			else if (IsPlayerMadeBorderPromise(eLoopPlayer, GC.getGame().getGameTurn() - 1)) // if the border promise expired last turn, announce it
			{
				// fire off notification that promise has expired
				CvNotifications* pNotifications = GET_PLAYER(eLoopPlayer).GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BORDER_PROMISE_EXPIRED", GET_PLAYER(GetPlayer()->GetID()).getCivilizationShortDescriptionKey());
					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_BORDER_PROMISE_EXPIRED_S");
					pNotifications->Add(NOTIFICATION_BORDER_PROMISE_EXPIRED, strBuffer, strSummary, -1, -1, GetPlayer()->GetID(), eLoopPlayer);
				}
#if defined(MOD_BALANCE_CORE)
				SetPlayerMadeBorderPromise(eLoopPlayer, false);
#endif
			}
		}
	}
}

#if defined(MOD_BALANCE_CORE)
/// Return the number of turns since ePlayer has made a military promise to us
int CvDiplomacyAI::GetPlayerMadeMilitaryPromise(PlayerTypes ePlayer)
{
	// Did they make a military promise?
	if (!IsPlayerMadeMilitaryPromise(ePlayer))
	{
		return -1;
	}
	// this promise does not scale with gamespeed!
	return std::max(/*20*/GC.getMOVE_TROOPS_MEMORY_TURN_EXPIRATION() - GetPlayerMilitaryPromiseCounter(ePlayer), 0);
}
#endif

/// Did ePlayer make a military promise to us?
bool CvDiplomacyAI::IsPlayerMadeMilitaryPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerMadeMilitaryPromise[ePlayer];
}

/// Sets if ePlayer made a military promise to us
void CvDiplomacyAI::SetPlayerMadeMilitaryPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerMadeMilitaryPromise[ePlayer] = bValue;
}

/// Did ePlayer break a military promise to us?
bool CvDiplomacyAI::IsPlayerBrokenMilitaryPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return false;
	
	return m_pabPlayerBrokenMilitaryPromise[ePlayer];
}

/// Sets if ePlayer broke a military promise to us
void CvDiplomacyAI::SetPlayerBrokenMilitaryPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return;
	
	m_pabPlayerBrokenMilitaryPromise[ePlayer] = bValue;

	if(bValue)
	{
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetBrokenMilitaryPromise(true);
	}
}

/// Did ePlayer ignore our request to make a military promise?
bool CvDiplomacyAI::IsPlayerIgnoredMilitaryPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerIgnoredMilitaryPromise[ePlayer];
}

/// Sets if ePlayer ignored our request to make a military promise
void CvDiplomacyAI::SetPlayerIgnoredMilitaryPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerIgnoredMilitaryPromise[ePlayer] = bValue;
}

/// How long has it been since ePlayer made a military promise to us?
short CvDiplomacyAI::GetPlayerMilitaryPromiseCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerMilitaryPromiseCounter[ePlayer];
}

/// Sets how long it has been since ePlayer made a military promise to us
void CvDiplomacyAI::SetPlayerMilitaryPromiseCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiPlayerMilitaryPromiseCounter[ePlayer] = iValue;
}

/// Changes how long it has been since ePlayer made a military promise to us
void CvDiplomacyAI::ChangePlayerMilitaryPromiseCounter(PlayerTypes ePlayer, int iChange)
{
	SetPlayerMilitaryPromiseCounter(ePlayer, GetPlayerMilitaryPromiseCounter(ePlayer) + iChange);
}
#if defined(MOD_BALANCE_CORE)
/// Return the number of turns since ePlayer has made an expansion promise to us
int CvDiplomacyAI::GetPlayerMadeExpansionPromise(PlayerTypes ePlayer) const
{
	if(!IsPlayerMadeExpansionPromise(ePlayer))
	{
		return -1;
	}
	int iGameTurn;
	iGameTurn = GC.getGame().getGameTurn();

	int iTurnDifference = iGameTurn - m_paiPlayerMadeExpansionPromiseTurn[ePlayer];
	int iTimeOutTurns = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;
	
	int iValue = (iTimeOutTurns - iTurnDifference);
	if(iValue > 0)
	{
		return iValue;
	}
	return -1;
}
#endif

/// Did ePlayer make an expansion promise to us?
bool CvDiplomacyAI::IsPlayerMadeExpansionPromise(PlayerTypes ePlayer, int iTestGameTurn) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (m_paiPlayerMadeExpansionPromiseTurn[ePlayer] < 0)
	{
		return false;
	}

	int iGameTurn;
	if (iTestGameTurn != -1)
	{
		iGameTurn = iTestGameTurn;
	}
	else
	{
		iGameTurn = GC.getGame().getGameTurn();
	}

	int iTurnDifference = iGameTurn - m_paiPlayerMadeExpansionPromiseTurn[ePlayer];
	int iTimeOutTurns = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;
	if (iTurnDifference < iTimeOutTurns)
	{
		return true;
	}
	else
	{
		return false;
	}
}

/// Sets if this player made an expansion promise to us
void CvDiplomacyAI::SetPlayerMadeExpansionPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (bValue)
	{
		m_paiPlayerMadeExpansionPromiseTurn[ePlayer] = GC.getGame().getGameTurn();
		m_paePlayerExpansionPromiseData[ePlayer] = GetExpansionAggressivePosture(ePlayer);
#if defined(MOD_BALANCE_CORE)
		SetEverMadeExpansionPromise(ePlayer, true);
		SetNoExpansionPromiseClosestCities(ePlayer, GetClosestCityPair(ePlayer));
#endif

	}
	else
	{
		m_paiPlayerMadeExpansionPromiseTurn[ePlayer] = -1;
		m_paePlayerExpansionPromiseData[ePlayer] = NO_AGGRESSIVE_POSTURE_TYPE;
#if defined(MOD_BALANCE_CORE)
		SetNoExpansionPromiseClosestCities(ePlayer, make_pair(-1,-1));
#endif
	}
}

/// Did this player break an expansion promise to us?
bool CvDiplomacyAI::IsPlayerBrokenExpansionPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerBrokenExpansionPromise[ePlayer];
}

/// Sets if this player broke an expansion promise to us
void CvDiplomacyAI::SetPlayerBrokenExpansionPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerBrokenExpansionPromise[ePlayer] = bValue;

	if(bValue)
	{
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetBrokenExpansionPromise(true);
	}
}

/// Did this player ignore our request to make an expansion promise?
bool CvDiplomacyAI::IsPlayerIgnoredExpansionPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerIgnoredExpansionPromise[ePlayer];
}

/// Sets if this player ignored our request to make an expansion promise
void CvDiplomacyAI::SetPlayerIgnoredExpansionPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerIgnoredExpansionPromise[ePlayer] = bValue;
}

AggressivePostureTypes CvDiplomacyAI::GetPlayerExpansionPromiseData(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paePlayerExpansionPromiseData[ePlayer];
}

#if defined(MOD_BALANCE_CORE)
/// Sets if this player ever made an expansion promise to us
void CvDiplomacyAI::SetEverMadeExpansionPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabPlayerEverMadeExpansionPromise[ePlayer] = bValue;
}
/// Did this player ever make an expansion promise to us?
bool CvDiplomacyAI::EverMadeExpansionPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerEverMadeExpansionPromise[ePlayer];
}
#else
/// Did this player ever make an expansion promise to us?
bool CvDiplomacyAI::EverMadeExpansionPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (m_paiPlayerMadeExpansionPromiseTurn[ePlayer] < 0)
	{
		return false;
	}
	else
	{
		return true;
	}
}
#endif
#if defined(MOD_BALANCE_CORE)
/// Return the number of turns since ePlayer has made a border promise to us
int CvDiplomacyAI::GetPlayerMadeBorderPromise(PlayerTypes ePlayer)
{
	if(!IsPlayerMadeBorderPromise(ePlayer))
	{
		return -1;
	}
	int iGameTurn;
	iGameTurn = GC.getGame().getGameTurn();

	int iTurnDifference = iGameTurn - m_paiPlayerMadeBorderPromiseTurn[ePlayer];
	int iTimeOutTurns = (GC.getEXPANSION_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;

	int iValue = (iTimeOutTurns - iTurnDifference);
	if(iValue > 0)
	{
		return iValue;
	}
	return -1;
}
#endif
/// Did this player make a border promise to us?
bool CvDiplomacyAI::IsPlayerMadeBorderPromise(PlayerTypes ePlayer, int iTestGameTurn)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (m_paiPlayerMadeBorderPromiseTurn[ePlayer] < 0)
	{
		return false;
	}

	int iGameTurn;
	if (iTestGameTurn != -1)
	{
		iGameTurn = iTestGameTurn;
	}
	else
	{
		iGameTurn = GC.getGame().getGameTurn();
	}

	int iTurnDifference = iGameTurn - m_paiPlayerMadeBorderPromiseTurn[ePlayer];
	int iTimeOutTurns = (GC.getBORDER_PROMISE_TURNS_EFFECTIVE() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent()) / 100;
	if (iTurnDifference < iTimeOutTurns)
	{
		return true;
	}
	else
	{
		return false;
	}
}

/// Sets if this player made a border promise to us
void CvDiplomacyAI::SetPlayerMadeBorderPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if (bValue)
	{
		m_paiPlayerMadeBorderPromiseTurn[ePlayer] = GC.getGame().getGameTurn();
	}
	else
	{
		m_paiPlayerMadeBorderPromiseTurn[ePlayer] = -1;
		SetPlayerBorderPromiseData(ePlayer, NO_AGGRESSIVE_POSTURE_TYPE);
	}
}

/// Did this player break a border promise to us?
bool CvDiplomacyAI::IsPlayerBrokenBorderPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerBrokenBorderPromise[ePlayer];
}

/// Sets if this player broke a border promise to us
void CvDiplomacyAI::SetPlayerBrokenBorderPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerBrokenBorderPromise[ePlayer] = bValue;

	if(bValue)
	{
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetBrokenBorderPromise(true);
	}
}

/// Did this player ignore our request to make a border promise?
bool CvDiplomacyAI::IsPlayerIgnoredBorderPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerIgnoredBorderPromise[ePlayer];
}

/// Sets if this player ignored our request to make a border promise
void CvDiplomacyAI::SetPlayerIgnoredBorderPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerIgnoredBorderPromise[ePlayer] = bValue;
}

AggressivePostureTypes CvDiplomacyAI::GetPlayerBorderPromiseData(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return (AggressivePostureTypes) m_paePlayerBorderPromiseData[ePlayer];
}

void CvDiplomacyAI::SetPlayerBorderPromiseData(PlayerTypes ePlayer, AggressivePostureTypes eValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paePlayerBorderPromiseData[ePlayer] = eValue;
}
#if defined(MOD_BALANCE_CORE)
/// Sets if this player ever made a border promise with us
void CvDiplomacyAI::SetEverMadeBorderPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabPlayerEverMadeBorderPromise[ePlayer] = bValue;
}
/// Sets if this player has ever asked to make a DoF with us
void CvDiplomacyAI::SetDoFEverAsked(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabDoFEverAsked[ePlayer] = bValue;
}
/// Sets if this player has ever requested help from us
void CvDiplomacyAI::SetHelpRequestEverMade(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabHelpRequestEverMade[ePlayer] = bValue;
}
/// Sets the number of demands this player has made towards us
void CvDiplomacyAI::SetNumDemandEverMade(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiDemandEverMade[ePlayer] += iValue;
	if (m_paiDemandEverMade[ePlayer] <= 0)
		m_paiDemandEverMade[ePlayer] = 0;
}
/// Sets if this player has ever requested that we not settle near their lands
void CvDiplomacyAI::SetPlayerNoSettleRequestEverAsked(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabPlayerNoSettleRequestEverAsked[ePlayer] = bValue;
}
/// Sets if this player has ever requested that we stop spying on them
void CvDiplomacyAI::SetPlayerStopSpyingRequestEverAsked(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_pabPlayerStopSpyingRequestEverAsked[ePlayer] = bValue;
}
/// Did this player ever make a border promise to us?
bool CvDiplomacyAI::EverMadeBorderPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerEverMadeBorderPromise[ePlayer];
}
#else
/// Did this player ever make a border promise to us?
bool CvDiplomacyAI::EverMadeBorderPromise(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if (m_paiPlayerMadeBorderPromiseTurn[ePlayer] < 0)
	{
		return false;
	}
	else
	{
		return true;
	}
}
#endif
/// Did this player promise to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerMadeAttackCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerMadeAttackCityStatePromise[ePlayer];
}

/// Sets if this player promised to stop attacking one of our protected Minors
void CvDiplomacyAI::SetPlayerMadeAttackCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerMadeAttackCityStatePromise[ePlayer] = bValue;
}

/// Did this player break a promise to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerBrokenAttackCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return false;
	
	return m_pabPlayerBrokenAttackCityStatePromise[ePlayer];
}

/// Sets if this player broke a promise to stop attacking one of our protected Minors
void CvDiplomacyAI::SetPlayerBrokenAttackCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	if (GetPlayer()->isHuman() && GET_PLAYER(ePlayer).isHuman())
		return;
	
	m_pabPlayerBrokenAttackCityStatePromise[ePlayer] = bValue;

	if(bValue)
	{
		GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetBrokenCityStatePromise(true);
	}
}

/// Did this player ignore our request to stop attacking one of our protected Minors?
bool CvDiplomacyAI::IsPlayerIgnoredAttackCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerIgnoredAttackCityStatePromise[ePlayer];
}

/// Sets if this player ignored our request to stop attacking one of our protected Minors
void CvDiplomacyAI::SetPlayerIgnoredAttackCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerIgnoredAttackCityStatePromise[ePlayer] = bValue;
}

/// Did this player promise to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerMadeBullyCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_pabPlayerMadeBullyCityStatePromise[ePlayer];
}

/// Sets if this player promised to stop bullying one of our protected Minors?
void CvDiplomacyAI::SetPlayerMadeBullyCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	m_pabPlayerMadeBullyCityStatePromise[ePlayer] = bValue;
}

/// Did this player break a promise to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerBrokenBullyCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_pabPlayerBrokenBullyCityStatePromise[ePlayer];
}

/// Sets if this player broke a promise to stop bullying one of our protected Minors
void CvDiplomacyAI::SetPlayerBrokenBullyCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	m_pabPlayerBrokenBullyCityStatePromise[ePlayer] = bValue;
}

/// Did this player ignore our request to stop bullying one of our protected Minors?
bool CvDiplomacyAI::IsPlayerIgnoredBullyCityStatePromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_pabPlayerIgnoredBullyCityStatePromise[ePlayer];
}

/// Sets if this player ignored our request to stop bullying one of our protected Minors
void CvDiplomacyAI::SetPlayerIgnoredBullyCityStatePromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	m_pabPlayerIgnoredBullyCityStatePromise[ePlayer] = bValue;
}

/// Did this player promise to stop spying on us?
bool CvDiplomacyAI::IsPlayerMadeSpyPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerMadeSpyPromise[ePlayer];
}

/// Sets if this player promised to stop spying on us
void CvDiplomacyAI::SetPlayerMadeSpyPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerMadeSpyPromise[ePlayer] = bValue;
}

/// Did this player break a promise to stop spying on us?
bool CvDiplomacyAI::IsPlayerBrokenSpyPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerBrokenSpyPromise[ePlayer];
}

/// Sets if this player broke a promise to stop spying on us
void CvDiplomacyAI::SetPlayerBrokenSpyPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerBrokenSpyPromise[ePlayer] = bValue;
}

/// Did this player ignore our request to stop spying on us?
bool CvDiplomacyAI::IsPlayerIgnoredSpyPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerIgnoredSpyPromise[ePlayer];
}

/// Sets if this player ignored our request to stop spying on us
void CvDiplomacyAI::SetPlayerIgnoredSpyPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerIgnoredSpyPromise[ePlayer] = bValue;
}

/// Did this player forgive us for spying on them?
bool CvDiplomacyAI::IsPlayerForgaveForSpying(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerForgaveForSpying[ePlayer];
}

/// Sets if this player forgave us for spying on them
void CvDiplomacyAI::SetPlayerForgaveForSpying(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerForgaveForSpying[ePlayer] = bValue;
}

/// Did this player promise to stop converting our cities?
bool CvDiplomacyAI::IsPlayerMadeNoConvertPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerMadeNoConvertPromise[ePlayer];
}

/// Sets if this player promised to stop converting our cities
void CvDiplomacyAI::SetPlayerMadeNoConvertPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerMadeNoConvertPromise[ePlayer] = bValue;
}

/// Did this player break a promise to stop converting our cities?
bool CvDiplomacyAI::IsPlayerBrokenNoConvertPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerBrokenNoConvertPromise[ePlayer];
}

/// Sets if this player promised to stop converting our cities
void CvDiplomacyAI::SetPlayerBrokenNoConvertPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerBrokenNoConvertPromise[ePlayer] = bValue;
}

/// Did this player ignore our request to stop converting our cities?
bool CvDiplomacyAI::IsPlayerIgnoredNoConvertPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerIgnoredNoConvertPromise[ePlayer];
}

/// Sets if this player ignored our request to stop converting our cities
void CvDiplomacyAI::SetPlayerIgnoredNoConvertPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerIgnoredNoConvertPromise[ePlayer] = bValue;
}

/// Has ePlayer asked us to stop sending missionaries and prophets to their cities?
bool CvDiplomacyAI::IsPlayerAskedNotToConvert(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerAskedNotToConvert[ePlayer];
}

/// Sets if ePlayer asked us to stop sending missionaries and prophets to their cities
void CvDiplomacyAI::SetPlayerAskedNotToConvert(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerAskedNotToConvert[ePlayer] = bValue;
}

/// Did we agree to stop sending missionaries and prophets to ePlayer's cities?
bool CvDiplomacyAI::IsPlayerAgreeNotToConvert(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerAgreedNotToConvert[ePlayer];
}

/// Sets if we agreed to stop sending missionaries and prophets to ePlayer's cities
void CvDiplomacyAI::SetPlayerAgreeNotToConvert(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerAgreedNotToConvert[ePlayer] = bValue;
}

/// Will this AI agree to stop sending missionaries and prophets to ePlayer's cities?
bool CvDiplomacyAI::IsStopSpreadingReligionAcceptable(PlayerTypes ePlayer)
{
	// Always acceptable for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return true;
	
	// Always acceptable if they resurrected us
	if(WasResurrectedBy(ePlayer))
		return true;
	
	FlavorTypes eFlavor = (FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION");
	if (eFlavor == NO_FLAVOR)
	{
		return false;
	}
	int iFlavorReligionValue = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	if (iFlavorReligionValue <= 5)
	{
		return true;
	}
	else if (iFlavorReligionValue >= 8)
	{
		return false;
	}
	else
	{
		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, true);
		switch (eApproach)
		{
		case MAJOR_CIV_APPROACH_AFRAID:
		case MAJOR_CIV_APPROACH_FRIENDLY:
		case MAJOR_CIV_APPROACH_NEUTRAL:
			return true;
			break;
		case MAJOR_CIV_APPROACH_DECEPTIVE:
		case MAJOR_CIV_APPROACH_WAR:
		case MAJOR_CIV_APPROACH_HOSTILE:
		case MAJOR_CIV_APPROACH_GUARDED:
			return false;
			break;
		}
	}

	return false;
}

/////////////////

/// Did this player promise to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerMadeNoDiggingPromise(PlayerTypes ePlayer) const
{
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS)
	{
		return false;
	}
	return m_pabPlayerMadeNoDiggingPromise[ePlayer];
}

/// Sets if this player promised to stop digging up our artifacts
void CvDiplomacyAI::SetPlayerMadeNoDiggingPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerMadeNoDiggingPromise[ePlayer] = bValue;
}

/// Did this player break a promise to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerBrokenNoDiggingPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerBrokenNoDiggingPromise[ePlayer];
}

/// Sets if this player promised to stop digging up our artifacts
void CvDiplomacyAI::SetPlayerBrokenNoDiggingPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerBrokenNoDiggingPromise[ePlayer] = bValue;
}

/// Did this player ignore our request to stop digging up our artifacts?
bool CvDiplomacyAI::IsPlayerIgnoredNoDiggingPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerIgnoredNoDiggingPromise[ePlayer];
}

/// Sets if this player ignored our request to stop digging up our artifacts
void CvDiplomacyAI::SetPlayerIgnoredNoDiggingPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerIgnoredNoDiggingPromise[ePlayer] = bValue;
}

/// Did ePlayer ask us not to dig up their artifacts?
bool CvDiplomacyAI::IsPlayerAskedNotToDig(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerAskedNotToDig[ePlayer];
}

/// Sets if ePlayer asked us not to dig up their artifacts
void CvDiplomacyAI::SetPlayerAskedNotToDig(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerAskedNotToDig[ePlayer] = bValue;
}

/// Did we agree to stop digging up ePlayer's artifacts?
bool CvDiplomacyAI::IsPlayerAgreeNotToDig(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	return m_pabPlayerAgreedNotToDig[ePlayer];
}

/// Sets if we agreed to stop digging up ePlayer's artifacts
void CvDiplomacyAI::SetPlayerAgreeNotToDig(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis your save file and version.");
	m_pabPlayerAgreedNotToDig[ePlayer] = bValue;
}

/// Will this AI agree to stop digging up ePlayer's artifacts?
bool CvDiplomacyAI::IsStopDiggingAcceptable(PlayerTypes ePlayer) const
{
	// Always acceptable for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return true;
	
	// Always acceptable if they resurrected us
	if(WasResurrectedBy(ePlayer))
		return true;
	
	FlavorTypes eFlavor = (FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE");
	if (eFlavor == NO_FLAVOR)
	{
		return false;
	}
	int iFlavorCultureValue = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	if (iFlavorCultureValue < 5)
	{
		return true;
	}
	else if (iFlavorCultureValue >= 8 || IsGoingForCultureVictory())
	{
		return false;
	}
	else
	{
		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, true);
		switch (eApproach)
		{
		case MAJOR_CIV_APPROACH_DECEPTIVE:
		case MAJOR_CIV_APPROACH_AFRAID:
		case MAJOR_CIV_APPROACH_FRIENDLY:
		case MAJOR_CIV_APPROACH_NEUTRAL:
			return true;
			break;
		case MAJOR_CIV_APPROACH_WAR:
		case MAJOR_CIV_APPROACH_HOSTILE:
		case MAJOR_CIV_APPROACH_GUARDED:
			return false;
			break;
		}
	}

	return false;
}

/////////////////
/// Did this player break a coop war promise to us?
bool CvDiplomacyAI::IsPlayerBrokenCoopWarPromise(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerBrokenCoopWarPromise[ePlayer];
}

/// Sets if this player broke a coop war promise to us
void CvDiplomacyAI::SetPlayerBrokenCoopWarPromise(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerBrokenCoopWarPromise[ePlayer] = bValue;
}

/// How many civilians has this player returned to us?
int CvDiplomacyAI::GetNumCiviliansReturnedToMe(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumCiviliansReturnedToMe[ePlayer];
}

/// Changes how many players this player has returned to us
void CvDiplomacyAI::ChangeNumCiviliansReturnedToMe(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNumCiviliansReturnedToMe[ePlayer] += iChange;
		CvAssertMsg(m_paiNumCiviliansReturnedToMe[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Civilians returned. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		// Message for human
		if(iChange > 0)
		{
#if defined(MOD_BALANCE_CORE)
			SetCiviliansReturnedToMeTurn(ePlayer, GC.getGame().getGameTurn());
#endif
#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
				// TODO: what about GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true)?
				CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), ePlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE, -1);
			}
			else
			{
				if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
				{
					if(GC.getGame().getActivePlayer() == ePlayer)
					{
						GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
						const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
						gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
					}
				}
			}
#else
			if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)
			{
				if(GC.getGame().getActivePlayer() == ePlayer)
				{
					GC.GetEngineUserInterface()->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_RETURNED_CIVILIAN);
					gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
#endif
		}
	}
}
#if defined(MOD_BALANCE_CORE)
/// On what turn did this player most recently return a civilian to us?
int CvDiplomacyAI::GetCiviliansReturnedToMeTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiCiviliansReturnedToMeTurn[ePlayer];
}

/// Sets on what turn this player most recently returned a civilian to us
void CvDiplomacyAI::SetCiviliansReturnedToMeTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiCiviliansReturnedToMeTurn[ePlayer] = iChange;
}

/// On what turn did this player most recently liberate one of our cities?
int CvDiplomacyAI::GetLiberatedCitiesTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiLiberatedCitiesTurn[ePlayer];
}

/// Sets on what turn this player most recently liberated one of our cities
void CvDiplomacyAI::SetLiberatedCitiesTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiLiberatedCitiesTurn[ePlayer] = iChange;
}

/// On what turn did this player most recently forgive us for spying?
int CvDiplomacyAI::GetForgaveForSpyingTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiPlayerForgaveForSpyingTurn[ePlayer];
}

/// Sets on what turn this player most recently forgave us for spying
void CvDiplomacyAI::SetForgaveForSpyingTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiPlayerForgaveForSpyingTurn[ePlayer] = iChange;
}

/// On what turn did this player most recently share intrigue with us?
int CvDiplomacyAI::GetIntrigueSharedTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiIntrigueSharedTurn[ePlayer];
}

/// Sets on what turn this player most recently shared intrigue with us
void CvDiplomacyAI::SetIntrigueSharedTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiIntrigueSharedTurn[ePlayer] = iChange;
}

/// On what turn did this player most recently convert one of our cities?
int CvDiplomacyAI::GetReligiousConversionTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiReligiousConversionTurn[ePlayer];
}

/// Sets on what turn this player most recently converted one of our cities
void CvDiplomacyAI::SetReligiousConversionTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiReligiousConversionTurn[ePlayer] = iChange;
}

/// On what turn did this player most recently steal from us?
int CvDiplomacyAI::GetRobbedTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiTimesRobbedTurn[ePlayer];
}

/// Sets on what turn this player most recently stole from us
void CvDiplomacyAI::SetRobbedTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiTimesRobbedTurn[ePlayer] = iChange;
}
#endif
/// How many landmarks has this player built in my territory?
int CvDiplomacyAI::GetNumLandmarksBuiltForMe(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumLandmarksBuiltForMe[ePlayer];
}

/// Changes how many landmarks have been built by ePlayer in my territory
void CvDiplomacyAI::ChangeNumLandmarksBuiltForMe(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNumLandmarksBuiltForMe[ePlayer] += iChange;
		CvAssertMsg(m_paiNumLandmarksBuiltForMe[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Landmarks built. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	}
}
#if defined(MOD_BALANCE_CORE)
/// On what turn did this player most recently build a landmark for me? 
int CvDiplomacyAI::GetLandmarksBuiltForMeTurn(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumLandmarksBuiltForMeTurn[ePlayer];
}

/// Sets on what turn this player most recently built a landmark for me
void CvDiplomacyAI::SetLandmarksBuiltForMeTurn(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiNumLandmarksBuiltForMeTurn[ePlayer] = iChange;
}
#endif

/// Did ePlayer bring us back to life?
bool CvDiplomacyAI::WasResurrectedBy(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiResurrectedOnTurn[ePlayer] != -1;
}

/// Did ePlayer bring us back to life on this turn?
bool CvDiplomacyAI::WasResurrectedThisTurnBy(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiResurrectedOnTurn[ePlayer] == GC.getGame().getGameTurn();
}

/// Sets if this player brought us back to life
void CvDiplomacyAI::SetResurrectedBy(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	if(bValue)
	{
		m_paiResurrectedOnTurn[ePlayer] = GC.getGame().getGameTurn();
	}
	else
	{
		m_paiResurrectedOnTurn[ePlayer] = -1;
	}
}

/// How many times has this player stolen our territory?
int CvDiplomacyAI::GetNumTimesCultureBombed(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesCultureBombed[ePlayer];
}

/// Sets how many times this player has stolen our territory
void CvDiplomacyAI::ChangeNumTimesCultureBombed(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNumTimesCultureBombed[ePlayer] += iChange;
		CvAssertMsg(m_paiNumTimesCultureBombed[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Culture Bombs returned. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	}
}

/// How many times has this player dug up our artifacts?
int CvDiplomacyAI::GetNegativeArchaeologyPoints(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Ed this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Ed this with your last 5 autosaves and what changelist # you're playing.");

	int iRtnValue = m_paiNegativeArchaeologyPoints[ePlayer];
	return iRtnValue;
}

/// Sets how many times this player has dug up our artifacts
void CvDiplomacyAI::ChangeNegativeArchaeologyPoints(PlayerTypes ePlayer, int iChange)
{
	if (iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Ed this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Ed this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNegativeArchaeologyPoints[ePlayer] += iChange;
		CvAssertMsg(m_paiNegativeArchaeologyPoints[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Digs in Other Player's Lands returned. Please send Ed this with your last 5 autosaves and what changelist # you're playing.");
		
		if (iChange > 0 && IsPlayerMadeNoDiggingPromise(ePlayer))
		{
			// You broke the promise you made!
			SetPlayerBrokenNoDiggingPromise(ePlayer, true);
			SetPlayerMadeNoDiggingPromise(ePlayer, false);
#if defined(MOD_BALANCE_CORE)
			SetPlayerBackstabCounter(ePlayer, 0);
#endif
		}

#if !defined(NO_ACHIEVEMENTS)
		if(!GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman() && ePlayer == GC.getGame().getActivePlayer())
		{
			if (m_paiNegativeArchaeologyPoints[ePlayer] > 200)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP2_34);
			}
		}
#endif
	}
}



/// How many times has this player converted the religion of our cities? (if we care)
int CvDiplomacyAI::GetNegativeReligiousConversionPoints(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNegativeReligiousConversionPoints[ePlayer];
}

/// Changes how many times this player has converted the religion of our cities (if we care)
void CvDiplomacyAI::ChangeNegativeReligiousConversionPoints(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNegativeReligiousConversionPoints[ePlayer] += iChange;
		CvAssertMsg(m_paiNegativeReligiousConversionPoints[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Religious Conversions returned. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	}
}
#if defined(MOD_BALANCE_CORE)
/// How many times has this player razed one of our cities?
int CvDiplomacyAI::GetNumTimesRazed(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesRazed[ePlayer];
}

/// Changes how many times this player has razed one of our cities
void CvDiplomacyAI::ChangeNumTimesRazed(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNumTimesRazed[ePlayer] += iChange;
		CvAssertMsg(m_paiNumTimesRazed[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Culture Bombs returned. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	}
}
#endif
/// How many times has this player nuked us?
int CvDiplomacyAI::GetNumTimesNuked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesNuked[ePlayer];
}

/// Changes how many times this player has nuked us
void CvDiplomacyAI::ChangeNumTimesNuked(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiNumTimesNuked[ePlayer] += iChange;
		CvAssertMsg(m_paiNumTimesNuked[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Culture Bombs returned. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	}
}

/// How many times has this player robbed us?
int CvDiplomacyAI::GetNumTimesRobbedBy(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesRobbedBy[ePlayer];
}

/// Changes how many times this player has robbed us
void CvDiplomacyAI::ChangeNumTimesRobbedBy(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
#if defined(MOD_BALANCE_CORE)
		if(iChange > 0)
		{
			SetRobbedTurn(ePlayer, GC.getGame().getGameTurn());
		}
#endif
		m_paiNumTimesRobbedBy[ePlayer] += iChange;
		CvAssertMsg(m_paiNumTimesRobbedBy[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Robbed By returned. Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	}
}

/// How many times has this player shared intrigue with us?
int CvDiplomacyAI::GetNumTimesIntrigueSharedBy(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesIntrigueSharedBy[ePlayer];
}

/// Changes how many times this player shared intrigue with us
void CvDiplomacyAI::ChangeNumTimesIntrigueSharedBy(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
#if defined(MOD_BALANCE_CORE)
		if(iChange > 0)
		{
			SetIntrigueSharedTurn(ePlayer, GC.getGame().getGameTurn());
		}
#endif
		m_paiNumTimesIntrigueSharedBy[ePlayer] += iChange;
		CvAssertMsg(m_paiNumTimesIntrigueSharedBy[ePlayer] >= 0, "DIPLOMACY_AI: Invalid # of Robbed By returned. Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
	}
}

/////////////////////////////////////////////////////////
// Opinion modifiers
/////////////////////////////////////////////////////////
int CvDiplomacyAI::GetLandDisputeLevelScore(PlayerTypes ePlayer)
{
	// Look at Land Dispute
	int iOpinionWeight = 0;
	switch (GetLandDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_LAND_FIERCE();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*25*/ GC.getOPINION_WEIGHT_LAND_STRONG();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_LAND_WEAK();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_LAND_NONE();
		break;
	}
	
	// AI will care more about land if they're a warmonger or it's the early game.
	if (iOpinionWeight > 0)
	{
#if defined(MOD_BALANCE_CORE)
		if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		{
			iOpinionWeight += 10;
		}
#endif
		if (GetPlayer()->GetCurrentEra() == 0)
		{
			iOpinionWeight += 10;
		}
		else if (GetPlayer()->GetCurrentEra() == 1)
		{
			iOpinionWeight += 5;
		}
	}
	
	else if (iOpinionWeight < 0)
	{
#if defined(MOD_BALANCE_CORE)
		if (GetPlayer()->GetPlayerTraits()->IsWarmonger())
		{
			iOpinionWeight -= 5;
		}
#endif
		if (GetPlayer()->GetCurrentEra() <= 1)
		{
			iOpinionWeight -= 5;
		}
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetWonderDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Look at Wonder Competition Dispute
	switch(GetWonderDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_WONDER_FIERCE();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_WONDER_STRONG();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_WONDER_WEAK();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_WONDER_NONE();
		break;
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetMinorCivDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Look at Minor Civ Friendship Dispute
	switch(GetMinorCivDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_MINOR_CIV_FIERCE();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_MINOR_CIV_STRONG();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_MINOR_CIV_WEAK();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_MINOR_CIV_NONE();
		break;
	}

	return iOpinionWeight;
}

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
int CvDiplomacyAI::GetVictoryDisputeLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Look at Victory Dispute
	switch(GetVictoryDisputeLevel(ePlayer))
	{
	case DISPUTE_LEVEL_FIERCE:
		iOpinionWeight += 40;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case DISPUTE_LEVEL_STRONG:
		iOpinionWeight += 30;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case DISPUTE_LEVEL_WEAK:
		iOpinionWeight += 20;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case DISPUTE_LEVEL_NONE:
		iOpinionWeight = 0;
		break;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVictoryBlockLevelScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Look at Victory Dispute
	switch(GetVictoryBlockLevel(ePlayer))
	{
	case BLOCK_LEVEL_FIERCE:
		iOpinionWeight += 30;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case BLOCK_LEVEL_STRONG:
		iOpinionWeight += 20;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case BLOCK_LEVEL_WEAK:
		iOpinionWeight += 10;
		iOpinionWeight += GetPlayer()->GetCurrentEra();
		break;
	case BLOCK_LEVEL_NONE:
		iOpinionWeight = 0;
		break;
	}

	return iOpinionWeight;
}
#endif

int CvDiplomacyAI::GetWarmongerThreatScore(PlayerTypes ePlayer)
{
	// EFB: Removed the divided by 2 in the next line (09/15/2013); all scaling now done and explained in GetOtherPlayerWarmongerScore()
	int iOpinionWeight = GetOtherPlayerWarmongerScore(ePlayer);
	if (iOpinionWeight < 5)
	{
		iOpinionWeight = 0;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetCiviliansReturnedToMeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumCivs = GetNumCiviliansReturnedToMe(ePlayer);
	if (iNumCivs > 0)
	{
		// Full credit for first one
		iOpinionWeight += /*-20*/ GC.getOPINION_WEIGHT_RETURNED_CIVILIAN();
		iOpinionWeight /= 2;
		// Partial credit for any after first
		if (iNumCivs > 1)
		{
			iOpinionWeight += ((GC.getOPINION_WEIGHT_RETURNED_CIVILIAN() / 4) * (iNumCivs - 1));
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(iOpinionWeight > 0)
	{
		int iTurn = GC.getGame().getGameSpeedInfo().GetDealDuration();
		if((GC.getGame().getGameTurn() - GetCiviliansReturnedToMeTurn(ePlayer)) > iTurn)
		{
			iOpinionWeight /= 2;
			if((GC.getGame().getGameTurn() - GetCiviliansReturnedToMeTurn(ePlayer)) > (iTurn * 2))
			{
				iOpinionWeight = 0;
			}
		}
	}
#endif
	return iOpinionWeight;
}

int CvDiplomacyAI::GetLandmarksBuiltForMeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumLandmarks = GetNumLandmarksBuiltForMe(ePlayer);
	if (iNumLandmarks> 0)
	{
		// Full credit for first one
		iOpinionWeight += /*-20*/ GC.getOPINION_WEIGHT_BUILT_LANDMARK();

		// Partial credit for any after first
		if (iNumLandmarks > 1)
		{
			iOpinionWeight += ((GC.getOPINION_WEIGHT_BUILT_LANDMARK() / 3) * (iNumLandmarks - 1));
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(iOpinionWeight > 0)
	{
		int iTurn = GC.getGame().getGameSpeedInfo().GetDealDuration();
		if((GC.getGame().getGameTurn() - GetLandmarksBuiltForMeTurn(ePlayer)) > iTurn)
		{
			iOpinionWeight /= 2;
			if((GC.getGame().getGameTurn() - GetLandmarksBuiltForMeTurn(ePlayer)) > (iTurn * 2))
			{
				iOpinionWeight = 0;
			}
		}
	}
#endif
	return iOpinionWeight;
}

int CvDiplomacyAI::GetResurrectedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(WasResurrectedBy(ePlayer))
		iOpinionWeight += (/*-200*/ GC.getOPINION_WEIGHT_RESURRECTED());
	return iOpinionWeight;
}

int CvDiplomacyAI::GetLiberatedCitiesScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumCitiesLiberated = GetNumCitiesLiberated(ePlayer);
	if (iNumCitiesLiberated >= 3)
	{
		iOpinionWeight = /*-60*/ GC.getOPINION_WEIGHT_LIBERATED_THREE_CITIES();
	}
	else if (iNumCitiesLiberated >= 2)
	{
		iOpinionWeight = /*-50*/ GC.getOPINION_WEIGHT_LIBERATED_TWO_CITIES();
	}
	else if (iNumCitiesLiberated >= 1)
	{
		iOpinionWeight = /*-30*/ GC.getOPINION_WEIGHT_LIBERATED_ONE_CITY();
	}
#if defined(MOD_BALANCE_CORE)
	if(iOpinionWeight > 0)
	{
		int iTurn = GC.getGame().getGameSpeedInfo().GetDealDuration();
		if((GC.getGame().getGameTurn() - GetLiberatedCitiesTurn(ePlayer)) > iTurn)
		{
			iOpinionWeight /= 2;
			if((GC.getGame().getGameTurn() - GetLiberatedCitiesTurn(ePlayer)) > (iTurn * 2))
			{
				iOpinionWeight = 0;
			}
		}
	}
#endif
	return iOpinionWeight;
}

int CvDiplomacyAI::GetEmbassyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	if(GET_TEAM(GET_PLAYER(GetPlayer()->GetID()).getTeam()).HasEmbassyAtTeam(GET_PLAYER(ePlayer).getTeam()))
		iOpinionWeight += (/*-1*/ GC.getOPINION_WEIGHT_EMBASSY() * 2); // -2 if AI has an embassy with them
	
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).HasEmbassyAtTeam(GET_PLAYER(GetPlayer()->GetID()).getTeam()))
		iOpinionWeight += (/*-1*/ GC.getOPINION_WEIGHT_EMBASSY()); // -1 if they have an embassy with AI
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetForgaveForSpyingScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(IsPlayerForgaveForSpying(ePlayer))
	{
		int iTurn = GC.getGame().getGameSpeedInfo().GetDealDuration();
		if((GC.getGame().getGameTurn() - GetForgaveForSpyingTurn(ePlayer)) > iTurn)
		{
			SetPlayerForgaveForSpying(ePlayer, false);
			SetForgaveForSpyingTurn(ePlayer, GC.getGame().getGameTurn());
		}
	}
#endif
	if(IsPlayerForgaveForSpying(ePlayer))
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_FORGAVE_FOR_SPYING();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetNoSetterRequestScore(PlayerTypes ePlayer)
{
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	int iOpinionWeight = 0;
	if(IsPlayerNoSettleRequestEverAsked(ePlayer))
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_ASKED_NO_SETTLE();
	
	if(GetPlayerNoSettleRequestCounter(ePlayer) >= 50)
		iOpinionWeight /= 2;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetStopSpyingRequestScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(IsPlayerStopSpyingRequestEverAsked(ePlayer))
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_ASKED_STOP_SPYING();
	
	if(GetPlayerStopSpyingRequestCounter(ePlayer) >= 50)
		iOpinionWeight /= 2;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDemandEverMadeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetNumDemandEverMade(ePlayer) > 0)
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_MADE_DEMAND_OF_US() / 2 * GetNumDemandEverMade(ePlayer);
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesCultureBombedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetNumTimesCultureBombed(ePlayer) > 0)
		iOpinionWeight += (GetNumTimesCultureBombed(ePlayer) * /*30*/ GC.getOPINION_WEIGHT_CULTURE_BOMBED());
	return iOpinionWeight;
}

int CvDiplomacyAI::GetReligiousConversionPointsScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(GetNegativeReligiousConversionPoints(ePlayer) > 0)
	{
		int iTurn = GC.getGame().getGameSpeedInfo().GetDealDuration();
		if((GC.getGame().getGameTurn() - GetReligiousConversionTurn(ePlayer)) > iTurn)
		{
			ChangeNegativeReligiousConversionPoints(ePlayer, -1);
			SetReligiousConversionTurn(ePlayer, GC.getGame().getGameTurn());
		}
	}
#endif
	if(GetNegativeReligiousConversionPoints(ePlayer) > 0)
	{
		iOpinionWeight += (GetNegativeReligiousConversionPoints(ePlayer) * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion() * /*2*/ GC.getOPINION_WEIGHT_PER_NEGATIVE_CONVERSION());
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetHasAdoptedHisReligionScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(m_pPlayer->GetReligions()->HasOthersReligionInMostCities(ePlayer) && !IsHolyCityCapturedBy(ePlayer))
	{
		iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_ADOPTING_HIS_RELIGION() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetHasAdoptedMyReligionScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(m_pPlayer->GetReligions()->HasOthersReligionInMostCities(ePlayer))
	{
		// this is commented out because the score should be zero if you have more religions in his city
		//iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_ADOPTING_HIS_RELIGION() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	else if(GET_PLAYER(ePlayer).GetReligions()->HasOthersReligionInMostCities(m_pPlayer->GetID()))
	{
		iOpinionWeight += /*-3*/ GC.getOPINION_WEIGHT_ADOPTING_MY_RELIGION() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	return iOpinionWeight;
}

#if defined(MOD_BALANCE_CORE)
int CvDiplomacyAI::GetHasReligionFounderDifferenceScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(m_pPlayer->GetReligions()->GetCurrentReligion(false) == NO_RELIGION || GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false) == NO_RELIGION)
	{
		return 0;
	}
	if(m_pPlayer->GetReligions()->GetCurrentReligion(false) != GET_PLAYER(ePlayer).GetReligions()->GetCurrentReligion(false))
	{
		iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_ADOPTING_HIS_RELIGION() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	return iOpinionWeight;
}
#endif

int CvDiplomacyAI::GetSameLatePoliciesScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	if(IsPlayerSameIdeology(ePlayer))
		iOpinionWeight += /*-5*/ GC.getOPINION_WEIGHT_SAME_LATE_POLICIES() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiplpEmphasisLatePolicies();

	return iOpinionWeight;
}

int CvDiplomacyAI::GetDifferentLatePoliciesScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	if(IsPlayerOpposingIdeology(ePlayer))
		iOpinionWeight += /*5*/ GC.getOPINION_WEIGHT_DIFFERENT_LATE_POLICIES() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiplpEmphasisLatePolicies();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesRobbedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(GetNumTimesRobbedBy(ePlayer) > 0 + GetNumTimesTheyPlottedAgainstUs(ePlayer))
	{
		int iTurn = (GC.getGame().getGameSpeedInfo().GetDealDuration());
		if((GC.getGame().getGameTurn() - GetRobbedTurn(ePlayer)) > iTurn)
		{
			ChangeNumTimesRobbedBy(ePlayer, -1);
			ChangeNumTimesTheyPlottedAgainstUs(ePlayer, -1);
			SetRobbedTurn(ePlayer, GC.getGame().getGameTurn());
		}
	}
#endif
	if (GetNumTimesRobbedBy(ePlayer) > 0 + GetNumTimesTheyPlottedAgainstUs(ePlayer))
		iOpinionWeight += (GetNumTimesRobbedBy(ePlayer) * /*20*/ GC.getOPINION_WEIGHT_ROBBED_BY());
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDugUpMyYardScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iArtifactsStolen = 0;
	int iNegativePoints = GetNegativeArchaeologyPoints(ePlayer);
	
	if (iNegativePoints > 100)
	{
		iArtifactsStolen = 3;
	}
	else if (iNegativePoints > 50)
	{
		iArtifactsStolen = 2;
	}
	else if (iNegativePoints > 0)
	{
		iArtifactsStolen = 1;
	}
	
	if (iArtifactsStolen == 3)
	{
		if (iNegativePoints > 125)
		{
			iOpinionWeight = 40;
		}
		else
		{
			iOpinionWeight = 35;
		}
	}
	else if (iArtifactsStolen == 2)
	{
		if (iNegativePoints > 75)
		{
			iOpinionWeight = 30;
		}
		else
		{
			iOpinionWeight = 25;
		}
	}
	else if (iArtifactsStolen == 1)
	{
		if (iNegativePoints > 25)
		{
			iOpinionWeight = 20;
		}
		else
		{
			iOpinionWeight = 15;
		}
	}
	
	if (iOpinionWeight > 0 && IsPlayerMadeNoDiggingPromise(ePlayer))
	{
		iOpinionWeight += -10;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetTimesIntrigueSharedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	int iNumIntrigue = GetNumTimesIntrigueSharedBy(ePlayer);

#if defined(MOD_BALANCE_CORE)
	if(iNumIntrigue > 0)
	{
		int iTurn = (GC.getGame().getGameSpeedInfo().GetDealDuration());
		if((GC.getGame().getGameTurn() - GetIntrigueSharedTurn(ePlayer)) > iTurn)
		{
			ChangeNumTimesIntrigueSharedBy(ePlayer, -1);
			SetIntrigueSharedTurn(ePlayer, GC.getGame().getGameTurn());
		}
	}
#endif

	if (iNumIntrigue > 0)
	{
		if(iNumIntrigue >= 3)
		{
			iNumIntrigue = 3;
		}
		// Full credit for first one
		iOpinionWeight += /*-20*/ GC.getOPINION_WEIGHT_INTRIGUE_SHARED_BY();
		// Partial credit for any after first
		if (iNumIntrigue > 1)
		{
			iOpinionWeight += ((GC.getOPINION_WEIGHT_INTRIGUE_SHARED_BY() / 3) * (iNumIntrigue - 1));
		}
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenMilitaryPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broken military promise with us?
	if(IsPlayerBrokenMilitaryPromise(ePlayer))
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_BROKEN_MILITARY_PROMISE();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenMilitaryPromiseWithAnybodyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Don't add this if they broke a military promise with US
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsBrokenMilitaryPromise() && !IsPlayerBrokenMilitaryPromise(ePlayer))
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredMilitaryPromiseScore(/*PlayerTypes ePlayer*/)
{
	return 0;
	//int iOpinionWeight = 0;
	//// Don't add this if they broke a military promise with anyone
	//if(IsPlayerIgnoredMilitaryPromise(ePlayer) && !IsPlayerBrokenMilitaryPromise(ePlayer) && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsBrokenMilitaryPromise())
	//	iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_IGNORED_MILITARY_PROMISE();
	//return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenExpansionPromiseScore (PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (GetBrokenExpansionPromiseValue(ePlayer) > 0)
	{
		int iWeightChange = GetBrokenExpansionPromiseValue(ePlayer) / (GC.getBROKEN_EXPANSION_PROMISE_PER_OPINION_WEIGHT() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
		if(iWeightChange > /*20*/ GC.getOPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredExpansionPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// Don't add this if they BROKE an expansion promise
	if (GetIgnoredExpansionPromiseValue(ePlayer) > 0 && GetBrokenExpansionPromiseValue(ePlayer) <= 0)
	{
		int iWeightChange = GetIgnoredExpansionPromiseValue(ePlayer) / (GC.getIGNORED_EXPANSION_PROMISE_PER_OPINION_WEIGHT() *  GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
		if(iWeightChange > /*15*/ GC.getOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenBorderPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broken Border promise with us?
	//if(IsPlayerBrokenBorderPromise(ePlayer))
	//	iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_BROKEN_BORDER_PROMISE();

	if (GetBrokenBorderPromiseValue(ePlayer) > 0)
	{
		int iWeightChange = GetBrokenBorderPromiseValue(ePlayer) / (GC.getBROKEN_BORDER_PROMISE_PER_OPINION_WEIGHT() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
		if (iWeightChange > /*20*/ GC.getOPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX())
		{
			iWeightChange += GC.getOPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX();
		}
		iOpinionWeight += iWeightChange;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredBorderPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broken Border promise with us?
	//if(IsPlayerBrokenBorderPromise(ePlayer))
	//{
	//}
	//// Ignored our request for them to make a Border promise?
	//else if(IsPlayerIgnoredBorderPromise(ePlayer))
	//{
	//	iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_IGNORED_BORDER_PROMISE();
	//}

	// Don't add this if they BROKE a border promise
	if (GetIgnoredBorderPromiseValue(ePlayer) > 0 && GetBrokenBorderPromiseValue(ePlayer) <= 0)
	{
		int iWeightChange = GetIgnoredBorderPromiseValue(ePlayer) / (GC.getIGNORED_BORDER_PROMISE_PER_OPINION_WEIGHT() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
		if (iWeightChange > /*15*/ GC.getOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX();
		}
		iOpinionWeight += iWeightChange;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenAttackCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broken City-State attack promise with us?
	if(IsPlayerBrokenAttackCityStatePromise(ePlayer))
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenAttackCityStatePromiseWithAnybodyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// Don't add this if they broke a City-State attack promise with US
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsBrokenCityStatePromise() && !IsPlayerBrokenAttackCityStatePromise(ePlayer))
		iOpinionWeight += /*0*/ GC.getOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredAttackCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	// Ignored our request for them to make a City-State attack promise?
	
	// Don't add this if they broke a City-State attack promise with anyone
	// if(IsPlayerIgnoredAttackCityStatePromise(ePlayer) && !IsPlayerBrokenAttackCityStatePromise(ePlayer) && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsBrokenCityStatePromise())
	//	 iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE(); //antonjs: todo: rename
	
	// Correction: The opinion weight for breaking a promise with another civ is 0, so let's still count it if they ignore our promise (but haven't broken one with us)
	if(IsPlayerIgnoredAttackCityStatePromise(ePlayer) && !IsPlayerBrokenAttackCityStatePromise(ePlayer))
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE(); //antonjs: todo: rename
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenBullyCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broke a promise not to bully a city-state?
	if(IsPlayerBrokenBullyCityStatePromise(ePlayer))
		iOpinionWeight += 20; //antonjs: todo: xml
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredBullyCityStatePromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Ignored a promise not to bully a city-state?
	// Don't add this if they BROKE a promise to not bully a city-state
	if(IsPlayerIgnoredBullyCityStatePromise(ePlayer) && !IsPlayerBrokenBullyCityStatePromise(ePlayer))
	{
		iOpinionWeight += 10; //antonjs: todo: xml
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenNoConvertPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broke a promise not to convert cities again?
	if(IsPlayerBrokenNoConvertPromise(ePlayer))
	{
		iOpinionWeight += /*8*/ GC.getOPINION_WEIGHT_BROKEN_NO_CONVERT_PROMISE() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredNoConvertPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Don't add this if they BROKE a promise not to convert cities again
	if(IsPlayerIgnoredNoConvertPromise(ePlayer) && !IsPlayerBrokenNoConvertPromise(ePlayer))
	{
		iOpinionWeight += /*4*/ GC.getOPINION_WEIGHT_IGNORED_NO_CONVERT_PROMISE() * GC.getEraInfo(GC.getGame().getCurrentEra())->getDiploEmphasisReligion();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetBrokenNoDiggingPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Broke a promise not to dig again?
	if (IsPlayerBrokenNoDiggingPromise(ePlayer))
	{
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_BROKEN_NO_DIG_PROMISE();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredNoDiggingPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// Don't add this if they BROKE a promise not to dig again
	if(IsPlayerIgnoredNoDiggingPromise(ePlayer) && !IsPlayerBrokenNoDiggingPromise(ePlayer))
	{
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_IGNORED_NO_DIG_PROMISE();
	}
	return iOpinionWeight;
}


int CvDiplomacyAI::GetBrokenSpyPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsPlayerBrokenSpyPromise(ePlayer))
	{
		iOpinionWeight += GC.getOPINION_WEIGHT_BROKEN_SPY_PROMISE();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetIgnoredSpyPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	// Don't add this if they BROKE a promise not to spy on us again
	if (IsPlayerIgnoredSpyPromise(ePlayer) && !IsPlayerBrokenSpyPromise(ePlayer))
	{
		iOpinionWeight += GC.getOPINION_WEIGHT_IGNORED_SPY_PROMISE();
	}
	return iOpinionWeight;
}


int CvDiplomacyAI::GetBrokenCoopWarPromiseScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// Didn't go to war with us when he said he would
	if(IsPlayerBrokenCoopWarPromise(ePlayer))
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_BROKEN_COOP_WAR_PROMISE();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorKilledScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsAngryAboutProtectedMinorKilled(ePlayer))
	{
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_KILLED_PROTECTED_MINOR();
		if (GetOtherPlayerNumProtectedMinorsKilled(ePlayer) > 1)
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_KILLED_MANY_PROTECTED_MINORS();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorAttackedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsAngryAboutProtectedMinorAttacked(ePlayer))
	{
		if (GetTurnsSincePlayerAttackedProtectedMinor(ePlayer) < /*50*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY_NUM_TURNS()) //antonjs: consider: scale by game speed
			iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY();
		else
			iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_WHILE_AGO();

		if (GetOtherPlayerNumProtectedMinorsAttacked(ePlayer) > 1)
			iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_ATTACKED_MANY_PROTECTED_MINORS();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutProtectedMinorBulliedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsAngryAboutProtectedMinorBullied(ePlayer))
	{
		if (GetTurnsSincePlayerBulliedProtectedMinor(ePlayer) < /*50*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY_NUM_TURNS()) //antonjs: consider: scale by game speed
			iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY();
		else
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_WHILE_AGO();

		if (GetOtherPlayerNumProtectedMinorsBullied(ePlayer) > 1)					
			iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_BULLIED_MANY_PROTECTED_MINORS();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutSidedWithProtectedMinorScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsAngryAboutSidedWithTheirProtectedMinor(ePlayer))
	{
		iOpinionWeight += /*5*/ GC.getOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR();
	}
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetResearchAgreementScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	// We have made a Research Agreement
	if (GET_TEAM(GetPlayer()->getTeam()).IsHasResearchAgreement(GET_PLAYER(ePlayer).getTeam()))
	{
		iOpinionWeight += -5;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPAcceptedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	// We have made a Defensive Pact
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsHasDefensivePact(GetPlayer()->getTeam()))
	{
		iOpinionWeight += /*-20*/ GC.getOPINION_WEIGHT_DP();
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPWithAnyFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	
	// They have a DP with at least one other player we have a DP with
	if(IsPlayerDPWithAnyFriend(ePlayer))
		iOpinionWeight += /*-10*/ GC.getOPINION_WEIGHT_DP_WITH_FRIEND();
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDPWithAnyEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They have a DP with at least one enemy we have denounced
	if(IsPlayerDPWithAnyEnemy(ePlayer))
		iOpinionWeight += /*-15*/ GC.getOPINION_WEIGHT_DP_WITH_ENEMY();

	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

#if defined(MOD_BALANCE_CORE_DEALS)
int CvDiplomacyAI::GetOpenBordersScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// We are friends
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsAllowsOpenBordersToTeam(GetPlayer()->getTeam()) && GET_TEAM(GetPlayer()->getTeam()).IsAllowsOpenBordersToTeam(GET_PLAYER(ePlayer).getTeam()))
	{
		iOpinionWeight += /*-12*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_MUTUAL();
	}
	else if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsAllowsOpenBordersToTeam(GetPlayer()->getTeam()))
	{
		iOpinionWeight += /*-8*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_US();
	}
	else if(GET_TEAM(GetPlayer()->getTeam()).IsAllowsOpenBordersToTeam(GET_PLAYER(ePlayer).getTeam()))
	{
		iOpinionWeight += /*-4*/ GC.getOPINION_WEIGHT_OPEN_BORDERS_THEM();
	}
	return iOpinionWeight;
}

/// What are our opinions of this player's neigbors?
MajorCivOpinionTypes CvDiplomacyAI::GetNeighborOpinion(PlayerTypes ePlayer) const
{
	if(ePlayer == NO_PLAYER)
	{
		return NO_MAJOR_CIV_OPINION_TYPE;
	}
	int iBad = 0;
	int iNeutral = 0;
	int iGood = 0;
	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(eLoopPlayer == NO_PLAYER)
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).isMinorCiv())
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).GetID() == m_pPlayer->GetID())
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
		{
			
			if(GetMajorCivOpinion(eLoopPlayer) <= MAJOR_CIV_OPINION_COMPETITOR)
			{
				iBad++;
			}
			else if(GetMajorCivOpinion(eLoopPlayer) == MAJOR_CIV_OPINION_NEUTRAL)
			{
				iNeutral++;
			}
			else if(GetMajorCivOpinion(eLoopPlayer) >= MAJOR_CIV_OPINION_FAVORABLE)
			{
				iGood++;
			}
		}
	}
	if(iGood > iNeutral && iGood > iBad)
	{
		return MAJOR_CIV_OPINION_FRIEND;
	}
	else if(iNeutral > iGood && iNeutral > iBad)
	{
		return MAJOR_CIV_OPINION_NEUTRAL;
	}
	else if(iBad > iGood && iBad > iNeutral)
	{
		return MAJOR_CIV_OPINION_ENEMY;
	}
	else
	{
		return NO_MAJOR_CIV_OPINION_TYPE;
	}
}
bool CvDiplomacyAI::MusteringForNeighborAttack(PlayerTypes ePlayer) const
{
	if(ePlayer == NO_PLAYER)
	{
		return false;
	}

	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(eLoopPlayer == NO_PLAYER)
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).isMinorCiv())
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).GetID() == m_pPlayer->GetID())
		{
			continue;
		}
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(ePlayer) == PLAYER_PROXIMITY_NEIGHBORS)
		{
			if(GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isAtWar(m_pPlayer->getTeam()))
			{
				return true;
			}
			if(IsArmyInPlaceForAttack(eLoopPlayer))
			{
				return true;
			}
			if(m_pPlayer->GetMilitaryAI()->GetSneakAttackOperation(eLoopPlayer) != NULL)
			{
				return true;
			}
			if(GetWarGoal(eLoopPlayer) == WAR_GOAL_PREPARE)
			{
				return true;
			}
		}
	}
	return false;
}
#endif

int CvDiplomacyAI::GetDOFAcceptedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// We are friends
	if(IsDoFAccepted(ePlayer))
		iOpinionWeight += /*-35*/ GC.getOPINION_WEIGHT_DOF();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDOFWithAnyFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They have a DoF with at least one other player we have a DoF with
	if(IsPlayerDoFwithAnyFriend(ePlayer))
		iOpinionWeight += /*-15*/ GC.getOPINION_WEIGHT_DOF_WITH_FRIEND();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDOFWithAnyEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They have a DoF with at least one other player we have DENOUNCED
	if(IsPlayerDoFwithAnyEnemy(ePlayer))
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_DOF_WITH_ENEMY();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;	
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetFriendDenouncementScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	
	// How many of their (trustworthy) friends have denounced them?
	PlayerTypes eLoopPlayer;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(eLoopPlayer != GetPlayer()->GetID() && GET_PLAYER(ePlayer).GetDiplomacyAI()->IsFriendDenouncedUs(eLoopPlayer))
		{
			// If this guy is untrustworthy, he doesn't count
			if(!IsUntrustworthyFriend(eLoopPlayer))
			{
				// Do we like this player who denounced them more than the player we're evaluating?
				if(GetMajorCivOpinion(eLoopPlayer) > GetMajorCivOpinion(ePlayer))
				{
					iTraitorOpinion += /*20*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH();
				}
			}
		}
	}
	
	if(iTraitorOpinion > /*20*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH())
		iTraitorOpinion = /*20*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH();

	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetWeDenouncedFriendScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	
	// If they're an untrustworthy friend, apply the full traitor penalty
	if(IsUntrustworthyFriend(ePlayer))
	{	
	    int iDenouncedFriends = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetWeDenouncedFriendCount();
	    if(iDenouncedFriends > 0)
		    iTraitorOpinion = iDenouncedFriends * /*15*/ GC.getOPINION_WEIGHT_DENOUNCED_FRIEND_EACH();
	}
	
	else
	{
		// Otherwise, apply a betrayal penalty if we like the friend(s) they denounced more than we like them
		PlayerTypes eLoopPlayer;

		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if(eLoopPlayer != GetPlayer()->GetID() && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsFriendDenouncedUs(ePlayer))
			{
				// We're more friendly with the player they've denounced than we are with them
				if(GetMajorCivOpinion(eLoopPlayer) > GetMajorCivOpinion(ePlayer))
				{
					iTraitorOpinion += (-1 * /*-10*/ GC.getOPINION_WEIGHT_DENOUNCED_BY_FRIEND_DONT_LIKE());
				}
			}
		}
	}   

	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;

	return iTraitorOpinion;
}

int CvDiplomacyAI::GetFriendDenouncedUsScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	// We had a DoF, and they later denounced us!
	if(IsFriendDenouncedUs(ePlayer))
		iTraitorOpinion = /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_ME_FRIENDS();
	return iTraitorOpinion;
}

int CvDiplomacyAI::GetWeDeclaredWarOnFriendScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	int iDeclaredWarOnFriendSum = 0;
	PlayerTypes eLoopPlayer;
	
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		iDeclaredWarOnFriendSum += GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetDeclaredWarOnFriendValue(ePlayer);
	}

	iTraitorOpinion = iDeclaredWarOnFriendSum / (GC.getDECLARED_WAR_ON_FRIEND_PER_OPINION_WEIGHT() * GC.getGame().getGameSpeedInfo().getOpinionDurationPercent());
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iTraitorOpinion;
}

int CvDiplomacyAI::GetFriendDeclaredWarOnUsScore(PlayerTypes ePlayer)
{
	int iTraitorOpinion = 0;
	// We had a DoF, and they later declared war on us!
	if(IsFriendDeclaredWarOnUs(ePlayer))
		iTraitorOpinion = /*60*/ GC.getOPINION_WEIGHT_WAR_ME_FRIENDS();
	return iTraitorOpinion;
}

int CvDiplomacyAI::GetDenouncedUsScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They denounced us!
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
		iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_ME();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedThemScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// We denounced them
	if(IsDenouncedPlayer(ePlayer))
		iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_DENOUNCED_THEM();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedFriendScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They've denounced someone we have a DoF with
	if(IsPlayerDenouncedFriend(ePlayer))
		iOpinionWeight += /*15*/ GC.getOPINION_WEIGHT_DENOUNCED_FRIEND();
	
	// No penalty for teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDenouncedEnemyScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	// They've denounced someone we've denounced
	if(IsPlayerDenouncedEnemy(ePlayer))
		iOpinionWeight += /*-15*/ GC.getOPINION_WEIGHT_DENOUNCED_ENEMY();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetRecklessExpanderScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(IsPlayerRecklessExpander(ePlayer))
		iOpinionWeight += /*35*/ GC.getOPINION_WEIGHT_RECKLESS_EXPANDER();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetRecentTradeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetRecentTradeValue(ePlayer) > 0)
	{
		int iWeightChange = -1 * GetRecentTradeValue(ePlayer) / GC.getDEAL_VALUE_PER_OPINION_WEIGHT();
		if(iWeightChange < /*-30*/ GC.getOPINION_WEIGHT_TRADE_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_TRADE_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetCommonFoeScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetCommonFoeValue(ePlayer) > 0)
	{
		int iWeightChange = -1 * GetCommonFoeValue(ePlayer) / GC.getCOMMON_FOE_VALUE_PER_OPINION_WEIGHT();
		if(iWeightChange < /*-50*/ GC.getOPINION_WEIGHT_COMMON_FOE_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_COMMON_FOE_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetRecentAssistScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetRecentAssistValue(ePlayer) != 0)
	{
		int iWeightChange = GetRecentAssistValue(ePlayer) / GC.getDEAL_VALUE_PER_OPINION_WEIGHT();
		if (iWeightChange < -GC.getOPINION_WEIGHT_ASSIST_MAX())
		{
			iWeightChange = -GC.getOPINION_WEIGHT_ASSIST_MAX();
		}
		else if (iWeightChange > GC.getOPINION_WEIGHT_ASSIST_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_ASSIST_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}
	
	// No penalty for teammates
	if(iOpinionWeight > 0 && GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetNukedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(IsNukedBy(ePlayer))
		iOpinionWeight += /*100*/ GC.getOPINION_WEIGHT_NUKED_MAX();
	return iOpinionWeight;
}
#if defined(MOD_BALANCE_CORE)
int CvDiplomacyAI::GetCitiesRazedScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetNumTimesRazed(ePlayer) > 0)
	{
		iOpinionWeight += min(GetNumTimesRazed(ePlayer), 50);

		//We high enough up to incur a global penalty?
		if ((GetNumTimesRazed(ePlayer) >= 50))
		{
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsCivilianKiller())
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetCivilianKiller(true);
		}
		else if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsCivilianKiller())
		{
			GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetCivilianKiller(false);
		}
	}

	return iOpinionWeight;
}
int CvDiplomacyAI::GetCitiesRazedGlobalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(GetMajorCivOpinion(ePlayer) <= MAJOR_CIV_OPINION_NEUTRAL && !GET_TEAM(GetPlayer()->getTeam()).IsHasDefensivePact(GET_PLAYER(ePlayer).getTeam()) && !IsDoFAccepted(ePlayer))
	{
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsCivilianKiller())
		{
			iOpinionWeight += (/*100*/ GC.getOPINION_WEIGHT_NUKED_MAX() / 5);
		}
	}

	return iOpinionWeight;
}
int CvDiplomacyAI::GetPolicyScore(PlayerTypes ePlayer)
{
	if (!MOD_BALANCE_CORE_DIPLOMACY_ADVANCED)
		return 0;

	int iOpinionWeight = 0;
	int iNumPolicies = GetNumSamePolicies(ePlayer);
	
	// Flip it!
	iNumPolicies *= -1;
	
	if(iNumPolicies > 0)
	{
		if(GetNeediness() > 7)
		{
			iOpinionWeight += max(10, (iNumPolicies * 2));
		}
		else
		{
			iOpinionWeight += max(5, (iNumPolicies * 1));
		}
	}
	else if(iNumPolicies < 0)
	{
		if(GetNeediness() > 7)
		{
			iOpinionWeight += min(-10, (iNumPolicies * 2));
		}
		else
		{
			iOpinionWeight += min(-5, (iNumPolicies * 1));
		}
	}
	
	// No penalty for teammates
	if(iOpinionWeight > 0 && GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetPtPSameCSScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;

	int iSamePtP = 0;
	PlayerTypes eMinorLoopPlayer;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eMinorLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(eMinorLoopPlayer == NO_PLAYER)
			continue;
		
		if(GET_PLAYER(eMinorLoopPlayer).isMinorCiv())
		{
			if(GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(ePlayer) && GET_PLAYER(eMinorLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
			{
				iSamePtP++;
			}
		}
	}
	if(iSamePtP > 0)
	{
		iOpinionWeight += min(-12, (iSamePtP * -3));
	}

	return iOpinionWeight;
}
#endif

int CvDiplomacyAI::GetCapitalCapturedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if(IsCapitalCapturedBy(ePlayer))
		iOpinionWeight += /*80*/ GC.getOPINION_WEIGHT_CAPTURED_CAPITAL();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetHolyCityCapturedByScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsHolyCityCapturedBy(ePlayer))
		iOpinionWeight += /*80*/ GC.getOPINION_WEIGHT_CAPTURED_CAPITAL();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetGaveAssistanceToScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsGaveAssistanceTo(ePlayer))
		iOpinionWeight += /*20*/ GC.getOPINION_WEIGHT_GAVE_ASSISTANCE();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetPaidTributeToScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
	if (IsHasPaidTributeTo(ePlayer))
		iOpinionWeight += /*30*/ GC.getOPINION_WEIGHT_PAID_TRIBUTE();
	return iOpinionWeight;
}

int CvDiplomacyAI::GetLikedTheirProposalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;
#endif
	int iTurnsSince = GetTurnsSinceWeLikedTheirProposal(ePlayer);
	if (iTurnsSince > -1 && iTurnsSince < GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS())
	{
		int iOpposingTurnsSince = GetTurnsSinceWeDislikedTheirProposal(ePlayer);
		if (iOpposingTurnsSince == -1 || iTurnsSince < iOpposingTurnsSince)
		{
			iOpinionWeight += GC.getOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL();
		}
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetDislikedTheirProposalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;
#endif
	int iTurnsSince = GetTurnsSinceWeDislikedTheirProposal(ePlayer);
	if (iTurnsSince > -1 && iTurnsSince < GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS())
	{
		int iOpposingTurnsSince = GetTurnsSinceWeLikedTheirProposal(ePlayer);
		if (iOpposingTurnsSince == -1 || iTurnsSince < iOpposingTurnsSince)
		{
			iOpinionWeight += GC.getOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL();
		}
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetSupportedMyProposalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;
#endif
	int iTurnsSince = GetTurnsSinceTheySupportedOurProposal(ePlayer);
	if (iTurnsSince > -1 && iTurnsSince < GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS())
	{
		int iOpposingTurnsSince = GetTurnsSinceTheyFoiledOurProposal(ePlayer);
		if (iOpposingTurnsSince == -1 || iTurnsSince < iOpposingTurnsSince)
		{
			iOpinionWeight += GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL();
		}
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetFoiledMyProposalScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;
#endif
	int iTurnsSince = GetTurnsSinceTheyFoiledOurProposal(ePlayer);
	if (iTurnsSince > -1 && iTurnsSince < GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS())
	{
		int iOpposingTurnsSince = GetTurnsSinceTheySupportedOurProposal(ePlayer);
		if (iOpposingTurnsSince == -1 || iTurnsSince < iOpposingTurnsSince)
		{
			iOpinionWeight += GC.getOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL();
		}
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetSupportedMyHostingScore(PlayerTypes ePlayer)
{
	int iOpinionWeight = 0;
#if defined(MOD_BALANCE_CORE)
	if(!GC.getGame().GetGameLeagues()->GetActiveLeague())
		return 0;
#endif
	int iTurnsSince = GetTurnsSinceTheySupportedOurHosting(ePlayer);
	if (iTurnsSince > -1 && iTurnsSince < GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS())
	{
		iOpinionWeight += GC.getOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING();	
	}
	return iOpinionWeight;
}

#if defined(MOD_EVENTS_DIPLO_MODIFIERS)
int CvDiplomacyAI::GetDiploModifiers(PlayerTypes eToPlayer, std::vector<Opinion>& aOpinions)
{
	int iValue = 0;
	int iModifier;

	iModifier = GetScenarioModifier1(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_1");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}
	
	iModifier = GetScenarioModifier2(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_2");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}

	iModifier = GetScenarioModifier3(eToPlayer);
	if (iModifier != 0) {
		iValue += iModifier;
		
		Opinion kOpinion;
		kOpinion.m_iValue = iModifier;
		Localization::String strOpinion = Localization::Lookup("TXT_KEY_SPECIFIC_DIPLO_STRING_3");
		kOpinion.m_str = strOpinion.toUTF8();
		aOpinions.push_back(kOpinion);
	}
	
	if (MOD_EVENTS_DIPLO_MODIFIERS)
	{
		PlayerTypes eFromPlayer = m_pPlayer->GetID();
		CivilizationTypes eFromCiv = m_pPlayer->getCivilizationType();
		
		CvPlayer* pToPlayer = &GET_PLAYER(eToPlayer);
		CivilizationTypes eToCiv = pToPlayer->getCivilizationType();
		
		
		for (int iI = 0; iI < GC.getNumDiploModifierInfos(); iI++) {
			CvDiploModifierInfo* pDiploModifierInfo = GC.getDiploModifierInfo((DiploModifierTypes) iI);
			
			if (pDiploModifierInfo && pDiploModifierInfo->isForFromCiv(eFromCiv) && pDiploModifierInfo->isForToCiv(eToCiv)) {
				iModifier = 0;
				
				if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_GetDiploModifier, pDiploModifierInfo->GetID(), eFromPlayer, eToPlayer) == GAMEEVENTRETURN_VALUE) {
					if (iModifier != 0) {
						iValue += iModifier;
		
						Opinion kOpinion;
						kOpinion.m_iValue = iModifier;
						Localization::String strOpinion = Localization::Lookup(pDiploModifierInfo->GetDescriptionKey());
						strOpinion << iModifier;
						strOpinion << m_pPlayer->getName();
						strOpinion << m_pPlayer->getCivilizationDescription();
						strOpinion << pToPlayer->getName();
						strOpinion << pToPlayer->getCivilizationDescription();

						kOpinion.m_str = strOpinion.toUTF8();
						aOpinions.push_back(kOpinion);
					}
				}
			}
		}
	}
	
	return iValue;
}
#endif

int CvDiplomacyAI::GetScenarioModifier1(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier1", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;
}

int CvDiplomacyAI::GetScenarioModifier2(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier2", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;
}

int CvDiplomacyAI::GetScenarioModifier3(PlayerTypes ePlayer)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(m_pPlayer->GetID());
		args->Push(ePlayer);

		int iValue = 0;
		if (LuaSupport::CallAccumulator(pkScriptSystem, "GetScenarioDiploModifier3", args.get(), iValue))
		{
			return iValue;
		}
	}

	return 0;

}

/////////////////////////////////////////////////////////
// Miscellaneous
/////////////////////////////////////////////////////////

/// Will this player liberate a Minor's City that it now owns?
bool CvDiplomacyAI::DoPossibleMinorLiberation(PlayerTypes eMinor, int iCityID)
{
	bool bLiberate = false;

	if(GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_FRIENDLY || GetMinorCivApproach(eMinor) == MINOR_CIV_APPROACH_PROTECTIVE || IsGoingForDiploVictory())
	{
		bLiberate = true;
	}
	
#if defined(MOD_BALANCE_CORE)
	if(GetPlayer()->GetPlayerTraits()->IsBullyAnnex())
	{
		bLiberate = false;
	}
#endif

	if(bLiberate)
	{
		GetPlayer()->DoLiberatePlayer(eMinor, iCityID);
	}

	return bLiberate;
}

/// How many players that we're Competitive or more with is ePlayer at war with?
int CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iAtWarCount = 0;

	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	TeamTypes eLoopTeam;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if(IsPlayerValid(eLoopPlayer))
		{
			if(IsAtWar(eLoopPlayer))
			{
				eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

				if(GET_TEAM(eTeam).isAtWar(eLoopTeam))
				{
					iAtWarCount++;
				}
			}
		}
	}

	return iAtWarCount;
}

/// Does this player want to conquer the world?
bool CvDiplomacyAI::IsGoingForWorldConquest() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	if(eGrandStrategy != NO_AIGRANDSTRATEGY)
	{
		if(GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
		{
			return true;
		}
	}

	return false;
}

/// Does this player want to win by diplomacy?
bool CvDiplomacyAI::IsGoingForDiploVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");

	if(eGrandStrategy != NO_AIGRANDSTRATEGY)
	{
		if(GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
		{
			return true;
		}
	}

	return false;
}

/// Does this player want to win by culture?
bool CvDiplomacyAI::IsGoingForCultureVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	if(eGrandStrategy != NO_AIGRANDSTRATEGY)
	{
		if(GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
		{
			return true;
		}
	}

	return false;
}

/// Does this player want to win by science?
bool CvDiplomacyAI::IsGoingForSpaceshipVictory() const
{
	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	if(eGrandStrategy != NO_AIGRANDSTRATEGY)
	{
		if(GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)
		{
			return true;
		}
	}

	return false;
}
#if defined(MOD_BALANCE_CORE)
/// Is this player close to ANY victory condition?
bool CvDiplomacyAI::IsCloseToAnyVictoryCondition() const
{
	if (IsCloseToSSVictory() || IsCloseToDominationVictory() || IsCloseToDiploVictory() || IsCloseToCultureVictory())
	{
		return true;
	}
	else
	{
		return false;
	}
}

/// Is this player close to a science victory?
bool CvDiplomacyAI::IsCloseToSSVictory() const
{
	VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	
	if (!GC.getGame().isVictoryValid(eSpaceshipVictory))
	{
		return false;
	}
	
	if (eSpaceshipVictory != NO_VICTORY)
	{
		int iProjectCount = GET_TEAM(GetPlayer()->getTeam()).GetSSProjectCount();
		if (iProjectCount > 2)
		{
			return true;
		}

		int iTotalTechs = GC.getNumTechInfos();
		iTotalTechs *= 90;
		iTotalTechs /= 100;

		int iOurTechs = GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown();
		
		if (iOurTechs >= iTotalTechs)
		{
			PlayerTypes eLoopPlayer;
			int iNumCivsAheadScience = 0;
			int iNumCivsBehindScience = 0;
			int iNumCivsAlive = 0;

			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes)iPlayerLoop;
				CvPlayer &kPlayer = GET_PLAYER(eLoopPlayer);

				if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian() && iPlayerLoop != GetPlayer()->GetID())
				{
					if (GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown() > GET_TEAM(kPlayer.getTeam()).GetTeamTechs()->GetNumTechsKnown())
					{
						iNumCivsAheadScience++;
					}
					else
					{
						iNumCivsBehindScience++;
					}
					iNumCivsAlive++;
				}
			}
			if (iNumCivsAlive > 0 && iNumCivsAheadScience > (iNumCivsBehindScience * 2))
			{
				return true;
			}
		}
	}	

	return false;
}

/// Is this player close to a domination victory?
bool CvDiplomacyAI::IsCloseToDominationVictory() const
{
	int iNumCivs = GetPlayer()->GetFractionOriginalCapitalsUnderControl();
	if(iNumCivs >= 75)
		return true;

	return false;
}

/// Is this player close to a cultural victory?
bool CvDiplomacyAI::IsCloseToCultureVictory() const
{
	VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	
	if (!GC.getGame().isVictoryValid(eCulturalVictory))
	{
		return false;
	}
	
	int iNumCivsInfluential = GetPlayer()->GetCulture()->GetNumCivsInfluentialOn();
	if(iNumCivsInfluential > 0)
	{
		int iNumCivsAlive = GetPlayer()->GetCulture()->GetNumCivsToBeInfluentialOn();
		int iPercentToGo = iNumCivsInfluential * 100 / max(1,iNumCivsAlive);
		int iPercentToCheck = 0;
		if (iNumCivsAlive >= 4)
			iPercentToCheck = 50;
		else if (iNumCivsAlive == 3)
			iPercentToCheck = 25;
		else
			iPercentToCheck = 0;

		if (iPercentToGo >= iPercentToCheck)
		{
			PlayerTypes eFinalPlayer = GetPlayer()->GetCulture()->GetCivLowestInfluence(false);
			if(eFinalPlayer != NO_PLAYER)
			{
				if(GetPlayer()->GetCulture()->GetTurnsToInfluential(eFinalPlayer) <= 75)
					return true;
			}
		}
	}
	ProjectTypes eUtopia = (ProjectTypes)GC.getInfoTypeForString("PROJECT_UTOPIA_PROJECT", true);
	if (eUtopia != NO_PROJECT)
	{
		if (GET_TEAM(GetPlayer()->getTeam()).getProjectMaking(eUtopia) > 0)
			return true;
	}
	return false;
}

/// Is this player close to a diplomatic victory?
bool CvDiplomacyAI::IsCloseToDiploVictory() const
{
	VictoryTypes eDiplomaticVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);
	
	if (!GC.getGame().isVictoryValid(eDiplomaticVictory))
	{
		return false;
	}
	
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (pLeague != NULL)
	{
		int iVotes = GC.getGame().GetGameLeagues()->GetActiveLeague()->CalculateStartingVotesForMember(GetPlayer()->GetID());
		int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();
		iVotesNeededToWin *= 75;
		iVotesNeededToWin /= 100;
		if(iVotes >= iVotesNeededToWin)
		{
			return true;
		}
	}
	return false;
}
#endif

/// Helper function: is this a valid player to be looking at? (e.g. are they alive, do we know them, etc.)
bool CvDiplomacyAI::IsPlayerValid(PlayerTypes eOtherPlayer, bool bMyTeamIsValid /* = false = */ ) const
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Alive?
	if(!GET_PLAYER(eOtherPlayer).isAlive())
	{
		return false;
	}

	// REALLY Alive? (For some reason a player can be "alive" but have no Cities, Units, etc... grrrr)
	if(GET_PLAYER(eOtherPlayer).getNumCities() == 0 || eOtherPlayer == BARBARIAN_PLAYER)
	{
		return false;
	}

	// A player we've met?
	if(!GET_TEAM(GetTeam()).isHasMet(GET_PLAYER(eOtherPlayer).getTeam()))
	{
		return false;
	}

	// Teammate?
	if(!bMyTeamIsValid)
	{
		if(GetTeam() == GET_PLAYER(eOtherPlayer).getTeam())
		{
			return false;
		}
	}

	return true;
}

/// Are there any valid minor civs that this player has met?
bool CvDiplomacyAI::HasMetValidMinorCiv() const
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
		
		if(IsPlayerValid(eLoopPlayer))
		{
			if(GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				return true;
			}
		}
	}
	
	return false;
}

/// Have we approached another civ about attacking their protected minor?
bool CvDiplomacyAI::HasSentAttackProtectedMinorTaunt(PlayerTypes ePlayer, PlayerTypes eMinor)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eMinor >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	return m_ppaabSentAttackMessageToMinorCivProtector[ePlayer][eMinor];
}

/// Set flag for whether we have sent a message to ePlayer about attacking their protected eMinor
void CvDiplomacyAI::SetSentAttackProtectedMinorTaunt(PlayerTypes ePlayer, PlayerTypes eMinor, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eMinor >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	m_ppaabSentAttackMessageToMinorCivProtector[ePlayer][eMinor] = bValue;
}

/// Reset whether we have approached another civ about attacking a protected minor (ie. once peace is made with the minor)
void CvDiplomacyAI::ResetSentAttackProtectedMinorTaunts(PlayerTypes eMinor)
{
	CvAssertMsg(eMinor >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	for(int iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		SetSentAttackProtectedMinorTaunt((PlayerTypes)iI, eMinor, false);
	}
}

/// We talked to someone, so keep a record of it
void CvDiplomacyAI::DoAddNewStatementToDiploLog(PlayerTypes ePlayer, DiploStatementTypes eNewDiploLogStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eNewDiploLogStatement >= 0, "DIPLOMACY_AI: Invalid Diplo Log Statement Type.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eNewDiploLogStatement < NUM_DIPLO_LOG_STATEMENT_TYPES, "DIPLOMACY_AI: Invalid Diplo Log Statement Type.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Bump current entries back so we can put the new one at index 0
	for(int iI = MAX_DIPLO_LOG_STATEMENTS - 1; iI > 0; iI--)
	{
		// Nothing in this entry to move?
		if(m_ppaDiploStatementsLog[ePlayer][iI-1].m_eDiploLogStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			m_ppaDiploStatementsLog[ePlayer][iI].m_eDiploLogStatement = m_ppaDiploStatementsLog[ePlayer][iI-1].m_eDiploLogStatement;
			m_ppaDiploStatementsLog[ePlayer][iI].m_iTurn = m_ppaDiploStatementsLog[ePlayer][iI-1].m_iTurn;
		}
	}

	m_ppaDiploStatementsLog[ePlayer][0].m_eDiploLogStatement = eNewDiploLogStatement;
	m_ppaDiploStatementsLog[ePlayer][0].m_iTurn = 0;
}

/// Returns the DiploLogStatementType associated with the index passed in
DiploStatementTypes CvDiplomacyAI::GetDiploLogStatementTypeForIndex(PlayerTypes ePlayer, int iIndex)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_ppaDiploStatementsLog[ePlayer][iIndex].m_eDiploLogStatement;
}

/// Returns the DiploLogStatement turn number associated with the index passed in
int CvDiplomacyAI::GetDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_ppaDiploStatementsLog[ePlayer][iIndex].m_iTurn;
}

/// Sets the DiploLogStatement turn number associated with the index passed in
void CvDiplomacyAI::SetDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex, int iNewValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iNewValue >= 0, "DIPLOMACY_AI: Setting DiploLogStatementTurnForIndex to a negative value.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_ppaDiploStatementsLog[ePlayer][iIndex].m_iTurn = iNewValue;
}

/// Changes the DiploLogStatement turn number associated with the index passed in
void CvDiplomacyAI::ChangeDiploLogStatementTurnForIndex(PlayerTypes ePlayer, int iIndex, int iChange)
{
	SetDiploLogStatementTurnForIndex(ePlayer, iIndex, GetDiploLogStatementTurnForIndex(ePlayer, iIndex) + iChange);
}

/// How long has it been since we sent eDiploLogStatement?
int CvDiplomacyAI::GetNumTurnsSinceStatementSent(PlayerTypes ePlayer, DiploStatementTypes eDiploLogStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDiploLogStatement >= 0, "DIPLOMACY_AI: Invalid Diplo Log Statement Type.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDiploLogStatement < NUM_DIPLO_LOG_STATEMENT_TYPES, "DIPLOMACY_AI: Invalid Diplo Log Statement Type.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	int iMostRecentTurn = MAX_TURNS_SAFE_ESTIMATE;

	int iLoopTurnNum;
	DiploStatementTypes eLoopStatement;

	for(int iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		eLoopStatement = GetDiploLogStatementTypeForIndex(ePlayer, iI);

		if(eLoopStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			if(eLoopStatement == eDiploLogStatement)
			{
				iLoopTurnNum = GetDiploLogStatementTurnForIndex(ePlayer, iI);

				if(iMostRecentTurn == MAX_TURNS_SAFE_ESTIMATE || iLoopTurnNum > iMostRecentTurn)
				{
					iMostRecentTurn = iLoopTurnNum;

					// Now break out, otherwise we'll find later entries and think it's been longer since we sent something than it really has been!
					break;
				}
			}
		}
	}

	return iMostRecentTurn;
}
#if defined(MOD_ACTIVE_DIPLOMACY)
/// How long has it been since we sent something?
int CvDiplomacyAI::GetNumTurnsSinceSomethingSent(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	int iMostRecentTurn = MAX_TURNS_SAFE_ESTIMATE;

	int iLoopTurnNum;
	DiploStatementTypes eLoopStatement;

	for (int iI = 0; iI < MAX_DIPLO_LOG_STATEMENTS; iI++)
	{
		eLoopStatement = GetDiploLogStatementTypeForIndex(ePlayer, iI);

		if (eLoopStatement != NO_DIPLO_STATEMENT_TYPE)
		{
			iLoopTurnNum = GetDiploLogStatementTurnForIndex(ePlayer, iI);

			if (iMostRecentTurn == MAX_TURNS_SAFE_ESTIMATE || iLoopTurnNum > iMostRecentTurn)
			{
				iMostRecentTurn = iLoopTurnNum;

				// Now break out, otherwise we'll find later entries and think it's been longer since we sent something than it really has been!
				break;
			}
		}
	}

	return iMostRecentTurn;
}
#endif
/// AI is doing something with a Minor civ
void CvDiplomacyAI::LogMinorCivGiftTile(PlayerTypes eMinor)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gift amount
		strTemp.Format("Tile Improvement");
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
	}
}
void CvDiplomacyAI::LogMinorCivGiftGold(PlayerTypes eMinor, int iOldFriendship, int iGold, bool bSaving, bool bWantQuickBoost, PlayerTypes ePlayerTryingToPass)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gift amount
		strTemp.Format("Gold Gift: %d", iGold);
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendship, GET_PLAYER(eMinor).GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetPlayer()->GetID()));
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Saving Gold for Gift
		if(bSaving)
			strOutBuf += ", (SAVING) ";

		// Wants a quick boost
		if(bWantQuickBoost)
			strOutBuf += ", Boost! ";

		// Trying to pass up a player!
		if(ePlayerTryingToPass != NO_PLAYER)
		{
			strOutBuf += ", Passing ";
			strOutBuf += GET_PLAYER(ePlayerTryingToPass).getCivilizationShortDescription();
		}

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// AI is doing something with a Minor civ
void CvDiplomacyAI::LogMinorCivBullyGold(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, int iGold, bool bSuccess, int iBullyMetricScore)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Gold tribute
		strTemp.Format("Gold Bully: %d", iGold);
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Did it work?
		if(bSuccess)
		{
			strOutBuf += ", ";
			strOutBuf += "Success!";
		}
		else
		{
			strOutBuf += ", ";
			strOutBuf += "Failure";
		}

		// Append the bully metric score
		strTemp.Format("Bully Score: %d", iBullyMetricScore);
		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

void CvDiplomacyAI::LogMinorCivBullyUnit(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, UnitTypes eUnit, bool bSuccess, int iBullyMetricScore)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Unit tribute
		strTemp.Format("Unit Bully: %s", eUnit == (UnitTypes) GC.getInfoTypeForString("UNIT_WORKER") ? "Worker" : "Other unit");
		strOutBuf += ", " + strTemp;

		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		LogGrandStrategy(strOutBuf);

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Did it work?
		if(bSuccess)
		{
			strOutBuf += ", ";
			strOutBuf += "Success!";
		}
		else
		{
			strOutBuf += ", ";
			strOutBuf += "Failure";
		}

		// Append the bully metric score
		strTemp.Format("Bully Score: %d", iBullyMetricScore);
		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// A quest was given to us, so log it
void CvDiplomacyAI::LogMinorCivQuestReceived(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "RECEIVED QUEST";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// We finished a quest! Now log it
void CvDiplomacyAI::LogMinorCivQuestFinished(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "FINISHED QUEST";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// A quest became obsolete and was cancelled, so log it
void CvDiplomacyAI::LogMinorCivQuestCancelled(PlayerTypes eMinor, int iOldFriendshipTimes100, int iNewFriendshipTimes100, MinorCivQuestTypes eType)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		// Quest Info
		strTemp = "cancelled";
		strOutBuf += ", " + strTemp;

		LogMinorCivQuestType(strOutBuf, eType);

		// Friendship Change
		strTemp.Format("Friendship: %d to %d", iOldFriendshipTimes100 / 100, iNewFriendshipTimes100 / 100);
		strOutBuf += ", " + strTemp;

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// A minor civ was bought, and possession changed
void CvDiplomacyAI::LogMinorCivBuyout(PlayerTypes eMinor, int iGoldPaid, bool bSaving)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
			strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
		else
			strLogName = "DiplomacyAI_MinorCiv_Log.csv";

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(eMinor).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		strTemp.Format("BUYOUT: %d", iGoldPaid);
		strOutBuf += ", " + strTemp;

		// Spacing
		strOutBuf += ", , ";

		// City State type
		strOutBuf += ", ";
		strOutBuf += GC.getMinorCivInfo(GET_PLAYER(eMinor).GetMinorCivAI()->GetMinorCivType())->GetType();

		// Saving Gold for Gift
		if(bSaving)
			strOutBuf += ", (SAVING) ";

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// We made a public declaration, so keep a record of it
void CvDiplomacyAI::DoAddNewDeclarationToLog(PublicDeclarationTypes eDeclaration, int iData1, int iData2, PlayerTypes eMustHaveMetPlayer, bool bActive)
{
	CvAssertMsg(eDeclaration >= 0, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeclaration < NUM_PUBLIC_DECLARATION_TYPES, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Bump current entries back so we can put the new one at index 0
	for(int iI = MAX_DIPLO_LOG_STATEMENTS - 1; iI > 0; iI--)
	{
		// Nothing in this entry to move?
		if(m_paDeclarationsLog[iI-1].m_eDeclaration != NO_PUBLIC_DECLARATION_TYPE)
		{
			m_paDeclarationsLog[iI].m_eDeclaration = m_paDeclarationsLog[iI-1].m_eDeclaration;
			m_paDeclarationsLog[iI].m_iData1 = m_paDeclarationsLog[iI-1].m_iData1;
			m_paDeclarationsLog[iI].m_iData2 = m_paDeclarationsLog[iI-1].m_iData2;
			m_paDeclarationsLog[iI].m_eMustHaveMetPlayer = m_paDeclarationsLog[iI-1].m_eMustHaveMetPlayer;
			m_paDeclarationsLog[iI].m_bActive = m_paDeclarationsLog[iI-1].m_bActive;
			m_paDeclarationsLog[iI].m_iTurn = m_paDeclarationsLog[iI-1].m_iTurn;
		}
	}

	m_paDeclarationsLog[0].m_eDeclaration = eDeclaration;
	m_paDeclarationsLog[0].m_iData1 = iData1;
	m_paDeclarationsLog[0].m_iData2 = iData2;
	m_paDeclarationsLog[0].m_eMustHaveMetPlayer = eMustHaveMetPlayer;
	m_paDeclarationsLog[0].m_bActive = bActive;
	m_paDeclarationsLog[0].m_iTurn = 0;
}

/// Returns the DeclarationLogType associated with the index passed in
PublicDeclarationTypes CvDiplomacyAI::GetDeclarationLogTypeForIndex(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_eDeclaration;
}

/// Returns the DeclarationLog iData1 number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogData1ForIndex(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_iData1;
}

/// Returns the DeclarationLog iData2 number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogData2ForIndex(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_iData2;
}

/// Does whoever is listening to our declaration have to have met someone?
PlayerTypes CvDiplomacyAI::GetDeclarationLogMustHaveMetPlayerForIndex(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_eMustHaveMetPlayer;
}

/// Returns the DeclarationLog iData2 number associated with the index passed in
bool CvDiplomacyAI::IsDeclarationLogForIndexActive(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_bActive;
}

/// Make Declaration invalid (so that it doesn't appear for new players we meet, for example)
void CvDiplomacyAI::DoMakeDeclarationInactive(PublicDeclarationTypes eDeclaration, int iData1, int iData2)
{
	CvAssertMsg(eDeclaration >= 0, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eDeclaration < NUM_DIPLO_LOG_STATEMENT_TYPES, "DIPLOMACY_AI: Invalid PublicDeclarationType.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	for(int iLoop = 0; iLoop < MAX_DIPLO_LOG_STATEMENTS; iLoop++)
	{
		// DeclarationType match?
		if(m_paDeclarationsLog[iLoop].m_eDeclaration == eDeclaration)
		{
			// iData1 match?
			if(m_paDeclarationsLog[iLoop].m_iData1 == iData1)
			{
				// iData2 match?
				if(m_paDeclarationsLog[iLoop].m_iData2 == iData2)
				{
					m_paDeclarationsLog[iLoop].m_bActive = false;
				}
			}
		}
	}
}

/// Returns the DeclarationLog turn number associated with the index passed in
int CvDiplomacyAI::GetDeclarationLogTurnForIndex(int iIndex)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paDeclarationsLog[iIndex].m_iTurn;
}

/// Sets the DeclarationLog turn number associated with the index passed in
void CvDiplomacyAI::SetDeclarationLogTurnForIndex(int iIndex, int iNewValue)
{
	CvAssertMsg(iIndex >= 0, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iIndex < MAX_DIPLO_LOG_STATEMENTS, "DIPLOMACY_AI: Invalid DiploLogStatement Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paDeclarationsLog[iIndex].m_iTurn = iNewValue;
}

/// Changes the DeclarationLog turn number associated with the index passed in
void CvDiplomacyAI::ChangeDeclarationLogTurnForIndex(int iIndex, int iChange)
{
	SetDeclarationLogTurnForIndex(iIndex, GetDeclarationLogTurnForIndex(iIndex) + iChange);
}

/// Deal to renew
CvDeal* CvDiplomacyAI::GetDealToRenew(int* piDealType, PlayerTypes eOtherPlayer)
{
	if (GetPlayer()->isHuman())
		return NULL;

	CvDeal* pTargetDeal = NULL;
	CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();

	if (piDealType)
	{
		*piDealType = -1;
	}

	for(int iDealTypes = 0; iDealTypes < 2; iDealTypes++)
	{
		int iNumDeals = 0;
		if(iDealTypes == 0)
		{
			iNumDeals = kGameDeals.GetNumHistoricDealsWithPlayer(m_pPlayer->GetID(), eOtherPlayer, 12);
		}
		else
		{
			iNumDeals = kGameDeals.GetNumCurrentDealsWithPlayer(m_pPlayer->GetID(), eOtherPlayer);
		}

		for(int iDeal = 0; iDeal < iNumDeals; iDeal++)
		{
			CvDeal* pCurrentDeal = NULL;
			if(iDealTypes == 0)
			{
				pCurrentDeal = kGameDeals.GetHistoricDealWithPlayer(m_pPlayer->GetID(), eOtherPlayer, iDeal);
			}
			else
			{
				pCurrentDeal = kGameDeals.GetCurrentDealWithPlayer(m_pPlayer->GetID(), eOtherPlayer, iDeal);
			}

			if (pCurrentDeal->m_bConsideringForRenewal)
			{
				CvAssertMsg(pTargetDeal == NULL, "pTargetDeal should be null");
				if (!pTargetDeal)
				{
					pTargetDeal = pCurrentDeal;
					if (piDealType)
					{
						*piDealType = iDealTypes;
					}
				}
			}
		}
	}

	return pTargetDeal;
}

/// Clear deal to renew
void CvDiplomacyAI::ClearDealToRenew()
{
	CvGameDeals& kGameDeals = GC.getGame().GetGameDeals();
	int iNumMarkedToRenew = 0;

	int iNumDeals = kGameDeals.GetNumHistoricDeals(m_pPlayer->GetID());

	for(int iDeal = 0; iDeal < iNumDeals; iDeal++)
	{
		CvDeal* pCurrentDeal = kGameDeals.GetHistoricDeal(m_pPlayer->GetID(), iDeal);

		if (pCurrentDeal->m_bConsideringForRenewal)
		{
			iNumMarkedToRenew++;
			CvAssertMsg(iNumMarkedToRenew <= 1, "iNumMarkedToRenew is greater than one. Too many deals are being renewed at the same time.");
			pCurrentDeal->m_bConsideringForRenewal = false;
		}
	}
}

// When someone dies, clear out data
// Currently clears out co-op war
void CvDiplomacyAI::KilledPlayerCleanup (PlayerTypes eKilledPlayer)
{
	// reset planned invasions
	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
	{
		PlayerTypes ePlayer = (PlayerTypes)ui;
		SetCoopWarAcceptedState(ePlayer, eKilledPlayer, NO_COOP_WAR_STATE);
		SetCoopWarCounter(ePlayer, eKilledPlayer, 0);
	}
	
	SetWarmongerThreat(eKilledPlayer, THREAT_NONE);
	SetOtherPlayerWarmongerAmountTimes100(eKilledPlayer, 0);
}

// ************************************
// PRIVATE
// ************************************



/// Helper function to determine if we're at war with a player
bool CvDiplomacyAI::IsAtWar(PlayerTypes eOtherPlayer)
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam());
}



// ************************************
// LOGGING
// ************************************



/// Log public declaration made by this AI
void CvDiplomacyAI::LogPublicDeclaration(PublicDeclarationTypes eDeclaration, int iData1, PlayerTypes eForSpecificPlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		// JON: Disabling some logspam
		if(eForSpecificPlayer != NO_PLAYER)
			return;

		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		strOutBuf = strBaseString;

		// Is this declaration for a specific player (one we met after we made the declaration?)
		if(eForSpecificPlayer != NO_PLAYER)
		{
			otherPlayerName = GET_PLAYER(eForSpecificPlayer).getCivilizationShortDescription();
			strTemp = "To " + otherPlayerName;
			strOutBuf += ", " + strTemp;
		}

		PlayerTypes eMinorCiv;

		bool bMinorMessage = false;

		switch(eDeclaration)
		{
		case PUBLIC_DECLARATION_PROTECT_MINOR:
			eMinorCiv = (PlayerTypes) iData1;
			otherPlayerName = GET_PLAYER(eMinorCiv).getCivilizationShortDescription();
			strTemp = "We're now protecting " + otherPlayerName + "!";
			bMinorMessage = true;
			break;
		case PUBLIC_DECLARATION_ABANDON_MINOR:
			eMinorCiv = (PlayerTypes) iData1;
			otherPlayerName = GET_PLAYER(eMinorCiv).getCivilizationShortDescription();
			strTemp = "We've abandoned " + otherPlayerName + "!";
			bMinorMessage = true;
			break;
		default:
			strTemp.Format("Unknown Declaration!!!");
			break;
		}

		strOutBuf += ", " + strTemp;

		pLog->Msg(strOutBuf);

		// Also send message to Minor Civ log if applicable
		if(bMinorMessage)
		{
			// Open the log file
			if(GC.getPlayerAndCityAILogSplit())
				strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
			else
				strLogName = "DiplomacyAI_MinorCiv_Log.csv";

			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// Log war declaration
void CvDiplomacyAI::LogWarDeclaration(PlayerTypes ePlayer, int iTotalWarWeight)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ", ***** WAR DECLARATION! *****, " + otherPlayerName;

		if(iTotalWarWeight >= 0)
		{
			CvString strWarWeight;
			strWarWeight.Format(", %d, ", iTotalWarWeight);
			strOutBuf += strWarWeight;
		}

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif

		// Want this in DiploMessage Log
//		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			if(GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Messages_Log.csv";
			}
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}

		// Log it to military AI too
		m_pPlayer->GetMilitaryAI()->LogDeclarationOfWar(ePlayer);
	}
}


/// Log war declaration
void CvDiplomacyAI::LogPeaceMade(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ", ***** PEACE MADE! *****, " + otherPlayerName;

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif

		// Want this in DiploMessage Log
//		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			if(GC.getPlayerAndCityAILogSplit())
			{
				strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
			}
			else
			{
				strLogName = "DiplomacyAI_Messages_Log.csv";
			}
			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}

		// Log it to military AI too
		m_pPlayer->GetMilitaryAI()->LogPeace(ePlayer);
	}
}


/// Log working with a player
void CvDiplomacyAI::LogDoF(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
#if defined(MOD_BALANCE_CORE)
		CvString strRank; 
		strRank.Format("Rank: %03d, ", (int)GetDoFType(ePlayer));
		strOutBuf = strBaseString + ",***** NOW FRIENDS " + otherPlayerName + strRank + "! *****";
#else
		strOutBuf = strBaseString + ",***** NOW FRIENDS " + otherPlayerName + "! *****";
#endif

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Log DoF Broken with a player
void CvDiplomacyAI::LogBrokenDoF(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** NO LONGER FRIENDS " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}
#endif

/// Log working with a player
void CvDiplomacyAI::LogDenounce(PlayerTypes ePlayer, bool bBackstab, bool bRefusal)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		//CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		if(bBackstab)
			strOutBuf = strBaseString + ",***** BACKSTABBED " + otherPlayerName + "! *****";
		else if(bRefusal)
			strOutBuf = strBaseString + ",***** REFUSED TO FORGIVE " + otherPlayerName + "! *****";
		else
#if defined(MOD_BALANCE_CORE)
		{
			strOutBuf = strBaseString + ",***** DENOUNCED GENERIC " + otherPlayerName + "! *****";
			int iMessage = GetDenounceMessage(ePlayer);
			if(iMessage != 0 && iMessage <= 7)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF IDEOLOGY " + otherPlayerName + "! *****";
			}
			else if(iMessage == 8)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF WARMONGER " + otherPlayerName + "! *****";
			}
			else if(iMessage == 9)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF MINORS " + otherPlayerName + "! *****";
			}
			else if(iMessage == 10)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF BULLYING" + otherPlayerName + "! *****";
			}
			else if(iMessage == 11)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF NUKES " + otherPlayerName + "! *****";
			}
			else if(iMessage == 12)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF SPYING " + otherPlayerName + "! *****";
			}
			else if(iMessage == 13)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF LAND " + otherPlayerName + "! *****";
			}
			else if(iMessage == 14)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE IS ENEMY OF FRIEND " + otherPlayerName + "! *****";
			}
			else if(iMessage == 15)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE DOGPILE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 16)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE UNTRUSTWORTHY " + otherPlayerName + "! *****";
			}
			else if(iMessage == 17)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE UNFORGIVEABLE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 18)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF RELIGION " + otherPlayerName + "! *****";
			}
			else if(iMessage == 19)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF DIGGING " + otherPlayerName + "! *****";
			}		
			else if(iMessage == 20)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF WONDERS " + otherPlayerName + "! *****";
			}
			else if(iMessage == 21)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF VICTORY DISPUTE " + otherPlayerName + "! *****";
			}
			else if(iMessage == 22)
			{
				strOutBuf = strBaseString + ",***** DENOUNCED BECAUSE OF VICTORY BLOCK " + otherPlayerName + "! *****";
			}
		}
#else
			strOutBuf = strBaseString + ",***** DENOUNCED " + otherPlayerName + "! *****";
#endif

		pLog->Msg(strOutBuf);

#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// Log friend asks another to denounce someone
void CvDiplomacyAI::LogFriendRequestDenounce(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, bool bAgreed)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		// Did they actually agree?
		if(bAgreed)
			strOutBuf = strBaseString + ",***** CONVINCED " + otherPlayerName + " TO DENOUNCE " + againstPlayerName + "! *****";
		else
			strOutBuf = strBaseString + ", ASKED " + otherPlayerName + " TO DENOUNCE " + againstPlayerName + "!";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}


/// Log working with a player
void CvDiplomacyAI::LogCoopWar(PlayerTypes ePlayer, PlayerTypes eAgainstPlayer, CoopWarStates eAcceptedState)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		CvString otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		CvString againstPlayerName = GET_PLAYER(eAgainstPlayer).getCivilizationShortDescription();

		// Did they actually agree?
		if(eAcceptedState == COOP_WAR_STATE_ACCEPTED)
			strOutBuf = strBaseString + ",***** NOW coop war with " + otherPlayerName + " against " + againstPlayerName + "! *****";
		// Asked and player said soon
		else if(eAcceptedState == COOP_WAR_STATE_SOON)
			strOutBuf = strBaseString + ",***** SOON coop war with " + otherPlayerName + " against " + againstPlayerName + "! *****";
		// Asked but player declined
		else if(eAcceptedState == COOP_WAR_STATE_REJECTED)
			strOutBuf = strBaseString + ", wanted coop war with " + otherPlayerName + " against " + againstPlayerName + "!";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

/// Log player wanting a RA
void CvDiplomacyAI::LogWantRA(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + otherPlayerName + ", Wants Research Agreement!";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}
#if defined(MOD_BALANCE_CORE_DEALS)
/// Log player wanting a DP
void CvDiplomacyAI::LogWantDP(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + otherPlayerName + ", Wants Defensive Pact!";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}
#endif

/// Log Major Civ Opinion Update
void CvDiplomacyAI::LogOpinionUpdate(PlayerTypes ePlayer, std::vector<int>& viOpinionValues)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strTemp.Format("OPINION");
		strOutBuf += ", " + strTemp;

		MajorCivOpinionTypes eMajorCivOpinion;
		//		MinorCivOpinionTypes eMinorCivOpinion;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// Current Opinion
			switch(GetMajorCivOpinion(ePlayer))
			{
			case MAJOR_CIV_OPINION_ALLY:
				strTemp.Format("** ALLY **");
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				strTemp.Format("FRIEND");
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				strTemp.Format("Favorable");
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				strTemp.Format("N");
				break;
			case MAJOR_CIV_OPINION_COMPETITOR:
				strTemp.Format("Competitor");
				break;
			case MAJOR_CIV_OPINION_ENEMY:
				strTemp.Format("ENEMY");
				break;
			case MAJOR_CIV_OPINION_UNFORGIVABLE:
				strTemp.Format("**UNFORGIVABLE**");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf += ", " + strTemp;

			for(int iMajorCivOpinionLoop = 0; iMajorCivOpinionLoop < NUM_MAJOR_CIV_OPINION_TYPES; iMajorCivOpinionLoop++)
			{
				eMajorCivOpinion = (MajorCivOpinionTypes) iMajorCivOpinionLoop;

				switch(eMajorCivOpinion)
				{
				case MAJOR_CIV_OPINION_ALLY:
					strTemp.Format("Ally");
					break;
				case MAJOR_CIV_OPINION_FRIEND:
					strTemp.Format("Friend");
					break;
				case MAJOR_CIV_OPINION_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				case MAJOR_CIV_OPINION_COMPETITOR:
					strTemp.Format("Competitor");
					break;
				case MAJOR_CIV_OPINION_ENEMY:
					strTemp.Format("Enemy");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", viOpinionValues[eMajorCivOpinion]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}
#if defined(MOD_BALANCE_CORE)
/// Log Major Civ Approach Update
void CvDiplomacyAI::LogApproachValueDeltas(PlayerTypes ePlayer, const int* aiApproachValues, const int* aiScratchValues)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Deltas_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Deltas_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		MajorCivApproachTypes eMajorCivApproach;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			strTemp.Format("Opinion: %d", GetMajorCivOpinionWeight(ePlayer));
			strOutBuf += ", " + strTemp;

			// Weights for each possible Approach
			for(int iMajorCivApproachLoop = 0; iMajorCivApproachLoop < NUM_MAJOR_CIV_APPROACHES; iMajorCivApproachLoop++)
			{
				eMajorCivApproach = (MajorCivApproachTypes) iMajorCivApproachLoop;

				switch(eMajorCivApproach)
				{
				case MAJOR_CIV_APPROACH_WAR:
					strTemp.Format("War");
					break;
				case MAJOR_CIV_APPROACH_HOSTILE:
					strTemp.Format("Hostile");
					break;
				case MAJOR_CIV_APPROACH_DECEPTIVE:
					strTemp.Format("Deceptive");
					break;
				case MAJOR_CIV_APPROACH_GUARDED:
					strTemp.Format("Guarded");
					break;
				case MAJOR_CIV_APPROACH_AFRAID:
					strTemp.Format("Afraid");
					break;
				case MAJOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MAJOR_CIV_APPROACH_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}

				strOutBuf += ", " + strTemp;

				strTemp.Format("Value: %d", aiApproachValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;

				strTemp.Format("Scratch: %d", aiScratchValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;

				int iDelta = 0;
				if(aiApproachValues[eMajorCivApproach] >= aiScratchValues[eMajorCivApproach])
				{
					iDelta = (aiApproachValues[eMajorCivApproach] - aiScratchValues[eMajorCivApproach]);
					strTemp.Format("Delta: +%d", iDelta);
					strOutBuf += ", " + strTemp;
				}
				else
				{
					iDelta = (aiScratchValues[eMajorCivApproach] - aiApproachValues[eMajorCivApproach]);
					strTemp.Format("Delta: -%d", iDelta);
					strOutBuf += ", " + strTemp;
				}
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}
#endif
/// Log Major Civ Warmonger Threat update
void CvDiplomacyAI::LogMajorCivWarmongerUpdate(PlayerTypes ePlayer, int iValue, bool bUpdateLogsSpecial)
{
	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if (GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_WarmongerStatus_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_WarmongerStatus_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		// Don't fill out this field for Minors, as it just makes the log harder to read
		if (GET_PLAYER(ePlayer).isMinorCiv())
		{
			strTemp.Format(",");
		}
		else
		{
			int iResistance = m_pPlayer->GetDominationResistance(ePlayer);

			if (bUpdateLogsSpecial)
			{
				switch (GetWarmongerThreat(ePlayer))
				{
				case THREAT_CRITICAL:
					strTemp.Format(" -- NEW STATUS -- W_THT CRIT, %d/%d, Decay Rate: %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_SEVERE:
					strTemp.Format(" -- NEW STATUS -- W_THT SEVR, %d/%d, Decay Rate : %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_MAJOR:
					strTemp.Format(" -- NEW STATUS -- W_THT MAJR, %d/%d, Decay Rate : %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_MINOR:
					strTemp.Format(" -- NEW STATUS -- W_THT MINR, %d/%d, Decay Rate : %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				case THREAT_NONE:
					strTemp.Format(" -- NEW STATUS -- W_THT NONE, %d/%d, Decay Rate : %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				default:
					strTemp.Format(" -- NEW STATUS -- W_THT XXXX, %d/%d, Decay Rate : %d, Resistance: %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, iResistance);
					break;
				}
			}
			else
			{
				strTemp.Format(" -- %d/%d, Decay Rate : %d, Resistance : %d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer), iValue, min(40, iResistance));
			}
		}

		strOutBuf = strBaseString + strTemp;
		pLog->Msg(strOutBuf);

	}
}
/// Log Major Civ Approach Update
void CvDiplomacyAI::LogMajorCivApproachUpdate(PlayerTypes ePlayer, const int* aiApproachValues, MajorCivApproachTypes eNewMajorCivApproach, MajorCivApproachTypes eOldApproach, WarFaceTypes eNewWarFace)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		MajorCivApproachTypes eMajorCivApproach;

		// Major Civs
		if(!GET_PLAYER(ePlayer).isMinorCiv())
		{
			LogMajorCivApproach(strOutBuf, eNewMajorCivApproach, eNewWarFace);

			if(eNewMajorCivApproach != eOldApproach)
			{
				LogMajorCivApproach(strOutBuf, eOldApproach, eNewWarFace);
			}
			else
			{
				strTemp.Format("---");
				strOutBuf += ", " + strTemp;
			}

			LogOpinion(strOutBuf, ePlayer);

			LogWarmongerThreat(strOutBuf, ePlayer);

			LogMilitaryThreat(strOutBuf, ePlayer);

			LogTargetValue(strOutBuf, ePlayer);

			LogWarGoal(strOutBuf, ePlayer);

			LogMilitaryAggressivePosture(strOutBuf, ePlayer);

			LogProximity(strOutBuf, ePlayer);

			LogLandDispute(strOutBuf, ePlayer);

			LogVictoryDispute(strOutBuf, ePlayer);

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			if(MOD_BALANCE_CORE_DIPLOMACY)
			{
				LogVictoryBlock(strOutBuf, ePlayer);
			}
#endif

			LogWonderDispute(strOutBuf, ePlayer);

			LogMinorCivDispute(strOutBuf, ePlayer);

			strTemp.Format("---");
			strOutBuf += ", " + strTemp;

			// Weights for each possible Approach
			for(int iMajorCivApproachLoop = 0; iMajorCivApproachLoop < NUM_MAJOR_CIV_APPROACHES; iMajorCivApproachLoop++)
			{
				eMajorCivApproach = (MajorCivApproachTypes) iMajorCivApproachLoop;

				switch(eMajorCivApproach)
				{
				case MAJOR_CIV_APPROACH_WAR:
					strTemp.Format("War");
					break;
				case MAJOR_CIV_APPROACH_HOSTILE:
					strTemp.Format("Hostile");
					break;
				case MAJOR_CIV_APPROACH_DECEPTIVE:
					strTemp.Format("Deceptive");
					break;
				case MAJOR_CIV_APPROACH_GUARDED:
					strTemp.Format("Guarded");
					break;
				case MAJOR_CIV_APPROACH_AFRAID:
					strTemp.Format("Afraid");
					break;
				case MAJOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MAJOR_CIV_APPROACH_NEUTRAL:
					strTemp.Format("Neutral");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", aiApproachValues[eMajorCivApproach]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}


/// Log Minor Civ Approach Update
void CvDiplomacyAI::LogMinorCivApproachUpdate(PlayerTypes ePlayer, const int* aiApproachValues, MinorCivApproachTypes eNewMinorCivApproach, MinorCivApproachTypes eOldApproach)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString strTemp;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Approach_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Approach_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Name
		strBaseString += playerName;

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", --- " + otherPlayerName;

		MinorCivApproachTypes eMinorCivApproach;

		// Minor Civs only
		if(GET_PLAYER(ePlayer).isMinorCiv())
		{
			LogMinorCivApproach(strOutBuf, eNewMinorCivApproach);

			if(eNewMinorCivApproach != eOldApproach)
			{
				LogMinorCivApproach(strOutBuf, eOldApproach);
			}
			else
			{
				strTemp.Format("---");
				strOutBuf += ", " + strTemp;
			}

			//LogOpinion(strOutBuf, ePlayer);
			strOutBuf += ", ";

			//LogWarmongerThreat(strOutBuf, ePlayer);
			strOutBuf += ", ";

			//LogMilitaryThreat(strOutBuf, ePlayer);
			strOutBuf += ", ";

			LogTargetValue(strOutBuf, ePlayer);

			LogWarGoal(strOutBuf, ePlayer);

			LogMilitaryAggressivePosture(strOutBuf, ePlayer);

			LogProximity(strOutBuf, ePlayer);

			LogLandDispute(strOutBuf, ePlayer);

			//LogVictoryDispute(strOutBuf, ePlayer);
			strOutBuf += ", ";

			strOutBuf += ", ---";

			// Weights for each possible Approach
			for(int iMinorCivApproachLoop = 0; iMinorCivApproachLoop < NUM_MINOR_CIV_APPROACHES; iMinorCivApproachLoop++)
			{
				eMinorCivApproach = (MinorCivApproachTypes) iMinorCivApproachLoop;

				switch(eMinorCivApproach)
				{
				case MINOR_CIV_APPROACH_IGNORE:
					strTemp.Format("Ignore");
					break;
				case MINOR_CIV_APPROACH_FRIENDLY:
					strTemp.Format("Friendly");
					break;
				case MINOR_CIV_APPROACH_PROTECTIVE:
					strTemp.Format("Protective");
					break;
				case MINOR_CIV_APPROACH_CONQUEST:
					strTemp.Format("Conquest");
					break;
				case MINOR_CIV_APPROACH_BULLY:
					strTemp.Format("Bully");
					break;
				default:
					strTemp.Format("XXX");
					break;
				}
				strOutBuf += ", " + strTemp;

				strTemp.Format("%d", aiApproachValues[eMinorCivApproach]);
				strOutBuf += ", " + strTemp;
			}

			strOutBuf = strBaseString + strOutBuf;
			pLog->Msg(strOutBuf);
		}
	}
}

/// Log the Personality of this player (Flavors & Personality Traits)
void CvDiplomacyAI::LogPersonality()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "AI_Personality_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "AI_Personality_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, PERSONALITY, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		// Loop through all Flavors
		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
		{
			strTemp.Format("%s, %d", GC.getFlavorTypes((FlavorTypes) iFlavorLoop).GetCString(), GetPlayer()->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes) iFlavorLoop));
			strOutBuf = strBaseString + ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		MajorCivApproachTypes eMajorCivApproach;

		// Loop through all Approaches to see what this player's bias is
		for(int iApproachLoop = 0; iApproachLoop < NUM_MAJOR_CIV_APPROACHES; iApproachLoop++)
		{
			eMajorCivApproach = (MajorCivApproachTypes) iApproachLoop;

			switch(eMajorCivApproach)
			{
			case MAJOR_CIV_APPROACH_WAR:
				strTemp.Format("War");
				break;
			case MAJOR_CIV_APPROACH_HOSTILE:
				strTemp.Format("Hostile");
				break;
			case MAJOR_CIV_APPROACH_DECEPTIVE:
				strTemp.Format("Deceptive");
				break;
			case MAJOR_CIV_APPROACH_GUARDED:
				strTemp.Format("Guarded");
				break;
			case MAJOR_CIV_APPROACH_AFRAID:
				strTemp.Format("Afraid");
				break;
			case MAJOR_CIV_APPROACH_FRIENDLY:
				strTemp.Format("Friendly");
				break;
			case MAJOR_CIV_APPROACH_NEUTRAL:
				strTemp.Format("Neutral");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf = strBaseString + ", " + strTemp;

			strTemp.Format("%d", GetPersonalityMajorCivApproachBias(eMajorCivApproach));
			strOutBuf += ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		MinorCivApproachTypes eMinorCivApproach;

		// Loop through all Approaches to see what this player's bias is
		for(int iApproachLoop = 0; iApproachLoop < NUM_MINOR_CIV_APPROACHES; iApproachLoop++)
		{
			eMinorCivApproach = (MinorCivApproachTypes) iApproachLoop;

			switch(eMinorCivApproach)
			{
			case MINOR_CIV_APPROACH_IGNORE:
				strTemp.Format("Ignore");
				break;
			case MINOR_CIV_APPROACH_FRIENDLY:
				strTemp.Format("Friendly");
				break;
			case MINOR_CIV_APPROACH_PROTECTIVE:
				strTemp.Format("Protective");
				break;
			case MINOR_CIV_APPROACH_CONQUEST:
				strTemp.Format("Conquest");
				break;
			case MINOR_CIV_APPROACH_BULLY:
				strTemp.Format("Bully");
				break;
			default:
				strTemp.Format("XXX");
				break;
			}
			strOutBuf = strBaseString + ", " + strTemp;

			strTemp.Format("%d", GetPersonalityMinorCivApproachBias(eMinorCivApproach));
			strOutBuf += ", " + strTemp;
			pLog->Msg(strOutBuf);
		}

		strTemp.Format("VICTORY COMPETITIVENESS, %d", GetVictoryCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("WONDER COMPETITIVENESS, %d", GetWonderCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("MINOR CIV COMPETITIVENESS, %d", GetMinorCivCompetitiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("BOLDNESS, %d", GetBoldness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DIPLO BALANCE, %d", GetDiploBalance());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("WARMONGER HATE, %d", GetWarmongerHate());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DENOUNCE, %d", GetDenounceWillingness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("DoF, %d", GetDoFWillingness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("LOYALTY, %d", GetLoyalty());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("NEEDINESS, %d", GetNeediness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("FORGIVENESS, %d", GetForgiveness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("CHATTINESS, %d", GetChattiness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);

		strTemp.Format("MEANNESS, %d", GetMeanness());
		strOutBuf = strBaseString + ", " + strTemp;
		pLog->Msg(strOutBuf);
	}
}

/// Log diplomatic status with other Players
void CvDiplomacyAI::LogStatus()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		int iPlayerLoop;
		PlayerTypes eLoopPlayer;

		// Loop through all (known) Players
		for(iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				strOutBuf = strBaseString;

				LogGrandStrategy(strOutBuf);

				// Name
				if(GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					strMinorString = "--- ";
				}

				otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
				strOutBuf += ", " + strMinorString + otherPlayerName;

				// Major Civ
				if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					if(IsDoFAccepted(eLoopPlayer))
						strOutBuf += ", WW";
					else
						strOutBuf += ", ";

					if(IsDenouncedPlayer(eLoopPlayer))
						strOutBuf += ", DEN";
					else
						strOutBuf += ", ";
#if defined(MOD_BALANCE_CORE)
					if(IsAtWar(eLoopPlayer))
						strOutBuf += ", AT WAR";
					else
						strOutBuf += ", ";
#endif

					//if (IsWorkingAgainstPlayer(eLoopPlayer))
					//	strOutBuf += ", WA";
					//else
					//	strOutBuf += ", ";

					if(GetGlobalCoopWarAcceptedState(eLoopPlayer) == COOP_WAR_STATE_ACCEPTED)
						strOutBuf += ", CW";
					else if(GetGlobalCoopWarAcceptedState(eLoopPlayer) == COOP_WAR_STATE_SOON)
						strOutBuf += ", CWS";
					else
						strOutBuf += ", ";

					LogMajorCivApproach(strOutBuf, GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false), GetWarFaceWithPlayer(eLoopPlayer));
					LogOpinion(strOutBuf, eLoopPlayer);
				}
				// Minor Civ
				else
				{
					strOutBuf += ", ";		// Working With
					strOutBuf += ", ";		// Working Against
					strOutBuf += ", ";		// Coop War

					LogMinorCivApproach(strOutBuf, GetMinorCivApproach(eLoopPlayer));
					strOutBuf += ", ";		// Opinion
				}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				//if (MOD_DIPLOMACY_CIV4_FEATURES) {
				//	LogGlobalState(strOutBuf, eLoopPlayer);
				//}
#endif

				LogProximity(strOutBuf, eLoopPlayer);

				LogWarState(strOutBuf, eLoopPlayer);

				LogEconomicStrength(strOutBuf, eLoopPlayer);

				LogMilitaryStrength(strOutBuf, eLoopPlayer);
				LogTargetValue(strOutBuf, eLoopPlayer);
				LogWarProjection(strOutBuf, eLoopPlayer);
				LogMilitaryAggressivePosture(strOutBuf, eLoopPlayer);
				LogWarmongerThreat(strOutBuf, eLoopPlayer);
				LogMilitaryThreat(strOutBuf, eLoopPlayer);

				LogExpansionAggressivePosture(strOutBuf, eLoopPlayer);
				LogPlotBuyingAggressivePosture(strOutBuf, eLoopPlayer);
				LogLandDispute(strOutBuf, eLoopPlayer);
				LogVictoryDispute(strOutBuf, eLoopPlayer);
				LogWonderDispute(strOutBuf, eLoopPlayer);
				LogMinorCivDispute(strOutBuf, eLoopPlayer);

				// Other Player's Estimated Grand Strategy
				if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					AIGrandStrategyTypes eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer);

					CvAIGrandStrategyXMLEntry* pEntry = (eGrandStrategy != NO_AIGRANDSTRATEGY)? GC.getAIGrandStrategyInfo(eGrandStrategy) : NULL;
					if(pEntry != NULL)
					{
						strTemp.Format("GSS %s", pEntry->GetType());
						strOutBuf += ", " + strTemp;

						// Confidence in our guess
						switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
						{
						case GUESS_CONFIDENCE_POSITIVE:
							strTemp.Format("POSITIVE");
							break;
						case GUESS_CONFIDENCE_LIKELY:
							strTemp.Format("Likely");
							break;
						case GUESS_CONFIDENCE_UNSURE:
							strTemp.Format("Unsure");
							break;
						default:
							strTemp.Format("XXX");
							break;
						}
					}
					else
					{
						strTemp.Format("No GS Guess, ");
					}
				}
				else
				{
					strTemp.Format(", ");
				}
				strOutBuf += ", " + strTemp;

				pLog->Msg(strOutBuf);
			}
		}
	}
}


/// Log Diplomatic War status with other Players
void CvDiplomacyAI::LogWarStatus()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_War_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_War_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		int iPlayerLoop;
		PlayerTypes eLoopPlayer;

		bool bLogPlayer;

		// Loop through all (known) Players
		for(iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				if(IsAtWar(eLoopPlayer))
				{
					bLogPlayer = true;
				}
				else if(GetWarState(eLoopPlayer) != NO_WAR_STATE_TYPE)
				{
					bLogPlayer = true;
				}
				else if(GetWarGoal(eLoopPlayer) != NO_WAR_GOAL_TYPE)
				{
					bLogPlayer = true;
				}
				else
				{
					bLogPlayer = false;
				}

				// Should we actually record a log entry for this player?
				if(bLogPlayer)
				{
					strOutBuf = strBaseString;

					// Name
					if(GET_PLAYER(eLoopPlayer).isMinorCiv())
					{
						strMinorString = "--- ";
					}

					otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();
					strOutBuf += ", " + strMinorString + otherPlayerName;

					// Approach
					if(GET_PLAYER(eLoopPlayer).isMinorCiv())
					{
						if(GetMinorCivApproach(eLoopPlayer) == MINOR_CIV_APPROACH_CONQUEST)
						{
							strOutBuf += ", APP: CONQUEST";
						}
						else
						{
							strOutBuf += ", APP: o";
						}
					}
					else
					{
						if(GetMajorCivApproach(eLoopPlayer, false) == MAJOR_CIV_APPROACH_WAR)
						{
							strOutBuf += ", APP: WAR";
						}
						else
						{
							strOutBuf += ", APP: o";
						}
					}

					// Wants to conquer the world?
					if(IsGoingForWorldConquest())
					{
						strOutBuf += ", WC";
					}
					else
					{
						strOutBuf += ", ";
					}

					// Wants peace with eLoopPlayer?
					if(!GET_PLAYER(eLoopPlayer).isMinorCiv() && IsWantsPeaceWithPlayer(eLoopPlayer))
					{
						strOutBuf += ", Wants Peace!!!";
					}
					else
					{
						strOutBuf += ", ";
					}

					LogWarGoal(strOutBuf, eLoopPlayer);
					LogWarState(strOutBuf, eLoopPlayer);
					LogWarProjection(strOutBuf, eLoopPlayer);

					LogWarPeaceWillingToOffer(strOutBuf, eLoopPlayer);
					LogWarPeaceWillingToAccept(strOutBuf, eLoopPlayer);

					// # of turns at War
					if(GetPlayerNumTurnsAtWar(eLoopPlayer) > 0)
					{
						strTemp.Format("%d", GetPlayerNumTurnsAtWar(eLoopPlayer));
						strOutBuf += ", " + strTemp;
					}
					else
					{
						strOutBuf += ", ";
					}

					LogWarDamage(strOutBuf, eLoopPlayer);

					LogMilitaryThreat(strOutBuf, eLoopPlayer);

					LogProximity(strOutBuf, eLoopPlayer);
					LogTargetValue(strOutBuf, eLoopPlayer);

					LogMilitaryStrength(strOutBuf, eLoopPlayer);
					LogEconomicStrength(strOutBuf, eLoopPlayer);

#if defined(MOD_BALANCE_CORE)
					if(!GET_PLAYER(eLoopPlayer).isMinorCiv() && IsAtWar(eLoopPlayer))
					{
						strTemp.Format("   !!!!WAR SCORE: %d !!!! ", GetWarScore(eLoopPlayer));
						strOutBuf += ", " + strTemp;
					}

					strTemp.Format(" ---  War Weariness: %d, Supply: %d", m_pPlayer->GetCulture()->GetWarWeariness(), m_pPlayer->GetNumUnitsSupplied());
					strOutBuf += ", " + strTemp;
#endif
					pLog->Msg(strOutBuf);
				}
			}
		}
	}
}


/// Log Statements, to make sure our record is solid
void CvDiplomacyAI::LogStatements()
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strMinorString;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Statement_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Statement_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		int iPlayerLoop;
		PlayerTypes eLoopPlayer;

		CvString strStatementLine;

		int iItem;
		DiploStatementTypes eStatement;
		int iTurn;

		// Loop through all (known) Players
		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();

				// Diplo Statement Log Counter
				for(iItem = 0; iItem < MAX_DIPLO_LOG_STATEMENTS; iItem++)
				{
					eStatement = GetDiploLogStatementTypeForIndex(eLoopPlayer, iItem);

					if(eStatement != NO_DIPLO_STATEMENT_TYPE)
					{
						iTurn = GetDiploLogStatementTurnForIndex(eLoopPlayer, iItem);

						strStatementLine.Format(", Statement: %d, Index: %d, Turn %d", eStatement, iItem, iTurn);

						strOutBuf = strBaseString;

						strOutBuf += ", " + otherPlayerName;
						strOutBuf += strStatementLine;

						pLog->Msg(strOutBuf);
					}
				}
			}
		}
	}
}

/// Log our guess as to another player's Expansion Flavor
void CvDiplomacyAI::LogOtherPlayerExpansionGuess(PlayerTypes ePlayer, int iGuess)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Guess_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Guess_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + "EXPANSION, " + otherPlayerName;

		CvString strExpansionGuess;
		strExpansionGuess.Format(", %d", iGuess);
		strOutBuf += strExpansionGuess;

		pLog->Msg(strOutBuf);
	}
}

/// Log our guesses as to what other players are up to
void CvDiplomacyAI::LogOtherPlayerGuessStatus()
{
	if((int)m_eTargetPlayer >= (int)DIPLO_FIRST_PLAYER)
		return;

	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString thirdPlayerName;
		CvString strOtherPlayerGrandStrategy;
		CvString strThirdPlayerGrandStrategy;
		CvString strDesc;
		CvString strLogName;
		CvString strTemp;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Guess_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Guess_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName;

		AIGrandStrategyTypes eGrandStrategy;

		int iPlayerLoop;
		PlayerTypes eLoopPlayer;
		int iOtherPlayerLoop;
		PlayerTypes eLoopOtherPlayer;

		// Loop through all (known) Players
		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(IsPlayerValid(eLoopPlayer))
			{
				otherPlayerName = GET_PLAYER(eLoopPlayer).getCivilizationShortDescription();

				eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopPlayer);

				CvAIGrandStrategyXMLEntry* pEntry = (eGrandStrategy != NO_AIGRANDSTRATEGY)? GC.getAIGrandStrategyInfo(eGrandStrategy) : NULL;
				if(pEntry != NULL)
				{
					strTemp.Format("%s", pEntry->GetType());
					strOtherPlayerGrandStrategy = strTemp;

					// Confidence in our guess
					switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopPlayer))
					{
					case GUESS_CONFIDENCE_POSITIVE:
						strTemp.Format("POSITIVE");
						break;
					case GUESS_CONFIDENCE_LIKELY:
						strTemp.Format("Likely");
						break;
					case GUESS_CONFIDENCE_UNSURE:
						strTemp.Format("unsure");
						break;
					default:
						strTemp.Format("ConfidenceUnknown");
						break;
					}

					strOtherPlayerGrandStrategy += ", " + strTemp;
				}
				else
				{
					strOtherPlayerGrandStrategy.Format("No GS Guess, ");
				}

				// Now loop through other players this guy knows
				for(iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
				{
					eLoopOtherPlayer = (PlayerTypes) iOtherPlayerLoop;

					// Don't check a player against himself
					if(eLoopPlayer != eLoopOtherPlayer)
					{
						// Do both we and the guy we're looking at know the third guy?
						if(IsPlayerValid(eLoopOtherPlayer, true) && GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerValid(eLoopOtherPlayer))
						{
							thirdPlayerName = GET_PLAYER(eLoopOtherPlayer).getCivilizationShortDescription();

							eGrandStrategy = GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eLoopOtherPlayer);
							if(eGrandStrategy != NO_AIGRANDSTRATEGY)
							{
								strTemp.Format("%s", GC.getAIGrandStrategyInfo(eGrandStrategy)->GetType());
								strThirdPlayerGrandStrategy = strTemp;

								// Confidence in our guess
								switch(GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategyConfidence(eLoopOtherPlayer))
								{
								case GUESS_CONFIDENCE_POSITIVE:
									strTemp.Format("Positive");
									break;
								case GUESS_CONFIDENCE_LIKELY:
									strTemp.Format("Likely");
									break;
								case GUESS_CONFIDENCE_UNSURE:
									strTemp.Format("Unsure");
									break;
								default:
									strTemp.Format("ConfidenceUnknown");
									break;
								}

								strThirdPlayerGrandStrategy += ", " + strTemp;
							}
							else
							{
								strThirdPlayerGrandStrategy.Format("No GS Guess, ");
							}

							strOutBuf = strBaseString + ", " + otherPlayerName + ", " + strOtherPlayerGrandStrategy + ", " + thirdPlayerName + ", " + strThirdPlayerGrandStrategy;

							// Overall Opinion
							switch(GetMajorCivOtherPlayerOpinion(eLoopPlayer, eLoopOtherPlayer))
							{
							case MAJOR_CIV_OPINION_ALLY:
								strTemp.Format("OPN **ALLY**");
								break;
							case MAJOR_CIV_OPINION_FRIEND:
								strTemp.Format("OPN FRIEND");
								break;
							case MAJOR_CIV_OPINION_FAVORABLE:
								strTemp.Format("OPN Favorable");
								break;
							case MAJOR_CIV_OPINION_NEUTRAL:
								strTemp.Format("OPN N");
								break;
							case MAJOR_CIV_OPINION_COMPETITOR:
								strTemp.Format("OPN Competitor");
								break;
							case MAJOR_CIV_OPINION_ENEMY:
								strTemp.Format("OPN ENEMY");
								break;
							case MAJOR_CIV_OPINION_UNFORGIVABLE:
								strTemp.Format("OPN **UNFORGIVABLE**");
								break;
							default:
								strTemp.Format("OPN Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							// Military Threat
							switch(GetEstimateOtherPlayerMilitaryThreat(eLoopPlayer, eLoopOtherPlayer))
							{
							case THREAT_CRITICAL:
								strTemp.Format("M_THT **CRITICAL**");
								break;
							case THREAT_SEVERE:
								strTemp.Format("M_THT SEVERE");
								break;
							case THREAT_MAJOR:
								strTemp.Format("M_THT Major");
								break;
							case THREAT_MINOR:
								strTemp.Format("M_THT mnr");
								break;
							case THREAT_NONE:
								strTemp.Format("M_THT N");
								break;
							default:
								strTemp.Format("M_THT Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							// War Damage
#if defined(MOD_BALANCE_CORE)
							switch(GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetWarDamageLevel(eLoopOtherPlayer))
#else
							switch(GetOtherPlayerWarDamageLevel(eLoopPlayer, eLoopOtherPlayer))
#endif
							{
							case WAR_DAMAGE_LEVEL_CRIPPLED:
								strTemp.Format("W_DMG **CRIPPLED*");
								break;
							case WAR_DAMAGE_LEVEL_SERIOUS:
								strTemp.Format("W_DMG SERIOUS");
								break;
							case WAR_DAMAGE_LEVEL_MAJOR:
								strTemp.Format("W_DMG Major");
								break;
							case WAR_DAMAGE_LEVEL_MINOR:
								strTemp.Format("W_DMG mnr");
								break;
							case WAR_DAMAGE_LEVEL_NONE:
								strTemp.Format("W_DMG None");
								break;
							default:
								strTemp.Format("W_DMG Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							// Proximity
							switch(GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eLoopOtherPlayer))
							{
							case PLAYER_PROXIMITY_NEIGHBORS:
								strTemp.Format("PRX Neighbors");
								break;
							case PLAYER_PROXIMITY_CLOSE:
								strTemp.Format("PRX Close");
								break;
							case PLAYER_PROXIMITY_FAR:
								strTemp.Format("PRX Far");
								break;
							case PLAYER_PROXIMITY_DISTANT:
								strTemp.Format("PRX Distant");
								break;
							default:
								strTemp.Format("PRX Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							// Land Dispute
							switch(GetEstimateOtherPlayerLandDisputeLevel(eLoopPlayer, eLoopOtherPlayer))
							{
							case DISPUTE_LEVEL_FIERCE:
								strTemp.Format("LND **FIERCE**");
								break;
							case DISPUTE_LEVEL_STRONG:
								strTemp.Format("LND STRONG");
								break;
							case DISPUTE_LEVEL_WEAK:
								strTemp.Format("LND Weak");
								break;
							case DISPUTE_LEVEL_NONE:
								strTemp.Format("LND N");
								break;
							default:
								strTemp.Format("LND Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							// Victory Dispute
							switch(GetEstimateOtherPlayerVictoryDisputeLevel(eLoopPlayer, eLoopOtherPlayer))
							{
							case DISPUTE_LEVEL_FIERCE:
								strTemp.Format("VCT **FIERCE**");
								break;
							case DISPUTE_LEVEL_STRONG:
								strTemp.Format("VCT STRONG");
								break;
							case DISPUTE_LEVEL_WEAK:
								strTemp.Format("VCT Weak");
								break;
							case DISPUTE_LEVEL_NONE:
								strTemp.Format("VCT N");
								break;
							default:
								strTemp.Format("VCT Unknown");
								break;
							}
							strOutBuf += ", " + strTemp;

							pLog->Msg(strOutBuf);
						}
					}
				}
			}
		}
	}
}

/// Log Grand Strategy
void CvDiplomacyAI::LogGrandStrategy(CvString& strString)
{
	CvString strTemp;

	AIGrandStrategyTypes eGrandStrategy =GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy();

	if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))
	{
		strTemp.Format("Conquest");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))
	{
		strTemp.Format("Spaceship");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))
	{
		strTemp.Format("Diplomacy");
	}
	else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))
	{
		strTemp.Format("Culture");
	}

	strString += ", " + strTemp;
}

/// Log Current Approach towards Major
void CvDiplomacyAI::LogMajorCivApproach(CvString& strString, MajorCivApproachTypes eNewMajorCivApproach, WarFaceTypes eNewWarFace)
{
	CvString strTemp;

	switch(eNewMajorCivApproach)
	{
	case MAJOR_CIV_APPROACH_WAR:
		switch(eNewWarFace)
		{
		case WAR_FACE_HOSTILE:
			strTemp.Format("**WAR_HOSTILE**");
			break;
		case WAR_FACE_NEUTRAL:
			strTemp.Format("**WAR_NEUTRAL**");
			break;
		case WAR_FACE_FRIENDLY:
			strTemp.Format("**WAR_FRIENDLY**");
			break;
		case WAR_FACE_GUARDED:
			strTemp.Format("**WAR_GUARDED**");
			break;
		default:
			strTemp.Format("**WAR**");
			break;
		}
		break;
	case MAJOR_CIV_APPROACH_HOSTILE:
		strTemp.Format("HOSTILE");
		break;
	case MAJOR_CIV_APPROACH_DECEPTIVE:
		strTemp.Format("DECEPTIVE");
		break;
	case MAJOR_CIV_APPROACH_GUARDED:
		strTemp.Format("GUARDED");
		break;
	case MAJOR_CIV_APPROACH_AFRAID:
		strTemp.Format("AFRAID");
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		strTemp.Format("FRIENDLY");
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		strTemp.Format("N");
		break;
	default:
		strTemp.Format("ApproachUnknown");
		break;
	}
	strString += ", " + strTemp;
}


/// Log Current Approach towards Minor
void CvDiplomacyAI::LogMinorCivApproach(CvString& strString, MinorCivApproachTypes eNewMinorCivApproach)
{
	CvString strTemp;

	switch(eNewMinorCivApproach)
	{
	case MINOR_CIV_APPROACH_IGNORE:
		strTemp.Format("IG");
		break;
	case MINOR_CIV_APPROACH_FRIENDLY:
		strTemp.Format("FRIENDLY");
		break;
	case MINOR_CIV_APPROACH_PROTECTIVE:
		strTemp.Format("PROTECTIVE");
		break;
	case MINOR_CIV_APPROACH_CONQUEST:
		strTemp.Format("**CONQUEST**");
		break;
	case MINOR_CIV_APPROACH_BULLY:
		strTemp.Format("BULLY");
		break;
	default:
		strTemp.Format("ApproachUnknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log a quest from a Minor
void CvDiplomacyAI::LogMinorCivQuestType(CvString& strString, MinorCivQuestTypes eQuestType)
{
	CvString strTemp;

	switch(eQuestType)
	{
	case MINOR_CIV_QUEST_ROUTE:
		strTemp.Format("Route");
		break;
	case MINOR_CIV_QUEST_KILL_CAMP:
		strTemp.Format("Kill Camp");
		break;
	case MINOR_CIV_QUEST_CONNECT_RESOURCE:
		strTemp.Format("Connect Resource");
		break;
	case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
		strTemp.Format("Construct Wonder");
		break;
	case MINOR_CIV_QUEST_GREAT_PERSON:
		strTemp.Format("Great Person");
		break;
	case MINOR_CIV_QUEST_KILL_CITY_STATE:
		strTemp.Format("Kill City State");
		break;
	case MINOR_CIV_QUEST_FIND_PLAYER:
		strTemp.Format("Find Player");
		break;
	case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
		strTemp.Format("Find Natural Wonder");
		break;
	case MINOR_CIV_QUEST_GIVE_GOLD:
		strTemp.Format("Give Gold");
		break;
	case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
		strTemp.Format("Pledge to Protect");
		break;
	case MINOR_CIV_QUEST_CONTEST_CULTURE:
		strTemp.Format("Contest Culture");
		break;
	case MINOR_CIV_QUEST_CONTEST_FAITH:
		strTemp.Format("Contest Faith");
		break;
	case MINOR_CIV_QUEST_CONTEST_TECHS:
		strTemp.Format("Contest Techs");
		break;
	case MINOR_CIV_QUEST_INVEST:
		strTemp.Format("Invest");
		break;
	case MINOR_CIV_QUEST_BULLY_CITY_STATE:
		strTemp.Format("Bully City-State");
		break;
	case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
		strTemp.Format("Denounce Major");
		break;
	case MINOR_CIV_QUEST_SPREAD_RELIGION:
		strTemp.Format("Spread Religion");
		break;
	case MINOR_CIV_QUEST_TRADE_ROUTE:
		strTemp.Format("Trade Route");
		break;
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
	case MINOR_CIV_QUEST_WAR:
		strTemp.Format("Declare War on Major");
		break;
	case MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER:
		strTemp.Format("Construct National Wonder");
		break;
	case MINOR_CIV_QUEST_FIND_CITY_STATE:
		strTemp.Format("Find City State");
		break;
	case MINOR_CIV_QUEST_INFLUENCE:
		strTemp.Format("Influence");
		break;
	case MINOR_CIV_QUEST_CONTEST_TOURISM:
		strTemp.Format("Contest Tourism");
		break;
	case MINOR_CIV_QUEST_ARCHAEOLOGY:
		strTemp.Format("Archaeology");
		break;
	case MINOR_CIV_QUEST_CIRCUMNAVIGATION:
		strTemp.Format("Circumnavigation");
		break;
	case MINOR_CIV_QUEST_LIBERATION:
		strTemp.Format("Liberation");
		break;
	case MINOR_CIV_QUEST_HORDE:
		strTemp.Format("Horde");
		break;
	case MINOR_CIV_QUEST_REBELLION:
		strTemp.Format("Rebellion");
		break;
	case MINOR_CIV_QUEST_DISCOVER_PLOT:
		strTemp.Format("Discover a Plot");
		break;
	case MINOR_CIV_QUEST_BUILD_X_BUILDINGS:
		strTemp.Format("Build X Buildings");
		break;
	case MINOR_CIV_QUEST_UNIT_STEAL_FROM:
		strTemp.Format("Steal From");
		break;
	case MINOR_CIV_QUEST_UNIT_COUP_CITY:
		strTemp.Format("Coup City");
		break;
	case MINOR_CIV_QUEST_UNIT_GET_CITY:
		strTemp.Format("Conquer a City");
		break;
#endif
	default:
		strTemp.Format("Quest_Unknown");
		break;
	}

	strString += ", " + strTemp;
}

/// Log Current Opinion of Major
void CvDiplomacyAI::LogOpinion(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Opinion
	switch(GetMajorCivOpinion(ePlayer))
	{
	case MAJOR_CIV_OPINION_ALLY:
		strTemp.Format("OPN **ALLY**");
		break;
	case MAJOR_CIV_OPINION_FRIEND:
		strTemp.Format("OPN FRIEND");
		break;
	case MAJOR_CIV_OPINION_FAVORABLE:
		strTemp.Format("OPN Favorable");
		break;
	case MAJOR_CIV_OPINION_NEUTRAL:
		strTemp.Format("OPN N");
		break;
	case MAJOR_CIV_OPINION_COMPETITOR:
		strTemp.Format("OPN Competitor");
		break;
	case MAJOR_CIV_OPINION_ENEMY:
		strTemp.Format("OPN ENEMY");
		break;
	case MAJOR_CIV_OPINION_UNFORGIVABLE:
		strTemp.Format("OPN **UNFORGIVABLE**");
		break;
	default:
		strTemp.Format("OPN Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Warmonger Threat
void CvDiplomacyAI::LogWarmongerThreat(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format(",");
	}
	else
	{
		switch(GetWarmongerThreat(ePlayer))
		{
		case THREAT_CRITICAL:
			strTemp.Format("W_THT CRIT, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_SEVERE:
			strTemp.Format("W_THT SEVR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_MAJOR:
			strTemp.Format("W_THT MAJR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_MINOR:
			strTemp.Format("W_THT MINR, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		case THREAT_NONE:
			strTemp.Format("W_THT NONE, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		default:
			strTemp.Format("W_THT XXXX, %d/%d", GetOtherPlayerWarmongerAmount(ePlayer), GetOtherPlayerWarmongerScore(ePlayer));
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Military Threat
void CvDiplomacyAI::LogMilitaryThreat(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		switch(GetMilitaryThreat(ePlayer))
		{
		case THREAT_CRITICAL:
			strTemp.Format("M_THT **CRITICAL**");
			break;
		case THREAT_SEVERE:
			strTemp.Format("M_THT SEVERE");
			break;
		case THREAT_MAJOR:
			strTemp.Format("M_THT Major");
			break;
		case THREAT_MINOR:
			strTemp.Format("M_THT mnr");
			break;
		case THREAT_NONE:
			strTemp.Format("M_THT N");
			break;
		default:
			strTemp.Format("M_THT Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Military Strength
void CvDiplomacyAI::LogMilitaryStrength(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Military Strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
		strTemp.Format("MSTR **IMMENSE**");
		break;
	case STRENGTH_POWERFUL:
		strTemp.Format("MSTR POWERFUL");
		break;
	case STRENGTH_STRONG:
		strTemp.Format("MSTR Strong");
		break;
	case STRENGTH_AVERAGE:
		strTemp.Format("MSTR A");
		break;
	case STRENGTH_POOR:
		strTemp.Format("MSTR Poor");
		break;
	case STRENGTH_WEAK:
		strTemp.Format("MSTR WEAK");
		break;
	case STRENGTH_PATHETIC:
		strTemp.Format("MSTR **PATHETIC**");
		break;
	default:
		strTemp.Format("MSTR Unknown");
		break;
	}
	strString += ", " + strTemp;

}

/// Log Economic Strength
void CvDiplomacyAI::LogEconomicStrength(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Economic Strength
	switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
	{
	case STRENGTH_IMMENSE:
		strTemp.Format("ESTR **IMMENSE**");
		break;
	case STRENGTH_POWERFUL:
		strTemp.Format("ESTR POWERFUL");
		break;
	case STRENGTH_STRONG:
		strTemp.Format("ESTR Strong");
		break;
	case STRENGTH_AVERAGE:
		strTemp.Format("ESTR Avg");
		break;
	case STRENGTH_POOR:
		strTemp.Format("ESTR Poor");
		break;
	case STRENGTH_WEAK:
		strTemp.Format("ESTR Weak");
		break;
	case STRENGTH_PATHETIC:
		strTemp.Format("ESTR Pathetic");
		break;
	default:
		strTemp.Format("ESTR Unknown");
		break;
	}
	strString += ", " + strTemp;

}

/// Log Target Value
void CvDiplomacyAI::LogTargetValue(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Target Value
	switch (GetPlayerTargetValue(ePlayer))
	{
	case TARGET_VALUE_IMPOSSIBLE:
		strTemp.Format("TGT Impossible");
		break;
	case TARGET_VALUE_BAD:
		strTemp.Format("TGT Bad");
		break;
	case TARGET_VALUE_AVERAGE:
		strTemp.Format("TGT Avg");
		break;
	case TARGET_VALUE_FAVORABLE:
		strTemp.Format("TGT Favorable");
		break;
	case TARGET_VALUE_SOFT:
		strTemp.Format("TGT Soft");
		break;
	default:
		strTemp.Format("TGT Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log War Goal
void CvDiplomacyAI::LogWarGoal(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Goal
	switch(GetWarGoal(ePlayer))
	{
	case WAR_GOAL_DEMAND:
		strTemp.Format("WGL Demand");
		break;
	case WAR_GOAL_PREPARE:
		strTemp.Format("WGL Preparing");
		break;
	case WAR_GOAL_CONQUEST:
		strTemp.Format("WGL Conquest");
		break;
	case WAR_GOAL_DAMAGE:
		strTemp.Format("WGL Damage");
		break;
	case WAR_GOAL_PEACE:
		strTemp.Format("WGL PEACE");
		break;
	default:
		if(IsAtWar(ePlayer))
		{
			strTemp.Format("WGL Unknown");
		}
		else
		{
			strTemp.Format("WGL None");
		}
		break;
	}
	strString += ", " + strTemp;
}

/// Log Peace Treaty Willing to Offer
void CvDiplomacyAI::LogWarPeaceWillingToOffer(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// No Minor Civs
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// War Goal
		switch(GetTreatyWillingToOffer(ePlayer))
		{
		case NO_PEACE_TREATY_TYPE:
			strTemp.Format("");
			break;
		case PEACE_TREATY_WHITE_PEACE:
			strTemp.Format("PeaceOff WhitePeace(0)");
			break;
		case PEACE_TREATY_ARMISTICE:
			strTemp.Format("PeaceOff Armistice(1)");
			break;
		case PEACE_TREATY_SETTLEMENT:
			strTemp.Format("PeaceOff Settlement(2)");
			break;
		case PEACE_TREATY_BACKDOWN:
			strTemp.Format("PeaceOff Backdown(3)");
			break;
		case PEACE_TREATY_SUBMISSION:
			strTemp.Format("PeaceOff Submission(4)");
			break;
		case PEACE_TREATY_SURRENDER:
			strTemp.Format("PeaceOff Surrender(5)");
			break;
		case PEACE_TREATY_CESSION:
			strTemp.Format("PeaceOff Cession(6)");
			break;
		case PEACE_TREATY_CAPITULATION:
			strTemp.Format("PeaceOff CAPITULATION(7)");
			break;
		case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
			strTemp.Format("PeaceOff **SURRENDER(8)**");
			break;
		default:
			strTemp.Format("PeaceOff Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Peace Treaty Willing to Accept
void CvDiplomacyAI::LogWarPeaceWillingToAccept(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// No Minor Civs
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// War Goal
		switch(GetTreatyWillingToAccept(ePlayer))
		{
		case NO_PEACE_TREATY_TYPE:
			strTemp.Format("");
			break;
		case PEACE_TREATY_WHITE_PEACE:
			strTemp.Format("PeaceAcc WhitePeace(0)");
			break;
		case PEACE_TREATY_ARMISTICE:
			strTemp.Format("PeaceAcc Armistice(1)");
			break;
		case PEACE_TREATY_SETTLEMENT:
			strTemp.Format("PeaceAcc Settlement(2)");
			break;
		case PEACE_TREATY_BACKDOWN:
			strTemp.Format("PeaceAcc Backdown(3)");
			break;
		case PEACE_TREATY_SUBMISSION:
			strTemp.Format("PeaceAcc Submission(4)");
			break;
		case PEACE_TREATY_SURRENDER:
			strTemp.Format("PeaceAcc Surrender(5)");
			break;
		case PEACE_TREATY_CESSION:
			strTemp.Format("PeaceAcc Cession(6)");
			break;
		case PEACE_TREATY_CAPITULATION:
			strTemp.Format("PeaceAcc CAPITULATION(7)");
			break;
		case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
			strTemp.Format("PeaceAcc **SURRENDER(8)**");
			break;
		default:
			strTemp.Format("PeaceAcc Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}


/// Log War State
void CvDiplomacyAI::LogWarState(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	bool bShowOperationProgress = false;

	// Log progress towards Sneak Attack Operation launch if we're not yet at war
	if(GetWarGoal(ePlayer) == WAR_GOAL_PREPARE)
	{
		CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetSneakAttackOperation(ePlayer);

		if(pOperation)
		{
			bShowOperationProgress = true;
			int iOperationPercentMustered = pOperation->PercentFromMusterPointToTarget();

			if(iOperationPercentMustered > 0)
			{
				strTemp.Format("PREP PRGS %2d", iOperationPercentMustered);
			}
			else
			{
				strTemp.Format("PREP Gathering");
			}
		}
	}
	// Preparing a demand?
	if(GetWarGoal(ePlayer) == WAR_GOAL_DEMAND)
	{
		CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetShowOfForceOperation(ePlayer);

		if(pOperation)
		{
			bShowOperationProgress = true;
			int iOperationPercentMustered = pOperation->PercentFromMusterPointToTarget();

			if(iOperationPercentMustered > 0)
			{
				strTemp.Format("DMND PRGS %2d", iOperationPercentMustered);
			}
			else
			{
				strTemp.Format("DMND Gathering");
			}
		}
	}

	if(!bShowOperationProgress)
	{
		// War State
		switch(GetWarState(ePlayer))
		{
		case WAR_STATE_CALM:
			strTemp.Format("WST Calm");
			break;
		case WAR_STATE_NEARLY_WON:
			strTemp.Format("WST Nearly Won");
			break;
		case WAR_STATE_OFFENSIVE:
			strTemp.Format("WST Offensive");
			break;
		case WAR_STATE_STALEMATE:
			strTemp.Format("WST Stalemate");
			break;
		case WAR_STATE_DEFENSIVE:
			strTemp.Format("WST DEFENSIVE");
			break;
		case WAR_STATE_NEARLY_DEFEATED:
			strTemp.Format("WST **NEARLY DEFEATED**");
			break;
		default:
			if(IsAtWar(ePlayer))
			{
				strTemp.Format("WST Unknown");
			}
			else
			{
				strTemp.Format("WST None");
			}
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log War Projection
void CvDiplomacyAI::LogWarProjection(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Projection
	switch(GetWarProjection(ePlayer))
	{
	case WAR_PROJECTION_DESTRUCTION:
		strTemp.Format("W_PRJ **DESTRUCTION**");
		break;
	case WAR_PROJECTION_DEFEAT:
		strTemp.Format("W_PRJ DEFEAT");
		break;
	case WAR_PROJECTION_STALEMATE:
		strTemp.Format("W_PRJ Stalemate");
		break;
	case WAR_PROJECTION_UNKNOWN:
		strTemp.Format("W_PRJ U");
		break;
	case WAR_PROJECTION_GOOD:
		strTemp.Format("W_PRJ GOOD");
		break;
	case WAR_PROJECTION_VERY_GOOD:
		strTemp.Format("W_PRJ ** VERY GOOD **");
		break;
	default:
		strTemp.Format("W_PRJ Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log War Damage
void CvDiplomacyAI::LogWarDamage(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// War Damage
	switch(GetWarDamageLevel(ePlayer))
	{
	case WAR_DAMAGE_LEVEL_CRIPPLED:
		strTemp.Format("W_DMG **CRIPPLED**");
		break;
	case WAR_DAMAGE_LEVEL_SERIOUS:
		strTemp.Format("W_DMG SERIOUS");
		break;
	case WAR_DAMAGE_LEVEL_MAJOR:
		strTemp.Format("W_DMG Major");
		break;
	case WAR_DAMAGE_LEVEL_MINOR:
		strTemp.Format("W_DMG mnr");
		break;
	case WAR_DAMAGE_LEVEL_NONE:
		strTemp.Format("W_DMG None");
		break;
	default:
		strTemp.Format("W_DMG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Military Aggressive Posture
void CvDiplomacyAI::LogMilitaryAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Military Aggressive Posture
	switch(GetMilitaryAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("MAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("MAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("MAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("MAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("MAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("MAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Expansion Aggressive Posture
void CvDiplomacyAI::LogExpansionAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Expansion Aggressive Posture
	switch(GetExpansionAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("EAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("EAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("EAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("EAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("EAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("EAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Plot Buying Aggressive Posture
void CvDiplomacyAI::LogPlotBuyingAggressivePosture(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Plot Buying Aggressive Posture
	switch(GetPlotBuyingAggressivePosture(ePlayer))
	{
	case AGGRESSIVE_POSTURE_NONE:
		strTemp.Format("BAGG None");
		break;
	case AGGRESSIVE_POSTURE_LOW:
		strTemp.Format("BAGG Low");
		break;
	case AGGRESSIVE_POSTURE_MEDIUM:
		strTemp.Format("BAGG Medium");
		break;
	case AGGRESSIVE_POSTURE_HIGH:
		strTemp.Format("BAGG HIGH");
		break;
	case AGGRESSIVE_POSTURE_INCREDIBLE:
		strTemp.Format("BAGG **INCREDIBLE**");
		break;
	default:
		strTemp.Format("BAGG Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// Log Land Dispute
void CvDiplomacyAI::LogLandDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		switch(GetLandDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("LND **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("LND STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("LND Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("LND N");
			break;
		default:
			strTemp.Format("LND Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Victory Dispute
void CvDiplomacyAI::LogVictoryDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetVictoryDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("VCT **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("VCT STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("VCT Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("VCT N");
			break;
		default:
			strTemp.Format("VCT Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
/// Log Victory Block
void CvDiplomacyAI::LogVictoryBlock(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetVictoryBlockLevel(ePlayer))
		{
		case BLOCK_LEVEL_FIERCE:
			strTemp.Format("VBlock **FIERCE**");
			break;
		case BLOCK_LEVEL_STRONG:
			strTemp.Format("VBlock STRONG");
			break;
		case BLOCK_LEVEL_WEAK:
			strTemp.Format("VBlock Weak");
			break;
		case BLOCK_LEVEL_NONE:
			strTemp.Format("VBlock N");
			break;
		default:
			strTemp.Format("VBlock Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}
#endif
/// Log Wonder Dispute
void CvDiplomacyAI::LogWonderDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetWonderDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("WND **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("WND STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("WND Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("WND N");
			break;
		default:
			strTemp.Format("WND Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Minor Civ Dispute
void CvDiplomacyAI::LogMinorCivDispute(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Don't fill out this field for Minors, as it just makes the log harder to read
	if(GET_PLAYER(ePlayer).isMinorCiv())
	{
		strTemp.Format("");
	}
	else
	{
		// Victory Dispute
		switch(GetMinorCivDisputeLevel(ePlayer))
		{
		case DISPUTE_LEVEL_FIERCE:
			strTemp.Format("MCF **FIERCE**");
			break;
		case DISPUTE_LEVEL_STRONG:
			strTemp.Format("MCF STRONG");
			break;
		case DISPUTE_LEVEL_WEAK:
			strTemp.Format("MCF Weak");
			break;
		case DISPUTE_LEVEL_NONE:
			strTemp.Format("MCF N");
			break;
		default:
			strTemp.Format("MCF Unknown");
			break;
		}
	}

	strString += ", " + strTemp;
}

/// Log Proximity
void CvDiplomacyAI::LogProximity(CvString& strString, PlayerTypes ePlayer)
{
	CvString strTemp;

	// Proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_NEIGHBORS:
		strTemp.Format("PRX Neighbors");
		break;
	case PLAYER_PROXIMITY_CLOSE:
		strTemp.Format("PRX Close");
		break;
	case PLAYER_PROXIMITY_FAR:
		strTemp.Format("PRX Far");
		break;
	case PLAYER_PROXIMITY_DISTANT:
		strTemp.Format("PRX Distant");
		break;
	default:
		strTemp.Format("PRX Unknown");
		break;
	}
	strString += ", " + strTemp;
}

/// AI sent a message to someone... what is it?!?!? :o
void CvDiplomacyAI::LogStatementToPlayer(PlayerTypes ePlayer, DiploStatementTypes eMessage)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogName;

		CvString strOutBuf;
		CvString strBaseString;

		CvString playerName;
		CvString otherPlayerName;

		CvString strTemp;

		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Turn number
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

		// Our Name
		strBaseString += playerName;

		// Their Name
		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strBaseString += ", " + otherPlayerName;

		strOutBuf = strBaseString;

		MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);

		bool bMinorMessage = false;

		switch(eMessage)
		{
		case DIPLO_STATEMENT_REQUEST_PEACE:
			strTemp.Format("We request peace!!!");
			break;
		case DIPLO_STATEMENT_AGGRESSIVE_MILITARY_WARNING:
			strTemp.Format("Your Military is stationed aggressively!");
			break;
		case DIPLO_STATEMENT_KILLED_PROTECTED_CITY_STATE:
			strTemp.Format("You Killed a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_ATTACKED_PROTECTED_CITY_STATE:
			strTemp.Format("You Attacked a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_BULLIED_PROTECTED_CITY_STATE:
			strTemp.Format("You Bullied a Protected City State!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_EXPANSION_SERIOUS_WARNING:
			strTemp.Format("Expansion SERIOUS Warning!");
			break;
		case DIPLO_STATEMENT_EXPANSION_WARNING:
			strTemp.Format("Expansion Warning!");
			break;
		case DIPLO_STATEMENT_EXPANSION_BROKEN_PROMISE:
			strTemp.Format("Expansion Broken Promise!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_SERIOUS_WARNING:
			strTemp.Format("Plot Buying SERIOUS Warning!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_WARNING:
			strTemp.Format("Plot Buying Warning!");
			break;
		case DIPLO_STATEMENT_PLOT_BUYING_BROKEN_PROMISE:
			strTemp.Format("Plot Buying Broken Promise!");
			break;
		case DIPLO_STATEMENT_WE_ATTACKED_YOUR_MINOR:
			strTemp.Format("Haha! We attacked your Minor!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_WE_BULLIED_YOUR_MINOR:
			strTemp.Format("Haha! We bullied your Minor!");
			bMinorMessage = true;
			break;
		case DIPLO_STATEMENT_WORK_WITH_US:
			strTemp.Format("Wanna team up?");
			break;
		case DIPLO_STATEMENT_END_WORK_WITH_US:
			strTemp.Format("***** We're done working with you. *****");
			break;
		case DIPLO_STATEMENT_DENOUNCE:
			strTemp.Format("Denounce!");
			break;
		case DIPLO_STATEMENT_DENOUNCE_RANDFAILED:
			strTemp.Format("Denounce RANDFAILED");
			break;
		case DIPLO_STATEMENT_END_WORK_AGAINST_SOMEONE:
			strTemp.Format("***** We're done working against someone with you. *****");
			break;
		case DIPLO_STATEMENT_COOP_WAR_REQUEST:
			strTemp.Format("Wanna coop war against someone?");
			break;
		case DIPLO_STATEMENT_COOP_WAR_TIME:
			strTemp.Format("It's time to coop war against someone!");
			break;
		case DIPLO_STATEMENT_NOW_UNFORGIVABLE:
			strTemp.Format("***** You are Unforgivable! *****");
			break;
		case DIPLO_STATEMENT_NOW_ENEMY:
			strTemp.Format("***** You are an Enemy! *****");
			break;
		case DIPLO_STATEMENT_DEMAND:
			strTemp.Format("***** Give in to my demands or else! *****");
			break;
		case DIPLO_STATEMENT_REQUEST:
			strTemp.Format("***** Can you spare something for a friend? *****");
			break;
		case DIPLO_STATEMENT_REQUEST_RANDFAILED:
			strTemp.Format("***** Request RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_LUXURY_TRADE:
			strTemp.Format("***** You have a Luxury I would like *****");
			break;
		case DIPLO_STATEMENT_OPEN_BORDERS_EXCHANGE:
			strTemp.Format("Open Borders Exchange");
			break;
		case DIPLO_STATEMENT_OPEN_BORDERS_OFFER:
			strTemp.Format("Open Borders Offer");
			break;
		case DIPLO_STATEMENT_PLAN_RESEARCH_AGREEMENT:
			strTemp.Format("Research Plan");
			break;
		case DIPLO_STATEMENT_RESEARCH_AGREEMENT_OFFER:
			strTemp.Format("Research Agreement Offer");
			break;
		case DIPLO_STATEMENT_RENEW_DEAL:
			strTemp.Format("Renew Deal");
			break;
		case DIPLO_STATEMENT_INSULT:
			strTemp.Format("Insult");
			break;
		case DIPLO_STATEMENT_COMPLIMENT:
			if(eApproach == MAJOR_CIV_APPROACH_DECEPTIVE)
			{
				strTemp.Format("DECEPTIVE Compliment");
			}
			else
			{
				strTemp.Format("Compliment");
			}
			break;
		case DIPLO_STATEMENT_BOOT_KISSING:
			strTemp.Format("Boot Kissing");
			break;
		case DIPLO_STATEMENT_WARMONGER:
			strTemp.Format("Warmonger!");
			break;
		case DIPLO_STATEMENT_DENOUNCE_FRIEND:
			strTemp.Format("***** DENOUNCING A FRIEND *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE:
			strTemp.Format("***** DENOUNCE SOMEONE FOR ME? *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_DENOUNCE_RANDFAILED:
			strTemp.Format("***** Denounce someone for me? RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_REQUEST_FRIEND_WAR:
			strTemp.Format("***** DECLARE WAR ON SOMEONE FOR ME? *****");
			break;
		case DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY:
			strTemp.Format("***** YOU BEFRIENDED AN ENEMY OF MINE! *****");
			break;
		case DIPLO_STATEMENT_ANGRY_BEFRIEND_ENEMY_RANDFAILED:
			strTemp.Format("***** You befriended an enemy of mine! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND:
			strTemp.Format("***** YOU DENOUNCED A FRIEND OF MINE! *****");
			break;
		case DIPLO_STATEMENT_ANGRY_DENOUNCED_FRIEND_RANDFAILED:
			strTemp.Format("***** You denounced a friend of mine! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY:
			strTemp.Format("***** YAY - YOU DENOUNCED AN ENEMY! *****");
			break;
		case DIPLO_STATEMENT_HAPPY_DENOUNCED_ENEMY_RANDFAILED:
			strTemp.Format("***** Yay - you denounced an enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND:
			strTemp.Format("***** YAY - YOU BEFRIENDED A FRIEND! *****");
			break;
		case DIPLO_STATEMENT_HAPPY_BEFRIENDED_FRIEND_RANDFAILED:
			strTemp.Format("***** Yay - you befriended a friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY:
			strTemp.Format("***** JUST FYI - I BEFRIENDED YOUR ENEMY! *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_ENEMY_RANDFAILED:
			strTemp.Format("***** Just FYI - I befriended your enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND:
			strTemp.Format("***** JUST FYI - I DENOUNCED YOUR FRIEND! *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_FRIEND_RANDFAILED:
			strTemp.Format("***** Just FYI - I denounced your friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY:
			strTemp.Format("***** JUST FYI - I DENOUNCED YOUR ENEMY! *****");
			break;
		case DIPLO_STATEMENT_FYI_DENOUNCED_HUMAN_ENEMY_RANDFAILED:
			strTemp.Format("***** Just FYI - I denounced your enemy! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND:
			strTemp.Format("***** JUST FYI - I BEFRIENDED YOUR FRIEND! *****");
			break;
		case DIPLO_STATEMENT_FYI_BEFRIEND_HUMAN_FRIEND_RANDFAILED:
			strTemp.Format("***** Just FYI - I befriended your friend! RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_SAME_POLICIES_AUTOCRACY:
		case DIPLO_STATEMENT_SAME_POLICIES_FREEDOM:
		case DIPLO_STATEMENT_SAME_POLICIES_ORDER:
			strTemp.Format("***** Yay! We like the same late game social policy tree *****");
			break;
		case DIPLO_STATEMENT_WE_LIKED_THEIR_PROPOSAL:
			strTemp.Format("***** We liked their World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_WE_DISLIKED_THEIR_PROPOSAL:
			strTemp.Format("***** We disliked their World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_SUPPORTED_OUR_PROPOSAL:
			strTemp.Format("***** They supported our World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_FOILED_OUR_PROPOSAL:
			strTemp.Format("***** They foiled our World Congress proposal *****");
			break;
		case DIPLO_STATEMENT_THEY_SUPPORTED_OUR_HOSTING:
			strTemp.Format("***** They supported our World Congress hosting *****");
			break;
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		case DIPLO_STATEMENT_YOUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
			strTemp.Format("***** Your ideology is causing civil unrest in our civ *****");
			break;
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_FREEDOM:
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_ORDER:
		case DIPLO_STATEMENT_OUR_IDEOLOGY_CAUSING_CIVIL_UNREST_AUTOCRACY:
			strTemp.Format("***** Taunt - our ideology is causing unrest in your civ *****");
			break;
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_FREEDOM:
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_ORDER:
		case DIPLO_STATEMENT_SWITCH_OUR_IDEOLOGY_AUTOCRACY:
			strTemp.Format("***** Yay! They switched to our ideology *****");
			break;
		case DIPLO_STATEMENT_YOUR_CULTURE_INFLUENTIAL:
			strTemp.Format("***** Your culture is now influential over us *****");
			break;
		case DIPLO_STATEMENT_OUR_CULTURE_INFLUENTIAL:
			strTemp.Format("***** Taunt - Our culture is now influential over you *****");
			break;
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONQUEST:
			strTemp.Format("***** Taunt - We are coming for you with guns! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_WORLD_CONGRESS:
			strTemp.Format("***** Taunt - We will rule the world through politics! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CULTURE:
			strTemp.Format("***** Taunt - Our culture is becoming unstoppable! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_SPACESHIP:
			strTemp.Format("***** Taunt - Our spaceship will be the first to launch! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_COMPETITION_ANNOUNCE_CONFUSED:
			strTemp.Format("***** Taunt - We don't know what you're doing, but we are grumpy! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONQUEST:
			strTemp.Format("***** Taunt - We don't want you to win war! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_WORLD_CONGRESS:
			strTemp.Format("***** Taunt - We don't want you to win WC! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_CULTURE:
			strTemp.Format("***** Taunt - We don't want you to win culture! *****");
			break;
		case DIPLO_STATEMENT_VICTORY_BLOCK_ANNOUNCE_SPACESHIP:
			strTemp.Format("***** Taunt - We don't want you to win spaceship! *****");
			break;
#endif
#if defined(MOD_BALANCE_CORE)
		case DIPLO_STATEMENT_DOF_BB:
			strTemp.Format("DOF offer - Battle Brothers");
			break;
		case DIPLO_STATEMENT_DOF_ALLIES:
			strTemp.Format("DOF offer - Allies");
			break;
		case DIPLO_STATEMENT_DOF_FRIENDS:
			strTemp.Format("DOF offer - Friends");
			break;
		case DIPLO_STATEMENT_DOF_UNTRUSTWORTHY:
			strTemp.Format("DOF offer - Untrustworthy");
			break;

		case DIPLO_STATEMENT_STRATEGIC_TRADE:
			strTemp.Format("Strategic Resource Trade");
			break;

		case DIPLO_STATEMENT_DEFENSIVE_PACT_REQUEST:
			strTemp.Format("Defensive Pact Offer");
			break;

		case DIPLO_STATEMENT_TRADE_CITIES_REQUEST:
			strTemp.Format("Trade Cities Offer");
			break;

		case DIPLO_STATEMENT_EXCHANGE_CITIES:
			strTemp.Format("Exchange Cities Offer");
			break;

		case DIPLO_STATEMENT_THIRDPARTY_PEACE_REQUEST:
			strTemp.Format("3rd Party PEACE Offer");
			break;

		case DIPLO_STATEMENT_THIRDPARTY_WAR_REQUEST:
			strTemp.Format("3rd Party WAR Offer");
			break;

		case DIPLO_STATEMENT_VOTE_REQUEST:
			strTemp.Format("Vote Buy Offer");
			break;

		case DIPLO_STATEMENT_EMBASSY_EXCHANGE:
			strTemp.Format("***** Embassy Exchange *****");
			break;

		case DIPLO_STATEMENT_EMBASSY_OFFER:
			strTemp.Format("***** Embassy Offer *****");
			break;
		
		case DIPLO_STATEMENT_MINOR_CIV_COMPETITION:
			strTemp.Format("***** MINOR CIV COMPETITION *****");
			break;

		case DIPLO_STATEMENT_SHARE_INTRIGUE:
			strTemp.Format("***** Share Intrigue *****");
			break;

		case DIPLO_STATEMENT_CAUGHT_YOUR_SPY:
			strTemp.Format("***** SPY CAUGHT *****");
			break;

		case DIPLO_STATEMENT_KILLED_YOUR_SPY:
			strTemp.Format("***** KILLED YOUR SPY *****");
			break;

		case DIPLO_STATEMENT_KILLED_MY_SPY:
			strTemp.Format("***** KILLED MY SPY *****");
			break;

		case DIPLO_STATEMENT_STOP_DIGGING:
			strTemp.Format("***** STOP DIGGING WARNING *****");
			break;

			
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		case DIPLO_STATEMENT_GENEROUS_OFFER:
			strTemp.Format("***** We would like to offer you a gift. *****");
			break;
		case DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED:
			strTemp.Format("***** Generous Offer RANDFAILED *****");
			break;
		case DIPLO_STATEMENT_MAPS_OFFER:
			strTemp.Format("*****Maps Offer*****");
			break;
		case DIPLO_STATEMENT_TECH_EXCHANGE:
			strTemp.Format("*****Technology Exchange*****");
			break;
		case DIPLO_STATEMENT_TECH_OFFER:
			strTemp.Format("*****You have a technology I would like*****");
			break;
		case DIPLO_STATEMENT_BECOME_MY_VASSAL:
			strTemp.Format("***** BECOME MY VASSAL *****");
			break;
		case DIPLO_STATEMENT_REVOKE_VASSALAGE:
			strTemp.Format("***** REVOKING VASSALAGE *****");
			break;
		case DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY:
			strTemp.Format("***** REVOKING VASSALAGE VIA TRADE *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER:
			strTemp.Format("***** HUMAN RAISED MY TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER:
			strTemp.Format("***** I RAISED HUMAN'S TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER:
			strTemp.Format("***** HUMAN RAISED MY TAXES! *****");
			break;
		case DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER:
			strTemp.Format("***** I LOWERED HUMAN'S TAXES! *****");
			break;
		case DIPLO_STATEMENT_LIBERATE_VASSAL:
			strTemp.Format("***** LIBERATED VASSAL! *****");
			break;
#endif
		default:
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			strTemp.Format("Unknown message!!! %d", eMessage);
#else
			strTemp.Format("Unknown message!!!");
#endif
			break;
		}

		strOutBuf += ", " + strTemp;

		// Don't log these messages for now - they have their own function
		if(eMessage != DIPLO_STATEMENT_DENOUNCE &&
		        eMessage != DIPLO_STATEMENT_COOP_WAR_REQUEST)
			pLog->Msg(strOutBuf);

		// Also send message to Minor Civ log if applicable
		if(bMinorMessage)
		{
			// Open the log file
			if(GC.getPlayerAndCityAILogSplit())
				strLogName = "DiplomacyAI_MinorCiv_Log_" + playerName + ".csv";
			else
				strLogName = "DiplomacyAI_MinorCiv_Log.csv";

			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);
			pLog->Msg(strOutBuf);
		}
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::TestUIDiploStatement(PlayerTypes eToPlayer, DiploStatementTypes eStatement, int iArg1)
{
	m_eTestToPlayer = eToPlayer;
	m_eTestStatement = eStatement;
	m_iTestStatementArg1 = iArg1;
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::LogOpenEmbassy(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** OPENED EMBASSY @ " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}

//	-------------------------------------------------------------------------------------
void CvDiplomacyAI::LogCloseEmbassy(PlayerTypes ePlayer)
{
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strOutBuf;
		CvString strBaseString;
		CvString playerName;
		CvString otherPlayerName;
		CvString strDesc;
		CvString strLogName;

		// Find the name of this civ and city
		playerName = GetPlayer()->getCivilizationShortDescription();

		// Open the log file
		if(GC.getPlayerAndCityAILogSplit())
		{
			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";
		}
		else
		{
			strLogName = "DiplomacyAI_Messages_Log.csv";
		}

		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

		// Get the leading info for this line
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";

		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
		strOutBuf = strBaseString + ",***** CLOSED EMBASSY @ " + otherPlayerName + "! *****";

		pLog->Msg(strOutBuf);
#if !defined(MOD_BALANCE_CORE_DIPLOMACY)
		OutputDebugString("\n");
		OutputDebugString(strOutBuf);
		OutputDebugString("\n");
#endif
	}
}
//	-------------------------------------------------------------------------------------
//	Returns true if the target is valid to show a UI to immediately.
//	This will return true if the source and destination are both AI.
bool CvDiplomacyAI::IsValidUIDiplomacyTarget(PlayerTypes eTargetPlayer)
{
	if(eTargetPlayer != NO_PLAYER)
	{
		CvPlayer& kTarget = GET_PLAYER(eTargetPlayer);
		if(m_eTargetPlayer == DIPLO_ALL_PLAYERS || m_eTargetPlayer == eTargetPlayer || (m_eTargetPlayer == DIPLO_AI_PLAYERS && !kTarget.isHuman()) || (m_eTargetPlayer == DIPLO_HUMAN_PLAYERS && kTarget.isHuman()))
			return true;
	}

	return false;
}

FDataStream& operator<<(FDataStream& saveTo, const DiploLogData& readFrom)
{
	saveTo << readFrom.m_eDiploLogStatement;
	saveTo << readFrom.m_iTurn;
	return saveTo;
}

FDataStream& operator>>(FDataStream& loadFrom, DiploLogData& writeTo)
{
	loadFrom >> writeTo.m_eDiploLogStatement;
	loadFrom >> writeTo.m_iTurn;
	return loadFrom;
}

FDataStream& operator<<(FDataStream& saveTo, const DeclarationLogData& readFrom)
{
	saveTo << readFrom.m_eDeclaration;
	saveTo << readFrom.m_iData1;
	saveTo << readFrom.m_iData2;
	saveTo << readFrom.m_eMustHaveMetPlayer;
	saveTo << readFrom.m_bActive;
	saveTo << readFrom.m_iTurn;
	return saveTo;
}

FDataStream& operator>>(FDataStream& loadFrom, DeclarationLogData& writeTo)
{
	loadFrom >> writeTo.m_eDeclaration;
	loadFrom >> writeTo.m_iData1;
	loadFrom >> writeTo.m_iData2;
	loadFrom >> writeTo.m_eMustHaveMetPlayer;
	loadFrom >> writeTo.m_bActive;
	loadFrom >> writeTo.m_iTurn;
	return loadFrom;
}

// AI HELPER ROUTINES

int CvDiplomacyAIHelpers::GetWarmongerOffset(bool bIsCapital, CvCity* pCity, PlayerTypes eWarmonger)
{
	if (pCity == NULL)
		return 0;

	int iGlobalAverageEconomicPower = GC.getGame().getTotalEconomicValue() / max(1, GC.getGame().getNumCities());
	int iLocalEconomicPower = pCity->getEconomicValue(pCity->getOwner());
	int iWarmongerWeight = (iLocalEconomicPower * 100) / max(1, iGlobalAverageEconomicPower);

	if (iWarmongerWeight <= 0)
		iWarmongerWeight = 1;

	if (GET_PLAYER(pCity->getOwner()).isMinorCiv()) iWarmongerWeight *= GC.getWARMONGER_THREAT_MINOR_CITY_WEIGHT() / 100;
	else
		iWarmongerWeight *= GC.getWARMONGER_THREAT_MAJOR_CITY_WEIGHT() / 100;

	if (bIsCapital) iWarmongerWeight *= GC.getWARMONGER_THREAT_CAPITAL_CITY_PERCENT() / 100;

	// (iWarmongerWeight / iNumCitiesRemaining) * (CapturedCityPop / (RemainingTotalPop/iNumCitiesRemaining))
	if(pCity != NULL && eWarmonger != NO_PLAYER)
	{
		int iNumTimesOwned(pCity->GetNumTimesOwned(eWarmonger));
		if(iNumTimesOwned > 1)
		{
			iWarmongerWeight /= (iNumTimesOwned * 5);
		}
	}

	iWarmongerWeight *= GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent();
	iWarmongerWeight /= 100;

	iWarmongerWeight *= 100;


	CUSTOMLOG("GetWarmongerOffset(capital=%s) = %i", (bIsCapital ? "true" : "false"), iWarmongerWeight);
	return iWarmongerWeight;
}

#if defined(MOD_CONFIG_AI_IN_XML)
CvString CvDiplomacyAIHelpers::GetWarmongerPreviewString(PlayerTypes eCurrentOwner, bool bIsCapital, CvCity* pCity, PlayerTypes eActivePlayer)
#else
CvString CvDiplomacyAIHelpers::GetWarmongerPreviewString(PlayerTypes eCurrentOwner)
#endif
{
	CvString szRtnValue = "";
#if defined(MOD_BALANCE_CORE)
	if(pCity != NULL && eActivePlayer != NO_PLAYER && eCurrentOwner != NO_PLAYER)
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_HEADER").toUTF8();
		CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veWarmongerWeights;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			// Ignore minors
			if(!GET_PLAYER((PlayerTypes)iPlayerLoop).isMinorCiv() && GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && (PlayerTypes)iPlayerLoop != eActivePlayer)
			{
				if (!GET_TEAM(GET_PLAYER(eActivePlayer).getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iPlayerLoop).getTeam()))
					continue;

				int iWarmongerCare = CvDiplomacyAIHelpers::GetPlayerCaresValue(eActivePlayer, eCurrentOwner, bIsCapital, pCity, (PlayerTypes)iPlayerLoop);
				iWarmongerCare *= GET_PLAYER((PlayerTypes)iPlayerLoop).GetDiplomacyAI()->GetWarmongerHate();
				iWarmongerCare /= 100;
				if(iWarmongerCare > 0)
				{
					veWarmongerWeights.push_back((PlayerTypes)iPlayerLoop, iWarmongerCare);
				}
			}
		}
		if(veWarmongerWeights.size() > 0)
		{
			veWarmongerWeights.SortItems();
			int iCap = 0;
			int iMax = 8;
			for(int iWarmongerCivs = 0; iWarmongerCivs < (int) veWarmongerWeights.size(); iWarmongerCivs++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) veWarmongerWeights.GetElement(iWarmongerCivs);
				int iWarmongerCare = veWarmongerWeights.GetWeight(iWarmongerCivs);
				if(iCap >= iMax)
				{
					break;
				}
				if(eLoopPlayer != NO_PLAYER)
				{
					if (iWarmongerCare >= GC.getWARMONGER_THREAT_CRITICAL_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_1000", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_SEVERE_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_800", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MAJOR_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_600", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MINOR_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_400", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MINOR_THRESHOLD() / 2 * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_200", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else 
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_WARMONGER_PREVIEW_CARE_NIL", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
				}
			}
		}
		else
		{
			szRtnValue = "";
		}
		return szRtnValue;
	}
	else
	{
#endif
#if defined(MOD_CONFIG_AI_IN_XML)
	int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(bIsCapital, pCity);
#else
	CvPlayer &kPlayer = GET_PLAYER(eCurrentOwner);
	int iNumCities = max(kPlayer.getNumCities(), 1);
	int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(iNumCities, kPlayer.isMinorCiv());
	iWarmongerOffset = iWarmongerOffset * GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent() / 100;
#endif
	if (iWarmongerOffset < GC.getWARMONGER_THREAT_MINOR_ATTACKED_WEIGHT())
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MINOR").toUTF8();
	}
	else if (iWarmongerOffset < GC.getWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT())
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MAJOR").toUTF8();
	}
	else
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_EXTREME").toUTF8();
	}
#if defined(MOD_BALANCE_CORE)
	}
#endif
	return szRtnValue;
}

#if defined(MOD_CONFIG_AI_IN_XML)
CvString CvDiplomacyAIHelpers::GetLiberationPreviewString(PlayerTypes eOriginalOwner, bool bIsCapital, CvCity* pCity, PlayerTypes eActivePlayer)
#else
CvString CvDiplomacyAIHelpers::GetLiberationPreviewString(PlayerTypes eOriginalOwner)
#endif
{
	CvString szRtnValue = "";
#if defined(MOD_BALANCE_CORE)
	if(pCity != NULL && eActivePlayer != NO_PLAYER && eOriginalOwner != NO_PLAYER)
	{
		szRtnValue = Localization::Lookup("TXT_KEY_LIBERATOR_PREVIEW_HEADER").toUTF8();
		CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veWarmongerWeights;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			// Ignore minors
			if(!GET_PLAYER((PlayerTypes)iPlayerLoop).isMinorCiv() && GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && (PlayerTypes)iPlayerLoop != eActivePlayer)
			{
				if (!GET_TEAM(GET_PLAYER(eActivePlayer).getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iPlayerLoop).getTeam()))
					continue;
				
				int iWarmongerCare = CvDiplomacyAIHelpers::GetPlayerCaresValue(eActivePlayer, eOriginalOwner, bIsCapital, pCity, (PlayerTypes)iPlayerLoop, true);
				iWarmongerCare *= GET_PLAYER((PlayerTypes)iPlayerLoop).GetDiplomacyAI()->GetWarmongerHate();
				iWarmongerCare /= 100;
				if(iWarmongerCare > 0)
				{
					veWarmongerWeights.push_back((PlayerTypes)iPlayerLoop, iWarmongerCare);
				}
			}
		}
		if(veWarmongerWeights.size() > 0)
		{
			veWarmongerWeights.SortItems();
			int iCap = 0;
			int iMax = 8;
			for(int iWarmongerCivs = 0; iWarmongerCivs < (int) veWarmongerWeights.size(); iWarmongerCivs++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) veWarmongerWeights.GetElement(iWarmongerCivs);
				int iWarmongerCare = veWarmongerWeights.GetWeight(iWarmongerCivs);
				if(iCap >= iMax)
				{
					break;
				}
				if(eLoopPlayer != NO_PLAYER)
				{
					if (iWarmongerCare >= GC.getWARMONGER_THREAT_CRITICAL_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_1000", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_SEVERE_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_800", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MAJOR_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_600", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MINOR_THRESHOLD() * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_400", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else if (iWarmongerCare >= GC.getWARMONGER_THREAT_MINOR_THRESHOLD() / 2 * 100)
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_200", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					else 
					{
						szRtnValue += "[NEWLINE]";
						szRtnValue += GetLocalizedText("TXT_KEY_LIBERATOR_PREVIEW_CARE_NIL", GET_PLAYER(eLoopPlayer).getCivilizationShortDescriptionKey());
					}
					iCap++;
				}
			}
		}
		else
		{
			szRtnValue = "";
		}
		return szRtnValue;
	}
	else
	{
#endif
#if defined(MOD_CONFIG_AI_IN_XML)
	int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(bIsCapital, pCity);
#else
	CvPlayer &kPlayer = GET_PLAYER(eOriginalOwner);
	int iNumCities = kPlayer.getNumCities() + 1;
	int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(iNumCities, kPlayer.isMinorCiv());
	iWarmongerOffset = iWarmongerOffset * GC.getEraInfo(GC.getGame().getCurrentEra())->getWarmongerPercent() / 100;
#endif
	if (iWarmongerOffset < GC.getWARMONGER_THREAT_MINOR_ATTACKED_WEIGHT())
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MINOR").toUTF8();
	}
	else if (iWarmongerOffset < GC.getWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT())
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_MAJOR").toUTF8();
	}
	else
	{
		szRtnValue = Localization::Lookup("TXT_KEY_WARMONGER_PREVIEW_EXTREME").toUTF8();
	}
#if defined(MOD_BALANCE_CORE)
	}
#endif
	return szRtnValue;

}

#if defined(MOD_CONFIG_AI_IN_XML)
void CvDiplomacyAIHelpers::ApplyWarmongerPenalties(PlayerTypes eConqueror, PlayerTypes eConquered, bool bIsCapital, CvCity* pCity)
#else
void CvDiplomacyAIHelpers::ApplyWarmongerPenalties(PlayerTypes eConqueror, PlayerTypes eConquered)
#endif
{
	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
	{
		PlayerTypes eMajor = (PlayerTypes)iMajorLoop;
		if (GET_PLAYER(eMajor).getTeam() != GET_PLAYER(eConqueror).getTeam() && GET_PLAYER(eMajor).isAlive() && !GET_PLAYER(eMajor).isMinorCiv())
		{
			int iWarmonger = GetPlayerCaresValue(eConqueror, eConquered, bIsCapital, pCity, eMajor);
			if (iWarmonger != 0)
			{
#if defined(MOD_API_EXTENSIONS)
				CUSTOMLOG("WarmongerTimes100: Total=%i", iWarmonger);
				GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(eConqueror, iWarmonger);
#else
				GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmount(eConqueror, iWarmonger);
#endif
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE)
int CvDiplomacyAIHelpers::GetPlayerCaresValue(PlayerTypes eConqueror, PlayerTypes eConquered, bool bIsCapital, CvCity* pCity, PlayerTypes eMajor, bool bLiberation)
{
	CvPlayer &kConqueringPlayer = GET_PLAYER(eConqueror);
	CvPlayer &kConqueredPlayer = GET_PLAYER(eConquered);
	
	//Don't consider ourselves, teammates or dead dudes.
	if (GET_PLAYER(eMajor).getTeam() != GET_PLAYER(eConqueror).getTeam() && GET_PLAYER(eMajor).isAlive() && !GET_PLAYER(eMajor).isMinorCiv())
	{
		CvTeam &kAffectedTeam = GET_TEAM(GET_PLAYER(eMajor).getTeam());
		
		// Don't apply warmongering if we haven't met the conqueror (otherwise that's cheating)
		if(!kAffectedTeam.isHasMet(kConqueringPlayer.getTeam()))
			return 0;
		
		// Have I met the player who conquered the city, or the owner of the conquered city?
		if (kAffectedTeam.isHasMet(kConqueringPlayer.getTeam()) || kAffectedTeam.isHasMet(kConqueredPlayer.getTeam()))
		{
			int iWarmongerModifier = 0;

			if (eMajor == eConquered && !bLiberation)
			{
				// The conquered city owner ALWAYS gets the full warmonger value
			}
			if (eConqueror == eConquered && bLiberation)
			{
				//Our city? Only we should care.
				return 0;
			}
			PlayerTypes eFormerOwner = pCity->getPreviousOwner();
			if (bLiberation && eFormerOwner == eMajor && GET_TEAM(GET_PLAYER(eMajor).getTeam()).isAtWar(kConqueringPlayer.getTeam()))
			{
				return 0;
			}
			//At war with the civ that formerly owned the city? No liberation bonuses for this.
			else if(kConqueredPlayer.isAlive() && bLiberation && GET_TEAM(kConqueredPlayer.getTeam()).isAtWar(GET_PLAYER(eConqueror).getTeam()))
			{
				return 0;
			}
			//At war with the civ that owns the city now? No liberation bonus for this.
			else if(bLiberation && eMajor == pCity->getOwner() && GET_TEAM(kConqueringPlayer.getTeam()).isAtWar(pCity->getTeam()))
			{
				return 0;
			}
			//At war with the conquering civ? No liberation bonus for this.
			else if (bLiberation && GET_TEAM(kConqueredPlayer.getTeam()).isAtWar(pCity->getTeam()))
			{
				return 0;
			}

			else
			{
				if (GC.getWARMONGER_THREAT_DEF_PACT_ENABLED() != 0 && kAffectedTeam.IsHasDefensivePact(kConqueredPlayer.getTeam()))
				{
					// Any DefPact allies of the conquered city owner also get the full warmonger value
					CUSTOMLOG("Warmonger: Bystander has a Def Pact with the defender");
				}
				else
				{
					int iWarmongerCoopWarPercent = GC.getWARMONGER_THREAT_COOP_WAR_PERCENT();
					//bool bCoopWarChecks = (iWarmongerCoopWarPercent != 100);
					bool bCoopWarWithAttacker = false;
						//bCoopWarChecks && (GET_PLAYER(eMajor).GetDiplomacyAI()->GetCoopWarAcceptedState(eConqueror, eConquered) == COOP_WAR_STATE_ACCEPTED);
					bool bCoopWarWithDefender = false;
						//bCoopWarChecks && (GET_PLAYER(eMajor).GetDiplomacyAI()->GetCoopWarAcceptedState(eConquered, eConqueror) == COOP_WAR_STATE_ACCEPTED);

					if (bCoopWarWithAttacker)
					{
						// The affected player is in a co-op war with the attacker against the defender - this trumps everything!
						iWarmongerModifier = iWarmongerCoopWarPercent;
						CUSTOMLOG("Warmonger: Bystander is in a co-op war with the attacker");

						if (bCoopWarWithDefender)
						{
							CUSTOMLOG("Warmonger: Bystander is ALSO in a co-op war with the defender!!!");
						}
					}
					else if (bCoopWarWithDefender)
					{
						// The affected player is in a co-op war with the defender against the attacker - we treat his loss as our own
						CUSTOMLOG("Warmonger: Bystander is in a co-op war with the defender");
					}
					else
					{
						// Do we know the defender?
						if (kAffectedTeam.isHasMet(kConqueredPlayer.getTeam()) && !kAffectedTeam.isHasMet(kConqueringPlayer.getTeam()))
						{
							iWarmongerModifier = GC.getWARMONGER_THREAT_KNOWS_DEFENDER_PERCENT();
							CUSTOMLOG("Warmonger: Bystander has met the attacker");
						}

						// Do we know the attacker?
						if (!kAffectedTeam.isHasMet(kConqueredPlayer.getTeam()) && kAffectedTeam.isHasMet(kConqueringPlayer.getTeam()))
						{
							// We may know both, so take the larger modifier
							iWarmongerModifier = std::max(iWarmongerModifier, GC.getWARMONGER_THREAT_KNOWS_ATTACKER_PERCENT());
							CUSTOMLOG("Warmonger: Bystander has met the defender");
						}
					}
				}
			}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			//Vassals take full warmonger if attacked/affected, and zero if on the conquering side.
			if(MOD_DIPLOMACY_CIV4_FEATURES && !bLiberation)
			{
				//Warmonger?
				if(kAffectedTeam.GetMaster() == kConqueringPlayer.getTeam())
				{
					iWarmongerModifier = 0;
				}
				if(kAffectedTeam.IsVassal(kConqueringPlayer.getTeam()))
				{
					iWarmongerModifier = 0;
				}
				if(kAffectedTeam.GetMaster() == GET_PLAYER(eConquered).getTeam())
				{
					iWarmongerModifier *= 200;
					iWarmongerModifier /= 100;
				}
				if(kAffectedTeam.IsVassal(GET_PLAYER(eConquered).getTeam()))
				{
					iWarmongerModifier *= 200;
					iWarmongerModifier /= 100;
				}
			}
#endif

			int iWarmongerApproachModifier = 0;
			if(!bLiberation)
			{
				if (eMajor == eConquered || (GC.getWARMONGER_THREAT_DEF_PACT_ENABLED() != 0 && kAffectedTeam.IsHasDefensivePact(kConqueredPlayer.getTeam())))
				{
					iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 2;
				}
				else
				{	
					// INCREASE if he's big and nasty, less so if he's not.
					switch (GET_PLAYER(eMajor).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eConqueror))
					{
						case STRENGTH_IMMENSE:
						case STRENGTH_POWERFUL:
							iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
							break;
						case STRENGTH_AVERAGE:
						case STRENGTH_STRONG:
							iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
							break;
						case STRENGTH_WEAK:
						case STRENGTH_POOR:
							iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();
							break;
						case STRENGTH_PATHETIC:
							iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
							break;
						default:
							break;
					}

					// DECREASE if opponent is big and nasty, less so if he's not.
					switch (GET_PLAYER(eMajor).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eConquered))
					{
					case STRENGTH_IMMENSE:
					case STRENGTH_POWERFUL:
						iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
						break;
					case STRENGTH_AVERAGE:
					case STRENGTH_STRONG:
						iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
						break;
					case STRENGTH_WEAK:
					case STRENGTH_POOR:
						iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();
						break;
					case STRENGTH_PATHETIC:
						iWarmongerApproachModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						break;
					default:
						break;
					}
				}
			}

			int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(bIsCapital, pCity);

			int iWarmongerAggrievedModifier = 0;
			int iWarmongerStatusModifier = 0;
			
			if (eMajor == eConquered)
			{
				iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 5;
				iWarmongerAggrievedModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 5;
			}

			if(eMajor != eConquered)
			{
				if (!bLiberation && GET_TEAM(kConqueringPlayer.getTeam()).isAggressor(kConqueredPlayer.getTeam()))
				{
					iWarmongerAggrievedModifier = GC.getWARMONGER_THREAT_AGGRIEVED_PERCENT();
				}

				//penalty if I'm also at war with conquered civ
				if (kAffectedTeam.isAtWar(GET_PLAYER(eConquered).getTeam()))
				{
					iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
				}

				if(!bLiberation)
				{
					//Minor
					if(kConqueredPlayer.isMinorCiv())
					{
						if(kConqueredPlayer.GetMinorCivAI()->IsAllies(eMajor))
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
						}
						else if(kConqueredPlayer.GetMinorCivAI()->IsFriends(eMajor))
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						}
						else
						{
							iWarmongerStatusModifier -= GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
						}

						if(kConqueredPlayer.GetMinorCivAI()->IsProtectedByMajor(eMajor))
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
						}
						else
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
						}
					}
					//RELIGION
					//Religious brothers/sisters should turn a blind eye to war conducted on different faiths.
					if((GET_PLAYER(eConqueror).GetReligions()->GetReligionInMostCities() ==  GET_PLAYER(eMajor).GetReligions()->GetReligionInMostCities()) && (GET_PLAYER(eConqueror).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
					{
						//Reduced penalties for religious friends.
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();

						//We don't mind when you war on enemies of the faith.
						if((GET_PLAYER(eConqueror).GetReligions()->GetReligionInMostCities() != GET_PLAYER(eConquered).GetReligions()->GetReligionInMostCities()))
						{
							//If everything is true, halve the standard warmonger amount for this player.
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
						}
					}
					//Religious enemies will not be allowed to expand!
					if((GET_PLAYER(eConqueror).GetReligions()->GetReligionInMostCities() != GET_PLAYER(eMajor).GetReligions()->GetReligionInMostCities()) && (GET_PLAYER(eConqueror).GetReligions()->GetReligionInMostCities() != NO_RELIGION) && (GET_PLAYER(eMajor).GetReligions()->GetReligionInMostCities() != NO_RELIGION))
					{
						//Increased penalties for religious enemies.
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();

						//We don't like it when you war on brothers of the faith.
						if((GET_PLAYER(eMajor).GetReligions()->GetReligionInMostCities() == GET_PLAYER(eConquered).GetReligions()->GetReligionInMostCities()))
						{
							//If everything is true, double the standard warmonger amount for this player.
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						}
					}

					//IDEOLOGY

					//Are the conqueror and I of the same ideology? We overlook war on our ideological opponents.
					if((GET_PLAYER(eConqueror).GetPlayerPolicies()->GetLateGamePolicyTree() == GET_PLAYER(eMajor).GetPlayerPolicies()->GetLateGamePolicyTree()) && (GET_PLAYER(eConqueror).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
					{
						//Reduced penalties for ideological companions.
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
						//We overlook war on our ideological comrades!
						if(GET_PLAYER(eConqueror).GetPlayerPolicies()->GetLateGamePolicyTree() != GET_PLAYER(eConquered).GetPlayerPolicies()->GetLateGamePolicyTree())
						{
							//If everything is true, halve the standard warmonger amount for this player.
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_MEDIUM();
						}
					}
					//Are the conqueror and I of different ideologies? We shall not overlook this (especially if they're fighting an ideological ally)!
					if((GET_PLAYER(eConqueror).GetPlayerPolicies()->GetLateGamePolicyTree() != GET_PLAYER(eMajor).GetPlayerPolicies()->GetLateGamePolicyTree()) && (GET_PLAYER(eConqueror).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE) && (GET_PLAYER(eMajor).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
					{
						//Increased penalties for ideological enemies.
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();

						if(GET_PLAYER(eMajor).GetPlayerPolicies()->GetLateGamePolicyTree() == GET_PLAYER(eConquered).GetPlayerPolicies()->GetLateGamePolicyTree() && (GET_PLAYER(eMajor).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE))
						{
							//If the conquered player and I are of the same ideology, this will really irritate us.
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						}
					}

					//SANCTIONED

					//Is the conquered player embargoed (i.e. sanctioned)? If so, half warmonger penalties against this civ.
					if(GC.getGame().GetGameLeagues()->IsTradeEmbargoed(eMajor, eConquered))
					{
						iWarmongerStatusModifier -= GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}

					//JUST WAR

					//Is the Just War resolution enabled? If so, greatly reduce warmonger penalties.
					if(MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->IsWorldWar(eMajor) > 0)
					{
						iWarmongerStatusModifier -= GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}
					//WORLD PEACE

					//Is the World Peace Accords resolution enabled? If so, greatly increase warmonger penalties.
					if(MOD_DIPLOMACY_CITYSTATES && GC.getGame().GetGameLeagues()->GetUnitMaintenanceMod(eMajor) > 0)
					{
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
					}

					//Personality should also matter
					if (!GET_PLAYER(eMajor).isHuman())
					{
						int iPersonality = GET_PLAYER(eMajor).GetDiplomacyAI()->GetDiploBalance() * GET_PLAYER(eMajor).GetDiplomacyAI()->GetWarmongerHate();
						iWarmongerStatusModifier *= 100 + iPersonality;
						iWarmongerStatusModifier /= 100;
					}
					//Humans we assume average.
					else
					{
						iWarmongerStatusModifier *= 100 + 25;
						iWarmongerStatusModifier /= 100;
					}
				}
				//Liberation bonuses/penalties
				else
				{
					//If the conqueror is at war, liberating cities matters way less to them.
					if(GET_TEAM(kConqueringPlayer.getTeam()).isAtWar(GET_PLAYER(eMajor).getTeam()))
					{
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
					}
					//Is this a city for me? Yay!
					if(eMajor == eConquered)
					{
						iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE() * 4;
					}

					//Minor
					if (kConqueredPlayer.isMinorCiv())
					{
						if (kConqueredPlayer.GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eMajor) >= GC.getFRIENDSHIP_THRESHOLD_ALLIES())
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
						}
						else if (kConqueredPlayer.GetMinorCivAI()->GetEffectiveFriendshipWithMajor(eMajor) >= GC.getFRIENDSHIP_THRESHOLD_FRIENDS())
						{
							iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
						}
						else
						{
							iWarmongerStatusModifier -= GC.getWARMONGER_THREAT_MODIFIER_SMALL();
						}
					}
				}
				//Proximity should matter.
				if(GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_DISTANT)
				{
					iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_NEGATIVE_SMALL();
				}
				else if(GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_FAR)
				{
					iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_SMALL();
				}
				else if(GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_CLOSE)
				{
					iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_MEDIUM();
				}
				else if(GET_PLAYER(eMajor).GetProximityToPlayer(eConquered) == PLAYER_PROXIMITY_NEIGHBORS)
				{
					iWarmongerStatusModifier += GC.getWARMONGER_THREAT_MODIFIER_LARGE();
				}
			}

			iWarmongerOffset *= (100 + iWarmongerModifier);
			iWarmongerOffset /= 100;

			iWarmongerOffset *= (100 + iWarmongerStatusModifier);
			iWarmongerOffset /= 100;

			iWarmongerOffset *=  (100 + iWarmongerAggrievedModifier);
			iWarmongerOffset /= 100;

			iWarmongerOffset *=  (100 + iWarmongerApproachModifier);
			iWarmongerOffset /= 100;

			return iWarmongerOffset;
		}
	}
	return 0;
}
#endif

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
/// Possible Contact Statement - AI only
void CvDiplomacyAI::DoMakeVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// note: we check to see if it's possible in IsMakeOfferForVassalage()

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can we make an offer for vassalage?
		if(GetPlayer()->GetDealAI()->IsMakeOfferForVassalage(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_BECOME_MY_VASSAL;
			int iTurnsBetweenStatement = 50;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
			{
				// Send the statement
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}
/// Possible Contact Statement - Vassal taxes have been raised
void CvDiplomacyAI::DoVassalTaxesRaisedStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Which player is actually the vassal?
		PlayerTypes eVassal = NO_PLAYER;
		if(IsVassal(ePlayer))
			eVassal = GetPlayer()->GetID();
		else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetPlayer()->GetID()))
			eVassal = ePlayer;

		if(eVassal != NO_PLAYER)
		{
			// We are ePlayer's vassal
			if(eVassal == GetPlayer()->GetID())
			{
				if(IsVassalTaxRaised(ePlayer))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_RAISED_HUMAN_MASTER;
					SetVassalTaxRaised(ePlayer, false);
				}
			}
			// ePlayer is our vassal
			else if(eVassal == ePlayer)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassalTaxRaised(GetPlayer()->GetID()))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_RAISED_AI_MASTER;
					
					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						// Modify player view to all AI teammates
						if(GET_PLAYER(eLoopPlayer).getTeam() == GetPlayer()->getTeam())
						{
							eLoopPlayer = (PlayerTypes) iPlayerLoop;
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetVassalTaxRaised(eLoopPlayer, false);
						}
					}
				}
			}
		}
	}
}
/// Possible Contact Statement - Vassal taxes have been lowered
void CvDiplomacyAI::DoVassalTaxesLoweredStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Which player is actually the vassal?
		PlayerTypes eVassal = NO_PLAYER;
		if(IsVassal(ePlayer))
			eVassal = GetPlayer()->GetID();
		else if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetPlayer()->GetID()))
			eVassal = ePlayer;

		if(eVassal != NO_PLAYER)
		{
			// We are ePlayer's vassal
			if(eVassal == GetPlayer()->GetID())
			{
				if(IsVassalTaxLowered(ePlayer))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_HUMAN_MASTER;
					SetVassalTaxLowered(ePlayer, false);
				}
			}
			// ePlayer is our vassal
			else if(eVassal == ePlayer)
			{
				if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassalTaxLowered(GetPlayer()->GetID()))
				{
					eStatement = DIPLO_STATEMENT_VASSAL_TAXES_LOWERED_AI_MASTER;
					
					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						// Modify player view to all AI teammates
						if(GET_PLAYER(eLoopPlayer).getTeam() == GetPlayer()->getTeam())
						{
							eLoopPlayer = (PlayerTypes) iPlayerLoop;
							GET_PLAYER(ePlayer).GetDiplomacyAI()->SetVassalTaxLowered(eLoopPlayer, false);
						}
					}
				}
			}

		}
	}
}
/// Possible Contact Statement - Vassal has been liberated
void CvDiplomacyAI::DoLiberateMyVassalStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Has to be my vassal
		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsVassal(GetPlayer()->GetID()))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_LIBERATE_VASSAL;
			int iTurnsBetweenStatement = 25;

			if(IsWantToLiberateVassal(ePlayer))
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
				{
					eStatement = eTempStatement;
				}
			}
		}
	}
}

/// Do we want to liberate ePlayer's team?
bool CvDiplomacyAI::IsWantToLiberateVassal(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	TeamTypes eMyTeam = m_pPlayer->getTeam();
	CvTeam& kMyTeam = GET_TEAM(eMyTeam);

	TeamTypes eVassalTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kVassalTeam = GET_TEAM(eVassalTeam);

	// Can't liberate? Abort!
	if(!kMyTeam.CanLiberateVassal(eVassalTeam))
		return false;

	// Shadow AI can't make this decision for teammate
	if(kMyTeam.isHuman() && !m_pPlayer->isHuman())
		return false;

	//World conqueror and this guy lost his capital? He's a perma-vassal.
	if (m_pPlayer->GetDiplomacyAI()->IsGoingForWorldConquest() && GET_PLAYER(ePlayer).IsHasLostCapital())
		return false;

	std::vector<CvPlayerAI*> m_Masters;
	std::vector<CvPlayerAI*> m_Vassals;

	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if(GET_PLAYER(eLoopPlayer).getTeam() == eMyTeam)
				m_Masters.push_back(&GET_PLAYER(eLoopPlayer));
			if(GET_PLAYER(eLoopPlayer).getTeam() == eVassalTeam)
				m_Vassals.push_back(&GET_PLAYER(eLoopPlayer));
		}
	}

	CvAssertMsg(m_Masters.size() > 0, "master team expected to be greater than size 0");
	CvAssertMsg(m_Vassals.size() > 0, "vassal team expected to be greater than size 0");

	MajorCivApproachTypes eMasterApproach = NO_MAJOR_CIV_APPROACH;
	MajorCivOpinionTypes eMasterOpinion = NO_MAJOR_CIV_OPINION_TYPE;
	StrengthTypes eVassalStrength = NO_STRENGTH_VALUE;
	StrengthTypes eVassalEcoStrength = NO_STRENGTH_VALUE;

	int iTotalGPTTimes100 = 0;
	int iApproachScore = 0;
	int iOpinionScore = 0;
	int iStrengthScore = 0;
	int iEcoStrengthScore = 0;

	InfluenceLevelTypes eMasterInfluence = NO_INFLUENCE_LEVEL;
	InfluenceLevelTypes eVassalInfluence = NO_INFLUENCE_LEVEL;

	// Calculate averages for master
	for(std::vector<CvPlayerAI*>::iterator it = m_Masters.begin(); it != m_Masters.end(); it++)
	{
		CvPlayer* pMaster = (*it);

		iTotalGPTTimes100 += pMaster->calculateGoldRateTimes100();

		// How does one master see each vassal?
		int iAverageApproachForOneMaster = 0;
		int iAverageOpinionForOneMaster = 0;
		int iAverageStrengthScoreForOneMaster = 0;
		int iAverageEcoStrengthScoreForOneMaster = 0;

		for(std::vector<CvPlayerAI*>::iterator vIt = m_Vassals.begin(); vIt != m_Vassals.end(); vIt++)
		{
			CvPlayer* pVassal = (*vIt);

			// Did they denounce us?
			if(pVassal->GetDiplomacyAI()->IsDenouncedPlayer(pMaster->GetID()))
				return false;

			// Did we denounce them?
			if(pMaster->GetDiplomacyAI()->IsDenouncedPlayer(pVassal->GetID()))
				return false;

			iAverageApproachForOneMaster += (int) pMaster->GetDiplomacyAI()->GetMajorCivApproach(pVassal->GetID(), /*bHideTrueFeelings*/ false);
			iAverageOpinionForOneMaster += (int) pMaster->GetDiplomacyAI()->GetMajorCivOpinion(pVassal->GetID());
			iAverageStrengthScoreForOneMaster += (int) pMaster->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(pVassal->GetID());
			iAverageEcoStrengthScoreForOneMaster += (int) pMaster->GetDiplomacyAI()->GetPlayerEconomicStrengthComparedToUs(pVassal->GetID());
			
			// Only care about the highest
			InfluenceLevelTypes eMasterInfluenceOverVassal = pMaster->GetCulture()->GetInfluenceLevel(pVassal->GetID());
			if(eMasterInfluenceOverVassal > eMasterInfluence)
				eMasterInfluence = eMasterInfluenceOverVassal;

			// Only care about the highest
			InfluenceLevelTypes eVassalInfluenceOverMaster = pVassal->GetCulture()->GetInfluenceLevel(pMaster->GetID());
			if(eVassalInfluenceOverMaster > eVassalInfluence)
				eVassalInfluence = eVassalInfluenceOverMaster;
		}

		iApproachScore += iAverageApproachForOneMaster;
		iApproachScore /= m_Vassals.size();

		iOpinionScore += iAverageOpinionForOneMaster;
		iOpinionScore /= m_Vassals.size();

		iStrengthScore += iAverageStrengthScoreForOneMaster;
		iStrengthScore /= m_Vassals.size();

		iEcoStrengthScore += iAverageEcoStrengthScoreForOneMaster;
		iEcoStrengthScore /= m_Vassals.size();
	}

	iApproachScore /= m_Masters.size();
	iOpinionScore /= m_Masters.size();
	iStrengthScore /= m_Masters.size();
	iEcoStrengthScore /= m_Masters.size();

	eMasterApproach = (MajorCivApproachTypes) iApproachScore;
	eMasterOpinion = (MajorCivOpinionTypes) iOpinionScore;
	eVassalStrength = (StrengthTypes) iStrengthScore;
	eVassalEcoStrength = (StrengthTypes) iEcoStrengthScore;

	CvAssertMsg(eMasterApproach >= NO_MAJOR_CIV_APPROACH && eMasterApproach < NUM_MAJOR_CIV_APPROACHES, "Something went wrong with the evaluation for approaches.");
	CvAssertMsg(eMasterOpinion >= NO_MAJOR_CIV_OPINION_TYPE && eMasterOpinion < NUM_MAJOR_CIV_OPINION_TYPES, "Something went wrong with the evaluation for opinions.");
	CvAssertMsg(eVassalStrength >= NO_STRENGTH_VALUE && eMasterOpinion < NUM_STRENGTH_VALUES, "Something went wrong with the evaluation for strengths.");
	CvAssertMsg(eMasterInfluence >= NO_INFLUENCE_LEVEL && eMasterInfluence < /* hard-coded */ 6, "Something went wrong with the evaluation for opinions.");
	CvAssertMsg(eVassalInfluence >= NO_INFLUENCE_LEVEL && eMasterInfluence < /* hard-coded */ 6, "Something went wrong with the evaluation for opinions.");

	// Note, could use a "less than "MAJOR_CIV_APPROACH_AFRAID" check, but this is more explicit :)
	// If team doesn't like them, don't consider it.
	if(eMasterApproach == MAJOR_CIV_APPROACH_WAR ||
		eMasterApproach == MAJOR_CIV_APPROACH_HOSTILE ||
		eMasterApproach == MAJOR_CIV_APPROACH_DECEPTIVE ||
		eMasterApproach == MAJOR_CIV_APPROACH_GUARDED)
	{
		return false;
	}

	// Opinion also bad?
	if(eMasterOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE ||
		eMasterOpinion == MAJOR_CIV_OPINION_ENEMY ||
		eMasterOpinion == MAJOR_CIV_OPINION_COMPETITOR)
	{
		return false;
	}

	int iScoreForLiberate = 0;
		
	// Initial score based on remaining approach
	switch(eMasterApproach)
	{
	case MAJOR_CIV_APPROACH_AFRAID:
		iScoreForLiberate = 100;
		break;
	case MAJOR_CIV_APPROACH_FRIENDLY:
		iScoreForLiberate = 50;
		break;
	case MAJOR_CIV_APPROACH_NEUTRAL:
		iScoreForLiberate = 20;
		break;
	default:
		CvAssertMsg(false, "IsWantToLiberateVassal(): Something went terribly wrong");
	}

	// mod based on opinion
	switch(eMasterOpinion)
	{
		case MAJOR_CIV_OPINION_NEUTRAL:
			iScoreForLiberate += 0;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iScoreForLiberate += 10;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			iScoreForLiberate += 15;
			break;
		case MAJOR_CIV_OPINION_ALLY:
			iScoreForLiberate += 25;
			break;
		default:
			CvAssertMsg(false, "IsWantToLiberateVassal(): Something went terribly wrong");
	}

	int iGoldFromTaxesTimes100 = 0;
	// Good source of revenue for us - not so likely to break off
	for(std::vector<CvPlayerAI*>::iterator it = m_Vassals.begin(); it != m_Vassals.end(); it++)
	{
		iGoldFromTaxesTimes100 += (*it)->GetTreasury()->GetExpensePerTurnFromVassalTaxesTimes100();
	}

	// more than 20 percent of our net GPT - less likely
	if(iGoldFromTaxesTimes100 * 100 > iTotalGPTTimes100 * 20)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// don't liberate a strong vassal - he could be a threat
	if(eVassalStrength > STRENGTH_AVERAGE ||
		eVassalEcoStrength > STRENGTH_AVERAGE)
		return false;

	switch(eVassalStrength)
	{
		case STRENGTH_PATHETIC:
			iScoreForLiberate *= 125;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_WEAK:
			iScoreForLiberate *= 115;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_POOR:
			iScoreForLiberate *= 100;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_AVERAGE:
			iScoreForLiberate *= 90;
			iScoreForLiberate /= 100;
			break;
	}

	switch(eVassalEcoStrength)
	{
		case STRENGTH_PATHETIC:
			iScoreForLiberate *= 125;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_WEAK:
			iScoreForLiberate *= 115;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_POOR:
			iScoreForLiberate *= 100;
			iScoreForLiberate /= 100;
			break;
		case STRENGTH_AVERAGE:
			iScoreForLiberate *= 90;
			iScoreForLiberate /= 100;
			break;
	}

	// Mod based on proximity
	switch(m_pPlayer->GetProximityToPlayer(ePlayer))
	{
	case PLAYER_PROXIMITY_DISTANT:
		iScoreForLiberate *= 125;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_FAR:
		iScoreForLiberate *= 110;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_CLOSE:
		iScoreForLiberate *= 100;
		iScoreForLiberate /= 100;
		break;
	case PLAYER_PROXIMITY_NEIGHBORS:
		iScoreForLiberate *= 75;
		iScoreForLiberate /= 100;
		break;
	}

	// City comparison modifier
	int iNumPop = kMyTeam.getTotalPopulation();
	int iNumVassalPop = kVassalTeam.getTotalPopulation();

	if(iNumVassalPop >= iNumPop)
		return false;

	if(iNumVassalPop * 100 > iNumPop * 75)
	{
		iScoreForLiberate *= 75;
		iScoreForLiberate /= 100;
	}
	else if(iNumVassalPop * 100 > iNumPop * 50)
	{
		iScoreForLiberate *= 100;
		iScoreForLiberate /= 100;
	}
	else if(iNumVassalPop * 100 > iNumPop * 33)
	{
		iScoreForLiberate *= 125;
		iScoreForLiberate /= 100;
	}
	else
	{
		iScoreForLiberate *= 150;	// not a threat at all to us
		iScoreForLiberate /= 100;
	}

	int iDominanceOverVassal = eMasterInfluence - eVassalInfluence;

	// someone is pretty dominant over vassal (not too much of a modifier, but helps our chances of liberation)
	if(iDominanceOverVassal > 0)
	{
		iScoreForLiberate *= 120;
		iScoreForLiberate /= 100;
	}
	else if(iDominanceOverVassal < 0)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// Someone influential over one of our vassals
	if(eMasterInfluence >= INFLUENCE_LEVEL_INFLUENTIAL)
	{
		iScoreForLiberate *= 150;
		iScoreForLiberate /= 100;
	}

	// A vassal is influential over us!!! Them being a vassal will be good for us
	if(eVassalInfluence >= INFLUENCE_LEVEL_INFLUENTIAL)
	{
		iScoreForLiberate *= 50;
		iScoreForLiberate /= 100;
	}

	// The longer they've been our vassal, give a very small boost toward liberation
	iScoreForLiberate += 3 * (kVassalTeam.GetNumTurnsIsVassal() / 50);	// 3% per 50 turns

	return (iScoreForLiberate > 100);
}

/// Possible Contact Statement - Third-party offer for ePlayer to liberate their vassals
void CvDiplomacyAI::DoRevokeVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// note: we check to see if it's possible in IsMakeOfferForVassalage()

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Can we make an offer for vassalage?
		if(GetPlayer()->GetDealAI()->IsMakeOfferForRevokeVassalage(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REVOKE_VASSALAGE_THIRD_PARTY;
			int iTurnsBetweenStatement = 50;

			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
			{
				// Send the statement
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
		else
		{
			pDeal->ClearItems();
		}
	}
}
///	Do we want to capitulate to ePlayer? (bWar: is this a wartime assessment?)
bool CvDiplomacyAI::IsVassalageAcceptable(PlayerTypes ePlayer, bool bWar)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// We can't become ePlayer's vassal
	if(!GET_TEAM(GetPlayer()->getTeam()).canBecomeVassal(GET_PLAYER(ePlayer).getTeam()))
		return false;

	// Human teams can capitulate, but the AI can't do it for him and he must accept on the trade screen
	if(GET_TEAM(GetPlayer()->getTeam()).isHuman() || GetPlayer()->IsAITeammateOfHuman())
		return false;

	// Split this function into two evaluations, capitulation (war) and voluntary (peace)
	if(bWar)
	{
		return IsCapitulationAcceptable(ePlayer);
	}
	else
	{
		return IsVoluntaryVassalageAcceptable(ePlayer);
	}
}

/// Do we want to capitulate to ePlayer due to war?
bool CvDiplomacyAI::IsCapitulationAcceptable(PlayerTypes ePlayer)
{
	TeamTypes eOurTeam = GetPlayer()->getTeam();
	CvTeam& kOurTeam = GET_TEAM(eOurTeam);
	
	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kTheirTeam = GET_TEAM(eTheirTeam);

	if(!kOurTeam.isAtWar(eTheirTeam))
		return false;

	// Check war score
	if (GetWarScore(ePlayer) == -100)
		return true;

	// How's the war going?
	WarStateTypes eWarState = GetWarState(ePlayer);
	if(eWarState >= WAR_STATE_STALEMATE ||
		eWarState == NO_WAR_STATE_TYPE)
		return false;

	// We have vassals
	if(GET_TEAM(GetPlayer()->getTeam()).GetNumVassals() > 0)
	{
		return false;
	}

	int iWantVassalageScore = 0;

	int iWarScore = GetWarScore(ePlayer);

	// Check war score
	if (GetWarScore(ePlayer) > -80)
		return false;
	
	if(iWarScore < -80)
		iWantVassalageScore = 75;
	else
		iWantVassalageScore = 100;

	// Mod based on distance
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_DISTANT:
			iWantVassalageScore *= 33;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_FAR:
			iWantVassalageScore *= 66;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWantVassalageScore *= 100;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWantVassalageScore *= 150;
			iWantVassalageScore /= 100;
			break;
	}

	// Factor in this guy's military strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
		case STRENGTH_IMMENSE:
			iWantVassalageScore *= 250;
			iWantVassalageScore /= 100;
			break;
		case STRENGTH_POWERFUL:
			iWantVassalageScore *= 150;
			iWantVassalageScore /= 100;
			break;
		case STRENGTH_STRONG:
			iWantVassalageScore *= 125;
			iWantVassalageScore /= 100;
			break;
		default:
			return false;
			break;
	}

	// We're going for conquest...
	if(IsGoingForWorldConquest())
	{
		iWantVassalageScore *= 50;
		iWantVassalageScore /= 100;
	}

	// Lost our capital?
	if(GetPlayer()->IsHasLostCapital())
	{
		iWantVassalageScore *= 150;
		iWantVassalageScore /= 100;

		// to this player?
		CvPlot* pOriginalCapitalPlot = GC.getMap().plot(GET_PLAYER(ePlayer).GetOriginalCapitalX(), GET_PLAYER(ePlayer).GetOriginalCapitalY());
		if(pOriginalCapitalPlot != NULL)
		{
			if(pOriginalCapitalPlot->isCity())
			{
				if(GET_PLAYER(pOriginalCapitalPlot->getOwner()).getTeam() == GET_PLAYER(ePlayer).getTeam())
				{
					iWantVassalageScore *= 150;
					iWantVassalageScore /= 100;
				}
			}
		}
	}

	//// They have more civs than us!
	if(kOurTeam.getAliveCount() < kTheirTeam.getAliveCount())
	{
		iWantVassalageScore *= 200;
		iWantVassalageScore /= 100;
	}
	else if (kOurTeam.getAliveCount() > kTheirTeam.getAliveCount())
	{
		iWantVassalageScore *= 50;
		iWantVassalageScore /= 100;
	}

	int iThreshold = /*100*/ GC.getVASSALAGE_CAPITULATE_BASE_THRESHOLD();
	return (iWantVassalageScore > iThreshold);
}

/// Do we want to voluntarily become ePlayer's vassal?
bool CvDiplomacyAI::IsVoluntaryVassalageAcceptable(PlayerTypes ePlayer)
{
	TeamTypes eOurTeam = GetPlayer()->getTeam();
	CvTeam& kOurTeam = GET_TEAM(eOurTeam);

	TeamTypes eTheirTeam = GET_PLAYER(ePlayer).getTeam();
	CvTeam& kTheirTeam = GET_TEAM(eTheirTeam);

	// No cities
	if(kTheirTeam.getNumCities() == 0)
		return false;

	// We have more members - no
	if(kOurTeam.getAliveCount() > kTheirTeam.getAliveCount())
		return false;

	// Vassalage never acceptable if I have vassals already
	if(GET_TEAM(GetPlayer()->getTeam()).GetNumVassals() > 0)
		return false;

	//cannot voluntary become a vassal if at war.
	if (GetPlayer()->IsAtWar())
		return false;
	
	// Don't become vassal if we're going for diplo victory and UN is available
	if (!GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
		{
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				if (pLeague->IsUnitedNations())
				{
					if(IsGoingForDiploVictory())
						return false;
				}
			}
		}
	}

	std::vector<PlayerTypes> aOurTeam;
	std::vector<PlayerTypes> aTheirTeam;
	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iI;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			if(GET_PLAYER(eLoopPlayer).getTeam() == eOurTeam)
				aOurTeam.push_back(eLoopPlayer);
			if(GET_PLAYER(eLoopPlayer).getTeam() == eTheirTeam)
				aTheirTeam.push_back(eLoopPlayer);
		}
	}

	int iAverageOpinionScore = 0;
	int iOurCapitals = 0;
	int iTheirCapitals = 0;
	for(std::vector<PlayerTypes>::iterator it = aOurTeam.begin(); it != aOurTeam.end(); it++)
	{
		iOurCapitals += GET_PLAYER(*it).GetNumCapitalCities();
		iAverageOpinionScore += (int) GET_PLAYER(*it).GetDiplomacyAI()->GetMajorCivOpinion(ePlayer);
	}
	for(std::vector<PlayerTypes>::iterator it = aTheirTeam.begin(); it != aTheirTeam.end(); it++)
	{
		iTheirCapitals += GET_PLAYER(*it).GetNumCapitalCities();
	}
	iAverageOpinionScore /= aOurTeam.size();
	MajorCivOpinionTypes eOpinion = (MajorCivOpinionTypes) iAverageOpinionScore;

	if (eOpinion <= MAJOR_CIV_OPINION_NEUTRAL)
		return false;

	// We possess more capitals than them
	if(iOurCapitals >= iTheirCapitals)
		return false;

	// We're going for world conquest?
	if(IsGoingForWorldConquest())
	{
		if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_STRONG)
			return false;
	}

	MajorCivApproachTypes eTrueApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
	
	// if we're planning on war or hostile with this player, don't want to be his voluntary vassal
	if(eTrueApproach == MAJOR_CIV_APPROACH_WAR ||
		eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	//Denouncement in either direction?
	if(IsDenouncedPlayer(ePlayer) || GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
			return false;

	// Don't accept vassalage from players too far away
	if(GetPlayer()->GetProximityToPlayer(ePlayer) < PLAYER_PROXIMITY_CLOSE)
		return false;

	// Player is not a threat
	if(GetPlayerMilitaryStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE)
		return false;

	// Player is not a threat
	if (GetPlayerEconomicStrengthComparedToUs(ePlayer) <= STRENGTH_AVERAGE)
		return false;

	// Are we dominating them in some way?
	InfluenceLevelTypes eInfluence = GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);
	if(eInfluence >= INFLUENCE_LEVEL_POPULAR)
		return false;

	// No voluntary capitulation if there's less than 50% of the players ever alive
	if(GC.getGame().countMajorCivsAlive() < (GC.getGame().countMajorCivsEverAlive() / 2 ))
		return false;

	// Has this player a military promise against us?
	if(IsPlayerBrokenMilitaryPromise(ePlayer))
		return false;

	// Do we think this player is a warmonger?
	if(GetWarmongerThreat(ePlayer) >= THREAT_MAJOR)
		return false;

	// Differing ideologies?
	if(GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE &&
		GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE &&
		GetPlayer()->GetPlayerPolicies()->GetLateGamePolicyTree() != GET_PLAYER(ePlayer).GetPlayerPolicies()->GetLateGamePolicyTree())
		return false;

	// If we got down here, then vassalage is possible - let's evaluate
	int iWantVassalageScore = 0;

	// Small bonus for voluntary vassalage depending on opinion
	if(eOpinion <= MAJOR_CIV_OPINION_NEUTRAL)
		iWantVassalageScore += -20;
	else if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
		iWantVassalageScore += 5;
	else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
		iWantVassalageScore += 10;
	else if(eOpinion == MAJOR_CIV_OPINION_ALLY)
		iWantVassalageScore += 15;
	else
		iWantVassalageScore += -25;

	// If they are economically strong, consider vassalage
	StrengthTypes eEconomyStrength = GetPlayerEconomicStrengthComparedToUs(ePlayer);
	if(eEconomyStrength == STRENGTH_IMMENSE)
		iWantVassalageScore += 60;
	else if(eEconomyStrength == STRENGTH_POWERFUL)
		iWantVassalageScore += 40;
	else if(eEconomyStrength == STRENGTH_STRONG)
		iWantVassalageScore += 20;
	else if(eEconomyStrength == STRENGTH_AVERAGE)
		iWantVassalageScore += -20;
	else if(eEconomyStrength == STRENGTH_POOR)
		iWantVassalageScore += -40;
	else if(eEconomyStrength == STRENGTH_WEAK)
		iWantVassalageScore += -75;
	else
		iWantVassalageScore += -100;

	// If they are militarily strong, consider vassalage
	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_IMMENSE)
		iWantVassalageScore += 60;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iWantVassalageScore += 45;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iWantVassalageScore += 25;
	else
		iWantVassalageScore += -100;

	// Small bonus for being a threat to us
	ThreatTypes eMilitaryThreat = GetMilitaryThreat(ePlayer);
	if(eMilitaryThreat == THREAT_CRITICAL)
		iWantVassalageScore += 20;
	else if(eMilitaryThreat == THREAT_SEVERE)
		iWantVassalageScore += 10;
	else if(eMilitaryThreat == THREAT_MAJOR)
		iWantVassalageScore += 5;
	else if(eMilitaryThreat <= THREAT_MINOR)
		iWantVassalageScore += -20;
	else
		iWantVassalageScore += 0;

	int iOurTechs = kOurTeam.GetTeamTechs()->GetNumTechsKnown();
	int iTheirTechs = kTheirTeam.GetTeamTechs()->GetNumTechsKnown();
	int iTechPercent = 0;
	if(iTheirTechs == 0)
		iTechPercent = INT_MAX;
	else
		iTechPercent = iOurTechs * 100 / iTheirTechs;

	// We are at a similar tech level!
	if(iTechPercent > 95)
		return false;

	// Lagging behind
	if(iTechPercent >= 85)
		iWantVassalageScore += 10;
	else if(iTechPercent >= 75)
		iWantVassalageScore += 20;
	// Really far behind!
	else if(iTechPercent >= 65)
		iWantVassalageScore += 30;
	else
		iWantVassalageScore += 40;

	int iVal = MOD_BALANCE_CORE_HAPPINESS ? 50 : 0;
	// Small mod based on happiness
	if (GetPlayer()->GetExcessHappiness() < iVal)
		iWantVassalageScore += 5;

	// Account for this player's flavors
	
	// If the player has deleted the EXPANSION Flavor we have to account for that
	int iExpansionFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iOffenseFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iMilitaryTrainingFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iDefenseFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iCultureFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();
	int iWonderFlavor = /*5*/ GC.getDEFAULT_FLAVOR_VALUE();

	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)
	{
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_EXPANSION")			iExpansionFlavor = GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_OFFENSE")			iOffenseFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")	iMilitaryTrainingFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_DEFENSE")			iDefenseFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_CULTURE")			iCultureFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
		if(GC.getFlavorTypes((FlavorTypes) iFlavorLoop) == "FLAVOR_WONDER")				iWonderFlavor =  GetPlayer()->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavorLoop);
	}

	// Adjust score based on civ flavors
	iWantVassalageScore += (iExpansionFlavor - GC.getDEFAULT_FLAVOR_VALUE()) * -2;	// expansionist civs don't like vassalage too much
	iWantVassalageScore += (iOffenseFlavor - GC.getDEFAULT_FLAVOR_VALUE()) * -2;	// offensive civs don't like vassalage too much
	iWantVassalageScore += (iMilitaryTrainingFlavor - GC.getDEFAULT_FLAVOR_VALUE())	* -2;	// offensive civs don't like vassalage too much
	iWantVassalageScore += (iDefenseFlavor - GC.getDEFAULT_FLAVOR_VALUE());	// defensive civs like vassalage a lot
	iWantVassalageScore += (iCultureFlavor - GC.getDEFAULT_FLAVOR_VALUE());	// cultural civs prefer vassalage
	iWantVassalageScore += (iWonderFlavor - GC.getDEFAULT_FLAVOR_VALUE());	// wonder civs don't mind vassalage

	// Modifier based on proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_NEIGHBORS:
			iWantVassalageScore *= 133;
			iWantVassalageScore /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			iWantVassalageScore *= 110;
			iWantVassalageScore /= 100;
			break;
		default:
			return false;
	}

	// Are they threatening us with military?
	AggressivePostureTypes eAggressivePosture = GetMilitaryAggressivePosture(ePlayer);
	if(eAggressivePosture == AGGRESSIVE_POSTURE_INCREDIBLE)
	{
		iWantVassalageScore *= 150;
		iWantVassalageScore /= 100;
	}
	else if(eAggressivePosture == AGGRESSIVE_POSTURE_HIGH)
	{
		iWantVassalageScore *= 125;
		iWantVassalageScore /= 100;
	}
	else if(eAggressivePosture == AGGRESSIVE_POSTURE_MEDIUM)
	{
		iWantVassalageScore *= 110;
		iWantVassalageScore /= 100;
	}

	// We're bigger than him? Bail!
	if (GET_PLAYER(ePlayer).getTotalPopulation() < GET_PLAYER(GetPlayer()->GetID()).getTotalPopulation())
	{
		iWantVassalageScore *= 75;
		iWantVassalageScore /= 100;
	}

	// Modifier based on culture
	int iCulturalDominanceOverUs = GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);

	iWantVassalageScore *= (100 + 10 * iCulturalDominanceOverUs);
	iWantVassalageScore /= 100;

	// Reduce score based on at war count
	iWantVassalageScore -= 20 * kTheirTeam.getAtWarCount(true);

	// Reduce score based on number of his vassals
	iWantVassalageScore -= 20 * kTheirTeam.GetNumVassals();

	int iThreshold = /*100*/ GC.getVASSALAGE_CAPITULATE_BASE_THRESHOLD() + 25;

	return (iWantVassalageScore > iThreshold);
}

/// Are we done being ePlayer's vassal, and now want to end it?
bool CvDiplomacyAI::IsEndVassalageAcceptable(PlayerTypes ePlayer)
{
	CvAssertMsg(IsVassal(ePlayer), "Diplomacy AI: Testing whether we should End Vassalage with someone, but we aren't right now. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	// If we actually can't end Vassalage with ePlayer (conditions not satisfied) then abort
	if(!GET_TEAM(GetPlayer()->getTeam()).canEndVassal(GET_PLAYER(ePlayer).getTeam()))
		return false;
	
	// Shadow AI does not make decisions for human!
	if(GetPlayer()->IsAITeammateOfHuman())
		return false;

	// don't do this in anarchy
	if(m_pPlayer->IsAnarchy())
		return false;

	if (GET_PLAYER(ePlayer).IsVassalsNoRebel())
		return false;

	// If UN is in session, end vassalage ASAP if going for diplo victory
	if (!GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
		{
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				if (pLeague->IsUnitedNations())
				{
					if(IsGoingForDiploVictory())
						return true;
				}
			}
		}
	}

	int iChance = 0;

	// How are we being treated?
	VassalTreatmentTypes eVassalTreatment = GetVassalTreatmentLevel(ePlayer);
	if(eVassalTreatment == VASSAL_TREATMENT_ENSLAVED)
		iChance += 80;
	else if(eVassalTreatment == VASSAL_TREATMENT_UNHAPPY)
		iChance += 60;
	else if(eVassalTreatment == VASSAL_TREATMENT_MISTREATED)
		iChance += 40;
	else if(eVassalTreatment == VASSAL_TREATMENT_DISAGREE)
		iChance += 20;
	else
		iChance += 0;

	// More likely to break vassals off with distant players than close neighbors
	PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
	if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChance += 30;
	else if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChance += 15;

	MajorCivApproachTypes eSurfaceApproach = GetMajorCivApproach(ePlayer, true);

	// if the current approach is a dangerous approach
	if (eSurfaceApproach == MAJOR_CIV_APPROACH_DECEPTIVE || eSurfaceApproach == MAJOR_CIV_APPROACH_WAR)
	{
		iChance += 25;
	}

	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_PATHETIC)
		iChance += 100;
	else if(eMilitaryStrength == STRENGTH_WEAK)
		iChance += 60;
	else if(eMilitaryStrength == STRENGTH_POOR)
		iChance += 40;
	else if(eMilitaryStrength == STRENGTH_AVERAGE)
		iChance += 10;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iChance += -40;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iChance += -60;
	else
		iChance += -40;

	// How will a war against ePlayer go?
	WarProjectionTypes eWarProjection = GetWarProjection(ePlayer);
	if(eWarProjection == WAR_PROJECTION_VERY_GOOD)
		iChance += 40;
	else if(eWarProjection == WAR_PROJECTION_GOOD)
		iChance += 30;
	if(eWarProjection == WAR_PROJECTION_STALEMATE)
		iChance += 5;
	else if(eWarProjection == WAR_PROJECTION_DEFEAT)
		iChance += -20;
	else if(eWarProjection == WAR_PROJECTION_DESTRUCTION)
		iChance += -50;
	else
		iChance += 0;

	// Are we culturally dominant over hem?
	int iCulturalDominanceOverUs = GET_PLAYER(ePlayer).GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - GetPlayer()->GetCulture()->GetInfluenceLevel(ePlayer);
	if(iCulturalDominanceOverUs <= 0)
	{
		iChance *= 150;
		iChance /= 100;
	}

	// Modifier based on number of wars currently fighting
	iChance *= (100 + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getAtWarCount(true) * 20);
	iChance /= 100;

	// Master is losing all of our wars at the moment - not protecting us
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		iChance *= 500;
		iChance /= 100;
	}

	// We're bigger than him? Bail!
	if (GET_PLAYER(ePlayer).getTotalPopulation() < GET_PLAYER(GetPlayer()->GetID()).getTotalPopulation())
	{
		iChance *= 500;
		iChance /= 100;
	}

	// Master is aggressive against us
	if(GetMilitaryAggressivePosture(ePlayer) >= AGGRESSIVE_POSTURE_MEDIUM)
	{
		iChance *= 80;
		iChance /= 100;
	}

	// if we're a warmonger
	if(IsGoingForWorldConquest())
	{
		iChance *= 500;
		iChance /= 100;
	}

	// Master in anarchy?
	if(GET_PLAYER(ePlayer).IsAnarchy())
	{
		iChance *= 500;
		iChance /= 100;
	}

	return (iChance >= 100); // todo: global define
}

/// Player ended vassalage with us, is that acceptable?
bool CvDiplomacyAI::IsEndVassalageRequestAcceptable(PlayerTypes ePlayer)
{
//	CvAssertMsg(GET_PLAYER(eHuman).GetDiplomacy()->IsVassal(GetPlayer()->GetID()), "CvDiplomacyAI: Human ending vassalage with us, but he's not our vassal.");

	int iChanceToGiveIn = 0;

	MajorCivApproachTypes eTrueApproach = (GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false));
	MajorCivOpinionTypes eOpinion = (GetMajorCivOpinion(ePlayer));

	// We hate him - war!
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE ||
		eOpinion == MAJOR_CIV_OPINION_ENEMY)
		return false;

	// We hate him - war!
	if(eTrueApproach == MAJOR_CIV_APPROACH_WAR ||
		eTrueApproach == MAJOR_CIV_APPROACH_DECEPTIVE ||
		eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
		return false;

	// We're afraid - give in 
	if(eTrueApproach == MAJOR_CIV_APPROACH_AFRAID)
		return true;

	// Do we like him?
	if(eOpinion == MAJOR_CIV_OPINION_ALLY)
		iChanceToGiveIn += 25;
	else if(eOpinion == MAJOR_CIV_OPINION_FRIEND)
		iChanceToGiveIn += 15;
	else if(eOpinion == MAJOR_CIV_OPINION_FAVORABLE)
		iChanceToGiveIn += 8;
	else if(eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
		iChanceToGiveIn += -20;		

	// How will a war against eHuman go?
	WarProjectionTypes eWarProjection = GetWarProjection(ePlayer);
	if(eWarProjection == WAR_PROJECTION_DESTRUCTION)
		iChanceToGiveIn += 33;
	else if(eWarProjection == WAR_PROJECTION_DEFEAT)
		iChanceToGiveIn += 18;
	else if(eWarProjection == WAR_PROJECTION_STALEMATE)
		iChanceToGiveIn += 0;
	else if(eWarProjection == WAR_PROJECTION_GOOD)
		iChanceToGiveIn += -18;
	else if(eWarProjection == WAR_PROJECTION_VERY_GOOD)
		iChanceToGiveIn += -33;
	else 
		iChanceToGiveIn += 0;

	StrengthTypes eMilitaryStrength = GetPlayerMilitaryStrengthComparedToUs(ePlayer);
	if(eMilitaryStrength == STRENGTH_IMMENSE)
		iChanceToGiveIn += 50;
	else if(eMilitaryStrength == STRENGTH_POWERFUL)
		iChanceToGiveIn += 33;
	else if(eMilitaryStrength == STRENGTH_STRONG)
		iChanceToGiveIn += 18;
	else if(eMilitaryStrength == STRENGTH_AVERAGE)
		iChanceToGiveIn += 0;
	else if(eMilitaryStrength == STRENGTH_POOR)
		iChanceToGiveIn += -20;
	else if(eMilitaryStrength == STRENGTH_WEAK)
		iChanceToGiveIn += -40;
	else 
		iChanceToGiveIn += 0;

	// How much money are we making off this vassal and his team?
	int iTaxIncome = GET_PLAYER(ePlayer).GetTreasury()->GetExpensePerTurnFromVassalTaxesTimes100();
	int iOurGPT = m_pPlayer->calculateGoldRateTimes100();
	
	// Tax is 50% of our income, heavily reliant on it
	if(iTaxIncome * 50 > iOurGPT)
		iChanceToGiveIn += -25;
	else if(iTaxIncome * 20 > iOurGPT)
		iChanceToGiveIn += -10;
	else
		iChanceToGiveIn += 0;

	PlayerProximityTypes eProximity = GetPlayer()->GetProximityToPlayer(ePlayer);
	if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChanceToGiveIn *= 120;
	else if(eProximity == PLAYER_PROXIMITY_DISTANT)
		iChanceToGiveIn *= 110;
	else
		iChanceToGiveIn *= 100;

	iChanceToGiveIn /= 1000;

	if (iChanceToGiveIn <= 3)
	{
		iChanceToGiveIn = 3;
	}

	int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

	if(iRand < iChanceToGiveIn)
		return true;

	return false;
}

/// Possible Contact Statement - We're done being ePlayer's vassal
void CvDiplomacyAI::DoEndVassalageStatement(PlayerTypes ePlayer, DiploStatementTypes& eStatement)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		// Must be vassal of ePlayer
		if(IsVassal(ePlayer))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_REVOKE_VASSALAGE;
			int iTurnsBetweenStatement = 10;

			// Done being this player's vassal?
			if (IsEndVassalageAcceptable(ePlayer))
			{
				if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatement)
					eStatement = eTempStatement;
			}
		}
	}
}

/// Possible Contact Statement - World Map
void CvDiplomacyAI::DoMapsOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForMaps(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_MAPS_OFFER;
			int iTurnsBetweenStatements = 30;

#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Purchase technology
void CvDiplomacyAI::DoTechOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		if(GetPlayer()->GetDealAI()->IsMakeOfferForTech(ePlayer, /*pDeal can be modified in this function*/ pDeal))
		{
			DiploStatementTypes eTempStatement = DIPLO_STATEMENT_TECH_OFFER;
			int iTurnsBetweenStatements = 30;

#if defined(MOD_BALANCE_CORE)
			if(GetNeediness() > 7)
			{
				iTurnsBetweenStatements /= 2;
			}
			int iMessage = 0;
			int iMessageMax = MAX_INT;
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;

				if(eLoopPlayer != NULL && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && eLoopPlayer != ePlayer)
				{
					iMessage = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTurnsSinceStatementSent(ePlayer, eTempStatement);
					if(iMessage < iMessageMax)
					{
						iMessageMax = iMessage;
					}
				}
			}
			if(iMessageMax >= iTurnsBetweenStatements && (GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements))
#else
			if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= iTurnsBetweenStatements)
#endif
			{
				eStatement = eTempStatement;
			}
			else
			{
				pDeal->ClearItems();
			}
		}
		else
		{
			// Clear out the deal if we don't want to offer it so that it's not tainted for the next trade possibility we look at
			pDeal->ClearItems();
		}
	}
}

/// Possible Contact Statement - Generous Offer
void CvDiplomacyAI::DoGenerousOffer(PlayerTypes ePlayer, DiploStatementTypes& eStatement, CvDeal* pDeal)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(eStatement == NO_DIPLO_STATEMENT_TYPE)
	{
		DiploStatementTypes eTempStatement = DIPLO_STATEMENT_GENEROUS_OFFER;

		if(GetNumTurnsSinceStatementSent(ePlayer, eTempStatement) >= 60 &&
				GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED) >= 15 &&
				// Don't send a generous offer request if we recently sent a Request to this player
				GetNumTurnsSinceStatementSent(ePlayer, DIPLO_STATEMENT_REQUEST) >= 25)
		{
			bool bRandPassed = false;
			bool bMakeGenerousOffer = IsMakeGenerousOffer(ePlayer, pDeal, bRandPassed);

			if(bMakeGenerousOffer && pDeal->GetNumItems() > 0)
			{
				eStatement = eTempStatement;
				SetOfferingGift(ePlayer, true);
				bRandPassed = true;
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
				pDeal->m_bIsGift = true;
#endif
			}
			else
			{
				pDeal->ClearItems();
			}
			
			// Add this statement to the log so we don't evaluate it again until 15 turns has come back around
			if(!bRandPassed)
				DoAddNewStatementToDiploLog(ePlayer, DIPLO_STATEMENT_GENEROUS_OFFER_RANDFAILED);
		}
	}
}
/// Is this AI offering a gift to ePlayer?
bool CvDiplomacyAI::IsOfferingGift(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabOfferingGift[ePlayer];
}

/// Sets if this AI is offering a gift to ePlayer
void CvDiplomacyAI::SetOfferingGift(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsOfferingGift(ePlayer))
	{
		m_pabOfferingGift[ePlayer] = bValue;
	}
}

/// Did this AI offer a gift to ePlayer?
bool CvDiplomacyAI::IsOfferedGift(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabOfferedGift[ePlayer];
}

/// Sets if this AI offered a gift to ePlayer
void CvDiplomacyAI::SetOfferedGift(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsOfferingGift(ePlayer))
	{
		m_pabOfferedGift[ePlayer] = bValue;
	}
}

/// Does this AI want to purchase a technology?
bool CvDiplomacyAI::IsTechRequest(PlayerTypes ePlayer, CvDeal* pDeal, int& iWeightBias)
{
	iWeightBias = 0;

	TechTypes eTechToAskFor = NO_TECH;

	int iTechLoop;

	int iNumTechsWeHave = GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iNumTechsTheyHave = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
	
	if(iNumTechsTheyHave == 0)
		return false;

	int iNumTechsPercent = iNumTechsWeHave * 100 / iNumTechsTheyHave;

	if(iNumTechsPercent < 90)
		return false;

	// See if the other player has a Tech to trade
	for(iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);

		// Can they actually give us this item
		if(!pDeal->IsPossibleToTradeItem(ePlayer, GetPlayer()->GetID(), TRADE_ITEM_TECHS, eTech))
			continue;

		eTechToAskFor = eTech;
		break;
	}

	// Didn't find something they could give us?
	if(eTechToAskFor == NO_TECH)
		return false;

	// Add a little something extra since we're in dire straights
	if(iNumTechsPercent < 90)
		iWeightBias += 25;

	// Now seed the deal
	pDeal->AddTechTrade(ePlayer, eTechToAskFor);

	return true;
}

/// Do we want to trade world maps with eOtherPlayer? - this is only used for when to trigger an AI request, not whether or not the AI will accept a deal period
bool CvDiplomacyAI::WantsMapsFromPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true);
	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)
	{
		return false;
	}

	// Physically see how much the deal will cost us. Only send request if it's in an acceptable range
	int iMapValue = GetPlayer()->GetDealAI()->GetMapValue(false, ePlayer, false);
	if(iMapValue > 750)
	{
		return true;
	}

	return false;
}

/// Do we want to make a generous offer to ePlayer?
bool CvDiplomacyAI::IsMakeGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal, bool& bRandPassed)
{
	bool bFriendly = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ true) == MAJOR_CIV_APPROACH_FRIENDLY;

	if(bFriendly && IsDoFAccepted(ePlayer))
	{
		// Something we want to offer?
		bool bWantsToOfferSomething = false;

		// Gold Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsGoldGenerousOffer(ePlayer, pDeal);
		// Luxury Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsLuxuryGenerousOffer(ePlayer, pDeal);
		// Tech Request
		if(!bWantsToOfferSomething)
			bWantsToOfferSomething = IsTechGenerousOffer(ePlayer, pDeal);

		if(bWantsToOfferSomething)
		{
			// Random element
			int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

			// modifier based on AI loyalty
			int iModifier = (GetLoyalty() - 5);	// +20 for 7 Loyalty, +0 for 5 Loyalty, -30 for 2 Loyalty, +50 for 10 Loyalty

			iRand += iModifier;

			if(iRand >= 6)
			{
				bRandPassed = true;
				return true;
			}
			else
			{
				bRandPassed = false;
				return false;
			}
		}
	}

	return false;
}

/// Do we want to make a gift of gold to ePlayer?
bool CvDiplomacyAI::IsGoldGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	int iOurGold = GetPlayer()->GetTreasury()->GetGold();
	int iOurGPT = GetPlayer()->calculateGoldRate();
	int iOurExpenses = GetPlayer()->GetTreasury()->CalculateInflatedCosts();
	int iOurGrossIncome = iOurGPT + iOurExpenses;

	// If we have no expenses, don't offer (and also don't crash)
	if(iOurExpenses == 0)
		return false;

	// If we don't have gold saved up, don't bother
	if(iOurGold < 100)
		return false;

	// If we're not making 35% more than we're spending then don't offer, we're not doing alright
	if(iOurGrossIncome * 100 / iOurExpenses < 135)
		return false;

	int iTheirGold = GET_PLAYER(ePlayer).GetTreasury()->GetGold();
	int iTheirGPT = GET_PLAYER(ePlayer).calculateGoldRate();
	int iTheirExpenses = GET_PLAYER(ePlayer).GetTreasury()->CalculateInflatedCosts();
	int iTheirGrossIncome = iTheirGPT + iTheirExpenses;

	// Don't divide by zero please
	if(iTheirExpenses != 0)
	{
		// If they're making more than 35% more than they're spending then don't offer, they're in good shape
		if(iTheirGrossIncome * 100 / iTheirExpenses > 135)
			return false;
	}
	else if(iTheirGPT >= iOurGPT)
	{
		return false;
	}

	// Let's not offer any gold if they have more than us
	if(iTheirGold > iOurGold)
	{
		return false;
	}

	// If we've made it this far we'd like to offer, so figure out how much we want to offer
	int iGoldToOffer = iOurGPT * GC.getGame().GetDealDuration() / 20;
	int iGPTToOffer = 0;

	// Let's not offer the player more than double the amount of gold they have
	/*if(iTheirGold != 0)
	{
		if(iGoldToOffer > iTheirGold * 2)
			iGoldToOffer = iTheirGold * 2;
	}*/

	if(iGoldToOffer > iOurGold)
	{
		iGoldToOffer = 0;
		iGPTToOffer = max(1, iOurGPT / 6);
	}

	// Now seed the deal
	if(iGoldToOffer > 0)
		pDeal->AddGoldTrade(GetPlayer()->GetID(), iGoldToOffer);
	else if(iGPTToOffer > 0)
		pDeal->AddGoldPerTurnTrade(GetPlayer()->GetID(), iGPTToOffer, GC.getGame().GetDealDuration());

	return true;
}

/// Do we want to gift a luxury to ePlayer?
bool CvDiplomacyAI::IsLuxuryGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	ResourceTypes eLuxuryToOffer = NO_RESOURCE;

	int iResourceLoop;

	// See if there's any Luxuries WE can trade
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			// Only look at Luxuries
			if(pkResource->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GetPlayer()->getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), ePlayer, TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			eLuxuryToOffer = eResource;
			break;
		}
	}

	// Didn't find something we could give them?
	if(eLuxuryToOffer == NO_RESOURCE)
		return false;

	// See if the other player has a Resource to trade (because if there are then we shouldn't be offering hand outs)
	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);

		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if(pkResourceInfo)
		{
			// Only look at Luxuries
			if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
				continue;

			// Any extras?
			if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, /*bIncludeImport*/ false) < 2)
				continue;

			// Can they actually give us this item
			if(!pDeal->IsPossibleToTradeItem(ePlayer, GetPlayer()->GetID(), TRADE_ITEM_RESOURCES, eResource, 1))
				continue;

			// Found something we can trade to them, so abort
			return false;
		}
	}

	// Now seed the deal
	pDeal->AddResourceTrade(GetPlayer()->GetID(), eLuxuryToOffer, 1, GC.getGame().GetDealDuration());

	return true;
}

/// Do we want to gift a technology to ePlayer?
bool CvDiplomacyAI::IsTechGenerousOffer(PlayerTypes ePlayer, CvDeal* pDeal)
{
	TechTypes eTechToOffer = NO_TECH;

	int iTechLoop;

	// See if the other player is lagging in science
	int iOurScience = GetPlayer()->GetScience();
	int iTheirScience = GetPlayer()->GetScience();

	if (iOurScience < iTheirScience)
		return false;

	// See if there's any Technologies WE can trade
	for(iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);

		// Can we actually give us this item
		if(!pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), ePlayer, TRADE_ITEM_TECHS, eTech, 1))
			continue;

		eTechToOffer = eTech;
		break;
	}

	// Didn't find something we could give them?
	if(eTechToOffer == NO_TECH)
		return false;

	// We made it this far, let's give them a tech.

	// Now seed the deal
	pDeal->AddTechTrade(GetPlayer()->GetID(), eTechToOffer);

	return true;
}

/// Are we willing to share our opinion of other players with ePlayer?
bool CvDiplomacyAI::IsShareOpinionAcceptable(PlayerTypes ePlayer)
{
	MajorCivApproachTypes eApproach = GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false);
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	// Have to share opinion to master
	if(IsVassal(ePlayer))
		return true;

    // Teammates
	if(GetTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return true;
	}

	//If we have a declaration of friendship, always yes
	if(IsDoFAccepted(ePlayer))
	{
		return true;
	}

	// If we act hostile, it's not acceptable
	if(IsActHostileTowardsHuman(ePlayer))
		return false;

	// Just in case we're not acting hostile (for some reason), but our approach is still something bad...
	if(eApproach == MAJOR_CIV_APPROACH_WAR ||
		eApproach == MAJOR_CIV_APPROACH_HOSTILE||
		eApproach == MAJOR_CIV_APPROACH_GUARDED)
	{
		return false;
	}

	if(eApproach == MAJOR_CIV_APPROACH_AFRAID)
	{
		return true;
	}

	// Haven't known this guy for long enough
	if(IsTooEarlyForShareOpinion(ePlayer))
		return false;
	
	// If player is unforgivable or an enemy, always say no
	if(eOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE ||
		eOpinion == MAJOR_CIV_OPINION_ENEMY)
		return false;

	// Has there been a denouncement in either direction?
	if(IsDenouncedPlayer(ePlayer))
		return false;
	if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetPlayer()->GetID()))
		return false;

	int iDiplomacyBalance = GetDiploBalance();

	/// For some reason it's missing
	if(GetDiploBalance() == 0)
	{
		iDiplomacyBalance = 5;
	}

	int iThreshold = (iDiplomacyBalance - /*2*/ GC.getSHARE_OPINION_FLAVOR_BASE()) * /*10*/ GC.getSHARE_OPINION_FLAVOR_MULTIPLIER();
	int iModifier = 0;

	// Modifier based on opinion
	switch(eOpinion)
	{
		case MAJOR_CIV_OPINION_COMPETITOR:
			iModifier = 25;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			iModifier = 75;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			iModifier = 120;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			iModifier = 150;
			break;
		case MAJOR_CIV_OPINION_ALLY:
			iModifier = 200;
			break;
	}
	
	// Modifier based on Approach
	switch(eApproach)
	{
		case MAJOR_CIV_APPROACH_NEUTRAL:
			iModifier += 100;
			break;
		case MAJOR_CIV_APPROACH_DECEPTIVE:
			iModifier += 75;
			break;
		case MAJOR_CIV_APPROACH_AFRAID:
			iModifier += 150;
			break;
		case MAJOR_CIV_APPROACH_FRIENDLY:
			iModifier += 200;
			break;
	}

	iThreshold *= iModifier;
	iThreshold /= 2000;	// 200 because adding two multipliers together
	if (iThreshold <= 3)
	{
		iThreshold = 3;
	}

	int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));

	if(iRand < iThreshold)
		return true;
		
	return false;
}

/// AI won't agree to share Opinions until they've known a player for at least a few turns.
bool CvDiplomacyAI::IsTooEarlyForShareOpinion(PlayerTypes ePlayer)
{
	int iShareOpinionBuffer = /*20*/ GC.getSHARE_OPINION_TURN_BUFFER();

	// Never too early for teammates to share opinion
	if(GET_PLAYER(ePlayer).getTeam() == GetTeam())
	{
		return false;
	}

	// Never too early for vassals to share opinion
	if(IsVassal(ePlayer))
	{
		return false;
	}

	// Never too early for friends to share opinion
	if(IsDoFAccepted(ePlayer))
	{
		return false;
	}

	if(GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < iShareOpinionBuffer)
		return true;

	return false;
}

bool CvDiplomacyAI::IsShareOpinionTooSoon(PlayerTypes ePlayer) const
{
	// If we have a DoF with player, it's never too soon
	if(IsDoFAccepted(ePlayer))
	{
		return false;
	} 
	// Have we already allowed them into our diplomatic secrets?
	if(IsShareOpinionAccepted(ePlayer))
	{
		return false;
	}

	//Last time we asked was 15 turns ago
	if(GetShareOpinionCounter(ePlayer) >= 0 &&
		GetShareOpinionCounter(ePlayer) < GC.getGame().getGameSpeedInfo().getShareOpinionDuration())
		return true;

	return false;
}

bool CvDiplomacyAI::IsShareOpinionAccepted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabShareOpinionAccepted[ePlayer];
}

void CvDiplomacyAI::SetShareOpinionAccepted(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	if(bValue != IsShareOpinionAccepted(ePlayer))
	{
		m_pabShareOpinionAccepted[ePlayer] = bValue;
	}
}

short CvDiplomacyAI::GetShareOpinionCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiShareOpinionCounter[ePlayer];
}

void CvDiplomacyAI::SetShareOpinionCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiShareOpinionCounter[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeShareOpinionCounter(PlayerTypes ePlayer, int iChange)
{
	SetShareOpinionCounter(ePlayer, GetShareOpinionCounter(ePlayer) + iChange);
}

void CvDiplomacyAI::DoHelpRequestMade(PlayerTypes ePlayer, DemandResponseTypes eResponse)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

#if defined(MOD_BALANCE_CORE)
	SetHelpRequestEverMade(ePlayer, true);
#endif
	
	// If gift was agreed to, reset the counter
	if (eResponse == DEMAND_RESPONSE_GIFT_ACCEPT)
	{
		SetHelpRequestCounter(ePlayer, 0);
		
		// See how long it'll be before we might agree to another help request

		int iNumTurns = /*20*/ GC.getHELP_REQUEST_TURN_LIMIT_MIN();
		int iRand = GC.getGame().getSmallFakeRandNum(/*10*/ GC.getHELP_REQUEST_TURN_LIMIT_RAND(),  ePlayer);
		iNumTurns += iRand;

		m_paiHelpRequestTooSoonNumTurns[ePlayer] = iNumTurns;
	}
}

bool CvDiplomacyAI::IsHelpRequestTooSoon(PlayerTypes ePlayer) const
{
	int iHelpRequestTooSoonNumTurns = GetHelpRequestTooSoonNumTurns(ePlayer);

	// Haven't gotten a help request before
	if(iHelpRequestTooSoonNumTurns == -1)
		return false;

	int iCounter = GetHelpRequestCounter(ePlayer);

	if(iCounter > -1 && iCounter < iHelpRequestTooSoonNumTurns)
		return true;

	return false;
}

short CvDiplomacyAI::GetHelpRequestTooSoonNumTurns(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiHelpRequestTooSoonNumTurns[ePlayer];
}

bool CvDiplomacyAI::IsHelpRequestEverMade(PlayerTypes ePlayer) const
{
#if defined(MOD_BALANCE_CORE)
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabHelpRequestEverMade[ePlayer];
#else
	if(GetHelpRequestCounter(ePlayer) == -1)
		return false;
	return true;
#endif
}

short CvDiplomacyAI::GetHelpRequestCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiHelpRequestCounter[ePlayer];
}

void CvDiplomacyAI::SetHelpRequestCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiHelpRequestCounter[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeHelpRequestCounter(PlayerTypes ePlayer, int iChange)
{
	SetHelpRequestCounter(ePlayer, GetHelpRequestCounter(ePlayer) + iChange);
}

int CvDiplomacyAI::GetMasterLiberatedMeFromVassalageScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if(IsMasterLiberatedMeFromVassalage(ePlayer))
	{
		iOpinionWeight += /*-50*/ GC.getOPINION_WEIGHT_MASTER_LIBERATED_ME_FROM_VASSALAGE();
	}

	return iOpinionWeight;
}

/// Opinion weight change based on being vassal
int CvDiplomacyAI::GetVassalScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	iOpinionWeight += bVoluntaryVassal ? GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VOLUNTARY_VASSAL() : GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_VASSAL();

	return iOpinionWeight;
}

/// Get how we think ePlayer has treated us as our master
VassalTreatmentTypes CvDiplomacyAI::GetVassalTreatmentLevel(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer))
		return NO_VASSAL_TREATMENT;

	int iScore = GetVassalTreatedScore(ePlayer);

	if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_DISAGREE())
		return VASSAL_TREATMENT_CONTENT;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_MISTREATED())
		return VASSAL_TREATMENT_DISAGREE;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_UNHAPPY())
		return VASSAL_TREATMENT_MISTREATED;
	else if(iScore <= GC.getVASSALAGE_TREATMENT_THRESHOLD_ENSLAVED())
		return VASSAL_TREATMENT_UNHAPPY;
	else
		return VASSAL_TREATMENT_ENSLAVED;
}

/// Tooltip for GetVassalTreatmentLevel()
CvString CvDiplomacyAI::GetVassalTreatmentToolTip(PlayerTypes ePlayer) const
{
	CvString szRtnValue = "";
	CvString szColor;

	int iScore = 0;
	
	int iTotalScore = GetVassalTreatedScore(ePlayer);

	if(iTotalScore == 0)
	{
		szRtnValue += GetLocalizedText("TXT_KEY_VO_TREATMENT_NOTHING", -iScore);
	}
	else
	{
		szRtnValue += GetLocalizedText("TXT_KEY_VO_TREATMENT_TT") + "[NEWLINE]";

		// Demands made of them
		iScore = GetVassalDemandScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_DEMAND", -iScore) + "[ENDCOLOR]";
		
		// Taxation policies
		iScore = GetVassalTaxScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TAX", -iScore) + "[ENDCOLOR]";
		
		// Protection of them
		iScore = GetVassalFailedProtectScore(ePlayer) - GetVassalProtectScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_PROTECT", -iScore) + "[ENDCOLOR]";
		
		// Trade routes made with them
		iScore = GetVassalTradeRouteScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TRADE_ROUTE", -iScore) + "[ENDCOLOR]";
		
		// Shared religion interests
		iScore = GetVassalReligionScore(ePlayer);
		szColor = ((iScore == 0) ? "[COLOR_GREY]" : ((iScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][TAB][ICON_BULLET]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_RELIGION", -iScore) + "[ENDCOLOR]";

		// Total score
		szColor = ((iTotalScore == 0) ? "[COLOR_GREY]" : ((iTotalScore < 0) ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_NEGATIVE_TEXT]"));
		szRtnValue += "[NEWLINE][NEWLINE][TAB]" + szColor + GetLocalizedText("TXT_KEY_VO_TREATMENT_TOTAL", -iTotalScore) + "[ENDCOLOR]";
	}

	return szRtnValue;
}

/// Opinion weight change based on how well we've been treated by our master
int CvDiplomacyAI::GetVassalTreatedScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	iOpinionWeight += GetVassalDemandScore(ePlayer);
	iOpinionWeight += GetVassalTaxScore(ePlayer);
	iOpinionWeight -= GetVassalProtectScore(ePlayer);
	iOpinionWeight += GetVassalFailedProtectScore(ePlayer);
	iOpinionWeight += GetVassalTradeRouteScore(ePlayer);
	iOpinionWeight += GetVassalReligionScore(ePlayer);

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalDemandScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	iOpinionWeight = GetNumTimesDemandedWhileVassal(ePlayer) * GC.getOPINION_WEIGHT_DEMANDED_WHILE_VASSAL();
	
	if(bVoluntaryVassal)
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalTaxScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;
	
	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());

	int iGoldCollectedSinceVassalStarted = GetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer); 
	if(iGoldCollectedSinceVassalStarted == 0)
		return 0;
	int iGoldTaxedSinceVassalStarted = GetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer);
	int iPercentTaxed = iGoldTaxedSinceVassalStarted * 100 / iGoldCollectedSinceVassalStarted;

	// Opinion weight from how much % we've taxed them
	iOpinionWeight = ((int) pow((float)iPercentTaxed, GC.getOPINION_WEIGHT_VASSAL_TAX_EXPONENT())) / std::max(1, GC.getOPINION_WEIGHT_VASSAL_TAX_DIVISOR());
	// Opinion weight from current tax %
	iOpinionWeight += GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetVassalTax(m_pPlayer->GetID()) * GC.getOPINION_WEIGHT_VASSAL_CURRENT_TAX_MODIFIER() / 100;
	
	if(bVoluntaryVassal) 
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalTradeRouteScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	
	bool bHaveTradeRouteWithUs = GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(ePlayer, m_pPlayer->GetID());
	if(bHaveTradeRouteWithUs)
	{
		iOpinionWeight += -15;
	}
	
	if(bVoluntaryVassal)
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalReligionScore(PlayerTypes ePlayer) const
{
	if(!IsVassal(ePlayer)) return 0;
	int iOpinionWeight = 0;

	bool bVoluntaryVassal = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVoluntaryVassal(GET_PLAYER(ePlayer).getTeam());
	
	ReligionTypes eVassalReligion = m_pPlayer->GetReligions()->GetReligionInMostCities();
	ReligionTypes eMasterReligion = GET_PLAYER(ePlayer).GetReligions()->GetReligionInMostCities();
	
	bool bShareReligion = (eVassalReligion == eMasterReligion);
	
	// No religion for vassal - don't care
	if(eVassalReligion == NO_RELIGION)
		return 0;

	// We are sharing a religion
	if(bShareReligion)
	{
		bool bVassalReligion = eVassalReligion == m_pPlayer->GetReligions()->GetReligionCreatedByPlayer();
		bool bMasterReligion = eVassalReligion == GET_PLAYER(ePlayer).GetReligions()->GetReligionCreatedByPlayer();

		// Vassal created the religion
		if(bVassalReligion)
		{
			iOpinionWeight += -40;
		}
		// Master created the religion
		else if(bMasterReligion)
		{
			iOpinionWeight += -20;
		}
		// Neither's religion
		else
		{
			iOpinionWeight += -10;
		}
	}
	// We do not share a religion, and the master has one
	else if(eMasterReligion != NO_RELIGION)
	{
		bool bVassalFounded = m_pPlayer->GetReligions()->GetReligionCreatedByPlayer() != NO_RELIGION;
		bool bMasterFounded = GET_PLAYER(ePlayer).GetReligions()->GetReligionCreatedByPlayer() != NO_RELIGION;
		
		// We both have a founded religion - at odds
		if(bVassalFounded && bMasterFounded)
		{
			iOpinionWeight += 25;
		}
		// We founded a religion
		else if(bVassalFounded)
		{
			iOpinionWeight += 10;
		}
		// We didn't found a religion - don't care
		else
		{
			iOpinionWeight += 0;
		}
	}

	if(bVoluntaryVassal)
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}
	// We do not share a religion, and the master has one
	else if(eMasterReligion != NO_RELIGION)
	{
		bool bVassalFounded = m_pPlayer->GetReligions()->GetReligionCreatedByPlayer() != NO_RELIGION;
		bool bMasterFounded = GET_PLAYER(ePlayer).GetReligions()->GetReligionCreatedByPlayer() != NO_RELIGION;
		
		// We both have a founded religion - at odds
		if(bVassalFounded && bMasterFounded)
		{
			iOpinionWeight += 25;
		}
		// We founded a religion
		else if(bVassalFounded)
		{
			iOpinionWeight += 10;
		}
		// We didn't found a religion - don't care
		else
		{
			iOpinionWeight += 0;
		}
	}

	if(bVoluntaryVassal)
	{
		iOpinionWeight *= GC.getOPINION_WEIGHT_VASSALAGE_VOLUNTARY_VASSAL_MOD();
		iOpinionWeight /= 100;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetMasterScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(GET_PLAYER(m_pPlayer->GetID()).getTeam()))
	{
		iOpinionWeight += (-1 * /*20*/ GC.getOPINION_WEIGHT_VASSALAGE_WE_ARE_MASTER());
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetTooManyVassalsScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	// Vassals, friends and teammates aren't too concerned
	if(IsVassal(ePlayer) || IsDoFAccepted(ePlayer) || GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
	{
		return 0;
	}

	// Each vassal contributes +10 to score (each player on a team counts as 1 vassal)
	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		// Only civs we have met
		if(GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iI).getTeam()))
		{
			if(GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).IsVassal(GET_PLAYER(ePlayer).getTeam()))
			{
				iOpinionWeight += /*10*/ GC.getOPINION_WEIGHT_VASSALAGE_TOO_MANY_VASSALS();
			}
		}
	}

	// First vassal worth nothing
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetNumVassals() == 1)
		iOpinionWeight = 0;

	return iOpinionWeight;
}

int CvDiplomacyAI::GetSameMasterScore(PlayerTypes ePlayer) const
{
	// Redundant for teammates
	if (GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return 0;
	
	int iOpinionWeight = 0;
	
	if (GET_TEAM(GetPlayer()->getTeam()).IsVassalOfSomeone() && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassalOfSomeone())
	{
		if (GET_TEAM(GetPlayer()->getTeam()).GetMaster() == GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetMaster())
			iOpinionWeight += -50;
	}
	
	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalProtectScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if(IsVassal(ePlayer))
	{
		int iWeightChange = -1 * GetVassalProtectValue(ePlayer) / std::max(1, GC.getVASSALAGE_PROTECT_VALUE_PER_OPINION_WEIGHT());
		if(iWeightChange < /*-50*/ GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX();
		}
		iOpinionWeight +=  iWeightChange;
	}

	return iOpinionWeight;
}

int CvDiplomacyAI::GetVassalFailedProtectScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;

	if(IsVassal(ePlayer))
	{
		int iWeightChange =  GetVassalFailedProtectValue(ePlayer) / std::max(1, GC.getVASSALAGE_FAILED_PROTECT_VALUE_PER_OPINION_WEIGHT());
		if(iWeightChange > GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX())
		{
			iWeightChange = GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX();
		}
		iOpinionWeight += iWeightChange;
	}

	return iOpinionWeight;
}

/// Returns value of vassal protection given
int CvDiplomacyAI::GetVassalProtectValue(PlayerTypes ePlayer) const
{
	return m_paiPlayerVassalageProtectValue[(int)ePlayer];
}

void CvDiplomacyAI::ChangeVassalProtectValue(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiPlayerVassalageProtectValue[ePlayer] += iChange;
		short iMaxOpinionValue = GC.getVASSALAGE_PROTECT_VALUE_PER_OPINION_WEIGHT() * -(GC.getOPINION_WEIGHT_VASSALAGE_PROTECT_MAX());

		// Must be between 0 and maximum possible boost to opinion
		if(m_paiPlayerVassalageProtectValue[ePlayer] < 0)
		{
			m_paiPlayerVassalageProtectValue[ePlayer] = 0;
		}
		else if(m_paiPlayerVassalageProtectValue[ePlayer] > iMaxOpinionValue)
		{
			m_paiPlayerVassalageProtectValue[ePlayer] = iMaxOpinionValue;
		}
	}
}

void CvDiplomacyAI::ChangeVassalFailedProtectValue(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		m_paiPlayerVassalageFailedProtectValue[ePlayer] += iChange;
		short iMaxOpinionValue = GC.getVASSALAGE_FAILED_PROTECT_VALUE_PER_OPINION_WEIGHT() * GC.getOPINION_WEIGHT_VASSALAGE_FAILED_PROTECT_MAX();

		// Must be between 0 and maximum possible boost to opinion
		if(m_paiPlayerVassalageFailedProtectValue[ePlayer] < 0)
		{
			m_paiPlayerVassalageFailedProtectValue[ePlayer] = 0;
		}
		else if(m_paiPlayerVassalageFailedProtectValue[ePlayer] > iMaxOpinionValue)
		{
			m_paiPlayerVassalageFailedProtectValue[ePlayer] = iMaxOpinionValue;
		}
	}
}

/// Returns value of failed vassal protection
int CvDiplomacyAI::GetVassalFailedProtectValue(PlayerTypes ePlayer) const
{
	return m_paiPlayerVassalageFailedProtectValue[(int)ePlayer];
}

/// Returns if we've peacefully revoked vassalage (and they agreed)
bool CvDiplomacyAI::IsHappyAboutPlayerVassalagePeacefullyRevoked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	
	int iTurnsSinceVassalPeacefullyRevoked = GetTurnsSinceVassalagePeacefullyRevoked(ePlayer);
	if (iTurnsSinceVassalPeacefullyRevoked > -1 && iTurnsSinceVassalPeacefullyRevoked < /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_PEACEFULLY_REVOKED_NUM_TURNS_UNTIL_FORGOTTEN())
	{
		return true;
	}

	return false;
}

int CvDiplomacyAI::GetHappyAboutVassalagePeacefullyRevokedScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;
	if (IsHappyAboutPlayerVassalagePeacefullyRevoked(ePlayer))
	{
		iOpinionWeight += /*-40*/ GC.getOPINION_WEIGHT_VASSALAGE_THEY_PEACEFULLY_REVOKED();
	}
	return iOpinionWeight;
}

int CvDiplomacyAI::GetAngryAboutVassalageForcefullyRevokedScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;
	if (IsAngryAboutPlayerVassalageForcefullyRevoked(ePlayer))
	{
		iOpinionWeight += /*50*/ GC.getOPINION_WEIGHT_VASSALAGE_THEY_FORCIBLY_REVOKED();
	}
	return iOpinionWeight;
}

/// Returns if we've forcefully revoked vassalage
bool CvDiplomacyAI::IsAngryAboutPlayerVassalageForcefullyRevoked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Anton your save file and version.");
	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;
	
	int iTurnsSinceVassalForcefullyRevoked = GetTurnsSinceVassalageForcefullyRevoked(ePlayer);
	if (iTurnsSinceVassalForcefullyRevoked > -1 && iTurnsSinceVassalForcefullyRevoked < /*100*/ GC.getOPINION_WEIGHT_VASSALAGE_FORCIBLY_REVOKED_NUM_TURNS_UNTIL_FORGIVEN())
	{
		return true;
	}

	return false;
}

int CvDiplomacyAI::GetBrokenVassalAgreementScore(PlayerTypes ePlayer) const
{
	int iOpinionWeight = 0;
	// Declared war on us while we were his vassal
	if(IsPlayerBrokenVassalAgreement(ePlayer))
		iOpinionWeight += /*40*/ GC.getOPINION_WEIGHT_VASSALAGE_BROKEN_VASSAL_AGREEMENT_OPINION_WEIGHT();
	return iOpinionWeight;
}

bool CvDiplomacyAI::IsPlayerBrokenVassalAgreement(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_pabPlayerBrokenVassalAgreement[(int)ePlayer];
}

void CvDiplomacyAI::SetBrokenVassalAgreement(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_pabPlayerBrokenVassalAgreement[(int)ePlayer] = bValue;
}

/// How many times did ePlayer demand from us while we were his vassal?
int CvDiplomacyAI::GetNumTimesDemandedWhileVassal(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return m_paiNumTimesDemandedWhenVassal[ePlayer];
}

void CvDiplomacyAI::SetNumTimesDemandedWhileVassal(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Vassal Peacefully Revoked turns to be negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_paiNumTimesDemandedWhenVassal[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeNumTimesDemandedWhileVassal(PlayerTypes ePlayer, int iChange)
{
	if(iChange != 0)
		SetNumTimesDemandedWhileVassal(ePlayer, GetNumTimesDemandedWhileVassal(ePlayer) + iChange);
}

/// How many turns since ePlayer peacefully revoked our vassalage?
int CvDiplomacyAI::GetTurnsSinceVassalagePeacefullyRevoked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage[ePlayer];
}

void CvDiplomacyAI::SetTurnsSinceVassalagePeacefullyRevoked(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Vassal Peacefully Revoked turns to be negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiPlayerVassalageTurnsSincePeacefullyRevokedVassalage[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeTurnsSinceVassalagePeacefullyRevoked(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceVassalagePeacefullyRevoked(ePlayer, GetTurnsSinceVassalagePeacefullyRevoked(ePlayer) + iChange);
}

/// How many turns since ePlayer forcefully revoked our vassalage?
int CvDiplomacyAI::GetTurnsSinceVassalageForcefullyRevoked(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	return m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage[ePlayer];
}

void CvDiplomacyAI::SetTurnsSinceVassalageForcefullyRevoked(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(iValue >= 0, "DIPLOMACY_AI: Setting number of Vassal Forcefully Revoked turns to be negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	m_paiPlayerVassalageTurnsSinceForcefullyRevokedVassalage[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeTurnsSinceVassalageForcefullyRevoked(PlayerTypes ePlayer, int iChange)
{
	SetTurnsSinceVassalageForcefullyRevoked(ePlayer, GetTurnsSinceVassalageForcefullyRevoked(ePlayer) + iChange);
}

/// eMasterTeam has changed our taxes
void CvDiplomacyAI::DoVassalTaxChanged(TeamTypes eMasterTeam, bool bTaxesLowered)
{
	if(!GET_TEAM(GetPlayer()->getTeam()).IsVassal(eMasterTeam))
		return;

	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).getTeam() == eMasterTeam)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
			SetVassalTaxRaised(eLoopPlayer, !bTaxesLowered);
			SetVassalTaxLowered(eLoopPlayer, bTaxesLowered);
		}
	}
}

/// eMasterTeam became our master
void CvDiplomacyAI::DoWeMadeVassalageWithSomeone(TeamTypes eMasterTeam, bool bVoluntary)
{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMasterTeam >= 0, "DIPLOMACY AI: Invalid Team Index. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eMasterTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	
	PlayerTypes eOtherTeamPlayer; // a player on eMasterTeam
	for(int iOtherPlayerLoop = 0; iOtherPlayerLoop < MAX_MAJOR_CIVS; iOtherPlayerLoop++)
	{
		eOtherTeamPlayer = (PlayerTypes) iOtherPlayerLoop;
		
		// OtherPlayer is on eTeam
		if(GET_PLAYER(eOtherTeamPlayer).getTeam() == eMasterTeam)
		{
			// Only stuff for Major Civs
			if(!GET_PLAYER(eOtherTeamPlayer).isMinorCiv())
			{
				// Is ePlayer the vassal of eOtherTeamPlayer? (just in case we call this function the other way around, and ePlayer is the master)
				if(GetPlayer()->GetDiplomacyAI()->IsVassal(eOtherTeamPlayer))
				{
					// Reset approach guesses, if any
					SetApproachTowardsUsGuess(eOtherTeamPlayer, MAJOR_CIV_APPROACH_NEUTRAL);
					SetApproachTowardsUsGuessCounter(eOtherTeamPlayer, 0);
					GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuess(GetPlayer()->GetID(), MAJOR_CIV_APPROACH_NEUTRAL);
					GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetApproachTowardsUsGuessCounter(GetPlayer()->GetID(), 0);
					
					// Reset warmongering penalty for both players
					SetWarmongerThreat(eOtherTeamPlayer, THREAT_NONE);
					SetOtherPlayerWarmongerAmountTimes100(eOtherTeamPlayer, 0);
					GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetWarmongerThreat(GetPlayer()->GetID(), THREAT_NONE);
					GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetOtherPlayerWarmongerAmountTimes100(GetPlayer()->GetID(), 0);
					
					// During capitulation, reset all (negative) diplomatic scores. Rationale: When capitulating, AI tends to be very hostile.
					if(!bVoluntary) {
						SetLandDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
						SetWonderDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
						SetMinorCivDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
						SetVictoryDisputeLevel(eOtherTeamPlayer, DISPUTE_LEVEL_NONE);
						
						SetPlayerNoSettleRequestCounter(eOtherTeamPlayer, -1);
						SetPlayerStopSpyingRequestCounter(eOtherTeamPlayer, -1);
#if defined(MOD_BALANCE_CORE)
						SetVictoryBlockLevel(eOtherTeamPlayer, BLOCK_LEVEL_NONE);
						
						SetPlayerNoSettleRequestEverAsked(eOtherTeamPlayer, false);
						SetPlayerStopSpyingRequestEverAsked(eOtherTeamPlayer, false);
						SetNumDemandEverMade(eOtherTeamPlayer, -GetNumDemandEverMade(eOtherTeamPlayer));
						
						SetNumTimesCoopWarDenied(eOtherTeamPlayer, 0);
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetNumTimesCoopWarDenied(GetPlayer()->GetID(), 0);
						
						if (GetRecentAssistValue(eOtherTeamPlayer) > 0)
						{
							ChangeRecentAssistValue(eOtherTeamPlayer, -GetRecentAssistValue(eOtherTeamPlayer));
						}
						
						ChangeNumTimesRazed(eOtherTeamPlayer, -GetNumTimesRazed(eOtherTeamPlayer));
#endif
						SetDemandCounter(eOtherTeamPlayer, -1);
						ChangeNumTimesCultureBombed(eOtherTeamPlayer, -GetNumTimesCultureBombed(eOtherTeamPlayer));
						ChangeNegativeReligiousConversionPoints(eOtherTeamPlayer, -GetNegativeReligiousConversionPoints(eOtherTeamPlayer));
						ChangeNegativeArchaeologyPoints(eOtherTeamPlayer, -GetNegativeArchaeologyPoints(eOtherTeamPlayer));
						ChangeNumTimesRobbedBy(eOtherTeamPlayer, -GetNumTimesRobbedBy(eOtherTeamPlayer));
						
						// Reset all promises
						SetPlayerMadeMilitaryPromise(eOtherTeamPlayer, false);
						SetPlayerMadeExpansionPromise(eOtherTeamPlayer, false);
						SetPlayerMadeBorderPromise(eOtherTeamPlayer, false);
						SetPlayerMadeAttackCityStatePromise(eOtherTeamPlayer, false);
						SetPlayerMadeBullyCityStatePromise(eOtherTeamPlayer, false);
						SetPlayerMadeNoConvertPromise(eOtherTeamPlayer, false);
						SetPlayerMadeNoDiggingPromise(eOtherTeamPlayer, false);
						SetPlayerMadeSpyPromise(eOtherTeamPlayer, false);
						
						SetPlayerBrokenMilitaryPromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredMilitaryPromise(eOtherTeamPlayer, false);
						SetBrokenBorderPromiseValue(eOtherTeamPlayer, 0);
						SetIgnoredBorderPromiseValue(eOtherTeamPlayer, 0);
						SetBrokenExpansionPromiseValue(eOtherTeamPlayer, 0);
						SetIgnoredExpansionPromiseValue(eOtherTeamPlayer, 0);
						
						SetPlayerBrokenAttackCityStatePromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredAttackCityStatePromise(eOtherTeamPlayer, false);
						SetPlayerBrokenBullyCityStatePromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredBullyCityStatePromise(eOtherTeamPlayer, false);
						
						SetPlayerBrokenNoConvertPromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredNoConvertPromise(eOtherTeamPlayer, false);
						
						SetPlayerBrokenNoDiggingPromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredNoDiggingPromise(eOtherTeamPlayer, false);
						
						SetPlayerBrokenSpyPromise(eOtherTeamPlayer, false);
						SetPlayerIgnoredSpyPromise(eOtherTeamPlayer, false);
						
						SetPlayerBrokenCoopWarPromise(eOtherTeamPlayer, false);
						
						SetOtherPlayerNumProtectedMinorsKilled(eOtherTeamPlayer, 0);
						SetOtherPlayerNumProtectedMinorsAttacked(eOtherTeamPlayer, 0);
						SetOtherPlayerNumProtectedMinorsBullied(eOtherTeamPlayer, 0);
						SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eOtherTeamPlayer, -1);
						
						SetFriendDenouncedUs(eOtherTeamPlayer, false);
						SetDenouncedPlayer(eOtherTeamPlayer, false); // forget any denouncing
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetDenouncedPlayer(GetPlayer()->GetID(), false); // forget any denouncing
						SetFriendDeclaredWarOnUs(eOtherTeamPlayer, false);
						
						ChangeNumTimesNuked(eOtherTeamPlayer, -GetNumTimesNuked(eOtherTeamPlayer));
						
						SetTurnsSinceWeDislikedTheirProposal(eOtherTeamPlayer, -1);
						SetTurnsSinceTheyFoiledOurProposal(eOtherTeamPlayer, -1);
						
						// Reset common foe bonus
						ChangeCommonFoeValue(eOtherTeamPlayer, -GetCommonFoeValue(eOtherTeamPlayer));
						
						// Master should also clear some war-related penalties
#if defined(MOD_BALANCE_CORE)
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->ChangeNumTimesRazed(GetPlayer()->GetID(), -GetNumTimesRazed(GetPlayer()->GetID()));
#endif
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->ChangeNumTimesNuked(GetPlayer()->GetID(), -GetNumTimesNuked(GetPlayer()->GetID()));
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerIgnoredMilitaryPromise(GetPlayer()->GetID(), false);
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerBrokenMilitaryPromise(GetPlayer()->GetID(), false);
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerIgnoredAttackCityStatePromise(GetPlayer()->GetID(), false);
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerBrokenAttackCityStatePromise(GetPlayer()->GetID(), false);
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerBrokenCoopWarPromise(GetPlayer()->GetID(), false);
					}

					// In case we had an ongoing operation against our Master, kill it
					SetArmyInPlaceForAttack(eOtherTeamPlayer, false);
					SetWantsSneakAttack(eOtherTeamPlayer, false);

					// Master had agreed to not settle nearby
					if(GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->IsPlayerNoSettleRequestAccepted(GetPlayer()->GetID()))
					{
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerNoSettleRequestAccepted(GetPlayer()->GetID(), false);
					}

					// Master had agreed not to spy on them
					if(GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->IsPlayerStopSpyingRequestAccepted(GetPlayer()->GetID()))
					{
						GET_PLAYER(eOtherTeamPlayer).GetDiplomacyAI()->SetPlayerStopSpyingRequestAccepted(GetPlayer()->GetID(), false);
					}

					// Vassal thought they were a liberator, but Master had other plans...
					SetMasterLiberatedMeFromVassalage(eOtherTeamPlayer, false);

					PlayerTypes eThirdPartyPlayer;	// player we were planning with
					PlayerTypes eThirdPartyTarget;	// player we were targeting
					for(int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
					{
						eThirdPartyPlayer = (PlayerTypes) iThirdPartyLoop;
						for(int iThirdPartyTarget = 0; iThirdPartyTarget < MAX_MAJOR_CIVS; iThirdPartyTarget++)
						{
							eThirdPartyTarget = (PlayerTypes) iThirdPartyTarget;
							
							// Reset our coop war counters with every player because as a vassal we shouldn't be in cahoots with anyone
							if(GetCoopWarAcceptedState(eThirdPartyPlayer, eThirdPartyTarget) != NO_COOP_WAR_STATE)
							{
								SetCoopWarAcceptedState(eThirdPartyPlayer, eThirdPartyTarget, NO_COOP_WAR_STATE);
								SetCoopWarCounter(eThirdPartyPlayer, eThirdPartyTarget, -666);
							}
						}
					}
				}
			}
		}
	}
}

/// ePlayer ended vassalage with someone, so figure out what that means
void CvDiplomacyAI::DoWeEndedVassalageWithSomeone(TeamTypes eTeam)
{
	CvAssertMsg(eTeam >= 0, "DIPLOMACY AI: Invalid Team Index. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	PlayerTypes ePlayer;
	// Loop through players, check it's team, and set the number of times demanded to be 0
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		
		if(GET_PLAYER(ePlayer).getTeam() == eTeam)
		{
			// Set number of times demanded while vassal to be 0, since, y'know, we're not a vassal anymore...
			SetNumTimesDemandedWhileVassal(ePlayer, 0);

			// Reset our memory of GPT that was taxed from us
			SetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer, 0);
			SetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer, 0);

			SetVassalTaxRaised(ePlayer, false);
			SetVassalTaxLowered(ePlayer, false);
		}
	}
}

/// We are liberated by a master
void CvDiplomacyAI::DoLiberatedFromVassalage(TeamTypes eTeam)
{
	CvAssertMsg(eTeam >= 0, "DIPLOMACY AI: Invalid Team Index. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eTeam < MAX_CIV_TEAMS, "DIPLOMACY_AI: Invalid Team Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	// Only do this if we are a vassal
	if(!GET_TEAM(GetPlayer()->getTeam()).IsVassal(eTeam))
		return;

	// Get players from Master's team
	for(int iMasterPlayer = 0; iMasterPlayer < MAX_MAJOR_CIVS; iMasterPlayer++)
	{
		PlayerTypes eMasterPlayer = (PlayerTypes) iMasterPlayer;
		if(GET_PLAYER(eMasterPlayer).getTeam() == eTeam)
		{
			SetMasterLiberatedMeFromVassalage(eMasterPlayer, true);

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (CvPreGame::isHuman(eMasterPlayer))
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
					CvDiplomacyRequests::SendRequest(GetPlayer()->GetID(), eMasterPlayer, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
			else
			{
				if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == eMasterPlayer)
				{
					const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
					gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
				}
			}
#else
			if(!CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == eMasterPlayer)
			{
				const char* strText = GetDiploStringForMessage(DIPLO_MESSAGE_VASSALAGE_LIBERATED_HUMAN, eMasterPlayer);
				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_POSITIVE);
			}
#endif
		}
	}
}

/// How does ePlayer think the world is going?
//GlobalStateTypes CvDiplomacyAI::GetGlobalState(PlayerTypes ePlayer) const
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	return (GlobalStateTypes) m_paeGlobalState[ePlayer];
//}
//
//void CvDiplomacyAI::SetGlobalState(PlayerTypes ePlayer, GlobalStateTypes eGlobalState)
//{
//	CvAssertMsg(ePlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
//	CvAssertMsg(eGlobalState >= 0, "DIPLOMACY_AI: Invalid GlobalState in SetGlobalState.");
//	CvAssertMsg(eGlobalState < NUM_GLOBAL_STATES, "DIPLOMACY_AI: Invalid GlobalState.");
//
//	m_paeGlobalState[ePlayer] = eGlobalState;
//}

//void CvDiplomacyAI::DoUpdateGlobalStates()
//{
	/*
	int iNumPlayersProcessed = 0;
	int iGlobalScore = 0;
	GlobalStateTypes eGlobalState = NO_GLOBAL_STATE;
	PlayerTypes eLoopPlayer;
	// Update global comparisons for each player
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(IsPlayerValid(eLoopPlayer, true))
		{
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Don't process ourselves...
				if(eLoopPlayer != GetPlayer()->GetID())
				{
					DoUpdateGlobalStateForOnePlayer(eLoopPlayer);
					iNumPlayersProcessed++;

					switch(GetGlobalState(eLoopPlayer))
					{
						case GLOBAL_STATE_UNKNOWN:
							iGlobalScore += 0;
						break;
						case GLOBAL_STATE_VERY_BAD:
							iGlobalScore += -25;
						case GLOBAL_STATE_BAD:
							iGlobalScore += -10;
							break;
						case GLOBAL_STATE_AVERAGE:
							iGlobalScore += 0;
							break;
						case GLOBAL_STATE_GOOD:
							iGlobalScore += 10;
						case GLOBAL_STATE_VERY_GOOD:
							iGlobalScore += 25;
							break;
						default:
							iGlobalScore += 0;
							break;
					}
				}
			}
		}
	}

	// Set the global state for us (how we think we're doing in the world), also prevent a divide by zero
	if(iNumPlayersProcessed == 0)
	{
		SetGlobalState(GetPlayer()->GetID(), GLOBAL_STATE_UNKNOWN);
	}
	else
	{
		iGlobalScore /= iNumPlayersProcessed;

		if(iGlobalScore >= 25)
			eGlobalState = GLOBAL_STATE_VERY_GOOD;
		else if(iGlobalScore >= 10)
			eGlobalState = GLOBAL_STATE_GOOD;
		else if(iGlobalScore >= 0)
			eGlobalState = GLOBAL_STATE_AVERAGE;
		else if(iGlobalScore >= -10)
			eGlobalState = GLOBAL_STATE_BAD;
		else
			eGlobalState = GLOBAL_STATE_VERY_BAD;
	}

	// Do checks here to make sure AI is setting correct global state due to certain situations

	// We've lost our capital
	if(GetPlayer()->IsHasLostCapital())
	{
		// We're at war with our conqueror and we're winning against him, maybe things are looking up?
		if(IsAtWar(GetPlayer()->GetCapitalConqueror()) && GetWarState(GetPlayer()->GetCapitalConqueror()) >= WAR_STATE_OFFENSIVE)
		{
			// do nothing, use previous evaluation to determine global state
		}
		else
		{
			eGlobalState = GLOBAL_STATE_VERY_BAD;
		}
	}

	// Going for conquest and winning all of our wars, we must be doing something right
	if(GetStateAllWars() == STATE_ALL_WARS_WINNING && IsGoingForWorldConquest())
	{
		if(eGlobalState < GLOBAL_STATE_GOOD)
		{
			eGlobalState = GLOBAL_STATE_GOOD;
		}
	}

	// We're losing all of our wars
	if(GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		// If we're going for world conquest and losing all of our wars, we're in really bad shape
		if(IsGoingForWorldConquest())
		{
			eGlobalState = GLOBAL_STATE_VERY_BAD;
		}
		else
		{
			if(eGlobalState > GLOBAL_STATE_BAD)
			{
				eGlobalState = GLOBAL_STATE_BAD;
			}
		}
	}

	// We're badly unhappy
	if(GetPlayer()->GetExcessHappiness() <= GC.getVERY_UNHAPPY_THRESHOLD())
	{
		if(eGlobalState > GLOBAL_STATE_BAD)
		{
			eGlobalState = GLOBAL_STATE_BAD;
		}
	}
	
	SetGlobalState(GetPlayer()->GetID(), eGlobalState);
	*/
//}

/// What do we think of our situation with ePlayer?
//void CvDiplomacyAI::DoUpdateGlobalStateForOnePlayer(PlayerTypes ePlayer)
//{

	//GlobalStateTypes eGlobalState;
	//int iOneGlobalStateWeight = 0;
	//int iTempWeight = 0;

	//// Haven't known this guy to process how our situation with him is going (and we're not at war...)
	//if(GET_TEAM(GetTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(ePlayer).getTeam()) < GC.getGLOBAL_STATE_MIN_TURNS_BEFORE_PROCESS_STATE()
	//	&& !IsAtWar(ePlayer))
	//{
	//	SetGlobalState(ePlayer, GLOBAL_STATE_UNKNOWN);
	//	return;
	//}

	//// Are we at war with this player? And if so, how is it going?
	//if(IsAtWar(ePlayer))
	//{
	//	switch(GetWarState(ePlayer))
	//	{
	//		case WAR_STATE_NEARLY_DEFEATED:
	//			iTempWeight += /*-20*/ GC.getGLOBAL_STATE_NEARLY_DEFEATED_WEIGHT();
	//			break;
	//		case WAR_STATE_DEFENSIVE:
	//			iTempWeight += /*-5*/ GC.getGLOBAL_STATE_DEFENSIVE_WEIGHT();
	//			break;
	//		case WAR_STATE_STALEMATE:
	//			iTempWeight += /*0*/ GC.getGLOBAL_STATE_STALEMATE_WEIGHT();
	//			break;
	//		case WAR_STATE_CALM:
	//			iTempWeight += /*0*/ GC.getGLOBAL_STATE_CALM_WEIGHT();
	//			break;
	//		case WAR_STATE_OFFENSIVE:
	//			iTempWeight += /*5*/ GC.getGLOBAL_STATE_OFFENSIVE_WEIGHT();
	//			break;
	//		case WAR_STATE_NEARLY_WON:
	//			iTempWeight += /*20*/ GC.getGLOBAL_STATE_NEARLY_WON_WEIGHT();
	//			break;
	//		default:
	//			iTempWeight += 0;
	//			break;
	//	}
	//	
	//	// We're going for conquest victory, this weight is very important
	//	if(IsGoingForWorldConquest())
	//	{
	//		iTempWeight *= 200;
	//		iTempWeight /= 100;
	//	}
	//}

	//// in any event, if we're not at war with ePlayer, Global weight starts at 0
	//iOneGlobalStateWeight = iTempWeight;
	//iTempWeight = 0;

	//// Compare strengths
	//switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	//{
	//	case STRENGTH_IMMENSE:
	//		iTempWeight += /*-20*/ GC.getGLOBAL_STATE_MIL_STRENGTH_IMMENSE_WEIGHT();
	//		break;
	//	case STRENGTH_POWERFUL:
	//		iTempWeight += /*-14*/ GC.getGLOBAL_STATE_MIL_STRENGTH_POWERFUL_WEIGHT();
	//		break;
	//	case STRENGTH_STRONG:
	//		iTempWeight += /*-8*/ GC.getGLOBAL_STATE_MIL_STRENGTH_STRONG_WEIGHT();
	//		break;
	//	case STRENGTH_AVERAGE:
	//		iTempWeight += /*0*/ GC.getGLOBAL_STATE_MIL_STRENGTH_AVERAGE_WEIGHT();
	//		break;
	//	case STRENGTH_WEAK:
	//		iTempWeight += /*8*/ GC.getGLOBAL_STATE_MIL_STRENGTH_WEAK_WEIGHT();
	//		break;
	//	case STRENGTH_POOR:
	//		iTempWeight += /*14*/ GC.getGLOBAL_STATE_MIL_STRENGTH_POOR_WEIGHT();
	//		break;
	//	case STRENGTH_PATHETIC:
	//		iTempWeight += /*20*/ GC.getGLOBAL_STATE_MIL_STRENGTH_PATHETIC_WEIGHT();
	//		break;
	//}

	//// military strength not as big a factor depending on distance
	//switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	//{
	//	case PLAYER_PROXIMITY_DISTANT:
	//		iTempWeight *= 50;
	//		break;
	//	case PLAYER_PROXIMITY_FAR:
	//		iTempWeight *= 75;
	//		break;
	//	case PLAYER_PROXIMITY_CLOSE:
	//		iTempWeight *= 100;
	//		break;
	//	case PLAYER_PROXIMITY_NEIGHBORS:
	//		iTempWeight *= 150;
	//		break;
	//}

	//iTempWeight /= 100;

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//switch(GetPlayerEconomicStrengthComparedToUs(ePlayer))
	//{
	//	case STRENGTH_IMMENSE:
	//		iTempWeight += /*-12*/ GC.getGLOBAL_STATE_ECON_STRENGTH_IMMENSE_WEIGHT();
	//		break;
	//	case STRENGTH_POWERFUL:
	//		iTempWeight += /*-7*/ GC.getGLOBAL_STATE_ECON_STRENGTH_POWERFUL_WEIGHT();
	//		break;
	//	case STRENGTH_STRONG:
	//		iTempWeight += /*-3*/ GC.getGLOBAL_STATE_ECON_STRENGTH_STRONG_WEIGHT();
	//		break;
	//	case STRENGTH_AVERAGE:
	//		iTempWeight += /*0*/ GC.getGLOBAL_STATE_ECON_STRENGTH_AVERAGE_WEIGHT();
	//		break;
	//	case STRENGTH_WEAK:
	//		iTempWeight += /*3*/ GC.getGLOBAL_STATE_ECON_STRENGTH_WEAK_WEIGHT();
	//		break;
	//	case STRENGTH_POOR:
	//		iTempWeight += /*7*/ GC.getGLOBAL_STATE_ECON_STRENGTH_POOR_WEIGHT();
	//		break;
	//	case STRENGTH_PATHETIC:
	//		iTempWeight += /*12*/ GC.getGLOBAL_STATE_ECON_STRENGTH_PATHETIC_WEIGHT();
	//		break;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Compared number of vassals
	//int iOurVassals = GET_TEAM(GetPlayer()->getTeam()).GetNumVassals();
	//int iTheirVassals = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetNumVassals();
	//int iVassalDifference = iOurVassals - iTheirVassals;

	//iOneGlobalStateWeight += (iVassalDifference * /*6*/ GC.getGLOBAL_STATE_NUM_VASSALS_MULTIPLIER());

	//// Compare Number of Techs
	//int iOurTechs = GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown();
	//int iTheirTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();
	//		
	//iTempWeight = 0;

	//// don't crash if they haven't researched anything yet
	//if(iTheirTechs == 0)
	//	iTheirTechs = 1;
	//		
	//int iTechPercent = iOurTechs * 100/ iTheirTechs;

	//if(iTechPercent >= 115)
	//	iTempWeight += /*12*/ GC.getGLOBAL_STATE_TECH_PERCENT_VERY_GOOD_WEIGHT();
	//else if(iTechPercent >= 105)
	//	iTempWeight += /*6*/ GC.getGLOBAL_STATE_TECH_PERCENT_GOOD_WEIGHT();
	//else if(iTechPercent >= 90)
	//	iTempWeight += /*0*/ GC.getGLOBAL_STATE_TECH_PERCENT_AVERAGE_WEIGHT();
	//else if(iTechPercent >= 75)
	//	iTempWeight += /*-6*/ GC.getGLOBAL_STATE_TECH_PERCENT_BAD_WEIGHT();
	//else
	//	iTempWeight += /*-12*/ GC.getGLOBAL_STATE_TECH_PERCENT_VERY_BAD_WEIGHT();

	//// Increase the science weight if going for spaceship
	//if(IsGoingForSpaceshipVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Compare Number of Policies Unlocked
	//int iOurPolicies = GetPlayer()->GetNumPolicies();
	//int iTheirPolicies = GET_PLAYER(ePlayer).GetNumPolicies();
	//		
	//iTempWeight = (iOurPolicies - iTheirPolicies) * /*3*/ GC.getGLOBAL_STATE_PER_POLICY_WEIGHT();

	////Influential? Bring that in.

	//int iOurInfluence = GetPlayer()->GetCulture()->GetNumCivsInfluentialOn();
	//int iTheirInfluence = GET_PLAYER(ePlayer).GetCulture()->GetNumCivsInfluentialOn();

	//iTempWeight += (iOurInfluence - iTheirInfluence) * 10;

	//// Increase weight if going for culture victory
	//if(IsGoingForCultureVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//int iOurAllies = 0, iTheirAllies = 0;

	//// Check this player's city-state allies
	//PlayerTypes eThirdPartyLoop;
	//for(int iThirdPartyLoop = MAX_MAJOR_CIVS; iThirdPartyLoop < MAX_MINOR_CIVS; iThirdPartyLoop++)
	//{
	//	eThirdPartyLoop = (PlayerTypes) iThirdPartyLoop;
	//	if(GET_PLAYER(eThirdPartyLoop).isMinorCiv())
	//	{
	//		// Minor civ ally of us
	//		if(GetPlayer()->GetMinorCivAI()->GetAlly())
	//		{
	//			iOurAllies++;
	//		}

	//		// Minor civ ally of this third party
	//		if(GET_PLAYER(eThirdPartyLoop).GetMinorCivAI()->GetAlly())
	//		{
	//			iTheirAllies++;
	//		}
	//	}
	//}

	//iTempWeight = (iOurAllies - iTheirAllies) * /*2*/ GC.getGLOBAL_STATE_PER_ALLY_WEIGHT();

	//// We're going for diplo victory, this metric is more important to us
	//if(IsGoingForDiploVictory())
	//{
	//	iTempWeight *= 200;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;
	//					
	//// Compare scores
	//int iOurScore = GetPlayer()->GetScore();
	//int iTheirScore = GET_PLAYER(ePlayer).GetScore();
	//if(iTheirScore == 0) iTheirScore = 1;
	//int iScorePercent = (iOurScore * 100/ iTheirScore);

	//if (iScorePercent > 200)
	//	iTempWeight += /*20*/ GC.getGLOBAL_STATE_SCORE_PERCENT_EXTREMELY_GOOD_WEIGHT();
	//else if(iScorePercent >= 150)
	//	iTempWeight += /*8*/ GC.getGLOBAL_STATE_SCORE_PERCENT_VERY_GOOD_WEIGHT();
	//else if(iScorePercent >= 100)
	//	iTempWeight += /*4*/ GC.getGLOBAL_STATE_SCORE_PERCENT_GOOD_WEIGHT();
	//else if(iScorePercent >= 75)
	//	iTempWeight += /*0*/ GC.getGLOBAL_STATE_SCORE_PERCENT_AVERAGE_WEIGHT();
	//else if(iScorePercent >= 50)
	//	iTempWeight += /*-4*/ GC.getGLOBAL_STATE_SCORE_PERCENT_BAD_WEIGHT();
	//else
	//	iTempWeight += /*-8*/ GC.getGLOBAL_STATE_SCORE_PERCENT_VERY_BAD_WEIGHT();

	//VictoryTypes eSpaceshipVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);
	//VictoryTypes eDominationVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DOMINATION", true);
	//VictoryTypes eCulturalVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);
	//VictoryTypes eDiplomaticVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);

	//// No victory condition is valid, we assume a Time Victory is left, our score is worth more
	//if(!GC.getGame().isVictoryValid(eSpaceshipVictory) &&
	//	!GC.getGame().isVictoryValid(eDominationVictory) &&
	//		!GC.getGame().isVictoryValid(eCulturalVictory)   &&
	//		!GC.getGame().isVictoryValid(eDiplomaticVictory))
	//{
	//	iTempWeight *= 150;
	//	iTempWeight /= 100;
	//}

	//iOneGlobalStateWeight += iTempWeight;
	//iTempWeight = 0;

	//// Do the final computation
	//if(iOneGlobalStateWeight >= 50)
	//	eGlobalState = GLOBAL_STATE_VERY_GOOD;
	//else if(iOneGlobalStateWeight >= 20)
	//	eGlobalState = GLOBAL_STATE_GOOD;
	//else if(iOneGlobalStateWeight  >= -5)
	//	eGlobalState = GLOBAL_STATE_AVERAGE;
	//else if(iOneGlobalStateWeight  >= -25)
	//	eGlobalState = GLOBAL_STATE_BAD;
	//else
	//	eGlobalState = GLOBAL_STATE_VERY_BAD;

	//// Set the global state for ePlayer
	//SetGlobalState(ePlayer, eGlobalState);
//}

/// Determine tax rates for all vassals, if we can
void CvDiplomacyAI::DoDetermineTaxRateForVassals()
{
	PlayerTypes eLoopPlayer;
	// Update global comparisons for each player
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(IsPlayerValid(eLoopPlayer, true))
		{
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				// Don't process ourselves...
				if(eLoopPlayer != GetPlayer()->GetID())
				{
					DoDetermineTaxRateForVassalOnePlayer(eLoopPlayer);
				}
			}
		}
	}
}

/// Determine how much we are going to tax this player, if we can
void CvDiplomacyAI::DoDetermineTaxRateForVassalOnePlayer(PlayerTypes ePlayer)
{
	// Must be able to set taxes for player
	if(!GET_TEAM(GetPlayer()->getTeam()).CanSetVassalTax(ePlayer))
		return;

	TeamTypes eMyTeam = GetPlayer()->getTeam();
	CvTeam& kMyTeam = GET_TEAM(eMyTeam);

	// Do not allow an AI teammate to do this for a human
	if(!GetPlayer()->isHuman() && kMyTeam.isHuman())
		return;

	// Current tax rate
	int iTaxRate = kMyTeam.GetVassalTax(ePlayer);

	// Make sure we can actually do that...
	bool bWantToLower = iTaxRate > GC.getVASSALAGE_VASSAL_TAX_PERCENT_MINIMUM();
	bool bWantToRaise = iTaxRate < GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM();

	// Because this function will involve lots of iteration over team members, let's store all alive team members in temporary vectors to improve the speed of this function
	std::vector<CvPlayerAI*> m_MasterTeam;
	std::vector<CvPlayerAI*> m_VassalTeam;

	for(int iI=0; iI < MAX_MAJOR_CIVS; iI++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iI;
		if(GET_PLAYER(eLoopPlayer).isAlive())
		{
			// Master team
			if(GET_PLAYER(eLoopPlayer).getTeam() == GetPlayer()->getTeam())
			{
				m_MasterTeam.push_back(&GET_PLAYER(eLoopPlayer));
			}
			// Vassal team
			else if(GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePlayer).getTeam())
			{
				m_VassalTeam.push_back(&GET_PLAYER(eLoopPlayer));
			}
		}
	}
	
	MajorCivOpinionTypes eTeamOpinion = MAJOR_CIV_OPINION_NEUTRAL;
	int iMyCurrentGPT = 0, iMyCurrentGross = 0, iAverageMeanness = 0, iAverageLoyalty = 0, iAverageOpinionScore = 0;
	for(std::vector<CvPlayerAI*>::iterator it = m_MasterTeam.begin(); it != m_MasterTeam.end(); it++)
	{
		iMyCurrentGPT += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();
		iMyCurrentGross += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();

		iAverageMeanness += (*it)->GetDiplomacyAI()->GetMeanness();
		iAverageLoyalty += (*it)->GetDiplomacyAI()->GetLoyalty();

		iAverageOpinionScore += (*it)->GetDiplomacyAI()->GetMajorCivOpinion(ePlayer);
	}

	iAverageMeanness /= m_MasterTeam.size();
	iAverageLoyalty /= m_MasterTeam.size();
	iAverageOpinionScore /= m_MasterTeam.size();

	eTeamOpinion = (MajorCivOpinionTypes) iAverageOpinionScore;

	int iVassalCurrentGPT = 0, iVassalCurrentGross = 0;
	for(std::vector<CvPlayerAI*>::iterator it = m_VassalTeam.begin(); it != m_VassalTeam.end(); it++)
	{
		iVassalCurrentGPT += (*it)->GetTreasury()->CalculateBaseNetGoldTimes100();
		iVassalCurrentGross += (*it)->GetTreasury()->CalculateGrossGoldTimes100();
	}

	// Hate him? Don't consider lowering!
	if(eTeamOpinion == MAJOR_CIV_OPINION_UNFORGIVABLE)
		bWantToLower = false;

	
	// Like him? Don't consider raising!
	if(eTeamOpinion == MAJOR_CIV_OPINION_ALLY)
		bWantToRaise = false;

	// We have some choice in the direction taxes can go - pick a direction so we can start deciding
	if(bWantToLower && bWantToRaise)
	{
		// We're in dire straights
		if(iMyCurrentGPT <= 0)
		{
			bWantToLower = false;	// don't even consider lowering
			
			// Check to see if taxing the vassal the maximum would get us out of dire straights
			if(bWantToRaise)
			{
				// Wouldn't help us out at all
				if((iVassalCurrentGross * GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM() / 100 < 100))
				{
					bWantToRaise = false;
				}
				// Tax vassal the maximum to get us out of trouble - his feelings be damned
				else
				{
					kMyTeam.DoApplyVassalTax(ePlayer, GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM());
					return;
				}
			}
		}
		// Doing fine - have some choice
		else
		{	

			int iScoreForLower = 0;
			int iScoreForRaise = 0;

			// Starting values based on opinion
			switch(eTeamOpinion)
			{
			case MAJOR_CIV_OPINION_ENEMY:
				iScoreForLower = -25;
				iScoreForRaise = 25;
			case MAJOR_CIV_OPINION_COMPETITOR:
				iScoreForLower = -10;
				iScoreForRaise = 10;
				break;
			case MAJOR_CIV_OPINION_NEUTRAL:
				iScoreForLower = 0;
				iScoreForRaise = 0;
				break;
			case MAJOR_CIV_OPINION_FAVORABLE:
				iScoreForLower = 10;
				iScoreForRaise = -10;
				break;
			case MAJOR_CIV_OPINION_FRIEND:
				iScoreForLower = 25;
				iScoreForRaise = -25;
				break;
			default:
				CvAssertMsg(false, "Should not have gotten here.");
			}

			// Still deciding what to be done?
			if(bWantToLower && bWantToRaise)
			{
				// Is our vassal doing better than us monetarily?
				if(iVassalCurrentGPT >= iMyCurrentGPT)
				{
					iScoreForLower *= 75;
					iScoreForLower /= 100;

					iScoreForRaise *= 125;
					iScoreForRaise /= 100;
				}
				// He is doing worse than 85% of our GPT
				else if(iVassalCurrentGPT * 85 <= iMyCurrentGPT * 100)
				{
					// Have to like the vassal
					if(eTeamOpinion > MAJOR_CIV_OPINION_NEUTRAL)
					{
						// Determine a percentage to lower
						int iThreshold = 3;

						// He is doing REALLY bad
						if(iVassalCurrentGPT * 150 < iMyCurrentGPT * 100)
							iThreshold = 7;

						int iRand = GC.getGame().getSmallFakeRandNum(10, m_pPlayer->getGlobalAverage(YIELD_CULTURE));
						if(iRand < iThreshold)
						{
							iScoreForLower *= 150;
							iScoreForLower /= 100;
						}
					}
				}

				// Raise score for lowering based on loyalty
				iScoreForLower *= 100 + (iAverageLoyalty - 5) * 10;
				iScoreForLower /= 100;

				// Raise score for lowering based on meanness
				iScoreForRaise *= 100 + (iAverageMeanness - 5) * 10;
				iScoreForRaise /= 100;

				bWantToLower = (iScoreForLower > iScoreForRaise);
				bWantToRaise = (iScoreForLower < iScoreForRaise);
			}
		}
	}

	CvWeightedVector<int, 20, true> aPossibleValues;	// in case changed, 100 / 5  is a safe bet for number of possible elements
	
	// New tax value defaults to current tax rate
	int iNewTaxValue = iTaxRate;

	// Decided we're going to lower - figure out by how much
	if(bWantToLower)
	{
		int iCurrentIndex = 0;

		// Possible values are determined by increments of 5 starting from below the current tax line
		for(int i = (iTaxRate - 5); i >= GC.getVASSALAGE_VASSAL_TAX_PERCENT_MINIMUM(); i -= 5)
		{
			int iValue = i;
			int iWeight = (iAverageOpinionScore - 3) * iCurrentIndex + 100;
			
			// Determine if we will make at least one GPT profit off of this value, if not, then decentivize
			if(iVassalCurrentGross * iValue < 10000)
				iWeight /= 4;

			aPossibleValues.push_back(iValue, iWeight);
			iCurrentIndex++;
		}

		RandomNumberDelegate fcn;
		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);
		iNewTaxValue = aPossibleValues.ChooseByWeight(&fcn, "Choose the tax value to assign");
	}
	// Decided we're going to raise - figure out by how much
	else
	{
		int iCurrentIndex = 0;
		
		// Possible values are determined by increments of 5 starting from above the current tax line
		for(int i = (iTaxRate + 5); i <= GC.getVASSALAGE_VASSAL_TAX_PERCENT_MAXIMUM(); i += 5)
		{
			int iValue = i;
			int iWeight = (3 - iAverageOpinionScore) * iCurrentIndex + 100;
			
			// Determine if we will make at least one GPT profit off of this value, if not, then decentivize
			if(iVassalCurrentGross * iValue < 10000)
				iWeight /= 4;
			
			aPossibleValues.push_back(iValue, iWeight);
			iCurrentIndex++;
		}

		RandomNumberDelegate fcn;
		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);
		iNewTaxValue = aPossibleValues.ChooseByWeight(&fcn, "Choose the tax value to assign");
	}

	// Set the tax.
	kMyTeam.DoApplyVassalTax(ePlayer, iNewTaxValue);
}

bool CvDiplomacyAI::IsVassal(PlayerTypes eOtherPlayer) const
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_CIV_PLAYERS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).IsVassal(GET_PLAYER(eOtherPlayer).getTeam());
}

/// Helper function to determine how many vassals ePlayer has
int CvDiplomacyAI::GetNumVassals(PlayerTypes eOtherPlayer) const
{
	CvAssertMsg(eOtherPlayer >= 0, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
	CvAssertMsg(eOtherPlayer < MAX_MAJOR_CIVS, "DIPLOMACY_AI: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	return GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetNumVassals();
}

/// Log Global State
//void CvDiplomacyAI::LogGlobalState(CvString& strString, PlayerTypes ePlayer)
//{
//	CvString strTemp;
//
//	switch(GetGlobalState(GetPlayer()->GetID()))
//	{
//		case NO_GLOBAL_STATE:
//			strTemp.Format("SELF: NO STATE!");
//			break;
//		case GLOBAL_STATE_UNKNOWN:
//			strTemp.Format("SELF: STATE UNKNOWN");
//			break;
//		case GLOBAL_STATE_ANNIHILATED:
//			strTemp.Format("SELF STATE ANNIH");
//			break;
//		case GLOBAL_STATE_VERY_BAD:
//			strTemp.Format("SELF STATE VERY BAD");
//			break;
//		case GLOBAL_STATE_BAD:
//			strTemp.Format("SELF STATE BAD");
//			break;
//		case GLOBAL_STATE_AVERAGE:
//			strTemp.Format("SELF STATE AVERAGE");
//			break;
//		case GLOBAL_STATE_GOOD:
//			strTemp.Format("SELF STATE GOOD");
//			break;
//		case GLOBAL_STATE_VERY_GOOD:
//			strTemp.Format("SELF STATE VERY GOOD");
//			break;
//		case GLOBAL_STATE_NEAR_VICTORY:
//			strTemp.Format("SELF STATE NEAR VICT");
//			break;
//		default:
//			strTemp.Format("SELF: XXX");
//			break;
//	}
//	strString += ", " + strTemp;
//
//	switch(GetGlobalState(ePlayer))
//	{
//		case NO_GLOBAL_STATE:
//			strTemp.Format("TheirGlbSt NONE");
//			break;
//		case GLOBAL_STATE_UNKNOWN:
//			strTemp.Format("TheirGlbSt UNKNOWN");
//			break;
//		case GLOBAL_STATE_VERY_BAD:
//			strTemp.Format("TheirGlbSt VERY BAD");
//			break;
//		case GLOBAL_STATE_BAD:
//			strTemp.Format("TheirGlbSt BAD");
//			break;
//		case GLOBAL_STATE_AVERAGE:
//			strTemp.Format("TheirGlbSt AVERAGE");
//			break;
//		case GLOBAL_STATE_GOOD:
//			strTemp.Format("TheirGlbSt GOOD");
//			break;
//		case GLOBAL_STATE_VERY_GOOD:
//			strTemp.Format("TheirGlbSt VERY GOOD");
//			break;
//		default:
//			strTemp.Format("XXX");
//			break;
//	}
//	strString += ", " + strTemp;
//}

// Version 9
/// Is moving our troops from ePlayer's lands acceptable?
int CvDiplomacyAI::IsMoveTroopsRequestAcceptable(PlayerTypes ePlayer, bool bJustChecking)
{
	// Create a small enum to handle the responses
	enum
	{
		ACCEPT = 0,
		NEUTRAL = 1,
		REFUSE = 2,

		NUM_MOVE_TROOPS_RESPONSE_TYPES
	};

	// Teammates
	if(GetPlayer()->getTeam() == GET_PLAYER(ePlayer).getTeam())
		return NEUTRAL;

	if (IsVassal(ePlayer))
		return ACCEPT;

	// If we have a pending coop war against this player then execute the attack
	for(int iI=0; iI < MAX_MAJOR_CIVS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if(GetCoopWarAcceptedState((PlayerTypes)iI, ePlayer) == COOP_WAR_STATE_SOON)
			{
				return REFUSE;	// War!
			}
		}
	}

	// We have an operation en route to opponent
	CvAIOperation* pOperation = GetPlayer()->GetMilitaryAI()->GetSneakAttackOperation(ePlayer);
	if(pOperation != NULL)
	{
		return REFUSE;	// War!
	}

	MajorCivApproachTypes eTrueApproach = GetMajorCivApproach(ePlayer, false);
	MajorCivOpinionTypes eOpinion = GetMajorCivOpinion(ePlayer);

	FStaticVector< int, 128, true, c_eCiv5GameplayDLL > viMoveTroopsWeights;

	// Push back values
	for(int i=0; i < NUM_MOVE_TROOPS_RESPONSE_TYPES; i++)
	{
		viMoveTroopsWeights.push_back(0);
	}

	// Initialize our parallel arrays based on various approaches
	// i.e. more inclined to agree to leave if they like to be friendly toward civs
	viMoveTroopsWeights[ACCEPT] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_FRIENDLY);
	viMoveTroopsWeights[NEUTRAL] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_NEUTRAL);
	viMoveTroopsWeights[REFUSE] = GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);

	if(IsGoingForWorldConquest())
	{
		viMoveTroopsWeights[ACCEPT] += -3;
		viMoveTroopsWeights[NEUTRAL] += -3;
		viMoveTroopsWeights[REFUSE] += 5;
	}
	
	// If we hate the guy then add weight for attacking
	switch(eOpinion)
	{
		case MAJOR_CIV_OPINION_UNFORGIVABLE:
			viMoveTroopsWeights[ACCEPT] += -4;
			viMoveTroopsWeights[NEUTRAL] += -2;
			viMoveTroopsWeights[REFUSE] += 6;
			break;
		case MAJOR_CIV_OPINION_ENEMY:
			viMoveTroopsWeights[ACCEPT] += -1;
			viMoveTroopsWeights[NEUTRAL] += 0;
			viMoveTroopsWeights[REFUSE] += 4;
			break;
		case MAJOR_CIV_OPINION_COMPETITOR:
			viMoveTroopsWeights[ACCEPT] += 0;
			viMoveTroopsWeights[NEUTRAL] += 0;
			viMoveTroopsWeights[REFUSE] += 2;
			break;
		case MAJOR_CIV_OPINION_NEUTRAL:
			viMoveTroopsWeights[ACCEPT] += 0;
			viMoveTroopsWeights[NEUTRAL] += 2;	// Slight weight for neutral as to not piss off neighbors
			viMoveTroopsWeights[REFUSE] += 0;
			break;
		case MAJOR_CIV_OPINION_FAVORABLE:
			viMoveTroopsWeights[ACCEPT] += 2;
			viMoveTroopsWeights[NEUTRAL] += 4;	// Just favorable? Weight being neutral higher.
			viMoveTroopsWeights[REFUSE] += 0;
			break;
		case MAJOR_CIV_OPINION_FRIEND:
			viMoveTroopsWeights[ACCEPT] += 4;
			viMoveTroopsWeights[NEUTRAL] += 2;
			viMoveTroopsWeights[REFUSE] += -8;
		case MAJOR_CIV_OPINION_ALLY:
			viMoveTroopsWeights[ACCEPT] += 6;	// Allies want to leave their allies alone more
			viMoveTroopsWeights[NEUTRAL] += 3;
			viMoveTroopsWeights[REFUSE] += -10;
			break;
	}

	// Add weight based on approach
	switch(eTrueApproach)
	{
		case MAJOR_CIV_APPROACH_HOSTILE:
			viMoveTroopsWeights[ACCEPT] += -2;
			viMoveTroopsWeights[NEUTRAL] += -1;
			viMoveTroopsWeights[REFUSE] += 4;
			break;
		case MAJOR_CIV_APPROACH_GUARDED:
			viMoveTroopsWeights[ACCEPT] += -2;
			viMoveTroopsWeights[NEUTRAL] += -1;
			viMoveTroopsWeights[REFUSE] += 3;
			break;
		case MAJOR_CIV_APPROACH_NEUTRAL:
			viMoveTroopsWeights[ACCEPT] += 0;
			viMoveTroopsWeights[NEUTRAL] += 0;
			viMoveTroopsWeights[REFUSE] += 0;
			break;
		case MAJOR_CIV_APPROACH_DECEPTIVE:
			viMoveTroopsWeights[ACCEPT] += 0;
			viMoveTroopsWeights[NEUTRAL] += 0;
			viMoveTroopsWeights[REFUSE] += 3;
			break;
		case MAJOR_CIV_APPROACH_FRIENDLY:
			viMoveTroopsWeights[ACCEPT] += 5;
			viMoveTroopsWeights[NEUTRAL] += 5;
			viMoveTroopsWeights[REFUSE] += 0;
			break;
	}

	// The REAL meat of the strategy: military strength
	switch(GetPlayerMilitaryStrengthComparedToUs(ePlayer))
	{
		case STRENGTH_IMMENSE:		// if he's really strong let's pull out!
			viMoveTroopsWeights[ACCEPT] += 10;
			viMoveTroopsWeights[NEUTRAL] += 3;
			viMoveTroopsWeights[REFUSE] += -10;
			break;
		case STRENGTH_POWERFUL:
			viMoveTroopsWeights[ACCEPT] += 7;
			viMoveTroopsWeights[NEUTRAL] += 5;
			viMoveTroopsWeights[REFUSE] += -6;
			break;
		case STRENGTH_STRONG:
			viMoveTroopsWeights[ACCEPT] += 3;
			viMoveTroopsWeights[NEUTRAL] += 4;
			viMoveTroopsWeights[REFUSE] += -3;
			break;
		case STRENGTH_AVERAGE:
			viMoveTroopsWeights[ACCEPT] += 0;
			viMoveTroopsWeights[NEUTRAL] += 3;
			viMoveTroopsWeights[REFUSE] += 0;
			break;
		case STRENGTH_WEAK:
			viMoveTroopsWeights[ACCEPT] += -2;
			viMoveTroopsWeights[NEUTRAL] += 0;
			viMoveTroopsWeights[REFUSE] += 3;
			break;
		case STRENGTH_POOR:	
			viMoveTroopsWeights[ACCEPT] += -6;
			viMoveTroopsWeights[NEUTRAL] += -4;
			viMoveTroopsWeights[REFUSE] += 6;
			break;
		case STRENGTH_PATHETIC:
			viMoveTroopsWeights[ACCEPT] += -10;
			viMoveTroopsWeights[NEUTRAL] += -10;
			viMoveTroopsWeights[REFUSE] += 10;
			break;
	}

	// If he's allowing open borders then maybe we want to move through them
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsAllowsOpenBordersToTeam(GetPlayer()->getTeam()))
	{
		viMoveTroopsWeights[ACCEPT] *= 70;
		viMoveTroopsWeights[ACCEPT] /= 100;
		viMoveTroopsWeights[NEUTRAL] *= 125;
		viMoveTroopsWeights[NEUTRAL] /= 100;
	}

	// Reduce weight if we're trading with them
	int iCurrentTradeValue = GetPlayer()->GetTrade()->GetAllTradeValueFromPlayerTimes100(YIELD_GOLD, ePlayer) / 100;
	if(iCurrentTradeValue > 0)
	{
		viMoveTroopsWeights[ACCEPT] += 2;
		viMoveTroopsWeights[NEUTRAL] += 5;
		viMoveTroopsWeights[REFUSE] += -3;
	}

	// Modifier for proximity
	switch(GetPlayer()->GetProximityToPlayer(ePlayer))
	{
		case PLAYER_PROXIMITY_DISTANT:
			viMoveTroopsWeights[ACCEPT] *= 120;
			viMoveTroopsWeights[ACCEPT] /= 100;
			viMoveTroopsWeights[NEUTRAL] *= 100;
			viMoveTroopsWeights[NEUTRAL] /= 100;
			viMoveTroopsWeights[REFUSE] *= 40;
			viMoveTroopsWeights[REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_FAR:
			viMoveTroopsWeights[ACCEPT] *= 100;
			viMoveTroopsWeights[ACCEPT] /= 100;
			viMoveTroopsWeights[NEUTRAL] *= 100;
			viMoveTroopsWeights[NEUTRAL] /= 100;
			viMoveTroopsWeights[REFUSE] *= 80;
			viMoveTroopsWeights[REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_CLOSE:
			viMoveTroopsWeights[ACCEPT] *= 85;
			viMoveTroopsWeights[ACCEPT] /= 100;
			viMoveTroopsWeights[NEUTRAL] *= 100;
			viMoveTroopsWeights[NEUTRAL] /= 100;
			viMoveTroopsWeights[REFUSE] *= 100;
			viMoveTroopsWeights[REFUSE] /= 100;
			break;
		case PLAYER_PROXIMITY_NEIGHBORS:
			viMoveTroopsWeights[ACCEPT] *= 70;
			viMoveTroopsWeights[ACCEPT] /= 100;
			viMoveTroopsWeights[NEUTRAL] *= 120;
			viMoveTroopsWeights[NEUTRAL] /= 100;
			viMoveTroopsWeights[REFUSE] *= 120;
			viMoveTroopsWeights[REFUSE] /= 100;
			break;
	}

	// And a random weight from 1-5 to each value
	int iRand;

	for(int i=0; i < NUM_MOVE_TROOPS_RESPONSE_TYPES; i++)
	{
		iRand = GC.getGame().getSmallFakeRandNum(5, ePlayer);
		viMoveTroopsWeights[i] += iRand;
	}

	// This vector is what we'll use to sort
	CvWeightedVector< int, 128 > vMoveTroopsWeightsForSorting;
	vMoveTroopsWeightsForSorting.clear();

	// Transfer values over to the sorting vector
	for(int i = 0; i < NUM_MOVE_TROOPS_RESPONSE_TYPES; i++)
	{
		vMoveTroopsWeightsForSorting.push_back(i, viMoveTroopsWeights[i]);
	}

	vMoveTroopsWeightsForSorting.SortItems();

	int eResponse = vMoveTroopsWeightsForSorting.GetElement(0);

	// If we're planning on war or going for world conquest and guarded or worse then refuse
	if(eTrueApproach == MAJOR_CIV_APPROACH_WAR ||
		(IsGoingForWorldConquest() && eTrueApproach <= MAJOR_CIV_APPROACH_GUARDED))
	{
		eResponse = REFUSE;
	}

	// Sanity check: What do my teammates think?
	// Prevent human from abusing AI to declare war on a human
	if(!bJustChecking)
	{
		int iResponse;
		int iYes = 0;
		int iNeutral = 0;
		int iNo = 0;

		PlayerTypes eLoopPlayer;
		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			eLoopPlayer = (PlayerTypes)iMajorLoop;

			// Not us
			if(GET_PLAYER(eLoopPlayer).GetID() != GetPlayer()->GetID())
			{
				// Has to be on our team
				if(GET_PLAYER(eLoopPlayer).getTeam() == GetPlayer()->getTeam())
				{
					// bJustChecking = true to prevent infinite loop
					iResponse = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsMoveTroopsRequestAcceptable(ePlayer, /*bJustChecking*/ true);

					switch(iResponse)
					{
						case 0:
							iYes++;
							break;
						case 1:
							iNeutral++;
							break;
						case 2:
							iNo++;
							break;
					}
				}
			}
		}

		// Add in our vote
		switch(eResponse)
		{
			case ACCEPT:
				iYes++;
				break;
			case NEUTRAL:
				iNeutral++;
				break;
			case REFUSE:
				iNo++;
				break;
		}

		// Change eResponse to whatever is highest
		if (iYes >= iNeutral && iNeutral >= iNo)
		{
			eResponse = ACCEPT;
		}
		else if (iNeutral >= iYes && iYes >= iNo)
		{
			eResponse = NEUTRAL;
		}
		else
		{
			eResponse = REFUSE;
		}
	}

	// If we hate the guy then only neutral
	if(eTrueApproach == MAJOR_CIV_APPROACH_HOSTILE)
	{
		if(eResponse == ACCEPT)
			eResponse = NEUTRAL;
	}

	// Final sanity check, if we're not planning war then don't go to war!
	if(GetWarGoal(ePlayer) == NO_WAR_GOAL_TYPE)
	{
		if(eResponse == REFUSE)
			eResponse = NEUTRAL;
	}

	return eResponse;
}
//--------------------------------------------------

bool CvDiplomacyAI::IsPlayerMoveTroopsRequestAccepted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_pabMoveTroopsRequestAccepted[ePlayer];
}

void CvDiplomacyAI::SetPlayerMoveTroopsRequestAccepted(PlayerTypes ePlayer, bool bNewValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_pabMoveTroopsRequestAccepted[ePlayer] = bNewValue;
}

int CvDiplomacyAI::GetPlayerMoveTroopsRequestCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_paiMoveTroopsRequestCounter[ePlayer];
}

void CvDiplomacyAI::SetPlayerMoveTroopsRequestCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_paiMoveTroopsRequestCounter[ePlayer] = iValue;
}

int CvDiplomacyAI::GetVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_paiVassalGoldPerTurnCollectedSinceVassalStarted[ePlayer];
}

void CvDiplomacyAI::SetVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_paiVassalGoldPerTurnCollectedSinceVassalStarted[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeVassalGoldPerTurnCollectedSinceVassalStarted(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	SetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer, GetVassalGoldPerTurnCollectedSinceVassalStarted(ePlayer) + iChange);
}

int CvDiplomacyAI::GetVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_paiVassalGoldPerTurnTaxedSinceVassalStarted[ePlayer];
}

void CvDiplomacyAI::SetVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_paiVassalGoldPerTurnTaxedSinceVassalStarted[ePlayer] = iValue;
}

void CvDiplomacyAI::ChangeVassalGoldPerTurnTaxedSinceVassalStarted(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	SetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer, GetVassalGoldPerTurnTaxedSinceVassalStarted(ePlayer) + iChange);
}

bool CvDiplomacyAI::IsVassalTaxRaised(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_pabVassalTaxRaised[ePlayer];
}

void CvDiplomacyAI::SetVassalTaxRaised(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_pabVassalTaxRaised[ePlayer] = bValue;
}

bool CvDiplomacyAI::IsVassalTaxLowered(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_pabVassalTaxLowered[ePlayer];
}

void CvDiplomacyAI::SetVassalTaxLowered(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_pabVassalTaxLowered[ePlayer] = bValue;
}

bool CvDiplomacyAI::IsMasterLiberatedMeFromVassalage(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	return m_pabMasterLiberatedMeFromVassalage[ePlayer];
}

void CvDiplomacyAI::SetMasterLiberatedMeFromVassalage(PlayerTypes ePlayer, bool bValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	m_pabMasterLiberatedMeFromVassalage[ePlayer] = bValue;
}

void CvDiplomacyAI::ChangePlayerMoveTroopsRequestCounter(PlayerTypes ePlayer, int iChange)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be greater than or equal to 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be less than MAX_MAJOR_CIVS");

	if(iChange != 0)
	{
		SetPlayerMoveTroopsRequestCounter(ePlayer, GetPlayerMoveTroopsRequestCounter(ePlayer) + iChange);
	}
}

bool CvDiplomacyAI::IsTooSoonForMoveTroopsRequest(PlayerTypes ePlayer) const
{
	// Too soon since we last asked
	if(GetPlayerMoveTroopsRequestCounter(ePlayer) > -1 &&
		GetPlayerMoveTroopsRequestCounter(ePlayer) < 30)
	{
		return true;
	}

	return false;
}
#endif

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
int CvDiplomacyAI::GetNumberOfThreatenedCities(PlayerTypes ePlayer)
{
	int iCountCitiesInDanger = 0;

	int iCityLoop;
	for (const CvCity* pFriendlyCity = GetPlayer()->firstCity(&iCityLoop); pFriendlyCity != NULL; pFriendlyCity = GetPlayer()->nextCity(&iCityLoop))
		if ( pFriendlyCity->IsInDanger( ePlayer ) )
			iCountCitiesInDanger++;

	return iCountCitiesInDanger;
}
#endif